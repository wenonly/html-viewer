const dv = `@charset "UTF-8";:root{--el-color-white:#ffffff;--el-color-black:#000000;--el-color-primary-rgb:64,158,255;--el-color-success-rgb:103,194,58;--el-color-warning-rgb:230,162,60;--el-color-danger-rgb:245,108,108;--el-color-error-rgb:245,108,108;--el-color-info-rgb:144,147,153;--el-font-size-extra-large:20px;--el-font-size-large:18px;--el-font-size-medium:16px;--el-font-size-base:14px;--el-font-size-small:13px;--el-font-size-extra-small:12px;--el-font-family:'Helvetica Neue',Helvetica,'PingFang SC','Hiragino Sans GB','Microsoft YaHei','微软雅黑',Arial,sans-serif;--el-font-weight-primary:500;--el-font-line-height-primary:24px;--el-index-normal:1;--el-index-top:1000;--el-index-popper:2000;--el-border-radius-base:4px;--el-border-radius-small:2px;--el-border-radius-round:20px;--el-border-radius-circle:100%;--el-transition-duration:0.3s;--el-transition-duration-fast:0.2s;--el-transition-function-ease-in-out-bezier:cubic-bezier(0.645, 0.045, 0.355, 1);--el-transition-function-fast-bezier:cubic-bezier(0.23, 1, 0.32, 1);--el-transition-all:all var(--el-transition-duration) var(--el-transition-function-ease-in-out-bezier);--el-transition-fade:opacity var(--el-transition-duration) var(--el-transition-function-fast-bezier);--el-transition-md-fade:transform var(--el-transition-duration) var(--el-transition-function-fast-bezier),opacity var(--el-transition-duration) var(--el-transition-function-fast-bezier);--el-transition-fade-linear:opacity var(--el-transition-duration-fast) linear;--el-transition-border:border-color var(--el-transition-duration-fast) var(--el-transition-function-ease-in-out-bezier);--el-transition-box-shadow:box-shadow var(--el-transition-duration-fast) var(--el-transition-function-ease-in-out-bezier);--el-transition-color:color var(--el-transition-duration-fast) var(--el-transition-function-ease-in-out-bezier);--el-component-size-large:40px;--el-component-size:32px;--el-component-size-small:24px}:root{color-scheme:light;--el-color-white:#ffffff;--el-color-black:#000000;--el-color-primary:#409eff;--el-color-primary-light-3:#79bbff;--el-color-primary-light-5:#a0cfff;--el-color-primary-light-7:#c6e2ff;--el-color-primary-light-8:#d9ecff;--el-color-primary-light-9:#ecf5ff;--el-color-primary-dark-2:#337ecc;--el-color-success:#67c23a;--el-color-success-light-3:#95d475;--el-color-success-light-5:#b3e19d;--el-color-success-light-7:#d1edc4;--el-color-success-light-8:#e1f3d8;--el-color-success-light-9:#f0f9eb;--el-color-success-dark-2:#529b2e;--el-color-warning:#e6a23c;--el-color-warning-light-3:#eebe77;--el-color-warning-light-5:#f3d19e;--el-color-warning-light-7:#f8e3c5;--el-color-warning-light-8:#faecd8;--el-color-warning-light-9:#fdf6ec;--el-color-warning-dark-2:#b88230;--el-color-danger:#f56c6c;--el-color-danger-light-3:#f89898;--el-color-danger-light-5:#fab6b6;--el-color-danger-light-7:#fcd3d3;--el-color-danger-light-8:#fde2e2;--el-color-danger-light-9:#fef0f0;--el-color-danger-dark-2:#c45656;--el-color-error:#f56c6c;--el-color-error-light-3:#f89898;--el-color-error-light-5:#fab6b6;--el-color-error-light-7:#fcd3d3;--el-color-error-light-8:#fde2e2;--el-color-error-light-9:#fef0f0;--el-color-error-dark-2:#c45656;--el-color-info:#909399;--el-color-info-light-3:#b1b3b8;--el-color-info-light-5:#c8c9cc;--el-color-info-light-7:#dedfe0;--el-color-info-light-8:#e9e9eb;--el-color-info-light-9:#f4f4f5;--el-color-info-dark-2:#73767a;--el-bg-color:#ffffff;--el-bg-color-page:#f2f3f5;--el-bg-color-overlay:#ffffff;--el-text-color-primary:#303133;--el-text-color-regular:#606266;--el-text-color-secondary:#909399;--el-text-color-placeholder:#a8abb2;--el-text-color-disabled:#c0c4cc;--el-border-color:#dcdfe6;--el-border-color-light:#e4e7ed;--el-border-color-lighter:#ebeef5;--el-border-color-extra-light:#f2f6fc;--el-border-color-dark:#d4d7de;--el-border-color-darker:#cdd0d6;--el-fill-color:#f0f2f5;--el-fill-color-light:#f5f7fa;--el-fill-color-lighter:#fafafa;--el-fill-color-extra-light:#fafcff;--el-fill-color-dark:#ebedf0;--el-fill-color-darker:#e6e8eb;--el-fill-color-blank:#ffffff;--el-box-shadow:0px 12px 32px 4px rgba(0, 0, 0, 0.04),0px 8px 20px rgba(0, 0, 0, 0.08);--el-box-shadow-light:0px 0px 12px rgba(0, 0, 0, 0.12);--el-box-shadow-lighter:0px 0px 6px rgba(0, 0, 0, 0.12);--el-box-shadow-dark:0px 16px 48px 16px rgba(0, 0, 0, 0.08),0px 12px 32px rgba(0, 0, 0, 0.12),0px 8px 16px -8px rgba(0, 0, 0, 0.16);--el-disabled-bg-color:var(--el-fill-color-light);--el-disabled-text-color:var(--el-text-color-placeholder);--el-disabled-border-color:var(--el-border-color-light);--el-overlay-color:rgba(0, 0, 0, 0.8);--el-overlay-color-light:rgba(0, 0, 0, 0.7);--el-overlay-color-lighter:rgba(0, 0, 0, 0.5);--el-mask-color:rgba(255, 255, 255, 0.9);--el-mask-color-extra-light:rgba(255, 255, 255, 0.3);--el-border-width:1px;--el-border-style:solid;--el-border-color-hover:var(--el-text-color-disabled);--el-border:var(--el-border-width) var(--el-border-style) var(--el-border-color);--el-svg-monochrome-grey:var(--el-border-color)}.fade-in-linear-enter-active,.fade-in-linear-leave-active{transition:var(--el-transition-fade-linear)}.fade-in-linear-enter-from,.fade-in-linear-leave-to{opacity:0}.el-fade-in-linear-enter-active,.el-fade-in-linear-leave-active{transition:var(--el-transition-fade-linear)}.el-fade-in-linear-enter-from,.el-fade-in-linear-leave-to{opacity:0}.el-fade-in-enter-active,.el-fade-in-leave-active{transition:all var(--el-transition-duration) cubic-bezier(.55,0,.1,1)}.el-fade-in-enter-from,.el-fade-in-leave-active{opacity:0}.el-zoom-in-center-enter-active,.el-zoom-in-center-leave-active{transition:all var(--el-transition-duration) cubic-bezier(.55,0,.1,1)}.el-zoom-in-center-enter-from,.el-zoom-in-center-leave-active{opacity:0;transform:scaleX(0)}.el-zoom-in-top-enter-active,.el-zoom-in-top-leave-active{opacity:1;transform:scaleY(1);transition:var(--el-transition-md-fade);transform-origin:center top}.el-zoom-in-top-enter-active[data-popper-placement^=top],.el-zoom-in-top-leave-active[data-popper-placement^=top]{transform-origin:center bottom}.el-zoom-in-top-enter-from,.el-zoom-in-top-leave-active{opacity:0;transform:scaleY(0)}.el-zoom-in-bottom-enter-active,.el-zoom-in-bottom-leave-active{opacity:1;transform:scaleY(1);transition:var(--el-transition-md-fade);transform-origin:center bottom}.el-zoom-in-bottom-enter-from,.el-zoom-in-bottom-leave-active{opacity:0;transform:scaleY(0)}.el-zoom-in-left-enter-active,.el-zoom-in-left-leave-active{opacity:1;transform:scale(1,1);transition:var(--el-transition-md-fade);transform-origin:top left}.el-zoom-in-left-enter-from,.el-zoom-in-left-leave-active{opacity:0;transform:scale(.45,.45)}.collapse-transition{transition:var(--el-transition-duration) height ease-in-out,var(--el-transition-duration) padding-top ease-in-out,var(--el-transition-duration) padding-bottom ease-in-out}.el-collapse-transition-enter-active,.el-collapse-transition-leave-active{transition:var(--el-transition-duration) max-height ease-in-out,var(--el-transition-duration) padding-top ease-in-out,var(--el-transition-duration) padding-bottom ease-in-out}.horizontal-collapse-transition{transition:var(--el-transition-duration) width ease-in-out,var(--el-transition-duration) padding-left ease-in-out,var(--el-transition-duration) padding-right ease-in-out}.el-list-enter-active,.el-list-leave-active{transition:all 1s}.el-list-enter-from,.el-list-leave-to{opacity:0;transform:translateY(-30px)}.el-list-leave-active{position:absolute!important}.el-opacity-transition{transition:opacity var(--el-transition-duration) cubic-bezier(.55,0,.1,1)}.el-icon-loading{-webkit-animation:rotating 2s linear infinite;animation:rotating 2s linear infinite}.el-icon--right{margin-left:5px}.el-icon--left{margin-right:5px}@-webkit-keyframes rotating{0%{transform:rotateZ(0)}100%{transform:rotateZ(360deg)}}@keyframes rotating{0%{transform:rotateZ(0)}100%{transform:rotateZ(360deg)}}.el-icon{--color:inherit;height:1em;width:1em;line-height:1em;display:inline-flex;justify-content:center;align-items:center;position:relative;fill:currentColor;color:var(--color);font-size:inherit}.el-icon.is-loading{-webkit-animation:rotating 2s linear infinite;animation:rotating 2s linear infinite}.el-icon svg{height:1em;width:1em}.el-affix--fixed{position:fixed}.el-alert{--el-alert-padding:8px 16px;--el-alert-border-radius-base:var(--el-border-radius-base);--el-alert-title-font-size:13px;--el-alert-description-font-size:12px;--el-alert-close-font-size:12px;--el-alert-close-customed-font-size:13px;--el-alert-icon-size:16px;--el-alert-icon-large-size:28px;width:100%;padding:var(--el-alert-padding);margin:0;box-sizing:border-box;border-radius:var(--el-alert-border-radius-base);position:relative;background-color:var(--el-color-white);overflow:hidden;opacity:1;display:flex;align-items:center;transition:opacity var(--el-transition-duration-fast)}.el-alert.is-light .el-alert__close-btn{color:var(--el-text-color-placeholder)}.el-alert.is-dark .el-alert__close-btn{color:var(--el-color-white)}.el-alert.is-dark .el-alert__description{color:var(--el-color-white)}.el-alert.is-center{justify-content:center}.el-alert--success{--el-alert-bg-color:var(--el-color-success-light-9)}.el-alert--success.is-light{background-color:var(--el-alert-bg-color);color:var(--el-color-success)}.el-alert--success.is-light .el-alert__description{color:var(--el-color-success)}.el-alert--success.is-dark{background-color:var(--el-color-success);color:var(--el-color-white)}.el-alert--info{--el-alert-bg-color:var(--el-color-info-light-9)}.el-alert--info.is-light{background-color:var(--el-alert-bg-color);color:var(--el-color-info)}.el-alert--info.is-light .el-alert__description{color:var(--el-color-info)}.el-alert--info.is-dark{background-color:var(--el-color-info);color:var(--el-color-white)}.el-alert--warning{--el-alert-bg-color:var(--el-color-warning-light-9)}.el-alert--warning.is-light{background-color:var(--el-alert-bg-color);color:var(--el-color-warning)}.el-alert--warning.is-light .el-alert__description{color:var(--el-color-warning)}.el-alert--warning.is-dark{background-color:var(--el-color-warning);color:var(--el-color-white)}.el-alert--error{--el-alert-bg-color:var(--el-color-error-light-9)}.el-alert--error.is-light{background-color:var(--el-alert-bg-color);color:var(--el-color-error)}.el-alert--error.is-light .el-alert__description{color:var(--el-color-error)}.el-alert--error.is-dark{background-color:var(--el-color-error);color:var(--el-color-white)}.el-alert__content{display:table-cell;padding:0 8px}.el-alert .el-alert__icon{font-size:var(--el-alert-icon-size);width:var(--el-alert-icon-size)}.el-alert .el-alert__icon.is-big{font-size:var(--el-alert-icon-large-size);width:var(--el-alert-icon-large-size)}.el-alert__title{font-size:var(--el-alert-title-font-size);line-height:18px;vertical-align:text-top}.el-alert__title.is-bold{font-weight:700}.el-alert .el-alert__description{font-size:var(--el-alert-description-font-size);margin:5px 0 0 0}.el-alert .el-alert__close-btn{font-size:var(--el-alert-close-font-size);opacity:1;position:absolute;top:12px;right:15px;cursor:pointer}.el-alert .el-alert__close-btn.is-customed{font-style:normal;font-size:var(--el-alert-close-customed-font-size);top:9px}.el-alert-fade-enter-from,.el-alert-fade-leave-active{opacity:0}.el-aside{overflow:auto;box-sizing:border-box;flex-shrink:0;width:var(--el-aside-width,300px)}.el-autocomplete{position:relative;display:inline-block}.el-autocomplete__popper.el-popper{background:var(--el-bg-color-overlay);border:1px solid var(--el-border-color-light);box-shadow:var(--el-box-shadow-light)}.el-autocomplete__popper.el-popper .el-popper__arrow::before{border:1px solid var(--el-border-color-light)}.el-autocomplete__popper.el-popper[data-popper-placement^=top] .el-popper__arrow::before{border-top-color:transparent;border-left-color:transparent}.el-autocomplete__popper.el-popper[data-popper-placement^=bottom] .el-popper__arrow::before{border-bottom-color:transparent;border-right-color:transparent}.el-autocomplete__popper.el-popper[data-popper-placement^=left] .el-popper__arrow::before{border-left-color:transparent;border-bottom-color:transparent}.el-autocomplete__popper.el-popper[data-popper-placement^=right] .el-popper__arrow::before{border-right-color:transparent;border-top-color:transparent}.el-autocomplete-suggestion{border-radius:var(--el-border-radius-base);box-sizing:border-box}.el-autocomplete-suggestion__wrap{max-height:280px;padding:10px 0;box-sizing:border-box}.el-autocomplete-suggestion__list{margin:0;padding:0}.el-autocomplete-suggestion li{padding:0 20px;margin:0;line-height:34px;cursor:pointer;color:var(--el-text-color-regular);font-size:var(--el-font-size-base);list-style:none;text-align:left;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}.el-autocomplete-suggestion li:hover{background-color:var(--el-fill-color-light)}.el-autocomplete-suggestion li.highlighted{background-color:var(--el-fill-color-light)}.el-autocomplete-suggestion li.divider{margin-top:6px;border-top:1px solid var(--el-color-black)}.el-autocomplete-suggestion li.divider:last-child{margin-bottom:-6px}.el-autocomplete-suggestion.is-loading li{text-align:center;height:100px;line-height:100px;font-size:20px;color:var(--el-text-color-secondary)}.el-autocomplete-suggestion.is-loading li::after{display:inline-block;content:"";height:100%;vertical-align:middle}.el-autocomplete-suggestion.is-loading li:hover{background-color:var(--el-bg-color-overlay)}.el-autocomplete-suggestion.is-loading .el-icon-loading{vertical-align:middle}.el-avatar{--el-avatar-text-color:var(--el-color-white);--el-avatar-bg-color:var(--el-text-color-disabled);--el-avatar-text-size:14px;--el-avatar-icon-size:18px;--el-avatar-border-radius:var(--el-border-radius-base);--el-avatar-size-large:56px;--el-avatar-size:40px;--el-avatar-size-small:24px;--el-avatar-size:40px;display:inline-flex;justify-content:center;align-items:center;box-sizing:border-box;text-align:center;overflow:hidden;color:var(--el-avatar-text-color);background:var(--el-avatar-bg-color);width:var(--el-avatar-size);height:var(--el-avatar-size);font-size:var(--el-avatar-text-size)}.el-avatar>img{display:block;height:100%}.el-avatar--circle{border-radius:50%}.el-avatar--square{border-radius:var(--el-avatar-border-radius)}.el-avatar--icon{font-size:var(--el-avatar-icon-size)}.el-avatar--small{--el-avatar-size:24px}.el-avatar--large{--el-avatar-size:56px}.el-backtop{--el-backtop-bg-color:var(--el-bg-color-overlay);--el-backtop-text-color:var(--el-color-primary);--el-backtop-hover-bg-color:var(--el-border-color-extra-light);position:fixed;background-color:var(--el-backtop-bg-color);width:40px;height:40px;border-radius:50%;color:var(--el-backtop-text-color);display:flex;align-items:center;justify-content:center;font-size:20px;box-shadow:var(--el-box-shadow-lighter);cursor:pointer;z-index:5}.el-backtop:hover{background-color:var(--el-backtop-hover-bg-color)}.el-backtop__icon{font-size:20px}.el-badge{--el-badge-bg-color:var(--el-color-danger);--el-badge-radius:10px;--el-badge-font-size:12px;--el-badge-padding:6px;--el-badge-size:18px;position:relative;vertical-align:middle;display:inline-block}.el-badge__content{background-color:var(--el-badge-bg-color);border-radius:var(--el-badge-radius);color:var(--el-color-white);display:inline-flex;justify-content:center;align-items:center;font-size:var(--el-badge-font-size);height:var(--el-badge-size);padding:0 var(--el-badge-padding);white-space:nowrap;border:1px solid var(--el-bg-color)}.el-badge__content.is-fixed{position:absolute;top:0;right:calc(1px + var(--el-badge-size)/ 2);transform:translateY(-50%) translateX(100%)}.el-badge__content.is-fixed.is-dot{right:5px}.el-badge__content.is-dot{height:8px;width:8px;padding:0;right:0;border-radius:50%}.el-badge__content--primary{background-color:var(--el-color-primary)}.el-badge__content--success{background-color:var(--el-color-success)}.el-badge__content--warning{background-color:var(--el-color-warning)}.el-badge__content--info{background-color:var(--el-color-info)}.el-badge__content--danger{background-color:var(--el-color-danger)}.el-breadcrumb{font-size:14px;line-height:1}.el-breadcrumb::after,.el-breadcrumb::before{display:table;content:""}.el-breadcrumb::after{clear:both}.el-breadcrumb__separator{margin:0 9px;font-weight:700;color:var(--el-text-color-placeholder)}.el-breadcrumb__separator.el-icon{margin:0 6px;font-weight:400}.el-breadcrumb__separator.el-icon svg{vertical-align:middle}.el-breadcrumb__item{float:left;display:flex;align-items:center}.el-breadcrumb__inner{color:var(--el-text-color-regular)}.el-breadcrumb__inner a,.el-breadcrumb__inner.is-link{font-weight:700;text-decoration:none;transition:var(--el-transition-color);color:var(--el-text-color-primary)}.el-breadcrumb__inner a:hover,.el-breadcrumb__inner.is-link:hover{color:var(--el-color-primary);cursor:pointer}.el-breadcrumb__item:last-child .el-breadcrumb__inner,.el-breadcrumb__item:last-child .el-breadcrumb__inner a,.el-breadcrumb__item:last-child .el-breadcrumb__inner a:hover,.el-breadcrumb__item:last-child .el-breadcrumb__inner:hover{font-weight:400;color:var(--el-text-color-regular);cursor:text}.el-breadcrumb__item:last-child .el-breadcrumb__separator{display:none}.el-button-group{display:inline-block;vertical-align:middle}.el-button-group::after,.el-button-group::before{display:table;content:""}.el-button-group::after{clear:both}.el-button-group>.el-button{float:left;position:relative}.el-button-group>.el-button+.el-button{margin-left:0}.el-button-group>.el-button:first-child{border-top-right-radius:0;border-bottom-right-radius:0}.el-button-group>.el-button:last-child{border-top-left-radius:0;border-bottom-left-radius:0}.el-button-group>.el-button:first-child:last-child{border-top-right-radius:var(--el-border-radius-base);border-bottom-right-radius:var(--el-border-radius-base);border-top-left-radius:var(--el-border-radius-base);border-bottom-left-radius:var(--el-border-radius-base)}.el-button-group>.el-button:first-child:last-child.is-round{border-radius:var(--el-border-radius-round)}.el-button-group>.el-button:first-child:last-child.is-circle{border-radius:50%}.el-button-group>.el-button:not(:first-child):not(:last-child){border-radius:0}.el-button-group>.el-button:not(:last-child){margin-right:-1px}.el-button-group>.el-button:active,.el-button-group>.el-button:focus,.el-button-group>.el-button:hover{z-index:1}.el-button-group>.el-button.is-active{z-index:1}.el-button-group>.el-dropdown>.el-button{border-top-left-radius:0;border-bottom-left-radius:0;border-left-color:var(--el-button-divide-border-color)}.el-button-group .el-button--primary:first-child{border-right-color:var(--el-button-divide-border-color)}.el-button-group .el-button--primary:last-child{border-left-color:var(--el-button-divide-border-color)}.el-button-group .el-button--primary:not(:first-child):not(:last-child){border-left-color:var(--el-button-divide-border-color);border-right-color:var(--el-button-divide-border-color)}.el-button-group .el-button--success:first-child{border-right-color:var(--el-button-divide-border-color)}.el-button-group .el-button--success:last-child{border-left-color:var(--el-button-divide-border-color)}.el-button-group .el-button--success:not(:first-child):not(:last-child){border-left-color:var(--el-button-divide-border-color);border-right-color:var(--el-button-divide-border-color)}.el-button-group .el-button--warning:first-child{border-right-color:var(--el-button-divide-border-color)}.el-button-group .el-button--warning:last-child{border-left-color:var(--el-button-divide-border-color)}.el-button-group .el-button--warning:not(:first-child):not(:last-child){border-left-color:var(--el-button-divide-border-color);border-right-color:var(--el-button-divide-border-color)}.el-button-group .el-button--danger:first-child{border-right-color:var(--el-button-divide-border-color)}.el-button-group .el-button--danger:last-child{border-left-color:var(--el-button-divide-border-color)}.el-button-group .el-button--danger:not(:first-child):not(:last-child){border-left-color:var(--el-button-divide-border-color);border-right-color:var(--el-button-divide-border-color)}.el-button-group .el-button--info:first-child{border-right-color:var(--el-button-divide-border-color)}.el-button-group .el-button--info:last-child{border-left-color:var(--el-button-divide-border-color)}.el-button-group .el-button--info:not(:first-child):not(:last-child){border-left-color:var(--el-button-divide-border-color);border-right-color:var(--el-button-divide-border-color)}.el-button{--el-button-font-weight:var(--el-font-weight-primary);--el-button-border-color:var(--el-border-color);--el-button-bg-color:var(--el-fill-color-blank);--el-button-text-color:var(--el-text-color-regular);--el-button-disabled-text-color:var(--el-disabled-text-color);--el-button-disabled-bg-color:var(--el-fill-color-blank);--el-button-disabled-border-color:var(--el-border-color-light);--el-button-divide-border-color:rgba(255, 255, 255, 0.5);--el-button-hover-text-color:var(--el-color-primary);--el-button-hover-bg-color:var(--el-color-primary-light-9);--el-button-hover-border-color:var(--el-color-primary-light-7);--el-button-active-text-color:var(--el-button-hover-text-color);--el-button-active-border-color:var(--el-color-primary);--el-button-active-bg-color:var(--el-button-hover-bg-color);--el-button-outline-color:var(--el-color-primary-light-5);--el-button-hover-link-text-color:var(--el-color-info);--el-button-active-color:var(--el-text-color-primary)}.el-button{display:inline-flex;justify-content:center;align-items:center;line-height:1;height:32px;white-space:nowrap;cursor:pointer;color:var(--el-button-text-color);text-align:center;box-sizing:border-box;outline:0;transition:.1s;font-weight:var(--el-button-font-weight);-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;vertical-align:middle;-webkit-appearance:none;background-color:var(--el-button-bg-color);border:var(--el-border);border-color:var(--el-button-border-color);padding:8px 15px;font-size:var(--el-font-size-base);border-radius:var(--el-border-radius-base)}.el-button:focus,.el-button:hover{color:var(--el-button-hover-text-color);border-color:var(--el-button-hover-border-color);background-color:var(--el-button-hover-bg-color);outline:0}.el-button:active{color:var(--el-button-active-text-color);border-color:var(--el-button-active-border-color);background-color:var(--el-button-active-bg-color);outline:0}.el-button:focus-visible{outline:2px solid var(--el-button-outline-color);outline-offset:1px}.el-button>span{display:inline-flex;align-items:center}.el-button+.el-button{margin-left:12px}.el-button.is-round{padding:8px 15px}.el-button::-moz-focus-inner{border:0}.el-button [class*=el-icon]+span{margin-left:6px}.el-button [class*=el-icon] svg{vertical-align:bottom}.el-button.is-plain{--el-button-hover-text-color:var(--el-color-primary);--el-button-hover-bg-color:var(--el-fill-color-blank);--el-button-hover-border-color:var(--el-color-primary)}.el-button.is-active{color:var(--el-button-active-text-color);border-color:var(--el-button-active-border-color);background-color:var(--el-button-active-bg-color);outline:0}.el-button.is-disabled,.el-button.is-disabled:focus,.el-button.is-disabled:hover{color:var(--el-button-disabled-text-color);cursor:not-allowed;background-image:none;background-color:var(--el-button-disabled-bg-color);border-color:var(--el-button-disabled-border-color)}.el-button.is-loading{position:relative;pointer-events:none}.el-button.is-loading:before{z-index:1;pointer-events:none;content:"";position:absolute;left:-1px;top:-1px;right:-1px;bottom:-1px;border-radius:inherit;background-color:var(--el-mask-color-extra-light)}.el-button.is-round{border-radius:var(--el-border-radius-round)}.el-button.is-circle{border-radius:50%;padding:8px}.el-button.is-text{color:var(--el-button-text-color);border:0 solid transparent;background-color:transparent}.el-button.is-text.is-disabled{color:var(--el-button-disabled-text-color);background-color:transparent!important}.el-button.is-text:not(.is-disabled):focus,.el-button.is-text:not(.is-disabled):hover{background-color:var(--el-fill-color-light)}.el-button.is-text:not(.is-disabled):focus-visible{outline:2px solid var(--el-button-outline-color);outline-offset:1px}.el-button.is-text:not(.is-disabled):active{background-color:var(--el-fill-color)}.el-button.is-text:not(.is-disabled).is-has-bg{background-color:var(--el-fill-color-light)}.el-button.is-text:not(.is-disabled).is-has-bg:focus,.el-button.is-text:not(.is-disabled).is-has-bg:hover{background-color:var(--el-fill-color)}.el-button.is-text:not(.is-disabled).is-has-bg:active{background-color:var(--el-fill-color-dark)}.el-button__text--expand{letter-spacing:.3em;margin-right:-.3em}.el-button.is-link{border-color:transparent;color:var(--el-button-text-color);background:0 0;padding:2px;height:auto}.el-button.is-link:focus,.el-button.is-link:hover{color:var(--el-button-hover-link-text-color)}.el-button.is-link.is-disabled{color:var(--el-button-disabled-text-color);background-color:transparent!important;border-color:transparent!important}.el-button.is-link:not(.is-disabled):focus,.el-button.is-link:not(.is-disabled):hover{border-color:transparent;background-color:transparent}.el-button.is-link:not(.is-disabled):active{color:var(--el-button-active-color);border-color:transparent;background-color:transparent}.el-button--text{border-color:transparent;background:0 0;color:var(--el-color-primary);padding-left:0;padding-right:0}.el-button--text.is-disabled{color:var(--el-button-disabled-text-color);background-color:transparent!important;border-color:transparent!important}.el-button--text:not(.is-disabled):focus,.el-button--text:not(.is-disabled):hover{color:var(--el-color-primary-light-3);border-color:transparent;background-color:transparent}.el-button--text:not(.is-disabled):active{color:var(--el-color-primary-dark-2);border-color:transparent;background-color:transparent}.el-button__link--expand{letter-spacing:.3em;margin-right:-.3em}.el-button--primary{--el-button-text-color:var(--el-color-white);--el-button-bg-color:var(--el-color-primary);--el-button-border-color:var(--el-color-primary);--el-button-outline-color:var(--el-color-primary-light-5);--el-button-active-color:var(--el-color-primary-dark-2);--el-button-hover-text-color:var(--el-color-white);--el-button-hover-link-text-color:var(--el-color-primary-light-5);--el-button-hover-bg-color:var(--el-color-primary-light-3);--el-button-hover-border-color:var(--el-color-primary-light-3);--el-button-active-bg-color:var(--el-color-primary-dark-2);--el-button-active-border-color:var(--el-color-primary-dark-2);--el-button-disabled-text-color:var(--el-color-white);--el-button-disabled-bg-color:var(--el-color-primary-light-5);--el-button-disabled-border-color:var(--el-color-primary-light-5)}.el-button--primary.is-link,.el-button--primary.is-plain,.el-button--primary.is-text{--el-button-text-color:var(--el-color-primary);--el-button-bg-color:var(--el-color-primary-light-9);--el-button-border-color:var(--el-color-primary-light-5);--el-button-hover-text-color:var(--el-color-white);--el-button-hover-bg-color:var(--el-color-primary);--el-button-hover-border-color:var(--el-color-primary);--el-button-active-text-color:var(--el-color-white)}.el-button--primary.is-link.is-disabled,.el-button--primary.is-link.is-disabled:active,.el-button--primary.is-link.is-disabled:focus,.el-button--primary.is-link.is-disabled:hover,.el-button--primary.is-plain.is-disabled,.el-button--primary.is-plain.is-disabled:active,.el-button--primary.is-plain.is-disabled:focus,.el-button--primary.is-plain.is-disabled:hover,.el-button--primary.is-text.is-disabled,.el-button--primary.is-text.is-disabled:active,.el-button--primary.is-text.is-disabled:focus,.el-button--primary.is-text.is-disabled:hover{color:var(--el-color-primary-light-5);background-color:var(--el-color-primary-light-9);border-color:var(--el-color-primary-light-8)}.el-button--success{--el-button-text-color:var(--el-color-white);--el-button-bg-color:var(--el-color-success);--el-button-border-color:var(--el-color-success);--el-button-outline-color:var(--el-color-success-light-5);--el-button-active-color:var(--el-color-success-dark-2);--el-button-hover-text-color:var(--el-color-white);--el-button-hover-link-text-color:var(--el-color-success-light-5);--el-button-hover-bg-color:var(--el-color-success-light-3);--el-button-hover-border-color:var(--el-color-success-light-3);--el-button-active-bg-color:var(--el-color-success-dark-2);--el-button-active-border-color:var(--el-color-success-dark-2);--el-button-disabled-text-color:var(--el-color-white);--el-button-disabled-bg-color:var(--el-color-success-light-5);--el-button-disabled-border-color:var(--el-color-success-light-5)}.el-button--success.is-link,.el-button--success.is-plain,.el-button--success.is-text{--el-button-text-color:var(--el-color-success);--el-button-bg-color:var(--el-color-success-light-9);--el-button-border-color:var(--el-color-success-light-5);--el-button-hover-text-color:var(--el-color-white);--el-button-hover-bg-color:var(--el-color-success);--el-button-hover-border-color:var(--el-color-success);--el-button-active-text-color:var(--el-color-white)}.el-button--success.is-link.is-disabled,.el-button--success.is-link.is-disabled:active,.el-button--success.is-link.is-disabled:focus,.el-button--success.is-link.is-disabled:hover,.el-button--success.is-plain.is-disabled,.el-button--success.is-plain.is-disabled:active,.el-button--success.is-plain.is-disabled:focus,.el-button--success.is-plain.is-disabled:hover,.el-button--success.is-text.is-disabled,.el-button--success.is-text.is-disabled:active,.el-button--success.is-text.is-disabled:focus,.el-button--success.is-text.is-disabled:hover{color:var(--el-color-success-light-5);background-color:var(--el-color-success-light-9);border-color:var(--el-color-success-light-8)}.el-button--warning{--el-button-text-color:var(--el-color-white);--el-button-bg-color:var(--el-color-warning);--el-button-border-color:var(--el-color-warning);--el-button-outline-color:var(--el-color-warning-light-5);--el-button-active-color:var(--el-color-warning-dark-2);--el-button-hover-text-color:var(--el-color-white);--el-button-hover-link-text-color:var(--el-color-warning-light-5);--el-button-hover-bg-color:var(--el-color-warning-light-3);--el-button-hover-border-color:var(--el-color-warning-light-3);--el-button-active-bg-color:var(--el-color-warning-dark-2);--el-button-active-border-color:var(--el-color-warning-dark-2);--el-button-disabled-text-color:var(--el-color-white);--el-button-disabled-bg-color:var(--el-color-warning-light-5);--el-button-disabled-border-color:var(--el-color-warning-light-5)}.el-button--warning.is-link,.el-button--warning.is-plain,.el-button--warning.is-text{--el-button-text-color:var(--el-color-warning);--el-button-bg-color:var(--el-color-warning-light-9);--el-button-border-color:var(--el-color-warning-light-5);--el-button-hover-text-color:var(--el-color-white);--el-button-hover-bg-color:var(--el-color-warning);--el-button-hover-border-color:var(--el-color-warning);--el-button-active-text-color:var(--el-color-white)}.el-button--warning.is-link.is-disabled,.el-button--warning.is-link.is-disabled:active,.el-button--warning.is-link.is-disabled:focus,.el-button--warning.is-link.is-disabled:hover,.el-button--warning.is-plain.is-disabled,.el-button--warning.is-plain.is-disabled:active,.el-button--warning.is-plain.is-disabled:focus,.el-button--warning.is-plain.is-disabled:hover,.el-button--warning.is-text.is-disabled,.el-button--warning.is-text.is-disabled:active,.el-button--warning.is-text.is-disabled:focus,.el-button--warning.is-text.is-disabled:hover{color:var(--el-color-warning-light-5);background-color:var(--el-color-warning-light-9);border-color:var(--el-color-warning-light-8)}.el-button--danger{--el-button-text-color:var(--el-color-white);--el-button-bg-color:var(--el-color-danger);--el-button-border-color:var(--el-color-danger);--el-button-outline-color:var(--el-color-danger-light-5);--el-button-active-color:var(--el-color-danger-dark-2);--el-button-hover-text-color:var(--el-color-white);--el-button-hover-link-text-color:var(--el-color-danger-light-5);--el-button-hover-bg-color:var(--el-color-danger-light-3);--el-button-hover-border-color:var(--el-color-danger-light-3);--el-button-active-bg-color:var(--el-color-danger-dark-2);--el-button-active-border-color:var(--el-color-danger-dark-2);--el-button-disabled-text-color:var(--el-color-white);--el-button-disabled-bg-color:var(--el-color-danger-light-5);--el-button-disabled-border-color:var(--el-color-danger-light-5)}.el-button--danger.is-link,.el-button--danger.is-plain,.el-button--danger.is-text{--el-button-text-color:var(--el-color-danger);--el-button-bg-color:var(--el-color-danger-light-9);--el-button-border-color:var(--el-color-danger-light-5);--el-button-hover-text-color:var(--el-color-white);--el-button-hover-bg-color:var(--el-color-danger);--el-button-hover-border-color:var(--el-color-danger);--el-button-active-text-color:var(--el-color-white)}.el-button--danger.is-link.is-disabled,.el-button--danger.is-link.is-disabled:active,.el-button--danger.is-link.is-disabled:focus,.el-button--danger.is-link.is-disabled:hover,.el-button--danger.is-plain.is-disabled,.el-button--danger.is-plain.is-disabled:active,.el-button--danger.is-plain.is-disabled:focus,.el-button--danger.is-plain.is-disabled:hover,.el-button--danger.is-text.is-disabled,.el-button--danger.is-text.is-disabled:active,.el-button--danger.is-text.is-disabled:focus,.el-button--danger.is-text.is-disabled:hover{color:var(--el-color-danger-light-5);background-color:var(--el-color-danger-light-9);border-color:var(--el-color-danger-light-8)}.el-button--info{--el-button-text-color:var(--el-color-white);--el-button-bg-color:var(--el-color-info);--el-button-border-color:var(--el-color-info);--el-button-outline-color:var(--el-color-info-light-5);--el-button-active-color:var(--el-color-info-dark-2);--el-button-hover-text-color:var(--el-color-white);--el-button-hover-link-text-color:var(--el-color-info-light-5);--el-button-hover-bg-color:var(--el-color-info-light-3);--el-button-hover-border-color:var(--el-color-info-light-3);--el-button-active-bg-color:var(--el-color-info-dark-2);--el-button-active-border-color:var(--el-color-info-dark-2);--el-button-disabled-text-color:var(--el-color-white);--el-button-disabled-bg-color:var(--el-color-info-light-5);--el-button-disabled-border-color:var(--el-color-info-light-5)}.el-button--info.is-link,.el-button--info.is-plain,.el-button--info.is-text{--el-button-text-color:var(--el-color-info);--el-button-bg-color:var(--el-color-info-light-9);--el-button-border-color:var(--el-color-info-light-5);--el-button-hover-text-color:var(--el-color-white);--el-button-hover-bg-color:var(--el-color-info);--el-button-hover-border-color:var(--el-color-info);--el-button-active-text-color:var(--el-color-white)}.el-button--info.is-link.is-disabled,.el-button--info.is-link.is-disabled:active,.el-button--info.is-link.is-disabled:focus,.el-button--info.is-link.is-disabled:hover,.el-button--info.is-plain.is-disabled,.el-button--info.is-plain.is-disabled:active,.el-button--info.is-plain.is-disabled:focus,.el-button--info.is-plain.is-disabled:hover,.el-button--info.is-text.is-disabled,.el-button--info.is-text.is-disabled:active,.el-button--info.is-text.is-disabled:focus,.el-button--info.is-text.is-disabled:hover{color:var(--el-color-info-light-5);background-color:var(--el-color-info-light-9);border-color:var(--el-color-info-light-8)}.el-button--large{--el-button-size:40px;height:var(--el-button-size);padding:12px 19px;font-size:var(--el-font-size-base);border-radius:var(--el-border-radius-base)}.el-button--large [class*=el-icon]+span{margin-left:8px}.el-button--large.is-round{padding:12px 19px}.el-button--large.is-circle{width:var(--el-button-size);padding:12px}.el-button--small{--el-button-size:24px;height:var(--el-button-size);padding:5px 11px;font-size:12px;border-radius:calc(var(--el-border-radius-base) - 1px)}.el-button--small [class*=el-icon]+span{margin-left:4px}.el-button--small.is-round{padding:5px 11px}.el-button--small.is-circle{width:var(--el-button-size);padding:5px}.el-calendar{--el-calendar-border:var(--el-table-border, 1px solid var(--el-border-color-lighter));--el-calendar-header-border-bottom:var(--el-calendar-border);--el-calendar-selected-bg-color:var(--el-color-primary-light-9);--el-calendar-cell-width:85px;background-color:var(--el-fill-color-blank)}.el-calendar__header{display:flex;justify-content:space-between;padding:12px 20px;border-bottom:var(--el-calendar-header-border-bottom)}.el-calendar__title{color:var(--el-text-color);align-self:center}.el-calendar__body{padding:12px 20px 35px}.el-calendar-table{table-layout:fixed;width:100%}.el-calendar-table thead th{padding:12px 0;color:var(--el-text-color-regular);font-weight:400}.el-calendar-table:not(.is-range) td.next,.el-calendar-table:not(.is-range) td.prev{color:var(--el-text-color-placeholder)}.el-calendar-table td{border-bottom:var(--el-calendar-border);border-right:var(--el-calendar-border);vertical-align:top;transition:background-color var(--el-transition-duration-fast) ease}.el-calendar-table td.is-selected{background-color:var(--el-calendar-selected-bg-color)}.el-calendar-table td.is-today{color:var(--el-color-primary)}.el-calendar-table tr:first-child td{border-top:var(--el-calendar-border)}.el-calendar-table tr td:first-child{border-left:var(--el-calendar-border)}.el-calendar-table tr.el-calendar-table__row--hide-border td{border-top:none}.el-calendar-table .el-calendar-day{box-sizing:border-box;padding:8px;height:var(--el-calendar-cell-width)}.el-calendar-table .el-calendar-day:hover{cursor:pointer;background-color:var(--el-calendar-selected-bg-color)}.el-card{--el-card-border-color:var(--el-border-color-light);--el-card-border-radius:4px;--el-card-padding:20px;--el-card-bg-color:var(--el-fill-color-blank)}.el-card{border-radius:var(--el-card-border-radius);border:1px solid var(--el-card-border-color);background-color:var(--el-card-bg-color);overflow:hidden;color:var(--el-text-color-primary);transition:var(--el-transition-duration)}.el-card.is-always-shadow{box-shadow:var(--el-box-shadow-light)}.el-card.is-hover-shadow:focus,.el-card.is-hover-shadow:hover{box-shadow:var(--el-box-shadow-light)}.el-card__header{padding:calc(var(--el-card-padding) - 2px) var(--el-card-padding);border-bottom:1px solid var(--el-card-border-color);box-sizing:border-box}.el-card__body{padding:var(--el-card-padding)}.el-carousel__item{position:absolute;top:0;left:0;width:100%;height:100%;display:inline-block;overflow:hidden;z-index:calc(var(--el-index-normal) - 1)}.el-carousel__item.is-active{z-index:calc(var(--el-index-normal) - 1)}.el-carousel__item.is-animating{transition:transform .4s ease-in-out}.el-carousel__item--card{width:50%;transition:transform .4s ease-in-out}.el-carousel__item--card.is-in-stage{cursor:pointer;z-index:var(--el-index-normal)}.el-carousel__item--card.is-in-stage.is-hover .el-carousel__mask,.el-carousel__item--card.is-in-stage:hover .el-carousel__mask{opacity:.12}.el-carousel__item--card.is-active{z-index:calc(var(--el-index-normal) + 1)}.el-carousel__mask{position:absolute;width:100%;height:100%;top:0;left:0;background-color:var(--el-color-white);opacity:.24;transition:var(--el-transition-duration-fast)}.el-carousel{--el-carousel-arrow-font-size:12px;--el-carousel-arrow-size:36px;--el-carousel-arrow-background:rgba(31, 45, 61, 0.11);--el-carousel-arrow-hover-background:rgba(31, 45, 61, 0.23);--el-carousel-indicator-width:30px;--el-carousel-indicator-height:2px;--el-carousel-indicator-padding-horizontal:4px;--el-carousel-indicator-padding-vertical:12px;--el-carousel-indicator-out-color:var(--el-border-color-hover);position:relative}.el-carousel--horizontal{overflow-x:hidden}.el-carousel--vertical{overflow-y:hidden}.el-carousel__container{position:relative;height:300px}.el-carousel__arrow{border:none;outline:0;padding:0;margin:0;height:var(--el-carousel-arrow-size);width:var(--el-carousel-arrow-size);cursor:pointer;transition:var(--el-transition-duration);border-radius:50%;background-color:var(--el-carousel-arrow-background);color:#fff;position:absolute;top:50%;z-index:10;transform:translateY(-50%);text-align:center;font-size:var(--el-carousel-arrow-font-size);display:inline-flex;justify-content:center;align-items:center}.el-carousel__arrow--left{left:16px}.el-carousel__arrow--right{right:16px}.el-carousel__arrow:hover{background-color:var(--el-carousel-arrow-hover-background)}.el-carousel__arrow i{cursor:pointer}.el-carousel__indicators{position:absolute;list-style:none;margin:0;padding:0;z-index:calc(var(--el-index-normal) + 1)}.el-carousel__indicators--horizontal{bottom:0;left:50%;transform:translateX(-50%)}.el-carousel__indicators--vertical{right:0;top:50%;transform:translateY(-50%)}.el-carousel__indicators--outside{bottom:calc(var(--el-carousel-indicator-height) + var(--el-carousel-indicator-padding-vertical) * 2);text-align:center;position:static;transform:none}.el-carousel__indicators--outside .el-carousel__indicator:hover button{opacity:.64}.el-carousel__indicators--outside button{background-color:var(--el-carousel-indicator-out-color);opacity:.24}.el-carousel__indicators--labels{left:0;right:0;transform:none;text-align:center}.el-carousel__indicators--labels .el-carousel__button{height:auto;width:auto;padding:2px 18px;font-size:12px;color:#000}.el-carousel__indicators--labels .el-carousel__indicator{padding:6px 4px}.el-carousel__indicator{background-color:transparent;cursor:pointer}.el-carousel__indicator:hover button{opacity:.72}.el-carousel__indicator--horizontal{display:inline-block;padding:var(--el-carousel-indicator-padding-vertical) var(--el-carousel-indicator-padding-horizontal)}.el-carousel__indicator--vertical{padding:var(--el-carousel-indicator-padding-horizontal) var(--el-carousel-indicator-padding-vertical)}.el-carousel__indicator--vertical .el-carousel__button{width:var(--el-carousel-indicator-height);height:calc(var(--el-carousel-indicator-width)/ 2)}.el-carousel__indicator.is-active button{opacity:1}.el-carousel__button{display:block;opacity:.48;width:var(--el-carousel-indicator-width);height:var(--el-carousel-indicator-height);background-color:#fff;border:none;outline:0;padding:0;margin:0;cursor:pointer;transition:var(--el-transition-duration)}.carousel-arrow-left-enter-from,.carousel-arrow-left-leave-active{transform:translateY(-50%) translateX(-10px);opacity:0}.carousel-arrow-right-enter-from,.carousel-arrow-right-leave-active{transform:translateY(-50%) translateX(10px);opacity:0}.el-cascader-panel{--el-cascader-menu-text-color:var(--el-text-color-regular);--el-cascader-menu-selected-text-color:var(--el-color-primary);--el-cascader-menu-fill:var(--el-bg-color-overlay);--el-cascader-menu-font-size:var(--el-font-size-base);--el-cascader-menu-radius:var(--el-border-radius-base);--el-cascader-menu-border:solid 1px var(--el-border-color-light);--el-cascader-menu-shadow:var(--el-box-shadow-light);--el-cascader-node-background-hover:var(--el-fill-color-light);--el-cascader-node-color-disabled:var(--el-text-color-placeholder);--el-cascader-color-empty:var(--el-text-color-placeholder);--el-cascader-tag-background:var(--el-fill-color)}.el-cascader-panel{display:flex;border-radius:var(--el-cascader-menu-radius);font-size:var(--el-cascader-menu-font-size)}.el-cascader-panel.is-bordered{border:var(--el-cascader-menu-border);border-radius:var(--el-cascader-menu-radius)}.el-cascader-menu{min-width:180px;box-sizing:border-box;color:var(--el-cascader-menu-text-color);border-right:var(--el-cascader-menu-border)}.el-cascader-menu:last-child{border-right:none}.el-cascader-menu:last-child .el-cascader-node{padding-right:20px}.el-cascader-menu__wrap.el-scrollbar__wrap{height:204px}.el-cascader-menu__list{position:relative;min-height:100%;margin:0;padding:6px 0;list-style:none;box-sizing:border-box}.el-cascader-menu__hover-zone{position:absolute;top:0;left:0;width:100%;height:100%;pointer-events:none}.el-cascader-menu__empty-text{position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);display:flex;align-items:center;color:var(--el-cascader-color-empty)}.el-cascader-menu__empty-text .is-loading{margin-right:2px}.el-cascader-node{position:relative;display:flex;align-items:center;padding:0 30px 0 20px;height:34px;line-height:34px;outline:0}.el-cascader-node.is-selectable.in-active-path{color:var(--el-cascader-menu-text-color)}.el-cascader-node.in-active-path,.el-cascader-node.is-active,.el-cascader-node.is-selectable.in-checked-path{color:var(--el-cascader-menu-selected-text-color);font-weight:700}.el-cascader-node:not(.is-disabled){cursor:pointer}.el-cascader-node:not(.is-disabled):focus,.el-cascader-node:not(.is-disabled):hover{background:var(--el-cascader-node-background-hover)}.el-cascader-node.is-disabled{color:var(--el-cascader-node-color-disabled);cursor:not-allowed}.el-cascader-node__prefix{position:absolute;left:10px}.el-cascader-node__postfix{position:absolute;right:10px}.el-cascader-node__label{flex:1;text-align:left;padding:0 8px;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}.el-cascader-node>.el-checkbox{margin-right:0}.el-cascader-node>.el-radio{margin-right:0}.el-cascader-node>.el-radio .el-radio__label{padding-left:0}.el-cascader{--el-cascader-menu-text-color:var(--el-text-color-regular);--el-cascader-menu-selected-text-color:var(--el-color-primary);--el-cascader-menu-fill:var(--el-bg-color-overlay);--el-cascader-menu-font-size:var(--el-font-size-base);--el-cascader-menu-radius:var(--el-border-radius-base);--el-cascader-menu-border:solid 1px var(--el-border-color-light);--el-cascader-menu-shadow:var(--el-box-shadow-light);--el-cascader-node-background-hover:var(--el-fill-color-light);--el-cascader-node-color-disabled:var(--el-text-color-placeholder);--el-cascader-color-empty:var(--el-text-color-placeholder);--el-cascader-tag-background:var(--el-fill-color);display:inline-block;vertical-align:middle;position:relative;font-size:var(--el-font-size-base);line-height:32px;outline:0}.el-cascader:not(.is-disabled):hover .el-input__wrapper{cursor:pointer;box-shadow:0 0 0 1px var(--el-input-hover-border-color) inset}.el-cascader .el-input{display:flex;cursor:pointer}.el-cascader .el-input .el-input__inner{text-overflow:ellipsis;cursor:pointer}.el-cascader .el-input .el-input__suffix-inner .el-icon{height:calc(100% - 2px)}.el-cascader .el-input .el-input__suffix-inner .el-icon svg{vertical-align:middle}.el-cascader .el-input .icon-arrow-down{transition:transform var(--el-transition-duration);font-size:14px}.el-cascader .el-input .icon-arrow-down.is-reverse{transform:rotateZ(180deg)}.el-cascader .el-input .icon-circle-close:hover{color:var(--el-input-clear-hover-color,var(--el-text-color-secondary))}.el-cascader .el-input.is-focus .el-input__wrapper{box-shadow:0 0 0 1px var(--el-input-focus-border-color,var(--el-color-primary)) inset}.el-cascader--large{font-size:14px;line-height:40px}.el-cascader--small{font-size:12px;line-height:24px}.el-cascader.is-disabled .el-cascader__label{z-index:calc(var(--el-index-normal) + 1);color:var(--el-disabled-text-color)}.el-cascader__dropdown{--el-cascader-menu-text-color:var(--el-text-color-regular);--el-cascader-menu-selected-text-color:var(--el-color-primary);--el-cascader-menu-fill:var(--el-bg-color-overlay);--el-cascader-menu-font-size:var(--el-font-size-base);--el-cascader-menu-radius:var(--el-border-radius-base);--el-cascader-menu-border:solid 1px var(--el-border-color-light);--el-cascader-menu-shadow:var(--el-box-shadow-light);--el-cascader-node-background-hover:var(--el-fill-color-light);--el-cascader-node-color-disabled:var(--el-text-color-placeholder);--el-cascader-color-empty:var(--el-text-color-placeholder);--el-cascader-tag-background:var(--el-fill-color)}.el-cascader__dropdown{font-size:var(--el-cascader-menu-font-size);border-radius:var(--el-cascader-menu-radius)}.el-cascader__dropdown.el-popper{background:var(--el-cascader-menu-fill);border:var(--el-cascader-menu-border);box-shadow:var(--el-cascader-menu-shadow)}.el-cascader__dropdown.el-popper .el-popper__arrow::before{border:var(--el-cascader-menu-border)}.el-cascader__dropdown.el-popper[data-popper-placement^=top] .el-popper__arrow::before{border-top-color:transparent;border-left-color:transparent}.el-cascader__dropdown.el-popper[data-popper-placement^=bottom] .el-popper__arrow::before{border-bottom-color:transparent;border-right-color:transparent}.el-cascader__dropdown.el-popper[data-popper-placement^=left] .el-popper__arrow::before{border-left-color:transparent;border-bottom-color:transparent}.el-cascader__dropdown.el-popper[data-popper-placement^=right] .el-popper__arrow::before{border-right-color:transparent;border-top-color:transparent}.el-cascader__dropdown.el-popper{box-shadow:var(--el-cascader-menu-shadow)}.el-cascader__tags{position:absolute;left:0;right:30px;top:50%;transform:translateY(-50%);display:flex;flex-wrap:wrap;line-height:normal;text-align:left;box-sizing:border-box}.el-cascader__tags .el-tag{display:inline-flex;align-items:center;max-width:100%;margin:2px 0 2px 6px;text-overflow:ellipsis;background:var(--el-cascader-tag-background)}.el-cascader__tags .el-tag:not(.is-hit){border-color:transparent}.el-cascader__tags .el-tag>span{flex:1;overflow:hidden;text-overflow:ellipsis}.el-cascader__tags .el-tag .el-icon-close{flex:none;background-color:var(--el-text-color-placeholder);color:var(--el-color-white)}.el-cascader__tags .el-tag .el-icon-close:hover{background-color:var(--el-text-color-secondary)}.el-cascader__collapse-tags{white-space:normal;z-index:var(--el-index-normal)}.el-cascader__collapse-tags .el-tag{display:inline-flex;align-items:center;max-width:100%;margin:2px 0 2px 6px;text-overflow:ellipsis;background:var(--el-fill-color)}.el-cascader__collapse-tags .el-tag:not(.is-hit){border-color:transparent}.el-cascader__collapse-tags .el-tag>span{flex:1;overflow:hidden;text-overflow:ellipsis}.el-cascader__collapse-tags .el-tag .el-icon-close{flex:none;background-color:var(--el-text-color-placeholder);color:var(--el-color-white)}.el-cascader__collapse-tags .el-tag .el-icon-close:hover{background-color:var(--el-text-color-secondary)}.el-cascader__suggestion-panel{border-radius:var(--el-cascader-menu-radius)}.el-cascader__suggestion-list{max-height:204px;margin:0;padding:6px 0;font-size:var(--el-font-size-base);color:var(--el-cascader-menu-text-color);text-align:center}.el-cascader__suggestion-item{display:flex;justify-content:space-between;align-items:center;height:34px;padding:0 15px;text-align:left;outline:0;cursor:pointer}.el-cascader__suggestion-item:focus,.el-cascader__suggestion-item:hover{background:var(--el-cascader-node-background-hover)}.el-cascader__suggestion-item.is-checked{color:var(--el-cascader-menu-selected-text-color);font-weight:700}.el-cascader__suggestion-item>span{margin-right:10px}.el-cascader__empty-text{margin:10px 0;color:var(--el-cascader-color-empty)}.el-cascader__search-input{flex:1;height:24px;min-width:60px;margin:2px 0 2px 11px;padding:0;color:var(--el-cascader-menu-text-color);border:none;outline:0;box-sizing:border-box;background:0 0}.el-cascader__search-input::-moz-placeholder{color:transparent}.el-cascader__search-input:-ms-input-placeholder{color:transparent}.el-cascader__search-input::placeholder{color:transparent}.el-check-tag{background-color:var(--el-color-info-light-9);border-radius:var(--el-border-radius-base);color:var(--el-color-info);cursor:pointer;display:inline-block;font-size:var(--el-font-size-base);line-height:var(--el-font-size-base);padding:7px 15px;transition:var(--el-transition-all);font-weight:700}.el-check-tag:hover{background-color:var(--el-color-info-light-7)}.el-check-tag.is-checked{background-color:var(--el-color-primary-light-8);color:var(--el-color-primary)}.el-check-tag.is-checked:hover{background-color:var(--el-color-primary-light-7)}.el-checkbox-button{--el-checkbox-button-checked-bg-color:var(--el-color-primary);--el-checkbox-button-checked-text-color:var(--el-color-white);--el-checkbox-button-checked-border-color:var(--el-color-primary)}.el-checkbox-button{position:relative;display:inline-block}.el-checkbox-button__inner{display:inline-block;line-height:1;font-weight:var(--el-checkbox-font-weight);white-space:nowrap;vertical-align:middle;cursor:pointer;background:var(--el-button-bg-color,var(--el-fill-color-blank));border:var(--el-border);border-left:0;color:var(--el-button-text-color,var(--el-text-color-regular));-webkit-appearance:none;text-align:center;box-sizing:border-box;outline:0;margin:0;position:relative;transition:var(--el-transition-all);-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;padding:8px 15px;font-size:var(--el-font-size-base);border-radius:0}.el-checkbox-button__inner.is-round{padding:8px 15px}.el-checkbox-button__inner:hover{color:var(--el-color-primary)}.el-checkbox-button__inner [class*=el-icon-]{line-height:.9}.el-checkbox-button__inner [class*=el-icon-]+span{margin-left:5px}.el-checkbox-button__original{opacity:0;outline:0;position:absolute;margin:0;z-index:-1}.el-checkbox-button.is-checked .el-checkbox-button__inner{color:var(--el-checkbox-button-checked-text-color);background-color:var(--el-checkbox-button-checked-bg-color);border-color:var(--el-checkbox-button-checked-border-color);box-shadow:-1px 0 0 0 var(--el-color-primary-light-7)}.el-checkbox-button.is-checked:first-child .el-checkbox-button__inner{border-left-color:var(--el-checkbox-button-checked-border-color)}.el-checkbox-button.is-disabled .el-checkbox-button__inner{color:var(--el-disabled-text-color);cursor:not-allowed;background-image:none;background-color:var(--el-button-disabled-bg-color,var(--el-fill-color-blank));border-color:var(--el-button-disabled-border-color,var(--el-border-color-light));box-shadow:none}.el-checkbox-button.is-disabled:first-child .el-checkbox-button__inner{border-left-color:var(--el-button-disabled-border-color,var(--el-border-color-light))}.el-checkbox-button:first-child .el-checkbox-button__inner{border-left:var(--el-border);border-top-left-radius:var(--el-border-radius-base);border-bottom-left-radius:var(--el-border-radius-base);box-shadow:none!important}.el-checkbox-button.is-focus .el-checkbox-button__inner{border-color:var(--el-checkbox-button-checked-border-color)}.el-checkbox-button:last-child .el-checkbox-button__inner{border-top-right-radius:var(--el-border-radius-base);border-bottom-right-radius:var(--el-border-radius-base)}.el-checkbox-button--large .el-checkbox-button__inner{padding:12px 19px;font-size:var(--el-font-size-base);border-radius:0}.el-checkbox-button--large .el-checkbox-button__inner.is-round{padding:12px 19px}.el-checkbox-button--small .el-checkbox-button__inner{padding:5px 11px;font-size:12px;border-radius:0}.el-checkbox-button--small .el-checkbox-button__inner.is-round{padding:5px 11px}.el-checkbox-group{font-size:0;line-height:0}.el-checkbox{--el-checkbox-font-size:14px;--el-checkbox-font-weight:var(--el-font-weight-primary);--el-checkbox-text-color:var(--el-text-color-regular);--el-checkbox-input-height:14px;--el-checkbox-input-width:14px;--el-checkbox-border-radius:var(--el-border-radius-small);--el-checkbox-bg-color:var(--el-fill-color-blank);--el-checkbox-input-border:var(--el-border);--el-checkbox-disabled-border-color:var(--el-border-color);--el-checkbox-disabled-input-fill:var(--el-fill-color-light);--el-checkbox-disabled-icon-color:var(--el-text-color-placeholder);--el-checkbox-disabled-checked-input-fill:var(--el-border-color-extra-light);--el-checkbox-disabled-checked-input-border-color:var(--el-border-color);--el-checkbox-disabled-checked-icon-color:var(--el-text-color-placeholder);--el-checkbox-checked-text-color:var(--el-color-primary);--el-checkbox-checked-input-border-color:var(--el-color-primary);--el-checkbox-checked-bg-color:var(--el-color-primary);--el-checkbox-checked-icon-color:var(--el-color-white);--el-checkbox-input-border-color-hover:var(--el-color-primary)}.el-checkbox{color:var(--el-checkbox-text-color);font-weight:var(--el-checkbox-font-weight);font-size:var(--el-font-size-base);position:relative;cursor:pointer;display:inline-flex;align-items:center;white-space:nowrap;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;margin-right:30px;height:32px}.el-checkbox.is-bordered{padding:0 15px 0 9px;border-radius:var(--el-border-radius-base);border:var(--el-border);box-sizing:border-box}.el-checkbox.is-bordered.is-checked{border-color:var(--el-color-primary)}.el-checkbox.is-bordered.is-disabled{border-color:var(--el-border-color-lighter);cursor:not-allowed}.el-checkbox.is-bordered.el-checkbox--large{padding:0 19px 0 11px;border-radius:var(--el-border-radius-base)}.el-checkbox.is-bordered.el-checkbox--large .el-checkbox__label{font-size:var(--el-font-size-base)}.el-checkbox.is-bordered.el-checkbox--large .el-checkbox__inner{height:14px;width:14px}.el-checkbox.is-bordered.el-checkbox--small{padding:0 11px 0 7px;border-radius:calc(var(--el-border-radius-base) - 1px)}.el-checkbox.is-bordered.el-checkbox--small .el-checkbox__label{font-size:12px}.el-checkbox.is-bordered.el-checkbox--small .el-checkbox__inner{height:12px;width:12px}.el-checkbox.is-bordered.el-checkbox--small .el-checkbox__inner::after{height:6px;width:2px}.el-checkbox input:focus-visible+.el-checkbox__inner{outline:2px solid var(--el-checkbox-input-border-color-hover);outline-offset:1px;border-radius:var(--el-checkbox-border-radius)}.el-checkbox__input{white-space:nowrap;cursor:pointer;outline:0;display:inline-flex;position:relative}.el-checkbox__input.is-disabled .el-checkbox__inner{background-color:var(--el-checkbox-disabled-input-fill);border-color:var(--el-checkbox-disabled-border-color);cursor:not-allowed}.el-checkbox__input.is-disabled .el-checkbox__inner::after{cursor:not-allowed;border-color:var(--el-checkbox-disabled-icon-color)}.el-checkbox__input.is-disabled .el-checkbox__inner+.el-checkbox__label{cursor:not-allowed}.el-checkbox__input.is-disabled.is-checked .el-checkbox__inner{background-color:var(--el-checkbox-disabled-checked-input-fill);border-color:var(--el-checkbox-disabled-checked-input-border-color)}.el-checkbox__input.is-disabled.is-checked .el-checkbox__inner::after{border-color:var(--el-checkbox-disabled-checked-icon-color)}.el-checkbox__input.is-disabled.is-indeterminate .el-checkbox__inner{background-color:var(--el-checkbox-disabled-checked-input-fill);border-color:var(--el-checkbox-disabled-checked-input-border-color)}.el-checkbox__input.is-disabled.is-indeterminate .el-checkbox__inner::before{background-color:var(--el-checkbox-disabled-checked-icon-color);border-color:var(--el-checkbox-disabled-checked-icon-color)}.el-checkbox__input.is-disabled+span.el-checkbox__label{color:var(--el-disabled-text-color);cursor:not-allowed}.el-checkbox__input.is-checked .el-checkbox__inner{background-color:var(--el-checkbox-checked-bg-color);border-color:var(--el-checkbox-checked-input-border-color)}.el-checkbox__input.is-checked .el-checkbox__inner::after{transform:rotate(45deg) scaleY(1)}.el-checkbox__input.is-checked+.el-checkbox__label{color:var(--el-checkbox-checked-text-color)}.el-checkbox__input.is-focus:not(.is-checked) .el-checkbox__original:not(:focus-visible){border-color:var(--el-checkbox-input-border-color-hover)}.el-checkbox__input.is-indeterminate .el-checkbox__inner{background-color:var(--el-checkbox-checked-bg-color);border-color:var(--el-checkbox-checked-input-border-color)}.el-checkbox__input.is-indeterminate .el-checkbox__inner::before{content:"";position:absolute;display:block;background-color:var(--el-checkbox-checked-icon-color);height:2px;transform:scale(.5);left:0;right:0;top:5px}.el-checkbox__input.is-indeterminate .el-checkbox__inner::after{display:none}.el-checkbox__inner{display:inline-block;position:relative;border:var(--el-checkbox-input-border);border-radius:var(--el-checkbox-border-radius);box-sizing:border-box;width:var(--el-checkbox-input-width);height:var(--el-checkbox-input-height);background-color:var(--el-checkbox-bg-color);z-index:var(--el-index-normal);transition:border-color .25s cubic-bezier(.71,-.46,.29,1.46),background-color .25s cubic-bezier(.71,-.46,.29,1.46),outline .25s cubic-bezier(.71,-.46,.29,1.46)}.el-checkbox__inner:hover{border-color:var(--el-checkbox-input-border-color-hover)}.el-checkbox__inner::after{box-sizing:content-box;content:"";border:1px solid var(--el-checkbox-checked-icon-color);border-left:0;border-top:0;height:7px;left:4px;position:absolute;top:1px;transform:rotate(45deg) scaleY(0);width:3px;transition:transform .15s ease-in 50ms;transform-origin:center}.el-checkbox__original{opacity:0;outline:0;position:absolute;margin:0;width:0;height:0;z-index:-1}.el-checkbox__label{display:inline-block;padding-left:8px;line-height:1;font-size:var(--el-checkbox-font-size)}.el-checkbox.el-checkbox--large{height:40px}.el-checkbox.el-checkbox--large .el-checkbox__label{font-size:14px}.el-checkbox.el-checkbox--large .el-checkbox__inner{width:14px;height:14px}.el-checkbox.el-checkbox--small{height:24px}.el-checkbox.el-checkbox--small .el-checkbox__label{font-size:12px}.el-checkbox.el-checkbox--small .el-checkbox__inner{width:12px;height:12px}.el-checkbox.el-checkbox--small .el-checkbox__input.is-indeterminate .el-checkbox__inner::before{top:4px}.el-checkbox.el-checkbox--small .el-checkbox__inner::after{width:2px;height:6px}.el-checkbox:last-of-type{margin-right:0}[class*=el-col-]{box-sizing:border-box}[class*=el-col-].is-guttered{display:block;min-height:1px}.el-col-0{display:none}.el-col-0.is-guttered{display:none}.el-col-0{max-width:0%;flex:0 0 0%}.el-col-offset-0{margin-left:0}.el-col-pull-0{position:relative;right:0}.el-col-push-0{position:relative;left:0}.el-col-1{max-width:4.1666666667%;flex:0 0 4.1666666667%}.el-col-offset-1{margin-left:4.1666666667%}.el-col-pull-1{position:relative;right:4.1666666667%}.el-col-push-1{position:relative;left:4.1666666667%}.el-col-2{max-width:8.3333333333%;flex:0 0 8.3333333333%}.el-col-offset-2{margin-left:8.3333333333%}.el-col-pull-2{position:relative;right:8.3333333333%}.el-col-push-2{position:relative;left:8.3333333333%}.el-col-3{max-width:12.5%;flex:0 0 12.5%}.el-col-offset-3{margin-left:12.5%}.el-col-pull-3{position:relative;right:12.5%}.el-col-push-3{position:relative;left:12.5%}.el-col-4{max-width:16.6666666667%;flex:0 0 16.6666666667%}.el-col-offset-4{margin-left:16.6666666667%}.el-col-pull-4{position:relative;right:16.6666666667%}.el-col-push-4{position:relative;left:16.6666666667%}.el-col-5{max-width:20.8333333333%;flex:0 0 20.8333333333%}.el-col-offset-5{margin-left:20.8333333333%}.el-col-pull-5{position:relative;right:20.8333333333%}.el-col-push-5{position:relative;left:20.8333333333%}.el-col-6{max-width:25%;flex:0 0 25%}.el-col-offset-6{margin-left:25%}.el-col-pull-6{position:relative;right:25%}.el-col-push-6{position:relative;left:25%}.el-col-7{max-width:29.1666666667%;flex:0 0 29.1666666667%}.el-col-offset-7{margin-left:29.1666666667%}.el-col-pull-7{position:relative;right:29.1666666667%}.el-col-push-7{position:relative;left:29.1666666667%}.el-col-8{max-width:33.3333333333%;flex:0 0 33.3333333333%}.el-col-offset-8{margin-left:33.3333333333%}.el-col-pull-8{position:relative;right:33.3333333333%}.el-col-push-8{position:relative;left:33.3333333333%}.el-col-9{max-width:37.5%;flex:0 0 37.5%}.el-col-offset-9{margin-left:37.5%}.el-col-pull-9{position:relative;right:37.5%}.el-col-push-9{position:relative;left:37.5%}.el-col-10{max-width:41.6666666667%;flex:0 0 41.6666666667%}.el-col-offset-10{margin-left:41.6666666667%}.el-col-pull-10{position:relative;right:41.6666666667%}.el-col-push-10{position:relative;left:41.6666666667%}.el-col-11{max-width:45.8333333333%;flex:0 0 45.8333333333%}.el-col-offset-11{margin-left:45.8333333333%}.el-col-pull-11{position:relative;right:45.8333333333%}.el-col-push-11{position:relative;left:45.8333333333%}.el-col-12{max-width:50%;flex:0 0 50%}.el-col-offset-12{margin-left:50%}.el-col-pull-12{position:relative;right:50%}.el-col-push-12{position:relative;left:50%}.el-col-13{max-width:54.1666666667%;flex:0 0 54.1666666667%}.el-col-offset-13{margin-left:54.1666666667%}.el-col-pull-13{position:relative;right:54.1666666667%}.el-col-push-13{position:relative;left:54.1666666667%}.el-col-14{max-width:58.3333333333%;flex:0 0 58.3333333333%}.el-col-offset-14{margin-left:58.3333333333%}.el-col-pull-14{position:relative;right:58.3333333333%}.el-col-push-14{position:relative;left:58.3333333333%}.el-col-15{max-width:62.5%;flex:0 0 62.5%}.el-col-offset-15{margin-left:62.5%}.el-col-pull-15{position:relative;right:62.5%}.el-col-push-15{position:relative;left:62.5%}.el-col-16{max-width:66.6666666667%;flex:0 0 66.6666666667%}.el-col-offset-16{margin-left:66.6666666667%}.el-col-pull-16{position:relative;right:66.6666666667%}.el-col-push-16{position:relative;left:66.6666666667%}.el-col-17{max-width:70.8333333333%;flex:0 0 70.8333333333%}.el-col-offset-17{margin-left:70.8333333333%}.el-col-pull-17{position:relative;right:70.8333333333%}.el-col-push-17{position:relative;left:70.8333333333%}.el-col-18{max-width:75%;flex:0 0 75%}.el-col-offset-18{margin-left:75%}.el-col-pull-18{position:relative;right:75%}.el-col-push-18{position:relative;left:75%}.el-col-19{max-width:79.1666666667%;flex:0 0 79.1666666667%}.el-col-offset-19{margin-left:79.1666666667%}.el-col-pull-19{position:relative;right:79.1666666667%}.el-col-push-19{position:relative;left:79.1666666667%}.el-col-20{max-width:83.3333333333%;flex:0 0 83.3333333333%}.el-col-offset-20{margin-left:83.3333333333%}.el-col-pull-20{position:relative;right:83.3333333333%}.el-col-push-20{position:relative;left:83.3333333333%}.el-col-21{max-width:87.5%;flex:0 0 87.5%}.el-col-offset-21{margin-left:87.5%}.el-col-pull-21{position:relative;right:87.5%}.el-col-push-21{position:relative;left:87.5%}.el-col-22{max-width:91.6666666667%;flex:0 0 91.6666666667%}.el-col-offset-22{margin-left:91.6666666667%}.el-col-pull-22{position:relative;right:91.6666666667%}.el-col-push-22{position:relative;left:91.6666666667%}.el-col-23{max-width:95.8333333333%;flex:0 0 95.8333333333%}.el-col-offset-23{margin-left:95.8333333333%}.el-col-pull-23{position:relative;right:95.8333333333%}.el-col-push-23{position:relative;left:95.8333333333%}.el-col-24{max-width:100%;flex:0 0 100%}.el-col-offset-24{margin-left:100%}.el-col-pull-24{position:relative;right:100%}.el-col-push-24{position:relative;left:100%}@media only screen and (max-width:768px){.el-col-xs-0{display:none}.el-col-xs-0.is-guttered{display:none}.el-col-xs-0{max-width:0%;flex:0 0 0%}.el-col-xs-offset-0{margin-left:0}.el-col-xs-pull-0{position:relative;right:0}.el-col-xs-push-0{position:relative;left:0}.el-col-xs-1{display:block;max-width:4.1666666667%;flex:0 0 4.1666666667%}.el-col-xs-offset-1{margin-left:4.1666666667%}.el-col-xs-pull-1{position:relative;right:4.1666666667%}.el-col-xs-push-1{position:relative;left:4.1666666667%}.el-col-xs-2{display:block;max-width:8.3333333333%;flex:0 0 8.3333333333%}.el-col-xs-offset-2{margin-left:8.3333333333%}.el-col-xs-pull-2{position:relative;right:8.3333333333%}.el-col-xs-push-2{position:relative;left:8.3333333333%}.el-col-xs-3{display:block;max-width:12.5%;flex:0 0 12.5%}.el-col-xs-offset-3{margin-left:12.5%}.el-col-xs-pull-3{position:relative;right:12.5%}.el-col-xs-push-3{position:relative;left:12.5%}.el-col-xs-4{display:block;max-width:16.6666666667%;flex:0 0 16.6666666667%}.el-col-xs-offset-4{margin-left:16.6666666667%}.el-col-xs-pull-4{position:relative;right:16.6666666667%}.el-col-xs-push-4{position:relative;left:16.6666666667%}.el-col-xs-5{display:block;max-width:20.8333333333%;flex:0 0 20.8333333333%}.el-col-xs-offset-5{margin-left:20.8333333333%}.el-col-xs-pull-5{position:relative;right:20.8333333333%}.el-col-xs-push-5{position:relative;left:20.8333333333%}.el-col-xs-6{display:block;max-width:25%;flex:0 0 25%}.el-col-xs-offset-6{margin-left:25%}.el-col-xs-pull-6{position:relative;right:25%}.el-col-xs-push-6{position:relative;left:25%}.el-col-xs-7{display:block;max-width:29.1666666667%;flex:0 0 29.1666666667%}.el-col-xs-offset-7{margin-left:29.1666666667%}.el-col-xs-pull-7{position:relative;right:29.1666666667%}.el-col-xs-push-7{position:relative;left:29.1666666667%}.el-col-xs-8{display:block;max-width:33.3333333333%;flex:0 0 33.3333333333%}.el-col-xs-offset-8{margin-left:33.3333333333%}.el-col-xs-pull-8{position:relative;right:33.3333333333%}.el-col-xs-push-8{position:relative;left:33.3333333333%}.el-col-xs-9{display:block;max-width:37.5%;flex:0 0 37.5%}.el-col-xs-offset-9{margin-left:37.5%}.el-col-xs-pull-9{position:relative;right:37.5%}.el-col-xs-push-9{position:relative;left:37.5%}.el-col-xs-10{display:block;max-width:41.6666666667%;flex:0 0 41.6666666667%}.el-col-xs-offset-10{margin-left:41.6666666667%}.el-col-xs-pull-10{position:relative;right:41.6666666667%}.el-col-xs-push-10{position:relative;left:41.6666666667%}.el-col-xs-11{display:block;max-width:45.8333333333%;flex:0 0 45.8333333333%}.el-col-xs-offset-11{margin-left:45.8333333333%}.el-col-xs-pull-11{position:relative;right:45.8333333333%}.el-col-xs-push-11{position:relative;left:45.8333333333%}.el-col-xs-12{display:block;max-width:50%;flex:0 0 50%}.el-col-xs-offset-12{margin-left:50%}.el-col-xs-pull-12{position:relative;right:50%}.el-col-xs-push-12{position:relative;left:50%}.el-col-xs-13{display:block;max-width:54.1666666667%;flex:0 0 54.1666666667%}.el-col-xs-offset-13{margin-left:54.1666666667%}.el-col-xs-pull-13{position:relative;right:54.1666666667%}.el-col-xs-push-13{position:relative;left:54.1666666667%}.el-col-xs-14{display:block;max-width:58.3333333333%;flex:0 0 58.3333333333%}.el-col-xs-offset-14{margin-left:58.3333333333%}.el-col-xs-pull-14{position:relative;right:58.3333333333%}.el-col-xs-push-14{position:relative;left:58.3333333333%}.el-col-xs-15{display:block;max-width:62.5%;flex:0 0 62.5%}.el-col-xs-offset-15{margin-left:62.5%}.el-col-xs-pull-15{position:relative;right:62.5%}.el-col-xs-push-15{position:relative;left:62.5%}.el-col-xs-16{display:block;max-width:66.6666666667%;flex:0 0 66.6666666667%}.el-col-xs-offset-16{margin-left:66.6666666667%}.el-col-xs-pull-16{position:relative;right:66.6666666667%}.el-col-xs-push-16{position:relative;left:66.6666666667%}.el-col-xs-17{display:block;max-width:70.8333333333%;flex:0 0 70.8333333333%}.el-col-xs-offset-17{margin-left:70.8333333333%}.el-col-xs-pull-17{position:relative;right:70.8333333333%}.el-col-xs-push-17{position:relative;left:70.8333333333%}.el-col-xs-18{display:block;max-width:75%;flex:0 0 75%}.el-col-xs-offset-18{margin-left:75%}.el-col-xs-pull-18{position:relative;right:75%}.el-col-xs-push-18{position:relative;left:75%}.el-col-xs-19{display:block;max-width:79.1666666667%;flex:0 0 79.1666666667%}.el-col-xs-offset-19{margin-left:79.1666666667%}.el-col-xs-pull-19{position:relative;right:79.1666666667%}.el-col-xs-push-19{position:relative;left:79.1666666667%}.el-col-xs-20{display:block;max-width:83.3333333333%;flex:0 0 83.3333333333%}.el-col-xs-offset-20{margin-left:83.3333333333%}.el-col-xs-pull-20{position:relative;right:83.3333333333%}.el-col-xs-push-20{position:relative;left:83.3333333333%}.el-col-xs-21{display:block;max-width:87.5%;flex:0 0 87.5%}.el-col-xs-offset-21{margin-left:87.5%}.el-col-xs-pull-21{position:relative;right:87.5%}.el-col-xs-push-21{position:relative;left:87.5%}.el-col-xs-22{display:block;max-width:91.6666666667%;flex:0 0 91.6666666667%}.el-col-xs-offset-22{margin-left:91.6666666667%}.el-col-xs-pull-22{position:relative;right:91.6666666667%}.el-col-xs-push-22{position:relative;left:91.6666666667%}.el-col-xs-23{display:block;max-width:95.8333333333%;flex:0 0 95.8333333333%}.el-col-xs-offset-23{margin-left:95.8333333333%}.el-col-xs-pull-23{position:relative;right:95.8333333333%}.el-col-xs-push-23{position:relative;left:95.8333333333%}.el-col-xs-24{display:block;max-width:100%;flex:0 0 100%}.el-col-xs-offset-24{margin-left:100%}.el-col-xs-pull-24{position:relative;right:100%}.el-col-xs-push-24{position:relative;left:100%}}@media only screen and (min-width:768px){.el-col-sm-0{display:none}.el-col-sm-0.is-guttered{display:none}.el-col-sm-0{max-width:0%;flex:0 0 0%}.el-col-sm-offset-0{margin-left:0}.el-col-sm-pull-0{position:relative;right:0}.el-col-sm-push-0{position:relative;left:0}.el-col-sm-1{display:block;max-width:4.1666666667%;flex:0 0 4.1666666667%}.el-col-sm-offset-1{margin-left:4.1666666667%}.el-col-sm-pull-1{position:relative;right:4.1666666667%}.el-col-sm-push-1{position:relative;left:4.1666666667%}.el-col-sm-2{display:block;max-width:8.3333333333%;flex:0 0 8.3333333333%}.el-col-sm-offset-2{margin-left:8.3333333333%}.el-col-sm-pull-2{position:relative;right:8.3333333333%}.el-col-sm-push-2{position:relative;left:8.3333333333%}.el-col-sm-3{display:block;max-width:12.5%;flex:0 0 12.5%}.el-col-sm-offset-3{margin-left:12.5%}.el-col-sm-pull-3{position:relative;right:12.5%}.el-col-sm-push-3{position:relative;left:12.5%}.el-col-sm-4{display:block;max-width:16.6666666667%;flex:0 0 16.6666666667%}.el-col-sm-offset-4{margin-left:16.6666666667%}.el-col-sm-pull-4{position:relative;right:16.6666666667%}.el-col-sm-push-4{position:relative;left:16.6666666667%}.el-col-sm-5{display:block;max-width:20.8333333333%;flex:0 0 20.8333333333%}.el-col-sm-offset-5{margin-left:20.8333333333%}.el-col-sm-pull-5{position:relative;right:20.8333333333%}.el-col-sm-push-5{position:relative;left:20.8333333333%}.el-col-sm-6{display:block;max-width:25%;flex:0 0 25%}.el-col-sm-offset-6{margin-left:25%}.el-col-sm-pull-6{position:relative;right:25%}.el-col-sm-push-6{position:relative;left:25%}.el-col-sm-7{display:block;max-width:29.1666666667%;flex:0 0 29.1666666667%}.el-col-sm-offset-7{margin-left:29.1666666667%}.el-col-sm-pull-7{position:relative;right:29.1666666667%}.el-col-sm-push-7{position:relative;left:29.1666666667%}.el-col-sm-8{display:block;max-width:33.3333333333%;flex:0 0 33.3333333333%}.el-col-sm-offset-8{margin-left:33.3333333333%}.el-col-sm-pull-8{position:relative;right:33.3333333333%}.el-col-sm-push-8{position:relative;left:33.3333333333%}.el-col-sm-9{display:block;max-width:37.5%;flex:0 0 37.5%}.el-col-sm-offset-9{margin-left:37.5%}.el-col-sm-pull-9{position:relative;right:37.5%}.el-col-sm-push-9{position:relative;left:37.5%}.el-col-sm-10{display:block;max-width:41.6666666667%;flex:0 0 41.6666666667%}.el-col-sm-offset-10{margin-left:41.6666666667%}.el-col-sm-pull-10{position:relative;right:41.6666666667%}.el-col-sm-push-10{position:relative;left:41.6666666667%}.el-col-sm-11{display:block;max-width:45.8333333333%;flex:0 0 45.8333333333%}.el-col-sm-offset-11{margin-left:45.8333333333%}.el-col-sm-pull-11{position:relative;right:45.8333333333%}.el-col-sm-push-11{position:relative;left:45.8333333333%}.el-col-sm-12{display:block;max-width:50%;flex:0 0 50%}.el-col-sm-offset-12{margin-left:50%}.el-col-sm-pull-12{position:relative;right:50%}.el-col-sm-push-12{position:relative;left:50%}.el-col-sm-13{display:block;max-width:54.1666666667%;flex:0 0 54.1666666667%}.el-col-sm-offset-13{margin-left:54.1666666667%}.el-col-sm-pull-13{position:relative;right:54.1666666667%}.el-col-sm-push-13{position:relative;left:54.1666666667%}.el-col-sm-14{display:block;max-width:58.3333333333%;flex:0 0 58.3333333333%}.el-col-sm-offset-14{margin-left:58.3333333333%}.el-col-sm-pull-14{position:relative;right:58.3333333333%}.el-col-sm-push-14{position:relative;left:58.3333333333%}.el-col-sm-15{display:block;max-width:62.5%;flex:0 0 62.5%}.el-col-sm-offset-15{margin-left:62.5%}.el-col-sm-pull-15{position:relative;right:62.5%}.el-col-sm-push-15{position:relative;left:62.5%}.el-col-sm-16{display:block;max-width:66.6666666667%;flex:0 0 66.6666666667%}.el-col-sm-offset-16{margin-left:66.6666666667%}.el-col-sm-pull-16{position:relative;right:66.6666666667%}.el-col-sm-push-16{position:relative;left:66.6666666667%}.el-col-sm-17{display:block;max-width:70.8333333333%;flex:0 0 70.8333333333%}.el-col-sm-offset-17{margin-left:70.8333333333%}.el-col-sm-pull-17{position:relative;right:70.8333333333%}.el-col-sm-push-17{position:relative;left:70.8333333333%}.el-col-sm-18{display:block;max-width:75%;flex:0 0 75%}.el-col-sm-offset-18{margin-left:75%}.el-col-sm-pull-18{position:relative;right:75%}.el-col-sm-push-18{position:relative;left:75%}.el-col-sm-19{display:block;max-width:79.1666666667%;flex:0 0 79.1666666667%}.el-col-sm-offset-19{margin-left:79.1666666667%}.el-col-sm-pull-19{position:relative;right:79.1666666667%}.el-col-sm-push-19{position:relative;left:79.1666666667%}.el-col-sm-20{display:block;max-width:83.3333333333%;flex:0 0 83.3333333333%}.el-col-sm-offset-20{margin-left:83.3333333333%}.el-col-sm-pull-20{position:relative;right:83.3333333333%}.el-col-sm-push-20{position:relative;left:83.3333333333%}.el-col-sm-21{display:block;max-width:87.5%;flex:0 0 87.5%}.el-col-sm-offset-21{margin-left:87.5%}.el-col-sm-pull-21{position:relative;right:87.5%}.el-col-sm-push-21{position:relative;left:87.5%}.el-col-sm-22{display:block;max-width:91.6666666667%;flex:0 0 91.6666666667%}.el-col-sm-offset-22{margin-left:91.6666666667%}.el-col-sm-pull-22{position:relative;right:91.6666666667%}.el-col-sm-push-22{position:relative;left:91.6666666667%}.el-col-sm-23{display:block;max-width:95.8333333333%;flex:0 0 95.8333333333%}.el-col-sm-offset-23{margin-left:95.8333333333%}.el-col-sm-pull-23{position:relative;right:95.8333333333%}.el-col-sm-push-23{position:relative;left:95.8333333333%}.el-col-sm-24{display:block;max-width:100%;flex:0 0 100%}.el-col-sm-offset-24{margin-left:100%}.el-col-sm-pull-24{position:relative;right:100%}.el-col-sm-push-24{position:relative;left:100%}}@media only screen and (min-width:992px){.el-col-md-0{display:none}.el-col-md-0.is-guttered{display:none}.el-col-md-0{max-width:0%;flex:0 0 0%}.el-col-md-offset-0{margin-left:0}.el-col-md-pull-0{position:relative;right:0}.el-col-md-push-0{position:relative;left:0}.el-col-md-1{display:block;max-width:4.1666666667%;flex:0 0 4.1666666667%}.el-col-md-offset-1{margin-left:4.1666666667%}.el-col-md-pull-1{position:relative;right:4.1666666667%}.el-col-md-push-1{position:relative;left:4.1666666667%}.el-col-md-2{display:block;max-width:8.3333333333%;flex:0 0 8.3333333333%}.el-col-md-offset-2{margin-left:8.3333333333%}.el-col-md-pull-2{position:relative;right:8.3333333333%}.el-col-md-push-2{position:relative;left:8.3333333333%}.el-col-md-3{display:block;max-width:12.5%;flex:0 0 12.5%}.el-col-md-offset-3{margin-left:12.5%}.el-col-md-pull-3{position:relative;right:12.5%}.el-col-md-push-3{position:relative;left:12.5%}.el-col-md-4{display:block;max-width:16.6666666667%;flex:0 0 16.6666666667%}.el-col-md-offset-4{margin-left:16.6666666667%}.el-col-md-pull-4{position:relative;right:16.6666666667%}.el-col-md-push-4{position:relative;left:16.6666666667%}.el-col-md-5{display:block;max-width:20.8333333333%;flex:0 0 20.8333333333%}.el-col-md-offset-5{margin-left:20.8333333333%}.el-col-md-pull-5{position:relative;right:20.8333333333%}.el-col-md-push-5{position:relative;left:20.8333333333%}.el-col-md-6{display:block;max-width:25%;flex:0 0 25%}.el-col-md-offset-6{margin-left:25%}.el-col-md-pull-6{position:relative;right:25%}.el-col-md-push-6{position:relative;left:25%}.el-col-md-7{display:block;max-width:29.1666666667%;flex:0 0 29.1666666667%}.el-col-md-offset-7{margin-left:29.1666666667%}.el-col-md-pull-7{position:relative;right:29.1666666667%}.el-col-md-push-7{position:relative;left:29.1666666667%}.el-col-md-8{display:block;max-width:33.3333333333%;flex:0 0 33.3333333333%}.el-col-md-offset-8{margin-left:33.3333333333%}.el-col-md-pull-8{position:relative;right:33.3333333333%}.el-col-md-push-8{position:relative;left:33.3333333333%}.el-col-md-9{display:block;max-width:37.5%;flex:0 0 37.5%}.el-col-md-offset-9{margin-left:37.5%}.el-col-md-pull-9{position:relative;right:37.5%}.el-col-md-push-9{position:relative;left:37.5%}.el-col-md-10{display:block;max-width:41.6666666667%;flex:0 0 41.6666666667%}.el-col-md-offset-10{margin-left:41.6666666667%}.el-col-md-pull-10{position:relative;right:41.6666666667%}.el-col-md-push-10{position:relative;left:41.6666666667%}.el-col-md-11{display:block;max-width:45.8333333333%;flex:0 0 45.8333333333%}.el-col-md-offset-11{margin-left:45.8333333333%}.el-col-md-pull-11{position:relative;right:45.8333333333%}.el-col-md-push-11{position:relative;left:45.8333333333%}.el-col-md-12{display:block;max-width:50%;flex:0 0 50%}.el-col-md-offset-12{margin-left:50%}.el-col-md-pull-12{position:relative;right:50%}.el-col-md-push-12{position:relative;left:50%}.el-col-md-13{display:block;max-width:54.1666666667%;flex:0 0 54.1666666667%}.el-col-md-offset-13{margin-left:54.1666666667%}.el-col-md-pull-13{position:relative;right:54.1666666667%}.el-col-md-push-13{position:relative;left:54.1666666667%}.el-col-md-14{display:block;max-width:58.3333333333%;flex:0 0 58.3333333333%}.el-col-md-offset-14{margin-left:58.3333333333%}.el-col-md-pull-14{position:relative;right:58.3333333333%}.el-col-md-push-14{position:relative;left:58.3333333333%}.el-col-md-15{display:block;max-width:62.5%;flex:0 0 62.5%}.el-col-md-offset-15{margin-left:62.5%}.el-col-md-pull-15{position:relative;right:62.5%}.el-col-md-push-15{position:relative;left:62.5%}.el-col-md-16{display:block;max-width:66.6666666667%;flex:0 0 66.6666666667%}.el-col-md-offset-16{margin-left:66.6666666667%}.el-col-md-pull-16{position:relative;right:66.6666666667%}.el-col-md-push-16{position:relative;left:66.6666666667%}.el-col-md-17{display:block;max-width:70.8333333333%;flex:0 0 70.8333333333%}.el-col-md-offset-17{margin-left:70.8333333333%}.el-col-md-pull-17{position:relative;right:70.8333333333%}.el-col-md-push-17{position:relative;left:70.8333333333%}.el-col-md-18{display:block;max-width:75%;flex:0 0 75%}.el-col-md-offset-18{margin-left:75%}.el-col-md-pull-18{position:relative;right:75%}.el-col-md-push-18{position:relative;left:75%}.el-col-md-19{display:block;max-width:79.1666666667%;flex:0 0 79.1666666667%}.el-col-md-offset-19{margin-left:79.1666666667%}.el-col-md-pull-19{position:relative;right:79.1666666667%}.el-col-md-push-19{position:relative;left:79.1666666667%}.el-col-md-20{display:block;max-width:83.3333333333%;flex:0 0 83.3333333333%}.el-col-md-offset-20{margin-left:83.3333333333%}.el-col-md-pull-20{position:relative;right:83.3333333333%}.el-col-md-push-20{position:relative;left:83.3333333333%}.el-col-md-21{display:block;max-width:87.5%;flex:0 0 87.5%}.el-col-md-offset-21{margin-left:87.5%}.el-col-md-pull-21{position:relative;right:87.5%}.el-col-md-push-21{position:relative;left:87.5%}.el-col-md-22{display:block;max-width:91.6666666667%;flex:0 0 91.6666666667%}.el-col-md-offset-22{margin-left:91.6666666667%}.el-col-md-pull-22{position:relative;right:91.6666666667%}.el-col-md-push-22{position:relative;left:91.6666666667%}.el-col-md-23{display:block;max-width:95.8333333333%;flex:0 0 95.8333333333%}.el-col-md-offset-23{margin-left:95.8333333333%}.el-col-md-pull-23{position:relative;right:95.8333333333%}.el-col-md-push-23{position:relative;left:95.8333333333%}.el-col-md-24{display:block;max-width:100%;flex:0 0 100%}.el-col-md-offset-24{margin-left:100%}.el-col-md-pull-24{position:relative;right:100%}.el-col-md-push-24{position:relative;left:100%}}@media only screen and (min-width:1200px){.el-col-lg-0{display:none}.el-col-lg-0.is-guttered{display:none}.el-col-lg-0{max-width:0%;flex:0 0 0%}.el-col-lg-offset-0{margin-left:0}.el-col-lg-pull-0{position:relative;right:0}.el-col-lg-push-0{position:relative;left:0}.el-col-lg-1{display:block;max-width:4.1666666667%;flex:0 0 4.1666666667%}.el-col-lg-offset-1{margin-left:4.1666666667%}.el-col-lg-pull-1{position:relative;right:4.1666666667%}.el-col-lg-push-1{position:relative;left:4.1666666667%}.el-col-lg-2{display:block;max-width:8.3333333333%;flex:0 0 8.3333333333%}.el-col-lg-offset-2{margin-left:8.3333333333%}.el-col-lg-pull-2{position:relative;right:8.3333333333%}.el-col-lg-push-2{position:relative;left:8.3333333333%}.el-col-lg-3{display:block;max-width:12.5%;flex:0 0 12.5%}.el-col-lg-offset-3{margin-left:12.5%}.el-col-lg-pull-3{position:relative;right:12.5%}.el-col-lg-push-3{position:relative;left:12.5%}.el-col-lg-4{display:block;max-width:16.6666666667%;flex:0 0 16.6666666667%}.el-col-lg-offset-4{margin-left:16.6666666667%}.el-col-lg-pull-4{position:relative;right:16.6666666667%}.el-col-lg-push-4{position:relative;left:16.6666666667%}.el-col-lg-5{display:block;max-width:20.8333333333%;flex:0 0 20.8333333333%}.el-col-lg-offset-5{margin-left:20.8333333333%}.el-col-lg-pull-5{position:relative;right:20.8333333333%}.el-col-lg-push-5{position:relative;left:20.8333333333%}.el-col-lg-6{display:block;max-width:25%;flex:0 0 25%}.el-col-lg-offset-6{margin-left:25%}.el-col-lg-pull-6{position:relative;right:25%}.el-col-lg-push-6{position:relative;left:25%}.el-col-lg-7{display:block;max-width:29.1666666667%;flex:0 0 29.1666666667%}.el-col-lg-offset-7{margin-left:29.1666666667%}.el-col-lg-pull-7{position:relative;right:29.1666666667%}.el-col-lg-push-7{position:relative;left:29.1666666667%}.el-col-lg-8{display:block;max-width:33.3333333333%;flex:0 0 33.3333333333%}.el-col-lg-offset-8{margin-left:33.3333333333%}.el-col-lg-pull-8{position:relative;right:33.3333333333%}.el-col-lg-push-8{position:relative;left:33.3333333333%}.el-col-lg-9{display:block;max-width:37.5%;flex:0 0 37.5%}.el-col-lg-offset-9{margin-left:37.5%}.el-col-lg-pull-9{position:relative;right:37.5%}.el-col-lg-push-9{position:relative;left:37.5%}.el-col-lg-10{display:block;max-width:41.6666666667%;flex:0 0 41.6666666667%}.el-col-lg-offset-10{margin-left:41.6666666667%}.el-col-lg-pull-10{position:relative;right:41.6666666667%}.el-col-lg-push-10{position:relative;left:41.6666666667%}.el-col-lg-11{display:block;max-width:45.8333333333%;flex:0 0 45.8333333333%}.el-col-lg-offset-11{margin-left:45.8333333333%}.el-col-lg-pull-11{position:relative;right:45.8333333333%}.el-col-lg-push-11{position:relative;left:45.8333333333%}.el-col-lg-12{display:block;max-width:50%;flex:0 0 50%}.el-col-lg-offset-12{margin-left:50%}.el-col-lg-pull-12{position:relative;right:50%}.el-col-lg-push-12{position:relative;left:50%}.el-col-lg-13{display:block;max-width:54.1666666667%;flex:0 0 54.1666666667%}.el-col-lg-offset-13{margin-left:54.1666666667%}.el-col-lg-pull-13{position:relative;right:54.1666666667%}.el-col-lg-push-13{position:relative;left:54.1666666667%}.el-col-lg-14{display:block;max-width:58.3333333333%;flex:0 0 58.3333333333%}.el-col-lg-offset-14{margin-left:58.3333333333%}.el-col-lg-pull-14{position:relative;right:58.3333333333%}.el-col-lg-push-14{position:relative;left:58.3333333333%}.el-col-lg-15{display:block;max-width:62.5%;flex:0 0 62.5%}.el-col-lg-offset-15{margin-left:62.5%}.el-col-lg-pull-15{position:relative;right:62.5%}.el-col-lg-push-15{position:relative;left:62.5%}.el-col-lg-16{display:block;max-width:66.6666666667%;flex:0 0 66.6666666667%}.el-col-lg-offset-16{margin-left:66.6666666667%}.el-col-lg-pull-16{position:relative;right:66.6666666667%}.el-col-lg-push-16{position:relative;left:66.6666666667%}.el-col-lg-17{display:block;max-width:70.8333333333%;flex:0 0 70.8333333333%}.el-col-lg-offset-17{margin-left:70.8333333333%}.el-col-lg-pull-17{position:relative;right:70.8333333333%}.el-col-lg-push-17{position:relative;left:70.8333333333%}.el-col-lg-18{display:block;max-width:75%;flex:0 0 75%}.el-col-lg-offset-18{margin-left:75%}.el-col-lg-pull-18{position:relative;right:75%}.el-col-lg-push-18{position:relative;left:75%}.el-col-lg-19{display:block;max-width:79.1666666667%;flex:0 0 79.1666666667%}.el-col-lg-offset-19{margin-left:79.1666666667%}.el-col-lg-pull-19{position:relative;right:79.1666666667%}.el-col-lg-push-19{position:relative;left:79.1666666667%}.el-col-lg-20{display:block;max-width:83.3333333333%;flex:0 0 83.3333333333%}.el-col-lg-offset-20{margin-left:83.3333333333%}.el-col-lg-pull-20{position:relative;right:83.3333333333%}.el-col-lg-push-20{position:relative;left:83.3333333333%}.el-col-lg-21{display:block;max-width:87.5%;flex:0 0 87.5%}.el-col-lg-offset-21{margin-left:87.5%}.el-col-lg-pull-21{position:relative;right:87.5%}.el-col-lg-push-21{position:relative;left:87.5%}.el-col-lg-22{display:block;max-width:91.6666666667%;flex:0 0 91.6666666667%}.el-col-lg-offset-22{margin-left:91.6666666667%}.el-col-lg-pull-22{position:relative;right:91.6666666667%}.el-col-lg-push-22{position:relative;left:91.6666666667%}.el-col-lg-23{display:block;max-width:95.8333333333%;flex:0 0 95.8333333333%}.el-col-lg-offset-23{margin-left:95.8333333333%}.el-col-lg-pull-23{position:relative;right:95.8333333333%}.el-col-lg-push-23{position:relative;left:95.8333333333%}.el-col-lg-24{display:block;max-width:100%;flex:0 0 100%}.el-col-lg-offset-24{margin-left:100%}.el-col-lg-pull-24{position:relative;right:100%}.el-col-lg-push-24{position:relative;left:100%}}@media only screen and (min-width:1920px){.el-col-xl-0{display:none}.el-col-xl-0.is-guttered{display:none}.el-col-xl-0{max-width:0%;flex:0 0 0%}.el-col-xl-offset-0{margin-left:0}.el-col-xl-pull-0{position:relative;right:0}.el-col-xl-push-0{position:relative;left:0}.el-col-xl-1{display:block;max-width:4.1666666667%;flex:0 0 4.1666666667%}.el-col-xl-offset-1{margin-left:4.1666666667%}.el-col-xl-pull-1{position:relative;right:4.1666666667%}.el-col-xl-push-1{position:relative;left:4.1666666667%}.el-col-xl-2{display:block;max-width:8.3333333333%;flex:0 0 8.3333333333%}.el-col-xl-offset-2{margin-left:8.3333333333%}.el-col-xl-pull-2{position:relative;right:8.3333333333%}.el-col-xl-push-2{position:relative;left:8.3333333333%}.el-col-xl-3{display:block;max-width:12.5%;flex:0 0 12.5%}.el-col-xl-offset-3{margin-left:12.5%}.el-col-xl-pull-3{position:relative;right:12.5%}.el-col-xl-push-3{position:relative;left:12.5%}.el-col-xl-4{display:block;max-width:16.6666666667%;flex:0 0 16.6666666667%}.el-col-xl-offset-4{margin-left:16.6666666667%}.el-col-xl-pull-4{position:relative;right:16.6666666667%}.el-col-xl-push-4{position:relative;left:16.6666666667%}.el-col-xl-5{display:block;max-width:20.8333333333%;flex:0 0 20.8333333333%}.el-col-xl-offset-5{margin-left:20.8333333333%}.el-col-xl-pull-5{position:relative;right:20.8333333333%}.el-col-xl-push-5{position:relative;left:20.8333333333%}.el-col-xl-6{display:block;max-width:25%;flex:0 0 25%}.el-col-xl-offset-6{margin-left:25%}.el-col-xl-pull-6{position:relative;right:25%}.el-col-xl-push-6{position:relative;left:25%}.el-col-xl-7{display:block;max-width:29.1666666667%;flex:0 0 29.1666666667%}.el-col-xl-offset-7{margin-left:29.1666666667%}.el-col-xl-pull-7{position:relative;right:29.1666666667%}.el-col-xl-push-7{position:relative;left:29.1666666667%}.el-col-xl-8{display:block;max-width:33.3333333333%;flex:0 0 33.3333333333%}.el-col-xl-offset-8{margin-left:33.3333333333%}.el-col-xl-pull-8{position:relative;right:33.3333333333%}.el-col-xl-push-8{position:relative;left:33.3333333333%}.el-col-xl-9{display:block;max-width:37.5%;flex:0 0 37.5%}.el-col-xl-offset-9{margin-left:37.5%}.el-col-xl-pull-9{position:relative;right:37.5%}.el-col-xl-push-9{position:relative;left:37.5%}.el-col-xl-10{display:block;max-width:41.6666666667%;flex:0 0 41.6666666667%}.el-col-xl-offset-10{margin-left:41.6666666667%}.el-col-xl-pull-10{position:relative;right:41.6666666667%}.el-col-xl-push-10{position:relative;left:41.6666666667%}.el-col-xl-11{display:block;max-width:45.8333333333%;flex:0 0 45.8333333333%}.el-col-xl-offset-11{margin-left:45.8333333333%}.el-col-xl-pull-11{position:relative;right:45.8333333333%}.el-col-xl-push-11{position:relative;left:45.8333333333%}.el-col-xl-12{display:block;max-width:50%;flex:0 0 50%}.el-col-xl-offset-12{margin-left:50%}.el-col-xl-pull-12{position:relative;right:50%}.el-col-xl-push-12{position:relative;left:50%}.el-col-xl-13{display:block;max-width:54.1666666667%;flex:0 0 54.1666666667%}.el-col-xl-offset-13{margin-left:54.1666666667%}.el-col-xl-pull-13{position:relative;right:54.1666666667%}.el-col-xl-push-13{position:relative;left:54.1666666667%}.el-col-xl-14{display:block;max-width:58.3333333333%;flex:0 0 58.3333333333%}.el-col-xl-offset-14{margin-left:58.3333333333%}.el-col-xl-pull-14{position:relative;right:58.3333333333%}.el-col-xl-push-14{position:relative;left:58.3333333333%}.el-col-xl-15{display:block;max-width:62.5%;flex:0 0 62.5%}.el-col-xl-offset-15{margin-left:62.5%}.el-col-xl-pull-15{position:relative;right:62.5%}.el-col-xl-push-15{position:relative;left:62.5%}.el-col-xl-16{display:block;max-width:66.6666666667%;flex:0 0 66.6666666667%}.el-col-xl-offset-16{margin-left:66.6666666667%}.el-col-xl-pull-16{position:relative;right:66.6666666667%}.el-col-xl-push-16{position:relative;left:66.6666666667%}.el-col-xl-17{display:block;max-width:70.8333333333%;flex:0 0 70.8333333333%}.el-col-xl-offset-17{margin-left:70.8333333333%}.el-col-xl-pull-17{position:relative;right:70.8333333333%}.el-col-xl-push-17{position:relative;left:70.8333333333%}.el-col-xl-18{display:block;max-width:75%;flex:0 0 75%}.el-col-xl-offset-18{margin-left:75%}.el-col-xl-pull-18{position:relative;right:75%}.el-col-xl-push-18{position:relative;left:75%}.el-col-xl-19{display:block;max-width:79.1666666667%;flex:0 0 79.1666666667%}.el-col-xl-offset-19{margin-left:79.1666666667%}.el-col-xl-pull-19{position:relative;right:79.1666666667%}.el-col-xl-push-19{position:relative;left:79.1666666667%}.el-col-xl-20{display:block;max-width:83.3333333333%;flex:0 0 83.3333333333%}.el-col-xl-offset-20{margin-left:83.3333333333%}.el-col-xl-pull-20{position:relative;right:83.3333333333%}.el-col-xl-push-20{position:relative;left:83.3333333333%}.el-col-xl-21{display:block;max-width:87.5%;flex:0 0 87.5%}.el-col-xl-offset-21{margin-left:87.5%}.el-col-xl-pull-21{position:relative;right:87.5%}.el-col-xl-push-21{position:relative;left:87.5%}.el-col-xl-22{display:block;max-width:91.6666666667%;flex:0 0 91.6666666667%}.el-col-xl-offset-22{margin-left:91.6666666667%}.el-col-xl-pull-22{position:relative;right:91.6666666667%}.el-col-xl-push-22{position:relative;left:91.6666666667%}.el-col-xl-23{display:block;max-width:95.8333333333%;flex:0 0 95.8333333333%}.el-col-xl-offset-23{margin-left:95.8333333333%}.el-col-xl-pull-23{position:relative;right:95.8333333333%}.el-col-xl-push-23{position:relative;left:95.8333333333%}.el-col-xl-24{display:block;max-width:100%;flex:0 0 100%}.el-col-xl-offset-24{margin-left:100%}.el-col-xl-pull-24{position:relative;right:100%}.el-col-xl-push-24{position:relative;left:100%}}.el-collapse{--el-collapse-border-color:var(--el-border-color-lighter);--el-collapse-header-height:48px;--el-collapse-header-bg-color:var(--el-fill-color-blank);--el-collapse-header-text-color:var(--el-text-color-primary);--el-collapse-header-font-size:13px;--el-collapse-content-bg-color:var(--el-fill-color-blank);--el-collapse-content-font-size:13px;--el-collapse-content-text-color:var(--el-text-color-primary);border-top:1px solid var(--el-collapse-border-color);border-bottom:1px solid var(--el-collapse-border-color)}.el-collapse-item.is-disabled .el-collapse-item__header{color:var(--el-text-color-disabled);cursor:not-allowed}.el-collapse-item__header{display:flex;align-items:center;height:var(--el-collapse-header-height);line-height:var(--el-collapse-header-height);background-color:var(--el-collapse-header-bg-color);color:var(--el-collapse-header-text-color);cursor:pointer;border-bottom:1px solid var(--el-collapse-border-color);font-size:var(--el-collapse-header-font-size);font-weight:500;transition:border-bottom-color var(--el-transition-duration);outline:0}.el-collapse-item__arrow{margin:0 8px 0 auto;transition:transform var(--el-transition-duration);font-weight:300}.el-collapse-item__arrow.is-active{transform:rotate(90deg)}.el-collapse-item__header.focusing:focus:not(:hover){color:var(--el-color-primary)}.el-collapse-item__header.is-active{border-bottom-color:transparent}.el-collapse-item__wrap{will-change:height;background-color:var(--el-collapse-content-bg-color);overflow:hidden;box-sizing:border-box;border-bottom:1px solid var(--el-collapse-border-color)}.el-collapse-item__content{padding-bottom:25px;font-size:var(--el-collapse-content-font-size);color:var(--el-collapse-content-text-color);line-height:1.7692307692}.el-collapse-item:last-child{margin-bottom:-1px}.el-color-predefine{display:flex;font-size:12px;margin-top:8px;width:280px}.el-color-predefine__colors{display:flex;flex:1;flex-wrap:wrap}.el-color-predefine__color-selector{margin:0 0 8px 8px;width:20px;height:20px;border-radius:4px;cursor:pointer}.el-color-predefine__color-selector:nth-child(10n+1){margin-left:0}.el-color-predefine__color-selector.selected{box-shadow:0 0 3px 2px var(--el-color-primary)}.el-color-predefine__color-selector>div{display:flex;height:100%;border-radius:3px}.el-color-predefine__color-selector.is-alpha{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAwAAAAMCAIAAADZF8uwAAAAGUlEQVQYV2M4gwH+YwCGIasIUwhT25BVBADtzYNYrHvv4gAAAABJRU5ErkJggg==)}.el-color-hue-slider{position:relative;box-sizing:border-box;width:280px;height:12px;background-color:red;padding:0 2px;float:right}.el-color-hue-slider__bar{position:relative;background:linear-gradient(to right,red 0,#ff0 17%,#0f0 33%,#0ff 50%,#00f 67%,#f0f 83%,red 100%);height:100%}.el-color-hue-slider__thumb{position:absolute;cursor:pointer;box-sizing:border-box;left:0;top:0;width:4px;height:100%;border-radius:1px;background:#fff;border:1px solid var(--el-border-color-lighter);box-shadow:0 0 2px rgba(0,0,0,.6);z-index:1}.el-color-hue-slider.is-vertical{width:12px;height:180px;padding:2px 0}.el-color-hue-slider.is-vertical .el-color-hue-slider__bar{background:linear-gradient(to bottom,red 0,#ff0 17%,#0f0 33%,#0ff 50%,#00f 67%,#f0f 83%,red 100%)}.el-color-hue-slider.is-vertical .el-color-hue-slider__thumb{left:0;top:0;width:100%;height:4px}.el-color-svpanel{position:relative;width:280px;height:180px}.el-color-svpanel__black,.el-color-svpanel__white{position:absolute;top:0;left:0;right:0;bottom:0}.el-color-svpanel__white{background:linear-gradient(to right,#fff,rgba(255,255,255,0))}.el-color-svpanel__black{background:linear-gradient(to top,#000,rgba(0,0,0,0))}.el-color-svpanel__cursor{position:absolute}.el-color-svpanel__cursor>div{cursor:head;width:4px;height:4px;box-shadow:0 0 0 1.5px #fff,inset 0 0 1px 1px rgba(0,0,0,.3),0 0 1px 2px rgba(0,0,0,.4);border-radius:50%;transform:translate(-2px,-2px)}.el-color-alpha-slider{position:relative;box-sizing:border-box;width:280px;height:12px;background-image:linear-gradient(45deg,var(--el-color-picker-alpha-bg-a) 25%,var(--el-color-picker-alpha-bg-b) 25%),linear-gradient(135deg,var(--el-color-picker-alpha-bg-a) 25%,var(--el-color-picker-alpha-bg-b) 25%),linear-gradient(45deg,var(--el-color-picker-alpha-bg-b) 75%,var(--el-color-picker-alpha-bg-a) 75%),linear-gradient(135deg,var(--el-color-picker-alpha-bg-b) 75%,var(--el-color-picker-alpha-bg-a) 75%);background-size:12px 12px;background-position:0 0,6px 0,6px -6px,0 6px}.el-color-alpha-slider__bar{position:relative;background:linear-gradient(to right,rgba(255,255,255,0) 0,var(--el-bg-color) 100%);height:100%}.el-color-alpha-slider__thumb{position:absolute;cursor:pointer;box-sizing:border-box;left:0;top:0;width:4px;height:100%;border-radius:1px;background:#fff;border:1px solid var(--el-border-color-lighter);box-shadow:0 0 2px rgba(0,0,0,.6);z-index:1}.el-color-alpha-slider.is-vertical{width:20px;height:180px}.el-color-alpha-slider.is-vertical .el-color-alpha-slider__bar{background:linear-gradient(to bottom,rgba(255,255,255,0) 0,#fff 100%)}.el-color-alpha-slider.is-vertical .el-color-alpha-slider__thumb{left:0;top:0;width:100%;height:4px}.el-color-dropdown{width:300px}.el-color-dropdown__main-wrapper{margin-bottom:6px}.el-color-dropdown__main-wrapper::after{content:"";display:table;clear:both}.el-color-dropdown__btns{margin-top:12px;text-align:right}.el-color-dropdown__value{float:left;line-height:26px;font-size:12px;color:#000;width:160px}.el-color-picker{display:inline-block;position:relative;line-height:normal;outline:0}.el-color-picker:hover:not(.is-disabled) .el-color-picker__trigger{border:1px solid var(--el-border-color-hover)}.el-color-picker:focus-visible:not(.is-disabled) .el-color-picker__trigger{outline:2px solid var(--el-color-primary);outline-offset:1px}.el-color-picker.is-disabled .el-color-picker__trigger{cursor:not-allowed}.el-color-picker--large{height:40px}.el-color-picker--large .el-color-picker__trigger{height:40px;width:40px}.el-color-picker--large .el-color-picker__mask{height:38px;width:38px}.el-color-picker--small{height:24px}.el-color-picker--small .el-color-picker__trigger{height:24px;width:24px}.el-color-picker--small .el-color-picker__mask{height:22px;width:22px}.el-color-picker--small .el-color-picker__empty,.el-color-picker--small .el-color-picker__icon{transform:scale(.8)}.el-color-picker__mask{height:30px;width:30px;border-radius:4px;position:absolute;top:1px;left:1px;z-index:1;cursor:not-allowed;background-color:rgba(255,255,255,.7)}.el-color-picker__trigger{display:inline-flex;justify-content:center;align-items:center;box-sizing:border-box;height:32px;width:32px;padding:4px;border:1px solid var(--el-border-color);border-radius:4px;font-size:0;position:relative;cursor:pointer}.el-color-picker__color{position:relative;display:block;box-sizing:border-box;border:1px solid var(--el-text-color-secondary);border-radius:var(--el-border-radius-small);width:100%;height:100%;text-align:center}.el-color-picker__color.is-alpha{background-image:linear-gradient(45deg,var(--el-color-picker-alpha-bg-a) 25%,var(--el-color-picker-alpha-bg-b) 25%),linear-gradient(135deg,var(--el-color-picker-alpha-bg-a) 25%,var(--el-color-picker-alpha-bg-b) 25%),linear-gradient(45deg,var(--el-color-picker-alpha-bg-b) 75%,var(--el-color-picker-alpha-bg-a) 75%),linear-gradient(135deg,var(--el-color-picker-alpha-bg-b) 75%,var(--el-color-picker-alpha-bg-a) 75%);background-size:12px 12px;background-position:0 0,6px 0,6px -6px,0 6px}.el-color-picker__color-inner{display:inline-flex;justify-content:center;align-items:center;width:100%;height:100%}.el-color-picker .el-color-picker__empty{font-size:12px;color:var(--el-text-color-secondary)}.el-color-picker .el-color-picker__icon{display:inline-flex;justify-content:center;align-items:center;color:#fff;font-size:12px}.el-color-picker__panel{position:absolute;z-index:10;padding:6px;box-sizing:content-box;background-color:#fff;border-radius:var(--el-border-radius-base);box-shadow:var(--el-box-shadow-light)}.el-color-picker__panel.el-popper{border:1px solid var(--el-border-color-lighter)}.el-color-picker,.el-color-picker__panel{--el-color-picker-alpha-bg-a:#ccc;--el-color-picker-alpha-bg-b:transparent}.dark .el-color-picker,.dark .el-color-picker__panel{--el-color-picker-alpha-bg-a:#333333}.el-container{display:flex;flex-direction:row;flex:1;flex-basis:auto;box-sizing:border-box;min-width:0}.el-container.is-vertical{flex-direction:column}.el-date-table{font-size:12px;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.el-date-table.is-week-mode .el-date-table__row:hover .el-date-table-cell{background-color:var(--el-datepicker-inrange-bg-color)}.el-date-table.is-week-mode .el-date-table__row:hover td.available:hover{color:var(--el-datepicker-text-color)}.el-date-table.is-week-mode .el-date-table__row:hover td:first-child .el-date-table-cell{margin-left:5px;border-top-left-radius:15px;border-bottom-left-radius:15px}.el-date-table.is-week-mode .el-date-table__row:hover td:last-child .el-date-table-cell{margin-right:5px;border-top-right-radius:15px;border-bottom-right-radius:15px}.el-date-table.is-week-mode .el-date-table__row.current .el-date-table-cell{background-color:var(--el-datepicker-inrange-bg-color)}.el-date-table td{width:32px;height:30px;padding:4px 0;box-sizing:border-box;text-align:center;cursor:pointer;position:relative}.el-date-table td .el-date-table-cell{height:30px;padding:3px 0;box-sizing:border-box}.el-date-table td .el-date-table-cell .el-date-table-cell__text{width:24px;height:24px;display:block;margin:0 auto;line-height:24px;position:absolute;left:50%;transform:translateX(-50%);border-radius:50%}.el-date-table td.next-month,.el-date-table td.prev-month{color:var(--el-datepicker-off-text-color)}.el-date-table td.today{position:relative}.el-date-table td.today .el-date-table-cell__text{color:var(--el-color-primary);font-weight:700}.el-date-table td.today.end-date .el-date-table-cell__text,.el-date-table td.today.start-date .el-date-table-cell__text{color:#fff}.el-date-table td.available:hover{color:var(--el-datepicker-hover-text-color)}.el-date-table td.in-range .el-date-table-cell{background-color:var(--el-datepicker-inrange-bg-color)}.el-date-table td.in-range .el-date-table-cell:hover{background-color:var(--el-datepicker-inrange-hover-bg-color)}.el-date-table td.current:not(.disabled) .el-date-table-cell__text{color:#fff;background-color:var(--el-datepicker-active-color)}.el-date-table td.current:not(.disabled):focus-visible .el-date-table-cell__text{outline:2px solid var(--el-datepicker-active-color);outline-offset:1px}.el-date-table td.end-date .el-date-table-cell,.el-date-table td.start-date .el-date-table-cell{color:#fff}.el-date-table td.end-date .el-date-table-cell__text,.el-date-table td.start-date .el-date-table-cell__text{background-color:var(--el-datepicker-active-color)}.el-date-table td.start-date .el-date-table-cell{margin-left:5px;border-top-left-radius:15px;border-bottom-left-radius:15px}.el-date-table td.end-date .el-date-table-cell{margin-right:5px;border-top-right-radius:15px;border-bottom-right-radius:15px}.el-date-table td.disabled .el-date-table-cell{background-color:var(--el-fill-color-light);opacity:1;cursor:not-allowed;color:var(--el-text-color-placeholder)}.el-date-table td.selected .el-date-table-cell{margin-left:5px;margin-right:5px;background-color:var(--el-datepicker-inrange-bg-color);border-radius:15px}.el-date-table td.selected .el-date-table-cell:hover{background-color:var(--el-datepicker-inrange-hover-bg-color)}.el-date-table td.selected .el-date-table-cell__text{background-color:var(--el-datepicker-active-color);color:#fff;border-radius:15px}.el-date-table td.week{font-size:80%;color:var(--el-datepicker-header-text-color)}.el-date-table td:focus{outline:0}.el-date-table th{padding:5px;color:var(--el-datepicker-header-text-color);font-weight:400;border-bottom:solid 1px var(--el-border-color-lighter)}.el-month-table{font-size:12px;margin:-1px;border-collapse:collapse}.el-month-table td{text-align:center;padding:8px 0;cursor:pointer}.el-month-table td div{height:48px;padding:6px 0;box-sizing:border-box}.el-month-table td.today .cell{color:var(--el-color-primary);font-weight:700}.el-month-table td.today.end-date .cell,.el-month-table td.today.start-date .cell{color:#fff}.el-month-table td.disabled .cell{background-color:var(--el-fill-color-light);cursor:not-allowed;color:var(--el-text-color-placeholder)}.el-month-table td.disabled .cell:hover{color:var(--el-text-color-placeholder)}.el-month-table td .cell{width:60px;height:36px;display:block;line-height:36px;color:var(--el-datepicker-text-color);margin:0 auto;border-radius:18px}.el-month-table td .cell:hover{color:var(--el-datepicker-hover-text-color)}.el-month-table td.in-range div{background-color:var(--el-datepicker-inrange-bg-color)}.el-month-table td.in-range div:hover{background-color:var(--el-datepicker-inrange-hover-bg-color)}.el-month-table td.end-date div,.el-month-table td.start-date div{color:#fff}.el-month-table td.end-date .cell,.el-month-table td.start-date .cell{color:#fff;background-color:var(--el-datepicker-active-color)}.el-month-table td.start-date div{border-top-left-radius:24px;border-bottom-left-radius:24px}.el-month-table td.end-date div{border-top-right-radius:24px;border-bottom-right-radius:24px}.el-month-table td.current:not(.disabled) .cell{color:var(--el-datepicker-active-color)}.el-month-table td:focus-visible{outline:0}.el-month-table td:focus-visible .cell{outline:2px solid var(--el-datepicker-active-color)}.el-year-table{font-size:12px;margin:-1px;border-collapse:collapse}.el-year-table .el-icon{color:var(--el-datepicker-icon-color)}.el-year-table td{text-align:center;padding:20px 3px;cursor:pointer}.el-year-table td.today .cell{color:var(--el-color-primary);font-weight:700}.el-year-table td.disabled .cell{background-color:var(--el-fill-color-light);cursor:not-allowed;color:var(--el-text-color-placeholder)}.el-year-table td.disabled .cell:hover{color:var(--el-text-color-placeholder)}.el-year-table td .cell{width:48px;height:36px;display:block;line-height:36px;color:var(--el-datepicker-text-color);border-radius:18px;margin:0 auto}.el-year-table td .cell:hover{color:var(--el-datepicker-hover-text-color)}.el-year-table td.current:not(.disabled) .cell{color:var(--el-datepicker-active-color)}.el-year-table td:focus-visible{outline:0}.el-year-table td:focus-visible .cell{outline:2px solid var(--el-datepicker-active-color)}.el-time-spinner.has-seconds .el-time-spinner__wrapper{width:33.3%}.el-time-spinner__wrapper{max-height:192px;overflow:auto;display:inline-block;width:50%;vertical-align:top;position:relative}.el-time-spinner__wrapper.el-scrollbar__wrap:not(.el-scrollbar__wrap--hidden-default){padding-bottom:15px}.el-time-spinner__wrapper.is-arrow{box-sizing:border-box;text-align:center;overflow:hidden}.el-time-spinner__wrapper.is-arrow .el-time-spinner__list{transform:translateY(-32px)}.el-time-spinner__wrapper.is-arrow .el-time-spinner__item:hover:not(.is-disabled):not(.is-active){background:var(--el-fill-color-light);cursor:default}.el-time-spinner__arrow{font-size:12px;color:var(--el-text-color-secondary);position:absolute;left:0;width:100%;z-index:var(--el-index-normal);text-align:center;height:30px;line-height:30px;cursor:pointer}.el-time-spinner__arrow:hover{color:var(--el-color-primary)}.el-time-spinner__arrow.arrow-up{top:10px}.el-time-spinner__arrow.arrow-down{bottom:10px}.el-time-spinner__input.el-input{width:70%}.el-time-spinner__input.el-input .el-input__inner{padding:0;text-align:center}.el-time-spinner__list{padding:0;margin:0;list-style:none;text-align:center}.el-time-spinner__list::after,.el-time-spinner__list::before{content:"";display:block;width:100%;height:80px}.el-time-spinner__item{height:32px;line-height:32px;font-size:12px;color:var(--el-text-color-regular)}.el-time-spinner__item:hover:not(.is-disabled):not(.is-active){background:var(--el-fill-color-light);cursor:pointer}.el-time-spinner__item.is-active:not(.is-disabled){color:var(--el-text-color-primary);font-weight:700}.el-time-spinner__item.is-disabled{color:var(--el-text-color-placeholder);cursor:not-allowed}.el-picker__popper{--el-datepicker-border-color:var(--el-disabled-border-color)}.el-picker__popper.el-popper{background:var(--el-bg-color-overlay);border:1px solid var(--el-datepicker-border-color);box-shadow:var(--el-box-shadow-light)}.el-picker__popper.el-popper .el-popper__arrow::before{border:1px solid var(--el-datepicker-border-color)}.el-picker__popper.el-popper[data-popper-placement^=top] .el-popper__arrow::before{border-top-color:transparent;border-left-color:transparent}.el-picker__popper.el-popper[data-popper-placement^=bottom] .el-popper__arrow::before{border-bottom-color:transparent;border-right-color:transparent}.el-picker__popper.el-popper[data-popper-placement^=left] .el-popper__arrow::before{border-left-color:transparent;border-bottom-color:transparent}.el-picker__popper.el-popper[data-popper-placement^=right] .el-popper__arrow::before{border-right-color:transparent;border-top-color:transparent}.el-date-editor{--el-date-editor-width:220px;--el-date-editor-monthrange-width:300px;--el-date-editor-daterange-width:350px;--el-date-editor-datetimerange-width:400px;--el-input-text-color:var(--el-text-color-regular);--el-input-border:var(--el-border);--el-input-hover-border:var(--el-border-color-hover);--el-input-focus-border:var(--el-color-primary);--el-input-transparent-border:0 0 0 1px transparent inset;--el-input-border-color:var(--el-border-color);--el-input-border-radius:var(--el-border-radius-base);--el-input-bg-color:var(--el-fill-color-blank);--el-input-icon-color:var(--el-text-color-placeholder);--el-input-placeholder-color:var(--el-text-color-placeholder);--el-input-hover-border-color:var(--el-border-color-hover);--el-input-clear-hover-color:var(--el-text-color-secondary);--el-input-focus-border-color:var(--el-color-primary);position:relative;display:inline-block;text-align:left}.el-date-editor.el-input__wrapper{box-shadow:0 0 0 1px var(--el-input-border-color,var(--el-border-color)) inset}.el-date-editor.el-input__wrapper:hover{box-shadow:0 0 0 1px var(--el-input-hover-border-color) inset}.el-date-editor.el-input,.el-date-editor.el-input__wrapper{width:var(--el-date-editor-width);height:var(--el-input-height,var(--el-component-size))}.el-date-editor--monthrange{--el-date-editor-width:var(--el-date-editor-monthrange-width)}.el-date-editor--daterange,.el-date-editor--timerange{--el-date-editor-width:var(--el-date-editor-daterange-width)}.el-date-editor--datetimerange{--el-date-editor-width:var(--el-date-editor-datetimerange-width)}.el-date-editor--dates .el-input__wrapper{text-overflow:ellipsis;white-space:nowrap}.el-date-editor .close-icon{cursor:pointer}.el-date-editor .clear-icon{cursor:pointer}.el-date-editor .clear-icon:hover{color:var(--el-text-color-secondary)}.el-date-editor .el-range__icon{height:inherit;font-size:14px;color:var(--el-text-color-placeholder);float:left}.el-date-editor .el-range__icon svg{vertical-align:middle}.el-date-editor .el-range-input{-webkit-appearance:none;-moz-appearance:none;appearance:none;border:none;outline:0;display:inline-block;height:30px;line-height:30px;margin:0;padding:0;width:39%;text-align:center;font-size:var(--el-font-size-base);color:var(--el-text-color-regular);background-color:transparent}.el-date-editor .el-range-input::-moz-placeholder{color:var(--el-text-color-placeholder)}.el-date-editor .el-range-input:-ms-input-placeholder{color:var(--el-text-color-placeholder)}.el-date-editor .el-range-input::placeholder{color:var(--el-text-color-placeholder)}.el-date-editor .el-range-separator{flex:1;display:inline-flex;justify-content:center;align-items:center;height:100%;padding:0 5px;margin:0;font-size:14px;word-break:keep-all;color:var(--el-text-color-primary)}.el-date-editor .el-range__close-icon{font-size:14px;color:var(--el-text-color-placeholder);height:inherit;width:unset;cursor:pointer}.el-date-editor .el-range__close-icon:hover{color:var(--el-text-color-secondary)}.el-date-editor .el-range__close-icon svg{vertical-align:middle}.el-date-editor .el-range__close-icon--hidden{opacity:0;visibility:hidden}.el-range-editor.el-input__wrapper{display:inline-flex;align-items:center;padding:0 10px}.el-range-editor.is-active{box-shadow:0 0 0 1px var(--el-input-focus-border-color) inset}.el-range-editor.is-active:hover{box-shadow:0 0 0 1px var(--el-input-focus-border-color) inset}.el-range-editor--large{line-height:var(--el-component-size-large)}.el-range-editor--large.el-input__wrapper{height:var(--el-component-size-large)}.el-range-editor--large .el-range-separator{line-height:40px;font-size:14px}.el-range-editor--large .el-range-input{height:38px;line-height:38px;font-size:14px}.el-range-editor--small{line-height:var(--el-component-size-small)}.el-range-editor--small.el-input__wrapper{height:var(--el-component-size-small)}.el-range-editor--small .el-range-separator{line-height:24px;font-size:12px}.el-range-editor--small .el-range-input{height:22px;line-height:22px;font-size:12px}.el-range-editor.is-disabled{background-color:var(--el-disabled-bg-color);border-color:var(--el-disabled-border-color);color:var(--el-disabled-text-color);cursor:not-allowed}.el-range-editor.is-disabled:focus,.el-range-editor.is-disabled:hover{border-color:var(--el-disabled-border-color)}.el-range-editor.is-disabled input{background-color:var(--el-disabled-bg-color);color:var(--el-disabled-text-color);cursor:not-allowed}.el-range-editor.is-disabled input::-moz-placeholder{color:var(--el-text-color-placeholder)}.el-range-editor.is-disabled input:-ms-input-placeholder{color:var(--el-text-color-placeholder)}.el-range-editor.is-disabled input::placeholder{color:var(--el-text-color-placeholder)}.el-range-editor.is-disabled .el-range-separator{color:var(--el-disabled-text-color)}.el-picker-panel{color:var(--el-text-color-regular);background:var(--el-bg-color-overlay);border-radius:var(--el-border-radius-base);line-height:30px}.el-picker-panel .el-time-panel{margin:5px 0;border:solid 1px var(--el-datepicker-border-color);background-color:var(--el-bg-color-overlay);box-shadow:var(--el-box-shadow-light)}.el-picker-panel__body-wrapper::after,.el-picker-panel__body::after{content:"";display:table;clear:both}.el-picker-panel__content{position:relative;margin:15px}.el-picker-panel__footer{border-top:1px solid var(--el-datepicker-inner-border-color);padding:4px 12px;text-align:right;background-color:var(--el-bg-color-overlay);position:relative;font-size:0}.el-picker-panel__shortcut{display:block;width:100%;border:0;background-color:transparent;line-height:28px;font-size:14px;color:var(--el-datepicker-text-color);padding-left:12px;text-align:left;outline:0;cursor:pointer}.el-picker-panel__shortcut:hover{color:var(--el-datepicker-hover-text-color)}.el-picker-panel__shortcut.active{background-color:#e6f1fe;color:var(--el-datepicker-active-color)}.el-picker-panel__btn{border:1px solid var(--el-fill-color-darker);color:var(--el-text-color-primary);line-height:24px;border-radius:2px;padding:0 20px;cursor:pointer;background-color:transparent;outline:0;font-size:12px}.el-picker-panel__btn[disabled]{color:var(--el-text-color-disabled);cursor:not-allowed}.el-picker-panel__icon-btn{font-size:12px;color:var(--el-datepicker-icon-color);border:0;background:0 0;cursor:pointer;outline:0;margin-top:8px}.el-picker-panel__icon-btn:hover{color:var(--el-datepicker-hover-text-color)}.el-picker-panel__icon-btn:focus-visible{color:var(--el-datepicker-hover-text-color)}.el-picker-panel__icon-btn.is-disabled{color:var(--el-text-color-disabled)}.el-picker-panel__icon-btn.is-disabled:hover{cursor:not-allowed}.el-picker-panel__icon-btn .el-icon{cursor:pointer;font-size:inherit}.el-picker-panel__link-btn{vertical-align:middle}.el-picker-panel [slot=sidebar],.el-picker-panel__sidebar{position:absolute;top:0;bottom:0;width:110px;border-right:1px solid var(--el-datepicker-inner-border-color);box-sizing:border-box;padding-top:6px;background-color:var(--el-bg-color-overlay);overflow:auto}.el-picker-panel [slot=sidebar]+.el-picker-panel__body,.el-picker-panel__sidebar+.el-picker-panel__body{margin-left:110px}.el-date-picker{--el-datepicker-text-color:var(--el-text-color-regular);--el-datepicker-off-text-color:var(--el-text-color-placeholder);--el-datepicker-header-text-color:var(--el-text-color-regular);--el-datepicker-icon-color:var(--el-text-color-primary);--el-datepicker-border-color:var(--el-disabled-border-color);--el-datepicker-inner-border-color:var(--el-border-color-light);--el-datepicker-inrange-bg-color:var(--el-border-color-extra-light);--el-datepicker-inrange-hover-bg-color:var(--el-border-color-extra-light);--el-datepicker-active-color:var(--el-color-primary);--el-datepicker-hover-text-color:var(--el-color-primary)}.el-date-picker{width:322px}.el-date-picker.has-sidebar.has-time{width:434px}.el-date-picker.has-sidebar{width:438px}.el-date-picker.has-time .el-picker-panel__body-wrapper{position:relative}.el-date-picker .el-picker-panel__content{width:292px}.el-date-picker table{table-layout:fixed;width:100%}.el-date-picker__editor-wrap{position:relative;display:table-cell;padding:0 5px}.el-date-picker__time-header{position:relative;border-bottom:1px solid var(--el-datepicker-inner-border-color);font-size:12px;padding:8px 5px 5px;display:table;width:100%;box-sizing:border-box}.el-date-picker__header{margin:12px;text-align:center}.el-date-picker__header--bordered{margin-bottom:0;padding-bottom:12px;border-bottom:solid 1px var(--el-border-color-lighter)}.el-date-picker__header--bordered+.el-picker-panel__content{margin-top:0}.el-date-picker__header-label{font-size:16px;font-weight:500;padding:0 5px;line-height:22px;text-align:center;cursor:pointer;color:var(--el-text-color-regular)}.el-date-picker__header-label:hover{color:var(--el-datepicker-hover-text-color)}.el-date-picker__header-label:focus-visible{outline:0;color:var(--el-datepicker-hover-text-color)}.el-date-picker__header-label.active{color:var(--el-datepicker-active-color)}.el-date-picker__prev-btn{float:left}.el-date-picker__next-btn{float:right}.el-date-picker__time-wrap{padding:10px;text-align:center}.el-date-picker__time-label{float:left;cursor:pointer;line-height:30px;margin-left:10px}.el-date-picker .el-time-panel{position:absolute}.el-date-range-picker{--el-datepicker-text-color:var(--el-text-color-regular);--el-datepicker-off-text-color:var(--el-text-color-placeholder);--el-datepicker-header-text-color:var(--el-text-color-regular);--el-datepicker-icon-color:var(--el-text-color-primary);--el-datepicker-border-color:var(--el-disabled-border-color);--el-datepicker-inner-border-color:var(--el-border-color-light);--el-datepicker-inrange-bg-color:var(--el-border-color-extra-light);--el-datepicker-inrange-hover-bg-color:var(--el-border-color-extra-light);--el-datepicker-active-color:var(--el-color-primary);--el-datepicker-hover-text-color:var(--el-color-primary)}.el-date-range-picker{width:646px}.el-date-range-picker.has-sidebar{width:756px}.el-date-range-picker.has-time .el-picker-panel__body-wrapper{position:relative}.el-date-range-picker table{table-layout:fixed;width:100%}.el-date-range-picker .el-picker-panel__body{min-width:513px}.el-date-range-picker .el-picker-panel__content{margin:0}.el-date-range-picker__header{position:relative;text-align:center;height:28px}.el-date-range-picker__header [class*=arrow-left]{float:left}.el-date-range-picker__header [class*=arrow-right]{float:right}.el-date-range-picker__header div{font-size:16px;font-weight:500;margin-right:50px}.el-date-range-picker__content{float:left;width:50%;box-sizing:border-box;margin:0;padding:16px}.el-date-range-picker__content.is-left{border-right:1px solid var(--el-datepicker-inner-border-color)}.el-date-range-picker__content .el-date-range-picker__header div{margin-left:50px;margin-right:50px}.el-date-range-picker__editors-wrap{box-sizing:border-box;display:table-cell}.el-date-range-picker__editors-wrap.is-right{text-align:right}.el-date-range-picker__time-header{position:relative;border-bottom:1px solid var(--el-datepicker-inner-border-color);font-size:12px;padding:8px 5px 5px 5px;display:table;width:100%;box-sizing:border-box}.el-date-range-picker__time-header>.el-icon-arrow-right{font-size:20px;vertical-align:middle;display:table-cell;color:var(--el-datepicker-icon-color)}.el-date-range-picker__time-picker-wrap{position:relative;display:table-cell;padding:0 5px}.el-date-range-picker__time-picker-wrap .el-picker-panel{position:absolute;top:13px;right:0;z-index:1;background:#fff}.el-date-range-picker__time-picker-wrap .el-time-panel{position:absolute}.el-time-range-picker{width:354px;overflow:visible}.el-time-range-picker__content{position:relative;text-align:center;padding:10px;z-index:1}.el-time-range-picker__cell{box-sizing:border-box;margin:0;padding:4px 7px 7px;width:50%;display:inline-block}.el-time-range-picker__header{margin-bottom:5px;text-align:center;font-size:14px}.el-time-range-picker__body{border-radius:2px;border:1px solid var(--el-datepicker-border-color)}.el-time-panel{border-radius:2px;position:relative;width:180px;left:0;z-index:var(--el-index-top);-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;box-sizing:content-box}.el-time-panel__content{font-size:0;position:relative;overflow:hidden}.el-time-panel__content::after,.el-time-panel__content::before{content:"";top:50%;position:absolute;margin-top:-16px;height:32px;z-index:-1;left:0;right:0;box-sizing:border-box;padding-top:6px;text-align:left}.el-time-panel__content::after{left:50%;margin-left:12%;margin-right:12%}.el-time-panel__content::before{padding-left:50%;margin-right:12%;margin-left:12%;border-top:1px solid var(--el-border-color-light);border-bottom:1px solid var(--el-border-color-light)}.el-time-panel__content.has-seconds::after{left:66.6666666667%}.el-time-panel__content.has-seconds::before{padding-left:33.3333333333%}.el-time-panel__footer{border-top:1px solid var(--el-timepicker-inner-border-color,var(--el-border-color-light));padding:4px;height:36px;line-height:25px;text-align:right;box-sizing:border-box}.el-time-panel__btn{border:none;line-height:28px;padding:0 5px;margin:0 5px;cursor:pointer;background-color:transparent;outline:0;font-size:12px;color:var(--el-text-color-primary)}.el-time-panel__btn.confirm{font-weight:800;color:var(--el-timepicker-active-color,var(--el-color-primary))}.el-descriptions{--el-descriptions-table-border:1px solid var(--el-border-color-lighter);--el-descriptions-item-bordered-label-background:var(--el-fill-color-light);box-sizing:border-box;font-size:var(--el-font-size-base);color:var(--el-text-color-primary)}.el-descriptions__header{display:flex;justify-content:space-between;align-items:center;margin-bottom:16px}.el-descriptions__title{color:var(--el-text-color-primary);font-size:16px;font-weight:700}.el-descriptions__body{background-color:var(--el-fill-color-blank)}.el-descriptions__body .el-descriptions__table{border-collapse:collapse;width:100%}.el-descriptions__body .el-descriptions__table .el-descriptions__cell{box-sizing:border-box;text-align:left;font-weight:400;line-height:23px;font-size:14px}.el-descriptions__body .el-descriptions__table .el-descriptions__cell.is-left{text-align:left}.el-descriptions__body .el-descriptions__table .el-descriptions__cell.is-center{text-align:center}.el-descriptions__body .el-descriptions__table .el-descriptions__cell.is-right{text-align:right}.el-descriptions__body .el-descriptions__table.is-bordered .el-descriptions__cell{border:var(--el-descriptions-table-border);padding:8px 11px}.el-descriptions__body .el-descriptions__table:not(.is-bordered) .el-descriptions__cell{padding-bottom:12px}.el-descriptions--large{font-size:14px}.el-descriptions--large .el-descriptions__header{margin-bottom:20px}.el-descriptions--large .el-descriptions__header .el-descriptions__title{font-size:16px}.el-descriptions--large .el-descriptions__body .el-descriptions__table .el-descriptions__cell{font-size:14px}.el-descriptions--large .el-descriptions__body .el-descriptions__table.is-bordered .el-descriptions__cell{padding:12px 15px}.el-descriptions--large .el-descriptions__body .el-descriptions__table:not(.is-bordered) .el-descriptions__cell{padding-bottom:16px}.el-descriptions--small{font-size:12px}.el-descriptions--small .el-descriptions__header{margin-bottom:12px}.el-descriptions--small .el-descriptions__header .el-descriptions__title{font-size:14px}.el-descriptions--small .el-descriptions__body .el-descriptions__table .el-descriptions__cell{font-size:12px}.el-descriptions--small .el-descriptions__body .el-descriptions__table.is-bordered .el-descriptions__cell{padding:4px 7px}.el-descriptions--small .el-descriptions__body .el-descriptions__table:not(.is-bordered) .el-descriptions__cell{padding-bottom:8px}.el-descriptions__label.el-descriptions__cell.is-bordered-label{font-weight:700;color:var(--el-text-color-regular);background:var(--el-descriptions-item-bordered-label-background)}.el-descriptions__label:not(.is-bordered-label){color:var(--el-text-color-primary);margin-right:16px}.el-descriptions__label.el-descriptions__cell:not(.is-bordered-label).is-vertical-label{padding-bottom:6px}.el-descriptions__content.el-descriptions__cell.is-bordered-content{color:var(--el-text-color-primary)}.el-descriptions__content:not(.is-bordered-label){color:var(--el-text-color-regular)}.el-descriptions--large .el-descriptions__label:not(.is-bordered-label){margin-right:16px}.el-descriptions--large .el-descriptions__label.el-descriptions__cell:not(.is-bordered-label).is-vertical-label{padding-bottom:8px}.el-descriptions--small .el-descriptions__label:not(.is-bordered-label){margin-right:12px}.el-descriptions--small .el-descriptions__label.el-descriptions__cell:not(.is-bordered-label).is-vertical-label{padding-bottom:4px}:root{--el-popup-modal-bg-color:var(--el-color-black);--el-popup-modal-opacity:0.5}.v-modal-enter{-webkit-animation:v-modal-in var(--el-transition-duration-fast) ease;animation:v-modal-in var(--el-transition-duration-fast) ease}.v-modal-leave{-webkit-animation:v-modal-out var(--el-transition-duration-fast) ease forwards;animation:v-modal-out var(--el-transition-duration-fast) ease forwards}@-webkit-keyframes v-modal-in{0%{opacity:0}}@keyframes v-modal-in{0%{opacity:0}}@-webkit-keyframes v-modal-out{100%{opacity:0}}@keyframes v-modal-out{100%{opacity:0}}.v-modal{position:fixed;left:0;top:0;width:100%;height:100%;opacity:var(--el-popup-modal-opacity);background:var(--el-popup-modal-bg-color)}.el-popup-parent--hidden{overflow:hidden}.el-dialog{--el-dialog-width:50%;--el-dialog-margin-top:15vh;--el-dialog-bg-color:var(--el-bg-color);--el-dialog-box-shadow:var(--el-box-shadow);--el-dialog-title-font-size:var(--el-font-size-large);--el-dialog-content-font-size:14px;--el-dialog-font-line-height:var(--el-font-line-height-primary);--el-dialog-padding-primary:20px;--el-dialog-border-radius:var(--el-border-radius-small);position:relative;margin:var(--el-dialog-margin-top,15vh) auto 50px;background:var(--el-dialog-bg-color);border-radius:var(--el-dialog-border-radius);box-shadow:var(--el-dialog-box-shadow);box-sizing:border-box;width:var(--el-dialog-width,50%)}.el-dialog:focus{outline:0!important}.el-dialog.is-align-center{margin:auto}.el-dialog.is-fullscreen{--el-dialog-width:100%;--el-dialog-margin-top:0;margin-bottom:0;height:100%;overflow:auto}.el-dialog__wrapper{position:fixed;top:0;right:0;bottom:0;left:0;overflow:auto;margin:0}.el-dialog.is-draggable .el-dialog__header{cursor:move;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.el-dialog__header{padding:var(--el-dialog-padding-primary);padding-bottom:10px;margin-right:16px;word-break:break-all}.el-dialog__headerbtn{position:absolute;top:6px;right:0;padding:0;width:54px;height:54px;background:0 0;border:none;outline:0;cursor:pointer;font-size:var(--el-message-close-size,16px)}.el-dialog__headerbtn .el-dialog__close{color:var(--el-color-info);font-size:inherit}.el-dialog__headerbtn:focus .el-dialog__close,.el-dialog__headerbtn:hover .el-dialog__close{color:var(--el-color-primary)}.el-dialog__title{line-height:var(--el-dialog-font-line-height);font-size:var(--el-dialog-title-font-size);color:var(--el-text-color-primary)}.el-dialog__body{padding:calc(var(--el-dialog-padding-primary) + 10px) var(--el-dialog-padding-primary);color:var(--el-text-color-regular);font-size:var(--el-dialog-content-font-size);word-break:break-all}.el-dialog__footer{padding:var(--el-dialog-padding-primary);padding-top:10px;text-align:right;box-sizing:border-box}.el-dialog--center{text-align:center}.el-dialog--center .el-dialog__body{text-align:initial;padding:25px calc(var(--el-dialog-padding-primary) + 5px) 30px}.el-dialog--center .el-dialog__footer{text-align:inherit}.el-overlay-dialog{position:fixed;top:0;right:0;bottom:0;left:0;overflow:auto}.dialog-fade-enter-active{-webkit-animation:modal-fade-in var(--el-transition-duration);animation:modal-fade-in var(--el-transition-duration)}.dialog-fade-enter-active .el-overlay-dialog{-webkit-animation:dialog-fade-in var(--el-transition-duration);animation:dialog-fade-in var(--el-transition-duration)}.dialog-fade-leave-active{-webkit-animation:modal-fade-out var(--el-transition-duration);animation:modal-fade-out var(--el-transition-duration)}.dialog-fade-leave-active .el-overlay-dialog{-webkit-animation:dialog-fade-out var(--el-transition-duration);animation:dialog-fade-out var(--el-transition-duration)}@-webkit-keyframes dialog-fade-in{0%{transform:translate3d(0,-20px,0);opacity:0}100%{transform:translate3d(0,0,0);opacity:1}}@keyframes dialog-fade-in{0%{transform:translate3d(0,-20px,0);opacity:0}100%{transform:translate3d(0,0,0);opacity:1}}@-webkit-keyframes dialog-fade-out{0%{transform:translate3d(0,0,0);opacity:1}100%{transform:translate3d(0,-20px,0);opacity:0}}@keyframes dialog-fade-out{0%{transform:translate3d(0,0,0);opacity:1}100%{transform:translate3d(0,-20px,0);opacity:0}}@-webkit-keyframes modal-fade-in{0%{opacity:0}100%{opacity:1}}@keyframes modal-fade-in{0%{opacity:0}100%{opacity:1}}@-webkit-keyframes modal-fade-out{0%{opacity:1}100%{opacity:0}}@keyframes modal-fade-out{0%{opacity:1}100%{opacity:0}}.el-divider{position:relative}.el-divider--horizontal{display:block;height:1px;width:100%;margin:24px 0;border-top:1px var(--el-border-color) var(--el-border-style)}.el-divider--vertical{display:inline-block;width:1px;height:1em;margin:0 8px;vertical-align:middle;position:relative;border-left:1px var(--el-border-color) var(--el-border-style)}.el-divider__text{position:absolute;background-color:var(--el-bg-color);padding:0 20px;font-weight:500;color:var(--el-text-color-primary);font-size:14px}.el-divider__text.is-left{left:20px;transform:translateY(-50%)}.el-divider__text.is-center{left:50%;transform:translateX(-50%) translateY(-50%)}.el-divider__text.is-right{right:20px;transform:translateY(-50%)}.el-drawer{--el-drawer-bg-color:var(--el-dialog-bg-color, var(--el-bg-color));--el-drawer-padding-primary:var(--el-dialog-padding-primary, 20px)}.el-drawer{position:absolute;box-sizing:border-box;background-color:var(--el-drawer-bg-color);display:flex;flex-direction:column;box-shadow:var(--el-box-shadow-dark);overflow:hidden;transition:all var(--el-transition-duration)}.el-drawer .rtl{transform:translate(0,0)}.el-drawer .ltr{transform:translate(0,0)}.el-drawer .ttb{transform:translate(0,0)}.el-drawer .btt{transform:translate(0,0)}.el-drawer__sr-focus:focus{outline:0!important}.el-drawer__header{align-items:center;color:#72767b;display:flex;margin-bottom:32px;padding:var(--el-drawer-padding-primary);padding-bottom:0}.el-drawer__header>:first-child{flex:1}.el-drawer__title{margin:0;flex:1;line-height:inherit;font-size:1rem}.el-drawer__footer{padding:var(--el-drawer-padding-primary);padding-top:10px;text-align:right}.el-drawer__close-btn{display:inline-flex;border:none;cursor:pointer;font-size:var(--el-font-size-extra-large);color:inherit;background-color:transparent;outline:0}.el-drawer__close-btn:focus i,.el-drawer__close-btn:hover i{color:var(--el-color-primary)}.el-drawer__body{flex:1;padding:var(--el-drawer-padding-primary);overflow:auto}.el-drawer__body>*{box-sizing:border-box}.el-drawer.ltr,.el-drawer.rtl{height:100%;top:0;bottom:0}.el-drawer.btt,.el-drawer.ttb{width:100%;left:0;right:0}.el-drawer.ltr{left:0}.el-drawer.rtl{right:0}.el-drawer.ttb{top:0}.el-drawer.btt{bottom:0}.el-drawer-fade-enter-active,.el-drawer-fade-leave-active{transition:all var(--el-transition-duration)}.el-drawer-fade-enter-active,.el-drawer-fade-enter-from,.el-drawer-fade-enter-to,.el-drawer-fade-leave-active,.el-drawer-fade-leave-from,.el-drawer-fade-leave-to{overflow:hidden!important}.el-drawer-fade-enter-from,.el-drawer-fade-leave-to{opacity:0}.el-drawer-fade-enter-to,.el-drawer-fade-leave-from{opacity:1}.el-drawer-fade-enter-from .rtl,.el-drawer-fade-leave-to .rtl{transform:translateX(100%)}.el-drawer-fade-enter-from .ltr,.el-drawer-fade-leave-to .ltr{transform:translateX(-100%)}.el-drawer-fade-enter-from .ttb,.el-drawer-fade-leave-to .ttb{transform:translateY(-100%)}.el-drawer-fade-enter-from .btt,.el-drawer-fade-leave-to .btt{transform:translateY(100%)}.el-dropdown{--el-dropdown-menu-box-shadow:var(--el-box-shadow-light);--el-dropdown-menuItem-hover-fill:var(--el-color-primary-light-9);--el-dropdown-menuItem-hover-color:var(--el-color-primary);--el-dropdown-menu-index:10;display:inline-flex;position:relative;color:var(--el-text-color-regular);font-size:var(--el-font-size-base);line-height:1;vertical-align:top}.el-dropdown.is-disabled{color:var(--el-text-color-placeholder);cursor:not-allowed}.el-dropdown__popper{--el-dropdown-menu-box-shadow:var(--el-box-shadow-light);--el-dropdown-menuItem-hover-fill:var(--el-color-primary-light-9);--el-dropdown-menuItem-hover-color:var(--el-color-primary);--el-dropdown-menu-index:10}.el-dropdown__popper.el-popper{background:var(--el-bg-color-overlay);border:1px solid var(--el-border-color-light);box-shadow:var(--el-dropdown-menu-box-shadow)}.el-dropdown__popper.el-popper .el-popper__arrow::before{border:1px solid var(--el-border-color-light)}.el-dropdown__popper.el-popper[data-popper-placement^=top] .el-popper__arrow::before{border-top-color:transparent;border-left-color:transparent}.el-dropdown__popper.el-popper[data-popper-placement^=bottom] .el-popper__arrow::before{border-bottom-color:transparent;border-right-color:transparent}.el-dropdown__popper.el-popper[data-popper-placement^=left] .el-popper__arrow::before{border-left-color:transparent;border-bottom-color:transparent}.el-dropdown__popper.el-popper[data-popper-placement^=right] .el-popper__arrow::before{border-right-color:transparent;border-top-color:transparent}.el-dropdown__popper .el-dropdown-menu{border:none}.el-dropdown__popper .el-dropdown__popper-selfdefine{outline:0}.el-dropdown__popper .el-scrollbar__bar{z-index:calc(var(--el-dropdown-menu-index) + 1)}.el-dropdown__popper .el-dropdown__list{list-style:none;padding:0;margin:0;box-sizing:border-box}.el-dropdown .el-dropdown__caret-button{padding-left:0;padding-right:0;display:inline-flex;justify-content:center;align-items:center;width:32px;border-left:none}.el-dropdown .el-dropdown__caret-button>span{display:inline-flex}.el-dropdown .el-dropdown__caret-button::before{content:"";position:absolute;display:block;width:1px;top:-1px;bottom:-1px;left:0;background:var(--el-overlay-color-lighter)}.el-dropdown .el-dropdown__caret-button.el-button::before{background:var(--el-border-color);opacity:.5}.el-dropdown .el-dropdown__caret-button .el-dropdown__icon{font-size:inherit;padding-left:0}.el-dropdown .el-dropdown-selfdefine{outline:0}.el-dropdown--large .el-dropdown__caret-button{width:40px}.el-dropdown--small .el-dropdown__caret-button{width:24px}.el-dropdown-menu{position:relative;top:0;left:0;z-index:var(--el-dropdown-menu-index);padding:5px 0;margin:0;background-color:var(--el-bg-color-overlay);border:none;border-radius:var(--el-border-radius-base);box-shadow:none;list-style:none}.el-dropdown-menu__item{display:flex;align-items:center;white-space:nowrap;list-style:none;line-height:22px;padding:5px 16px;margin:0;font-size:var(--el-font-size-base);color:var(--el-text-color-regular);cursor:pointer;outline:0}.el-dropdown-menu__item:not(.is-disabled):focus{background-color:var(--el-dropdown-menuItem-hover-fill);color:var(--el-dropdown-menuItem-hover-color)}.el-dropdown-menu__item i{margin-right:5px}.el-dropdown-menu__item--divided{margin:6px 0;border-top:1px solid var(--el-border-color-lighter)}.el-dropdown-menu__item.is-disabled{cursor:not-allowed;color:var(--el-text-color-disabled)}.el-dropdown-menu--large{padding:7px 0}.el-dropdown-menu--large .el-dropdown-menu__item{padding:7px 20px;line-height:22px;font-size:14px}.el-dropdown-menu--large .el-dropdown-menu__item--divided{margin:8px 0}.el-dropdown-menu--small{padding:3px 0}.el-dropdown-menu--small .el-dropdown-menu__item{padding:2px 12px;line-height:20px;font-size:12px}.el-dropdown-menu--small .el-dropdown-menu__item--divided{margin:4px 0}.el-empty{--el-empty-padding:40px 0;--el-empty-image-width:160px;--el-empty-description-margin-top:20px;--el-empty-bottom-margin-top:20px;--el-empty-fill-color-0:var(--el-color-white);--el-empty-fill-color-1:#fcfcfd;--el-empty-fill-color-2:#f8f9fb;--el-empty-fill-color-3:#f7f8fc;--el-empty-fill-color-4:#eeeff3;--el-empty-fill-color-5:#edeef2;--el-empty-fill-color-6:#e9ebef;--el-empty-fill-color-7:#e5e7e9;--el-empty-fill-color-8:#e0e3e9;--el-empty-fill-color-9:#d5d7de;display:flex;justify-content:center;align-items:center;flex-direction:column;text-align:center;box-sizing:border-box;padding:var(--el-empty-padding)}.el-empty__image{width:var(--el-empty-image-width)}.el-empty__image img{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;width:100%;height:100%;vertical-align:top;-o-object-fit:contain;object-fit:contain}.el-empty__image svg{color:var(--el-svg-monochrome-grey);fill:currentColor;width:100%;height:100%;vertical-align:top}.el-empty__description{margin-top:var(--el-empty-description-margin-top)}.el-empty__description p{margin:0;font-size:var(--el-font-size-base);color:var(--el-text-color-secondary)}.el-empty__bottom{margin-top:var(--el-empty-bottom-margin-top)}.el-footer{--el-footer-padding:0 20px;--el-footer-height:60px;padding:var(--el-footer-padding);box-sizing:border-box;flex-shrink:0;height:var(--el-footer-height)}.el-form{--el-form-label-font-size:var(--el-font-size-base)}.el-form--label-left .el-form-item__label{justify-content:flex-start}.el-form--label-top .el-form-item{display:block}.el-form--label-top .el-form-item .el-form-item__label{display:block;height:auto;text-align:left;margin-bottom:8px;line-height:22px}.el-form--inline .el-form-item{display:inline-flex;vertical-align:middle;margin-right:32px}.el-form--inline.el-form--label-top{display:flex;flex-wrap:wrap}.el-form--inline.el-form--label-top .el-form-item{display:block}.el-form--large.el-form--label-top .el-form-item .el-form-item__label{margin-bottom:12px;line-height:22px}.el-form--default.el-form--label-top .el-form-item .el-form-item__label{margin-bottom:8px;line-height:22px}.el-form--small.el-form--label-top .el-form-item .el-form-item__label{margin-bottom:4px;line-height:20px}.el-form-item{display:flex;--font-size:14px;margin-bottom:18px}.el-form-item .el-form-item{margin-bottom:0}.el-form-item .el-input__validateIcon{display:none}.el-form-item--large{--font-size:14px;--el-form-label-font-size:var(--font-size);margin-bottom:22px}.el-form-item--large .el-form-item__label{height:40px;line-height:40px}.el-form-item--large .el-form-item__content{line-height:40px}.el-form-item--large .el-form-item__error{padding-top:4px}.el-form-item--default{--font-size:14px;--el-form-label-font-size:var(--font-size);margin-bottom:18px}.el-form-item--default .el-form-item__label{height:32px;line-height:32px}.el-form-item--default .el-form-item__content{line-height:32px}.el-form-item--default .el-form-item__error{padding-top:2px}.el-form-item--small{--font-size:12px;--el-form-label-font-size:var(--font-size);margin-bottom:18px}.el-form-item--small .el-form-item__label{height:24px;line-height:24px}.el-form-item--small .el-form-item__content{line-height:24px}.el-form-item--small .el-form-item__error{padding-top:2px}.el-form-item__label-wrap{display:flex}.el-form-item__label{display:inline-flex;justify-content:flex-end;align-items:flex-start;flex:0 0 auto;font-size:var(--el-form-label-font-size);color:var(--el-text-color-regular);height:32px;line-height:32px;padding:0 12px 0 0;box-sizing:border-box}.el-form-item__content{display:flex;flex-wrap:wrap;align-items:center;flex:1;line-height:32px;position:relative;font-size:var(--font-size);min-width:0}.el-form-item__content .el-input-group{vertical-align:top}.el-form-item__error{color:var(--el-color-danger);font-size:12px;line-height:1;padding-top:2px;position:absolute;top:100%;left:0}.el-form-item__error--inline{position:relative;top:auto;left:auto;display:inline-block;margin-left:10px}.el-form-item.is-required:not(.is-no-asterisk).asterisk-left>.el-form-item__label-wrap>.el-form-item__label:before,.el-form-item.is-required:not(.is-no-asterisk).asterisk-left>.el-form-item__label:before{content:"*";color:var(--el-color-danger);margin-right:4px}.el-form-item.is-required:not(.is-no-asterisk).asterisk-right>.el-form-item__label-wrap>.el-form-item__label:after,.el-form-item.is-required:not(.is-no-asterisk).asterisk-right>.el-form-item__label:after{content:"*";color:var(--el-color-danger);margin-left:4px}.el-form-item.is-error .el-select-v2__wrapper,.el-form-item.is-error .el-select-v2__wrapper:focus,.el-form-item.is-error .el-textarea__inner,.el-form-item.is-error .el-textarea__inner:focus{box-shadow:0 0 0 1px var(--el-color-danger) inset}.el-form-item.is-error .el-input__wrapper{box-shadow:0 0 0 1px var(--el-color-danger) inset}.el-form-item.is-error .el-input-group__append .el-input__wrapper,.el-form-item.is-error .el-input-group__prepend .el-input__wrapper{box-shadow:0 0 0 1px transparent inset}.el-form-item.is-error .el-input__validateIcon{color:var(--el-color-danger)}.el-form-item--feedback .el-input__validateIcon{display:inline-flex}.el-header{--el-header-padding:0 20px;--el-header-height:60px;padding:var(--el-header-padding);box-sizing:border-box;flex-shrink:0;height:var(--el-header-height)}.el-image-viewer__wrapper{position:fixed;top:0;right:0;bottom:0;left:0}.el-image-viewer__btn{position:absolute;z-index:1;display:flex;align-items:center;justify-content:center;border-radius:50%;opacity:.8;cursor:pointer;box-sizing:border-box;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.el-image-viewer__btn .el-icon{font-size:inherit;cursor:pointer}.el-image-viewer__close{top:40px;right:40px;width:40px;height:40px;font-size:40px}.el-image-viewer__canvas{position:static;width:100%;height:100%;display:flex;justify-content:center;align-items:center;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.el-image-viewer__actions{left:50%;bottom:30px;transform:translateX(-50%);width:282px;height:44px;padding:0 23px;background-color:var(--el-text-color-regular);border-color:#fff;border-radius:22px}.el-image-viewer__actions__inner{width:100%;height:100%;text-align:justify;cursor:default;font-size:23px;color:#fff;display:flex;align-items:center;justify-content:space-around}.el-image-viewer__prev{top:50%;transform:translateY(-50%);left:40px;width:44px;height:44px;font-size:24px;color:#fff;background-color:var(--el-text-color-regular);border-color:#fff}.el-image-viewer__next{top:50%;transform:translateY(-50%);right:40px;text-indent:2px;width:44px;height:44px;font-size:24px;color:#fff;background-color:var(--el-text-color-regular);border-color:#fff}.el-image-viewer__close{width:44px;height:44px;font-size:24px;color:#fff;background-color:var(--el-text-color-regular);border-color:#fff}.el-image-viewer__mask{position:absolute;width:100%;height:100%;top:0;left:0;opacity:.5;background:#000}.viewer-fade-enter-active{-webkit-animation:viewer-fade-in var(--el-transition-duration);animation:viewer-fade-in var(--el-transition-duration)}.viewer-fade-leave-active{-webkit-animation:viewer-fade-out var(--el-transition-duration);animation:viewer-fade-out var(--el-transition-duration)}@-webkit-keyframes viewer-fade-in{0%{transform:translate3d(0,-20px,0);opacity:0}100%{transform:translate3d(0,0,0);opacity:1}}@keyframes viewer-fade-in{0%{transform:translate3d(0,-20px,0);opacity:0}100%{transform:translate3d(0,0,0);opacity:1}}@-webkit-keyframes viewer-fade-out{0%{transform:translate3d(0,0,0);opacity:1}100%{transform:translate3d(0,-20px,0);opacity:0}}@keyframes viewer-fade-out{0%{transform:translate3d(0,0,0);opacity:1}100%{transform:translate3d(0,-20px,0);opacity:0}}.el-image__error,.el-image__inner,.el-image__placeholder,.el-image__wrapper{width:100%;height:100%}.el-image{position:relative;display:inline-block;overflow:hidden}.el-image__inner{vertical-align:top;opacity:1}.el-image__inner.is-loading{opacity:0}.el-image__wrapper{position:absolute;top:0;left:0}.el-image__placeholder{background:var(--el-fill-color-light)}.el-image__error{display:flex;justify-content:center;align-items:center;font-size:14px;background:var(--el-fill-color-light);color:var(--el-text-color-placeholder);vertical-align:middle}.el-image__preview{cursor:pointer}.el-input-number{position:relative;display:inline-flex;width:150px;line-height:30px}.el-input-number .el-input__wrapper{padding-left:42px;padding-right:42px}.el-input-number .el-input__inner{-webkit-appearance:none;-moz-appearance:textfield;text-align:center;line-height:1}.el-input-number .el-input__inner::-webkit-inner-spin-button,.el-input-number .el-input__inner::-webkit-outer-spin-button{margin:0;-webkit-appearance:none}.el-input-number__decrease,.el-input-number__increase{display:flex;justify-content:center;align-items:center;height:auto;position:absolute;z-index:1;top:1px;bottom:1px;width:32px;background:var(--el-fill-color-light);color:var(--el-text-color-regular);cursor:pointer;font-size:13px;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.el-input-number__decrease:hover,.el-input-number__increase:hover{color:var(--el-color-primary)}.el-input-number__decrease:hover~.el-input:not(.is-disabled) .el-input_wrapper,.el-input-number__increase:hover~.el-input:not(.is-disabled) .el-input_wrapper{box-shadow:0 0 0 1px var(--el-input-focus-border-color,var(--el-color-primary)) inset}.el-input-number__decrease.is-disabled,.el-input-number__increase.is-disabled{color:var(--el-disabled-text-color);cursor:not-allowed}.el-input-number__increase{right:1px;border-radius:0 var(--el-border-radius-base) var(--el-border-radius-base) 0;border-left:var(--el-border)}.el-input-number__decrease{left:1px;border-radius:var(--el-border-radius-base) 0 0 var(--el-border-radius-base);border-right:var(--el-border)}.el-input-number.is-disabled .el-input-number__decrease,.el-input-number.is-disabled .el-input-number__increase{border-color:var(--el-disabled-border-color);color:var(--el-disabled-border-color)}.el-input-number.is-disabled .el-input-number__decrease:hover,.el-input-number.is-disabled .el-input-number__increase:hover{color:var(--el-disabled-border-color);cursor:not-allowed}.el-input-number--large{width:180px;line-height:38px}.el-input-number--large .el-input-number__decrease,.el-input-number--large .el-input-number__increase{width:40px;font-size:14px}.el-input-number--large .el-input__wrapper{padding-left:47px;padding-right:47px}.el-input-number--small{width:120px;line-height:22px}.el-input-number--small .el-input-number__decrease,.el-input-number--small .el-input-number__increase{width:24px;font-size:12px}.el-input-number--small .el-input__wrapper{padding-left:31px;padding-right:31px}.el-input-number--small .el-input-number__decrease [class*=el-icon],.el-input-number--small .el-input-number__increase [class*=el-icon]{transform:scale(.9)}.el-input-number.is-without-controls .el-input__wrapper{padding-left:15px;padding-right:15px}.el-input-number.is-controls-right .el-input__wrapper{padding-left:15px;padding-right:42px}.el-input-number.is-controls-right .el-input-number__decrease,.el-input-number.is-controls-right .el-input-number__increase{--el-input-number-controls-height:15px;height:var(--el-input-number-controls-height);line-height:var(--el-input-number-controls-height)}.el-input-number.is-controls-right .el-input-number__decrease [class*=el-icon],.el-input-number.is-controls-right .el-input-number__increase [class*=el-icon]{transform:scale(.8)}.el-input-number.is-controls-right .el-input-number__increase{bottom:auto;left:auto;border-radius:0 var(--el-border-radius-base) 0 0;border-bottom:var(--el-border)}.el-input-number.is-controls-right .el-input-number__decrease{right:1px;top:auto;left:auto;border-right:none;border-left:var(--el-border);border-radius:0 0 var(--el-border-radius-base) 0}.el-input-number.is-controls-right[class*=large] [class*=decrease],.el-input-number.is-controls-right[class*=large] [class*=increase]{--el-input-number-controls-height:19px}.el-input-number.is-controls-right[class*=small] [class*=decrease],.el-input-number.is-controls-right[class*=small] [class*=increase]{--el-input-number-controls-height:11px}.el-textarea{--el-input-text-color:var(--el-text-color-regular);--el-input-border:var(--el-border);--el-input-hover-border:var(--el-border-color-hover);--el-input-focus-border:var(--el-color-primary);--el-input-transparent-border:0 0 0 1px transparent inset;--el-input-border-color:var(--el-border-color);--el-input-border-radius:var(--el-border-radius-base);--el-input-bg-color:var(--el-fill-color-blank);--el-input-icon-color:var(--el-text-color-placeholder);--el-input-placeholder-color:var(--el-text-color-placeholder);--el-input-hover-border-color:var(--el-border-color-hover);--el-input-clear-hover-color:var(--el-text-color-secondary);--el-input-focus-border-color:var(--el-color-primary)}.el-textarea{position:relative;display:inline-block;width:100%;vertical-align:bottom;font-size:var(--el-font-size-base)}.el-textarea__inner{position:relative;display:block;resize:vertical;padding:5px 11px;line-height:1.5;box-sizing:border-box;width:100%;font-size:inherit;font-family:inherit;color:var(--el-input-text-color,var(--el-text-color-regular));background-color:var(--el-input-bg-color,var(--el-fill-color-blank));background-image:none;-webkit-appearance:none;box-shadow:0 0 0 1px var(--el-input-border-color,var(--el-border-color)) inset;border-radius:var(--el-input-border-radius,var(--el-border-radius-base));transition:var(--el-transition-box-shadow);border:none}.el-textarea__inner::-moz-placeholder{color:var(--el-input-placeholder-color,var(--el-text-color-placeholder))}.el-textarea__inner:-ms-input-placeholder{color:var(--el-input-placeholder-color,var(--el-text-color-placeholder))}.el-textarea__inner::placeholder{color:var(--el-input-placeholder-color,var(--el-text-color-placeholder))}.el-textarea__inner:hover{box-shadow:0 0 0 1px var(--el-input-hover-border-color) inset}.el-textarea__inner:focus{outline:0;box-shadow:0 0 0 1px var(--el-input-focus-border-color) inset}.el-textarea .el-input__count{color:var(--el-color-info);background:var(--el-fill-color-blank);position:absolute;font-size:12px;line-height:14px;bottom:5px;right:10px}.el-textarea.is-disabled .el-textarea__inner{background-color:var(--el-disabled-bg-color);border-color:var(--el-disabled-border-color);color:var(--el-disabled-text-color);cursor:not-allowed}.el-textarea.is-disabled .el-textarea__inner::-moz-placeholder{color:var(--el-text-color-placeholder)}.el-textarea.is-disabled .el-textarea__inner:-ms-input-placeholder{color:var(--el-text-color-placeholder)}.el-textarea.is-disabled .el-textarea__inner::placeholder{color:var(--el-text-color-placeholder)}.el-textarea.is-exceed .el-textarea__inner{border-color:var(--el-color-danger)}.el-textarea.is-exceed .el-input__count{color:var(--el-color-danger)}.el-input{--el-input-text-color:var(--el-text-color-regular);--el-input-border:var(--el-border);--el-input-hover-border:var(--el-border-color-hover);--el-input-focus-border:var(--el-color-primary);--el-input-transparent-border:0 0 0 1px transparent inset;--el-input-border-color:var(--el-border-color);--el-input-border-radius:var(--el-border-radius-base);--el-input-bg-color:var(--el-fill-color-blank);--el-input-icon-color:var(--el-text-color-placeholder);--el-input-placeholder-color:var(--el-text-color-placeholder);--el-input-hover-border-color:var(--el-border-color-hover);--el-input-clear-hover-color:var(--el-text-color-secondary);--el-input-focus-border-color:var(--el-color-primary)}.el-input{--el-input-height:var(--el-component-size);position:relative;font-size:var(--el-font-size-base);display:inline-flex;width:100%;line-height:var(--el-input-height);box-sizing:border-box;vertical-align:middle}.el-input::-webkit-scrollbar{z-index:11;width:6px}.el-input::-webkit-scrollbar:horizontal{height:6px}.el-input::-webkit-scrollbar-thumb{border-radius:5px;width:6px;background:var(--el-text-color-disabled)}.el-input::-webkit-scrollbar-corner{background:var(--el-fill-color-blank)}.el-input::-webkit-scrollbar-track{background:var(--el-fill-color-blank)}.el-input::-webkit-scrollbar-track-piece{background:var(--el-fill-color-blank);width:6px}.el-input .el-input__clear,.el-input .el-input__password{color:var(--el-input-icon-color);font-size:14px;cursor:pointer}.el-input .el-input__clear:hover,.el-input .el-input__password:hover{color:var(--el-input-clear-hover-color)}.el-input .el-input__count{height:100%;display:inline-flex;align-items:center;color:var(--el-color-info);font-size:12px}.el-input .el-input__count .el-input__count-inner{background:var(--el-fill-color-blank);line-height:initial;display:inline-block;padding-left:8px}.el-input__wrapper{display:inline-flex;flex-grow:1;align-items:center;justify-content:center;padding:1px 11px;background-color:var(--el-input-bg-color,var(--el-fill-color-blank));background-image:none;border-radius:var(--el-input-border-radius,var(--el-border-radius-base));transition:var(--el-transition-box-shadow);box-shadow:0 0 0 1px var(--el-input-border-color,var(--el-border-color)) inset}.el-input__wrapper:hover{box-shadow:0 0 0 1px var(--el-input-hover-border-color) inset}.el-input__wrapper.is-focus{box-shadow:0 0 0 1px var(--el-input-focus-border-color) inset}.el-input__inner{--el-input-inner-height:calc(var(--el-input-height, 32px) - 2px);width:100%;flex-grow:1;-webkit-appearance:none;color:var(--el-input-text-color,var(--el-text-color-regular));font-size:inherit;height:var(--el-input-inner-height);line-height:var(--el-input-inner-height);padding:0;outline:0;border:none;background:0 0;box-sizing:border-box}.el-input__inner:focus{outline:0}.el-input__inner::-moz-placeholder{color:var(--el-input-placeholder-color,var(--el-text-color-placeholder))}.el-input__inner:-ms-input-placeholder{color:var(--el-input-placeholder-color,var(--el-text-color-placeholder))}.el-input__inner::placeholder{color:var(--el-input-placeholder-color,var(--el-text-color-placeholder))}.el-input__inner[type=password]::-ms-reveal{display:none}.el-input__prefix{display:inline-flex;white-space:nowrap;flex-shrink:0;flex-wrap:nowrap;height:100%;text-align:center;color:var(--el-input-icon-color,var(--el-text-color-placeholder));transition:all var(--el-transition-duration);pointer-events:none}.el-input__prefix-inner{pointer-events:all;display:inline-flex;align-items:center;justify-content:center}.el-input__prefix-inner>:last-child{margin-right:8px}.el-input__prefix-inner>:first-child,.el-input__prefix-inner>:first-child.el-input__icon{margin-left:0}.el-input__suffix{display:inline-flex;white-space:nowrap;flex-shrink:0;flex-wrap:nowrap;height:100%;text-align:center;color:var(--el-input-icon-color,var(--el-text-color-placeholder));transition:all var(--el-transition-duration);pointer-events:none}.el-input__suffix-inner{pointer-events:all;display:inline-flex;align-items:center;justify-content:center}.el-input__suffix-inner>:first-child{margin-left:8px}.el-input .el-input__icon{height:inherit;line-height:inherit;display:flex;justify-content:center;align-items:center;transition:all var(--el-transition-duration);margin-left:8px}.el-input__validateIcon{pointer-events:none}.el-input.is-active .el-input__wrapper{box-shadow:0 0 0 1px var(--el-input-focus-color,) inset}.el-input.is-disabled{cursor:not-allowed}.el-input.is-disabled .el-input__wrapper{background-color:var(--el-disabled-bg-color);box-shadow:0 0 0 1px var(--el-disabled-border-color) inset}.el-input.is-disabled .el-input__inner{color:var(--el-disabled-text-color);-webkit-text-fill-color:var(--el-disabled-text-color);cursor:not-allowed}.el-input.is-disabled .el-input__inner::-moz-placeholder{color:var(--el-text-color-placeholder)}.el-input.is-disabled .el-input__inner:-ms-input-placeholder{color:var(--el-text-color-placeholder)}.el-input.is-disabled .el-input__inner::placeholder{color:var(--el-text-color-placeholder)}.el-input.is-disabled .el-input__icon{cursor:not-allowed}.el-input.is-exceed .el-input__wrapper{box-shadow:0 0 0 1px var(--el-color-danger) inset}.el-input.is-exceed .el-input__suffix .el-input__count{color:var(--el-color-danger)}.el-input--large{--el-input-height:var(--el-component-size-large);font-size:14px}.el-input--large .el-input__wrapper{padding:1px 15px}.el-input--large .el-input__inner{--el-input-inner-height:calc(var(--el-input-height, 40px) - 2px)}.el-input--small{--el-input-height:var(--el-component-size-small);font-size:12px}.el-input--small .el-input__wrapper{padding:1px 7px}.el-input--small .el-input__inner{--el-input-inner-height:calc(var(--el-input-height, 24px) - 2px)}.el-input-group{display:inline-flex;width:100%;align-items:stretch}.el-input-group__append,.el-input-group__prepend{background-color:var(--el-fill-color-light);color:var(--el-color-info);position:relative;display:inline-flex;align-items:center;justify-content:center;min-height:100%;border-radius:var(--el-input-border-radius);padding:0 20px;white-space:nowrap}.el-input-group__append:focus,.el-input-group__prepend:focus{outline:0}.el-input-group__append .el-button,.el-input-group__append .el-select,.el-input-group__prepend .el-button,.el-input-group__prepend .el-select{display:inline-block;margin:0 -20px}.el-input-group__append button.el-button,.el-input-group__append button.el-button:hover,.el-input-group__append div.el-select .el-input__wrapper,.el-input-group__append div.el-select:hover .el-input__wrapper,.el-input-group__prepend button.el-button,.el-input-group__prepend button.el-button:hover,.el-input-group__prepend div.el-select .el-input__wrapper,.el-input-group__prepend div.el-select:hover .el-input__wrapper{border-color:transparent;background-color:transparent;color:inherit}.el-input-group__append .el-button,.el-input-group__append .el-input,.el-input-group__prepend .el-button,.el-input-group__prepend .el-input{font-size:inherit}.el-input-group__prepend{border-right:0;border-top-right-radius:0;border-bottom-right-radius:0;box-shadow:1px 0 0 0 var(--el-input-border-color) inset,0 1px 0 0 var(--el-input-border-color) inset,0 -1px 0 0 var(--el-input-border-color) inset}.el-input-group__append{border-left:0;border-top-left-radius:0;border-bottom-left-radius:0;box-shadow:0 1px 0 0 var(--el-input-border-color) inset,0 -1px 0 0 var(--el-input-border-color) inset,-1px 0 0 0 var(--el-input-border-color) inset}.el-input-group--prepend>.el-input__wrapper{border-top-left-radius:0;border-bottom-left-radius:0}.el-input-group--prepend .el-input-group__prepend .el-select .el-input .el-input__inner{box-shadow:none!important}.el-input-group--prepend .el-input-group__prepend .el-select .el-input .el-input__wrapper{border-top-right-radius:0;border-bottom-right-radius:0;box-shadow:1px 0 0 0 var(--el-input-border-color) inset,0 1px 0 0 var(--el-input-border-color) inset,0 -1px 0 0 var(--el-input-border-color) inset}.el-input-group--prepend .el-input-group__prepend .el-select .el-input.is-focus .el-input__inner{box-shadow:none!important}.el-input-group--prepend .el-input-group__prepend .el-select .el-input.is-focus .el-input__wrapper{box-shadow:1px 0 0 0 var(--el-input-focus-border-color) inset,1px 0 0 0 var(--el-input-focus-border-color),0 1px 0 0 var(--el-input-focus-border-color) inset,0 -1px 0 0 var(--el-input-focus-border-color) inset!important;z-index:2}.el-input-group--prepend .el-input-group__prepend .el-select .el-input.is-focus .el-input__wrapper:focus{outline:0;z-index:2;box-shadow:1px 0 0 0 var(--el-input-focus-border-color) inset,1px 0 0 0 var(--el-input-focus-border-color),0 1px 0 0 var(--el-input-focus-border-color) inset,0 -1px 0 0 var(--el-input-focus-border-color) inset!important}.el-input-group--prepend .el-input-group__prepend .el-select:hover .el-input__inner{box-shadow:none!important}.el-input-group--prepend .el-input-group__prepend .el-select:hover .el-input__wrapper{z-index:1;box-shadow:1px 0 0 0 var(--el-input-hover-border-color) inset,1px 0 0 0 var(--el-input-hover-border-color),0 1px 0 0 var(--el-input-hover-border-color) inset,0 -1px 0 0 var(--el-input-hover-border-color) inset!important}.el-input-group--append>.el-input__wrapper{border-top-right-radius:0;border-bottom-right-radius:0}.el-input-group--append .el-input-group__append .el-select .el-input .el-input__inner{box-shadow:none!important}.el-input-group--append .el-input-group__append .el-select .el-input .el-input__wrapper{border-top-left-radius:0;border-bottom-left-radius:0;box-shadow:0 1px 0 0 var(--el-input-border-color) inset,0 -1px 0 0 var(--el-input-border-color) inset,-1px 0 0 0 var(--el-input-border-color) inset}.el-input-group--append .el-input-group__append .el-select .el-input.is-focus .el-input__inner{box-shadow:none!important}.el-input-group--append .el-input-group__append .el-select .el-input.is-focus .el-input__wrapper{z-index:2;box-shadow:-1px 0 0 0 var(--el-input-focus-border-color),-1px 0 0 0 var(--el-input-focus-border-color) inset,0 1px 0 0 var(--el-input-focus-border-color) inset,0 -1px 0 0 var(--el-input-focus-border-color) inset!important}.el-input-group--append .el-input-group__append .el-select:hover .el-input__inner{box-shadow:none!important}.el-input-group--append .el-input-group__append .el-select:hover .el-input__wrapper{z-index:1;box-shadow:-1px 0 0 0 var(--el-input-hover-border-color),-1px 0 0 0 var(--el-input-hover-border-color) inset,0 1px 0 0 var(--el-input-hover-border-color) inset,0 -1px 0 0 var(--el-input-hover-border-color) inset!important}.el-link{--el-link-font-size:var(--el-font-size-base);--el-link-font-weight:var(--el-font-weight-primary);--el-link-text-color:var(--el-text-color-regular);--el-link-hover-text-color:var(--el-color-primary);--el-link-disabled-text-color:var(--el-text-color-placeholder)}.el-link{display:inline-flex;flex-direction:row;align-items:center;justify-content:center;vertical-align:middle;position:relative;text-decoration:none;outline:0;cursor:pointer;padding:0;font-size:var(--el-link-font-size);font-weight:var(--el-link-font-weight);color:var(--el-link-text-color)}.el-link:hover{color:var(--el-link-hover-text-color)}.el-link.is-underline:hover:after{content:"";position:absolute;left:0;right:0;height:0;bottom:0;border-bottom:1px solid var(--el-link-hover-text-color)}.el-link.is-disabled{color:var(--el-link-disabled-text-color);cursor:not-allowed}.el-link [class*=el-icon-]+span{margin-left:5px}.el-link.el-link--default:after{border-color:var(--el-link-hover-text-color)}.el-link__inner{display:inline-flex;justify-content:center;align-items:center}.el-link.el-link--primary{--el-link-text-color:var(--el-color-primary);--el-link-hover-text-color:var(--el-color-primary-light-3);--el-link-disabled-text-color:var(--el-color-primary-light-5)}.el-link.el-link--primary:after{border-color:var(--el-link-text-color)}.el-link.el-link--primary.is-underline:hover:after{border-color:var(--el-link-text-color)}.el-link.el-link--success{--el-link-text-color:var(--el-color-success);--el-link-hover-text-color:var(--el-color-success-light-3);--el-link-disabled-text-color:var(--el-color-success-light-5)}.el-link.el-link--success:after{border-color:var(--el-link-text-color)}.el-link.el-link--success.is-underline:hover:after{border-color:var(--el-link-text-color)}.el-link.el-link--warning{--el-link-text-color:var(--el-color-warning);--el-link-hover-text-color:var(--el-color-warning-light-3);--el-link-disabled-text-color:var(--el-color-warning-light-5)}.el-link.el-link--warning:after{border-color:var(--el-link-text-color)}.el-link.el-link--warning.is-underline:hover:after{border-color:var(--el-link-text-color)}.el-link.el-link--danger{--el-link-text-color:var(--el-color-danger);--el-link-hover-text-color:var(--el-color-danger-light-3);--el-link-disabled-text-color:var(--el-color-danger-light-5)}.el-link.el-link--danger:after{border-color:var(--el-link-text-color)}.el-link.el-link--danger.is-underline:hover:after{border-color:var(--el-link-text-color)}.el-link.el-link--error{--el-link-text-color:var(--el-color-error);--el-link-hover-text-color:var(--el-color-error-light-3);--el-link-disabled-text-color:var(--el-color-error-light-5)}.el-link.el-link--error:after{border-color:var(--el-link-text-color)}.el-link.el-link--error.is-underline:hover:after{border-color:var(--el-link-text-color)}.el-link.el-link--info{--el-link-text-color:var(--el-color-info);--el-link-hover-text-color:var(--el-color-info-light-3);--el-link-disabled-text-color:var(--el-color-info-light-5)}.el-link.el-link--info:after{border-color:var(--el-link-text-color)}.el-link.el-link--info.is-underline:hover:after{border-color:var(--el-link-text-color)}:root{--el-loading-spinner-size:42px;--el-loading-fullscreen-spinner-size:50px}.el-loading-parent--relative{position:relative!important}.el-loading-parent--hidden{overflow:hidden!important}.el-loading-mask{position:absolute;z-index:2000;background-color:var(--el-mask-color);margin:0;top:0;right:0;bottom:0;left:0;transition:opacity var(--el-transition-duration)}.el-loading-mask.is-fullscreen{position:fixed}.el-loading-mask.is-fullscreen .el-loading-spinner{margin-top:calc((0px - var(--el-loading-fullscreen-spinner-size))/ 2)}.el-loading-mask.is-fullscreen .el-loading-spinner .circular{height:var(--el-loading-fullscreen-spinner-size);width:var(--el-loading-fullscreen-spinner-size)}.el-loading-spinner{top:50%;margin-top:calc((0px - var(--el-loading-spinner-size))/ 2);width:100%;text-align:center;position:absolute}.el-loading-spinner .el-loading-text{color:var(--el-color-primary);margin:3px 0;font-size:14px}.el-loading-spinner .circular{display:inline;height:var(--el-loading-spinner-size);width:var(--el-loading-spinner-size);-webkit-animation:loading-rotate 2s linear infinite;animation:loading-rotate 2s linear infinite}.el-loading-spinner .path{-webkit-animation:loading-dash 1.5s ease-in-out infinite;animation:loading-dash 1.5s ease-in-out infinite;stroke-dasharray:90,150;stroke-dashoffset:0;stroke-width:2;stroke:var(--el-color-primary);stroke-linecap:round}.el-loading-spinner i{color:var(--el-color-primary)}.el-loading-fade-enter-from,.el-loading-fade-leave-to{opacity:0}@-webkit-keyframes loading-rotate{100%{transform:rotate(360deg)}}@keyframes loading-rotate{100%{transform:rotate(360deg)}}@-webkit-keyframes loading-dash{0%{stroke-dasharray:1,200;stroke-dashoffset:0}50%{stroke-dasharray:90,150;stroke-dashoffset:-40px}100%{stroke-dasharray:90,150;stroke-dashoffset:-120px}}@keyframes loading-dash{0%{stroke-dasharray:1,200;stroke-dashoffset:0}50%{stroke-dasharray:90,150;stroke-dashoffset:-40px}100%{stroke-dasharray:90,150;stroke-dashoffset:-120px}}.el-main{--el-main-padding:20px;display:block;flex:1;flex-basis:auto;overflow:auto;box-sizing:border-box;padding:var(--el-main-padding)}:root{--el-menu-active-color:var(--el-color-primary);--el-menu-text-color:var(--el-text-color-primary);--el-menu-hover-text-color:var(--el-color-primary);--el-menu-bg-color:var(--el-fill-color-blank);--el-menu-hover-bg-color:var(--el-color-primary-light-9);--el-menu-item-height:56px;--el-menu-sub-item-height:calc(var(--el-menu-item-height) - 6px);--el-menu-horizontal-sub-item-height:36px;--el-menu-item-font-size:var(--el-font-size-base);--el-menu-item-hover-fill:var(--el-color-primary-light-9);--el-menu-border-color:var(--el-border-color);--el-menu-base-level-padding:20px;--el-menu-level-padding:20px;--el-menu-icon-width:24px}.el-menu{border-right:solid 1px var(--el-menu-border-color);list-style:none;position:relative;margin:0;padding-left:0;background-color:var(--el-menu-bg-color);box-sizing:border-box}.el-menu--vertical:not(.el-menu--collapse):not(.el-menu--popup-container) .el-menu-item,.el-menu--vertical:not(.el-menu--collapse):not(.el-menu--popup-container) .el-menu-item-group__title,.el-menu--vertical:not(.el-menu--collapse):not(.el-menu--popup-container) .el-sub-menu__title{white-space:nowrap;padding-left:calc(var(--el-menu-base-level-padding) + var(--el-menu-level) * var(--el-menu-level-padding))}.el-menu--horizontal{display:flex;flex-wrap:nowrap;border-bottom:solid 1px var(--el-menu-border-color);border-right:none}.el-menu--horizontal>.el-menu-item{display:inline-flex;justify-content:center;align-items:center;height:100%;margin:0;border-bottom:2px solid transparent;color:var(--el-menu-text-color)}.el-menu--horizontal>.el-menu-item a,.el-menu--horizontal>.el-menu-item a:hover{color:inherit}.el-menu--horizontal>.el-menu-item:not(.is-disabled):focus,.el-menu--horizontal>.el-menu-item:not(.is-disabled):hover{background-color:#fff}.el-menu--horizontal>.el-sub-menu:focus,.el-menu--horizontal>.el-sub-menu:hover{outline:0}.el-menu--horizontal>.el-sub-menu:hover .el-sub-menu__title{color:var(--el-menu-hover-text-color)}.el-menu--horizontal>.el-sub-menu.is-active .el-sub-menu__title{border-bottom:2px solid var(--el-menu-active-color);color:var(--el-menu-active-color)}.el-menu--horizontal>.el-sub-menu .el-sub-menu__title{height:100%;border-bottom:2px solid transparent;color:var(--el-menu-text-color)}.el-menu--horizontal>.el-sub-menu .el-sub-menu__title:hover{background-color:var(--el-bg-color-overlay)}.el-menu--horizontal .el-menu .el-menu-item,.el-menu--horizontal .el-menu .el-sub-menu__title{background-color:var(--el-menu-bg-color);display:flex;align-items:center;height:var(--el-menu-horizontal-sub-item-height);padding:0 10px;color:var(--el-menu-text-color)}.el-menu--horizontal .el-menu .el-sub-menu__title{padding-right:40px}.el-menu--horizontal .el-menu .el-menu-item.is-active,.el-menu--horizontal .el-menu .el-sub-menu.is-active>.el-sub-menu__title{color:var(--el-menu-active-color)}.el-menu--horizontal .el-menu-item:not(.is-disabled):focus,.el-menu--horizontal .el-menu-item:not(.is-disabled):hover{outline:0;color:var(--el-menu-hover-text-color);background-color:var(--el-menu-hover-bg-color)}.el-menu--horizontal>.el-menu-item.is-active{border-bottom:2px solid var(--el-menu-active-color);color:var(--el-menu-active-color)!important}.el-menu--collapse{width:calc(var(--el-menu-icon-width) + var(--el-menu-base-level-padding) * 2)}.el-menu--collapse>.el-menu-item [class^=el-icon],.el-menu--collapse>.el-menu-item-group>ul>.el-sub-menu>.el-sub-menu__title [class^=el-icon],.el-menu--collapse>.el-sub-menu>.el-sub-menu__title [class^=el-icon]{margin:0;vertical-align:middle;width:var(--el-menu-icon-width);text-align:center}.el-menu--collapse>.el-menu-item .el-sub-menu__icon-arrow,.el-menu--collapse>.el-menu-item-group>ul>.el-sub-menu>.el-sub-menu__title .el-sub-menu__icon-arrow,.el-menu--collapse>.el-sub-menu>.el-sub-menu__title .el-sub-menu__icon-arrow{display:none}.el-menu--collapse>.el-menu-item-group>ul>.el-sub-menu>.el-sub-menu__title>span,.el-menu--collapse>.el-menu-item>span,.el-menu--collapse>.el-sub-menu>.el-sub-menu__title>span{height:0;width:0;overflow:hidden;visibility:hidden;display:inline-block}.el-menu--collapse>.el-menu-item.is-active i{color:inherit}.el-menu--collapse .el-menu .el-sub-menu{min-width:200px}.el-menu--popup{z-index:100;min-width:200px;border:none;padding:5px 0;border-radius:var(--el-border-radius-small);box-shadow:var(--el-box-shadow-light)}.el-menu .el-icon{flex-shrink:0}.el-menu-item{display:flex;align-items:center;height:var(--el-menu-item-height);line-height:var(--el-menu-item-height);font-size:var(--el-menu-item-font-size);color:var(--el-menu-text-color);padding:0 var(--el-menu-base-level-padding);list-style:none;cursor:pointer;position:relative;transition:border-color var(--el-transition-duration),background-color var(--el-transition-duration),color var(--el-transition-duration);box-sizing:border-box;white-space:nowrap}.el-menu-item *{vertical-align:bottom}.el-menu-item i{color:inherit}.el-menu-item:focus,.el-menu-item:hover{outline:0}.el-menu-item:hover{background-color:var(--el-menu-hover-bg-color)}.el-menu-item.is-disabled{opacity:.25;cursor:not-allowed;background:0 0!important}.el-menu-item [class^=el-icon]{margin-right:5px;width:var(--el-menu-icon-width);text-align:center;font-size:18px;vertical-align:middle}.el-menu-item.is-active{color:var(--el-menu-active-color)}.el-menu-item.is-active i{color:inherit}.el-menu-item .el-menu-tooltip__trigger{position:absolute;left:0;top:0;height:100%;width:100%;display:inline-flex;align-items:center;box-sizing:border-box;padding:0 var(--el-menu-base-level-padding)}.el-sub-menu{list-style:none;margin:0;padding-left:0}.el-sub-menu__title{display:flex;align-items:center;height:var(--el-menu-item-height);line-height:var(--el-menu-item-height);font-size:var(--el-menu-item-font-size);color:var(--el-menu-text-color);padding:0 var(--el-menu-base-level-padding);list-style:none;cursor:pointer;position:relative;transition:border-color var(--el-transition-duration),background-color var(--el-transition-duration),color var(--el-transition-duration);box-sizing:border-box;white-space:nowrap;padding-right:calc(var(--el-menu-base-level-padding) + var(--el-menu-icon-width))}.el-sub-menu__title *{vertical-align:bottom}.el-sub-menu__title i{color:inherit}.el-sub-menu__title:focus,.el-sub-menu__title:hover{outline:0}.el-sub-menu__title:hover{background-color:var(--el-menu-hover-bg-color)}.el-sub-menu__title.is-disabled{opacity:.25;cursor:not-allowed;background:0 0!important}.el-sub-menu__title:hover{background-color:var(--el-menu-hover-bg-color)}.el-sub-menu .el-menu{border:none}.el-sub-menu .el-menu-item{height:var(--el-menu-sub-item-height);line-height:var(--el-menu-sub-item-height)}.el-sub-menu__hide-arrow .el-sub-menu__icon-arrow{display:none!important}.el-sub-menu.is-active .el-sub-menu__title{border-bottom-color:var(--el-menu-active-color)}.el-sub-menu.is-disabled .el-menu-item,.el-sub-menu.is-disabled .el-sub-menu__title{opacity:.25;cursor:not-allowed;background:0 0!important}.el-sub-menu .el-icon{vertical-align:middle;margin-right:5px;width:var(--el-menu-icon-width);text-align:center;font-size:18px}.el-sub-menu .el-icon.el-sub-menu__icon-more{margin-right:0!important}.el-sub-menu .el-sub-menu__icon-arrow{position:absolute;top:50%;right:var(--el-menu-base-level-padding);margin-top:-6px;transition:transform var(--el-transition-duration);font-size:12px;margin-right:0;width:inherit}.el-menu-item-group>ul{padding:0}.el-menu-item-group__title{padding:7px 0 7px var(--el-menu-base-level-padding);line-height:normal;font-size:12px;color:var(--el-text-color-secondary)}.horizontal-collapse-transition .el-sub-menu__title .el-sub-menu__icon-arrow{transition:var(--el-transition-duration-fast);opacity:0}.el-message-box{--el-messagebox-title-color:var(--el-text-color-primary);--el-messagebox-width:420px;--el-messagebox-border-radius:4px;--el-messagebox-font-size:var(--el-font-size-large);--el-messagebox-content-font-size:var(--el-font-size-base);--el-messagebox-content-color:var(--el-text-color-regular);--el-messagebox-error-font-size:12px;--el-messagebox-padding-primary:15px}.el-message-box{display:inline-block;max-width:var(--el-messagebox-width);width:100%;padding-bottom:10px;vertical-align:middle;background-color:var(--el-bg-color);border-radius:var(--el-messagebox-border-radius);border:1px solid var(--el-border-color-lighter);font-size:var(--el-messagebox-font-size);box-shadow:var(--el-box-shadow-light);text-align:left;overflow:hidden;-webkit-backface-visibility:hidden;backface-visibility:hidden}.el-message-box:focus{outline:0!important}.el-overlay.is-message-box .el-overlay-message-box{text-align:center;position:fixed;top:0;right:0;bottom:0;left:0;padding:16px;overflow:auto}.el-overlay.is-message-box .el-overlay-message-box::after{content:"";display:inline-block;height:100%;width:0;vertical-align:middle}.el-message-box.is-draggable .el-message-box__header{cursor:move;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.el-message-box__header{position:relative;padding:var(--el-messagebox-padding-primary);padding-bottom:10px}.el-message-box__title{padding-left:0;margin-bottom:0;font-size:var(--el-messagebox-font-size);line-height:1;color:var(--el-messagebox-title-color)}.el-message-box__headerbtn{position:absolute;top:var(--el-messagebox-padding-primary);right:var(--el-messagebox-padding-primary);padding:0;border:none;outline:0;background:0 0;font-size:var(--el-message-close-size,16px);cursor:pointer}.el-message-box__headerbtn .el-message-box__close{color:var(--el-color-info);font-size:inherit}.el-message-box__headerbtn:focus .el-message-box__close,.el-message-box__headerbtn:hover .el-message-box__close{color:var(--el-color-primary)}.el-message-box__content{padding:10px var(--el-messagebox-padding-primary);color:var(--el-messagebox-content-color);font-size:var(--el-messagebox-content-font-size)}.el-message-box__container{position:relative}.el-message-box__input{padding-top:15px}.el-message-box__input div.invalid>input{border-color:var(--el-color-error)}.el-message-box__input div.invalid>input:focus{border-color:var(--el-color-error)}.el-message-box__status{position:absolute;top:50%;transform:translateY(-50%);font-size:24px!important}.el-message-box__status::before{padding-left:1px}.el-message-box__status.el-icon{position:absolute}.el-message-box__status+.el-message-box__message{padding-left:36px;padding-right:12px;word-break:break-word}.el-message-box__status.el-message-box-icon--success{--el-messagebox-color:var(--el-color-success);color:var(--el-messagebox-color)}.el-message-box__status.el-message-box-icon--info{--el-messagebox-color:var(--el-color-info);color:var(--el-messagebox-color)}.el-message-box__status.el-message-box-icon--warning{--el-messagebox-color:var(--el-color-warning);color:var(--el-messagebox-color)}.el-message-box__status.el-message-box-icon--error{--el-messagebox-color:var(--el-color-error);color:var(--el-messagebox-color)}.el-message-box__message{margin:0}.el-message-box__message p{margin:0;line-height:24px}.el-message-box__errormsg{color:var(--el-color-error);font-size:var(--el-messagebox-error-font-size);min-height:18px;margin-top:2px}.el-message-box__btns{padding:5px 15px 0;display:flex;flex-wrap:wrap;justify-content:flex-end;align-items:center}.el-message-box__btns button:nth-child(2){margin-left:10px}.el-message-box__btns-reverse{flex-direction:row-reverse}.el-message-box--center .el-message-box__title{position:relative;display:flex;align-items:center;justify-content:center}.el-message-box--center .el-message-box__status{position:relative;top:auto;padding-right:5px;text-align:center;transform:translateY(-1px)}.el-message-box--center .el-message-box__message{margin-left:0}.el-message-box--center .el-message-box__btns{justify-content:center}.el-message-box--center .el-message-box__content{padding-left:calc(var(--el-messagebox-padding-primary) + 12px);padding-right:calc(var(--el-messagebox-padding-primary) + 12px);text-align:center}.fade-in-linear-enter-active .el-overlay-message-box{-webkit-animation:msgbox-fade-in var(--el-transition-duration);animation:msgbox-fade-in var(--el-transition-duration)}.fade-in-linear-leave-active .el-overlay-message-box{animation:msgbox-fade-in var(--el-transition-duration) reverse}@-webkit-keyframes msgbox-fade-in{0%{transform:translate3d(0,-20px,0);opacity:0}100%{transform:translate3d(0,0,0);opacity:1}}@keyframes msgbox-fade-in{0%{transform:translate3d(0,-20px,0);opacity:0}100%{transform:translate3d(0,0,0);opacity:1}}@-webkit-keyframes msgbox-fade-out{0%{transform:translate3d(0,0,0);opacity:1}100%{transform:translate3d(0,-20px,0);opacity:0}}@keyframes msgbox-fade-out{0%{transform:translate3d(0,0,0);opacity:1}100%{transform:translate3d(0,-20px,0);opacity:0}}.el-message{--el-message-bg-color:var(--el-color-info-light-9);--el-message-border-color:var(--el-border-color-lighter);--el-message-padding:15px 19px;--el-message-close-size:16px;--el-message-close-icon-color:var(--el-text-color-placeholder);--el-message-close-hover-color:var(--el-text-color-secondary)}.el-message{width:-webkit-fit-content;width:-moz-fit-content;width:fit-content;max-width:calc(100% - 32px);box-sizing:border-box;border-radius:var(--el-border-radius-base);border-width:var(--el-border-width);border-style:var(--el-border-style);border-color:var(--el-message-border-color);position:fixed;left:50%;top:20px;transform:translateX(-50%);background-color:var(--el-message-bg-color);transition:opacity var(--el-transition-duration),transform .4s,top .4s;padding:var(--el-message-padding);display:flex;align-items:center}.el-message.is-center{justify-content:center}.el-message.is-closable .el-message__content{padding-right:31px}.el-message p{margin:0}.el-message--success{--el-message-bg-color:var(--el-color-success-light-9);--el-message-border-color:var(--el-color-success-light-8);--el-message-text-color:var(--el-color-success)}.el-message--success .el-message__content{color:var(--el-message-text-color);overflow-wrap:anywhere}.el-message .el-message-icon--success{color:var(--el-message-text-color)}.el-message--info{--el-message-bg-color:var(--el-color-info-light-9);--el-message-border-color:var(--el-color-info-light-8);--el-message-text-color:var(--el-color-info)}.el-message--info .el-message__content{color:var(--el-message-text-color);overflow-wrap:anywhere}.el-message .el-message-icon--info{color:var(--el-message-text-color)}.el-message--warning{--el-message-bg-color:var(--el-color-warning-light-9);--el-message-border-color:var(--el-color-warning-light-8);--el-message-text-color:var(--el-color-warning)}.el-message--warning .el-message__content{color:var(--el-message-text-color);overflow-wrap:anywhere}.el-message .el-message-icon--warning{color:var(--el-message-text-color)}.el-message--error{--el-message-bg-color:var(--el-color-error-light-9);--el-message-border-color:var(--el-color-error-light-8);--el-message-text-color:var(--el-color-error)}.el-message--error .el-message__content{color:var(--el-message-text-color);overflow-wrap:anywhere}.el-message .el-message-icon--error{color:var(--el-message-text-color)}.el-message__icon{margin-right:10px}.el-message .el-message__badge{position:absolute;top:-8px;right:-8px}.el-message__content{padding:0;font-size:14px;line-height:1}.el-message__content:focus{outline-width:0}.el-message .el-message__closeBtn{position:absolute;top:50%;right:19px;transform:translateY(-50%);cursor:pointer;color:var(--el-message-close-icon-color);font-size:var(--el-message-close-size)}.el-message .el-message__closeBtn:focus{outline-width:0}.el-message .el-message__closeBtn:hover{color:var(--el-message-close-hover-color)}.el-message-fade-enter-from,.el-message-fade-leave-to{opacity:0;transform:translate(-50%,-100%)}.el-notification{--el-notification-width:330px;--el-notification-padding:14px 26px 14px 13px;--el-notification-radius:8px;--el-notification-shadow:var(--el-box-shadow-light);--el-notification-border-color:var(--el-border-color-lighter);--el-notification-icon-size:24px;--el-notification-close-font-size:var(--el-message-close-size, 16px);--el-notification-group-margin-left:13px;--el-notification-group-margin-right:8px;--el-notification-content-font-size:var(--el-font-size-base);--el-notification-content-color:var(--el-text-color-regular);--el-notification-title-font-size:16px;--el-notification-title-color:var(--el-text-color-primary);--el-notification-close-color:var(--el-text-color-secondary);--el-notification-close-hover-color:var(--el-text-color-regular)}.el-notification{display:flex;width:var(--el-notification-width);padding:var(--el-notification-padding);border-radius:var(--el-notification-radius);box-sizing:border-box;border:1px solid var(--el-notification-border-color);position:fixed;background-color:var(--el-bg-color-overlay);box-shadow:var(--el-notification-shadow);transition:opacity var(--el-transition-duration),transform var(--el-transition-duration),left var(--el-transition-duration),right var(--el-transition-duration),top .4s,bottom var(--el-transition-duration);overflow-wrap:anywhere;overflow:hidden;z-index:9999}.el-notification.right{right:16px}.el-notification.left{left:16px}.el-notification__group{margin-left:var(--el-notification-group-margin-left);margin-right:var(--el-notification-group-margin-right)}.el-notification__title{font-weight:700;font-size:var(--el-notification-title-font-size);line-height:var(--el-notification-icon-size);color:var(--el-notification-title-color);margin:0}.el-notification__content{font-size:var(--el-notification-content-font-size);line-height:24px;margin:6px 0 0;color:var(--el-notification-content-color);text-align:justify}.el-notification__content p{margin:0}.el-notification .el-notification__icon{height:var(--el-notification-icon-size);width:var(--el-notification-icon-size);font-size:var(--el-notification-icon-size)}.el-notification .el-notification__closeBtn{position:absolute;top:18px;right:15px;cursor:pointer;color:var(--el-notification-close-color);font-size:var(--el-notification-close-font-size)}.el-notification .el-notification__closeBtn:hover{color:var(--el-notification-close-hover-color)}.el-notification .el-notification--success{--el-notification-icon-color:var(--el-color-success);color:var(--el-notification-icon-color)}.el-notification .el-notification--info{--el-notification-icon-color:var(--el-color-info);color:var(--el-notification-icon-color)}.el-notification .el-notification--warning{--el-notification-icon-color:var(--el-color-warning);color:var(--el-notification-icon-color)}.el-notification .el-notification--error{--el-notification-icon-color:var(--el-color-error);color:var(--el-notification-icon-color)}.el-notification-fade-enter-from.right{right:0;transform:translateX(100%)}.el-notification-fade-enter-from.left{left:0;transform:translateX(-100%)}.el-notification-fade-leave-to{opacity:0}.el-overlay{position:fixed;top:0;right:0;bottom:0;left:0;z-index:2000;height:100%;background-color:var(--el-overlay-color-lighter);overflow:auto}.el-overlay .el-overlay-root{height:0}.el-page-header.is-contentful .el-page-header__main{border-top:1px solid var(--el-border-color-light);margin-top:16px}.el-page-header__header{display:flex;align-items:center;justify-content:space-between;line-height:24px}.el-page-header__left{display:flex;align-items:center;margin-right:40px;position:relative}.el-page-header__back{display:flex;align-items:center;cursor:pointer}.el-page-header__left .el-divider--vertical{margin:0 16px}.el-page-header__icon{font-size:16px;margin-right:10px;display:flex;align-items:center}.el-page-header__icon .el-icon{font-size:inherit}.el-page-header__title{font-size:14px;font-weight:500}.el-page-header__content{font-size:18px;color:var(--el-text-color-primary)}.el-page-header__breadcrumb{margin-bottom:16px}.el-pagination{--el-pagination-font-size:14px;--el-pagination-bg-color:var(--el-fill-color-blank);--el-pagination-text-color:var(--el-text-color-primary);--el-pagination-border-radius:2px;--el-pagination-button-color:var(--el-text-color-primary);--el-pagination-button-width:32px;--el-pagination-button-height:32px;--el-pagination-button-disabled-color:var(--el-text-color-placeholder);--el-pagination-button-disabled-bg-color:var(--el-fill-color-blank);--el-pagination-button-bg-color:var(--el-fill-color);--el-pagination-hover-color:var(--el-color-primary);--el-pagination-font-size-small:12px;--el-pagination-button-width-small:24px;--el-pagination-button-height-small:24px;--el-pagination-item-gap:16px;white-space:nowrap;color:var(--el-pagination-text-color);font-size:var(--el-pagination-font-size);font-weight:400;display:flex;align-items:center}.el-pagination .el-input__inner{text-align:center;-moz-appearance:textfield}.el-pagination .el-select .el-input{width:128px}.el-pagination button{display:flex;justify-content:center;align-items:center;font-size:var(--el-pagination-font-size);min-width:var(--el-pagination-button-width);height:var(--el-pagination-button-height);line-height:var(--el-pagination-button-height);color:var(--el-pagination-button-color);background:var(--el-pagination-bg-color);padding:0 4px;border:none;border-radius:var(--el-pagination-border-radius);cursor:pointer;text-align:center;box-sizing:border-box}.el-pagination button *{pointer-events:none}.el-pagination button:focus{outline:0}.el-pagination button:hover{color:var(--el-pagination-hover-color)}.el-pagination button.is-active{color:var(--el-pagination-hover-color);cursor:default;font-weight:700}.el-pagination button.is-active.is-disabled{font-weight:700;color:var(--el-text-color-secondary)}.el-pagination button.is-disabled,.el-pagination button:disabled{color:var(--el-pagination-button-disabled-color);background-color:var(--el-pagination-button-disabled-bg-color);cursor:not-allowed}.el-pagination button:focus-visible{outline:1px solid var(--el-pagination-hover-color);outline-offset:-1px}.el-pagination .btn-next .el-icon,.el-pagination .btn-prev .el-icon{display:block;font-size:12px;font-weight:700;width:inherit}.el-pagination>.is-first{margin-left:0!important}.el-pagination>.is-last{margin-right:0!important}.el-pagination .btn-prev{margin-left:var(--el-pagination-item-gap)}.el-pagination__sizes{margin-left:var(--el-pagination-item-gap);font-weight:400;color:var(--el-text-color-regular)}.el-pagination__total{margin-left:var(--el-pagination-item-gap);font-weight:400;color:var(--el-text-color-regular)}.el-pagination__total[disabled=true]{color:var(--el-text-color-placeholder)}.el-pagination__jump{display:flex;align-items:center;margin-left:var(--el-pagination-item-gap);font-weight:400;color:var(--el-text-color-regular)}.el-pagination__jump[disabled=true]{color:var(--el-text-color-placeholder)}.el-pagination__goto{margin-right:8px}.el-pagination__editor{text-align:center;box-sizing:border-box}.el-pagination__editor.el-input{width:56px}.el-pagination__editor .el-input__inner::-webkit-inner-spin-button,.el-pagination__editor .el-input__inner::-webkit-outer-spin-button{-webkit-appearance:none;margin:0}.el-pagination__classifier{margin-left:8px}.el-pagination__rightwrapper{flex:1;display:flex;align-items:center;justify-content:flex-end}.el-pagination.is-background .btn-next,.el-pagination.is-background .btn-prev,.el-pagination.is-background .el-pager li{margin:0 4px;background-color:var(--el-pagination-button-bg-color)}.el-pagination.is-background .btn-next.is-active,.el-pagination.is-background .btn-prev.is-active,.el-pagination.is-background .el-pager li.is-active{background-color:var(--el-color-primary);color:var(--el-color-white)}.el-pagination.is-background .btn-next.is-disabled,.el-pagination.is-background .btn-next:disabled,.el-pagination.is-background .btn-prev.is-disabled,.el-pagination.is-background .btn-prev:disabled,.el-pagination.is-background .el-pager li.is-disabled,.el-pagination.is-background .el-pager li:disabled{color:var(--el-text-color-placeholder);background-color:var(--el-disabled-bg-color)}.el-pagination.is-background .btn-next.is-disabled.is-active,.el-pagination.is-background .btn-next:disabled.is-active,.el-pagination.is-background .btn-prev.is-disabled.is-active,.el-pagination.is-background .btn-prev:disabled.is-active,.el-pagination.is-background .el-pager li.is-disabled.is-active,.el-pagination.is-background .el-pager li:disabled.is-active{color:var(--el-text-color-secondary);background-color:var(--el-fill-color-dark)}.el-pagination.is-background .btn-prev{margin-left:var(--el-pagination-item-gap)}.el-pagination--small .btn-next,.el-pagination--small .btn-prev,.el-pagination--small .el-pager li{height:var(--el-pagination-button-height-small);line-height:var(--el-pagination-button-height-small);font-size:var(--el-pagination-font-size-small);min-width:var(--el-pagination-button-width-small)}.el-pagination--small button,.el-pagination--small span:not([class*=suffix]){font-size:var(--el-pagination-font-size-small)}.el-pagination--small .el-select .el-input{width:100px}.el-pager{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;list-style:none;font-size:0;padding:0;margin:0;display:flex;align-items:center}.el-pager li{display:flex;justify-content:center;align-items:center;font-size:var(--el-pagination-font-size);min-width:var(--el-pagination-button-width);height:var(--el-pagination-button-height);line-height:var(--el-pagination-button-height);color:var(--el-pagination-button-color);background:var(--el-pagination-bg-color);padding:0 4px;border:none;border-radius:var(--el-pagination-border-radius);cursor:pointer;text-align:center;box-sizing:border-box}.el-pager li *{pointer-events:none}.el-pager li:focus{outline:0}.el-pager li:hover{color:var(--el-pagination-hover-color)}.el-pager li.is-active{color:var(--el-pagination-hover-color);cursor:default;font-weight:700}.el-pager li.is-active.is-disabled{font-weight:700;color:var(--el-text-color-secondary)}.el-pager li.is-disabled,.el-pager li:disabled{color:var(--el-pagination-button-disabled-color);background-color:var(--el-pagination-button-disabled-bg-color);cursor:not-allowed}.el-pager li:focus-visible{outline:1px solid var(--el-pagination-hover-color);outline-offset:-1px}.el-popconfirm__main{display:flex;align-items:center}.el-popconfirm__icon{margin-right:5px}.el-popconfirm__action{text-align:right;margin-top:8px}.el-popover{--el-popover-bg-color:var(--el-bg-color-overlay);--el-popover-font-size:var(--el-font-size-base);--el-popover-border-color:var(--el-border-color-lighter);--el-popover-padding:12px;--el-popover-padding-large:18px 20px;--el-popover-title-font-size:16px;--el-popover-title-text-color:var(--el-text-color-primary);--el-popover-border-radius:4px}.el-popover.el-popper{background:var(--el-popover-bg-color);min-width:150px;border-radius:var(--el-popover-border-radius);border:1px solid var(--el-popover-border-color);padding:var(--el-popover-padding);z-index:var(--el-index-popper);color:var(--el-text-color-regular);line-height:1.4;text-align:justify;font-size:var(--el-popover-font-size);box-shadow:var(--el-box-shadow-light);word-break:break-all;box-sizing:border-box}.el-popover.el-popper--plain{padding:var(--el-popover-padding-large)}.el-popover__title{color:var(--el-popover-title-text-color);font-size:var(--el-popover-title-font-size);line-height:1;margin-bottom:12px}.el-popover__reference:focus:hover,.el-popover__reference:focus:not(.focusing){outline-width:0}.el-popover.el-popper.is-dark{--el-popover-bg-color:var(--el-text-color-primary);--el-popover-border-color:var(--el-text-color-primary);--el-popover-title-text-color:var(--el-bg-color);color:var(--el-bg-color)}.el-popover.el-popper:focus,.el-popover.el-popper:focus:active{outline-width:0}.el-progress{position:relative;line-height:1;display:flex;align-items:center}.el-progress__text{font-size:14px;color:var(--el-text-color-regular);margin-left:5px;min-width:50px;line-height:1}.el-progress__text i{vertical-align:middle;display:block}.el-progress--circle,.el-progress--dashboard{display:inline-block}.el-progress--circle .el-progress__text,.el-progress--dashboard .el-progress__text{position:absolute;top:50%;left:0;width:100%;text-align:center;margin:0;transform:translate(0,-50%)}.el-progress--circle .el-progress__text i,.el-progress--dashboard .el-progress__text i{vertical-align:middle;display:inline-block}.el-progress--without-text .el-progress__text{display:none}.el-progress--without-text .el-progress-bar{padding-right:0;margin-right:0;display:block}.el-progress--text-inside .el-progress-bar{padding-right:0;margin-right:0}.el-progress.is-success .el-progress-bar__inner{background-color:var(--el-color-success)}.el-progress.is-success .el-progress__text{color:var(--el-color-success)}.el-progress.is-warning .el-progress-bar__inner{background-color:var(--el-color-warning)}.el-progress.is-warning .el-progress__text{color:var(--el-color-warning)}.el-progress.is-exception .el-progress-bar__inner{background-color:var(--el-color-danger)}.el-progress.is-exception .el-progress__text{color:var(--el-color-danger)}.el-progress-bar{flex-grow:1;box-sizing:border-box}.el-progress-bar__outer{height:6px;border-radius:100px;background-color:var(--el-border-color-lighter);overflow:hidden;position:relative;vertical-align:middle}.el-progress-bar__inner{position:absolute;left:0;top:0;height:100%;background-color:var(--el-color-primary);text-align:right;border-radius:100px;line-height:1;white-space:nowrap;transition:width .6s ease}.el-progress-bar__inner::after{display:inline-block;content:"";height:100%;vertical-align:middle}.el-progress-bar__inner--indeterminate{transform:translateZ(0);-webkit-animation:indeterminate 3s infinite;animation:indeterminate 3s infinite}.el-progress-bar__innerText{display:inline-block;vertical-align:middle;color:#fff;font-size:12px;margin:0 5px}@-webkit-keyframes progress{0%{background-position:0 0}100%{background-position:32px 0}}@keyframes progress{0%{background-position:0 0}100%{background-position:32px 0}}@-webkit-keyframes indeterminate{0%{left:-100%}100%{left:100%}}@keyframes indeterminate{0%{left:-100%}100%{left:100%}}.el-radio-button{--el-radio-button-checked-bg-color:var(--el-color-primary);--el-radio-button-checked-text-color:var(--el-color-white);--el-radio-button-checked-border-color:var(--el-color-primary);--el-radio-button-disabled-checked-fill:var(--el-border-color-extra-light)}.el-radio-button{position:relative;display:inline-block;outline:0}.el-radio-button__inner{display:inline-block;line-height:1;white-space:nowrap;vertical-align:middle;background:var(--el-button-bg-color,var(--el-fill-color-blank));border:var(--el-border);font-weight:var(--el-button-font-weight,var(--el-font-weight-primary));border-left:0;color:var(--el-button-text-color,var(--el-text-color-regular));-webkit-appearance:none;text-align:center;box-sizing:border-box;outline:0;margin:0;position:relative;cursor:pointer;transition:var(--el-transition-all);-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;padding:8px 15px;font-size:var(--el-font-size-base);border-radius:0}.el-radio-button__inner.is-round{padding:8px 15px}.el-radio-button__inner:hover{color:var(--el-color-primary)}.el-radio-button__inner [class*=el-icon-]{line-height:.9}.el-radio-button__inner [class*=el-icon-]+span{margin-left:5px}.el-radio-button:first-child .el-radio-button__inner{border-left:var(--el-border);border-radius:var(--el-border-radius-base) 0 0 var(--el-border-radius-base);box-shadow:none!important}.el-radio-button__original-radio{opacity:0;outline:0;position:absolute;z-index:-1}.el-radio-button__original-radio:checked+.el-radio-button__inner{color:var(--el-radio-button-checked-text-color,var(--el-color-white));background-color:var(--el-radio-button-checked-bg-color,var(--el-color-primary));border-color:var(--el-radio-button-checked-border-color,var(--el-color-primary));box-shadow:-1px 0 0 0 var(--el-radio-button-checked-border-color,var(--el-color-primary))}.el-radio-button__original-radio:focus-visible+.el-radio-button__inner{border-left:var(--el-border);border-left-color:var(--el-radio-button-checked-border-color,var(--el-color-primary));outline:2px solid var(--el-radio-button-checked-border-color);outline-offset:1px;z-index:2;border-radius:var(--el-border-radius-base);box-shadow:none}.el-radio-button__original-radio:disabled+.el-radio-button__inner{color:var(--el-disabled-text-color);cursor:not-allowed;background-image:none;background-color:var(--el-button-disabled-bg-color,var(--el-fill-color-blank));border-color:var(--el-button-disabled-border-color,var(--el-border-color-light));box-shadow:none}.el-radio-button__original-radio:disabled:checked+.el-radio-button__inner{background-color:var(--el-radio-button-disabled-checked-fill)}.el-radio-button:last-child .el-radio-button__inner{border-radius:0 var(--el-border-radius-base) var(--el-border-radius-base) 0}.el-radio-button:first-child:last-child .el-radio-button__inner{border-radius:var(--el-border-radius-base)}.el-radio-button--large .el-radio-button__inner{padding:12px 19px;font-size:var(--el-font-size-base);border-radius:0}.el-radio-button--large .el-radio-button__inner.is-round{padding:12px 19px}.el-radio-button--small .el-radio-button__inner{padding:5px 11px;font-size:12px;border-radius:0}.el-radio-button--small .el-radio-button__inner.is-round{padding:5px 11px}.el-radio-group{display:inline-flex;align-items:center;flex-wrap:wrap;font-size:0}.el-radio{--el-radio-font-size:var(--el-font-size-base);--el-radio-text-color:var(--el-text-color-regular);--el-radio-font-weight:var(--el-font-weight-primary);--el-radio-input-height:14px;--el-radio-input-width:14px;--el-radio-input-border-radius:var(--el-border-radius-circle);--el-radio-input-bg-color:var(--el-fill-color-blank);--el-radio-input-border:var(--el-border);--el-radio-input-border-color:var(--el-border-color);--el-radio-input-border-color-hover:var(--el-color-primary)}.el-radio{color:var(--el-radio-text-color);font-weight:var(--el-radio-font-weight);position:relative;cursor:pointer;display:inline-flex;align-items:center;white-space:nowrap;outline:0;font-size:var(--el-font-size-base);-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;margin-right:32px;height:32px}.el-radio.el-radio--large{height:40px}.el-radio.el-radio--small{height:24px}.el-radio.is-bordered{padding:0 15px 0 9px;border-radius:var(--el-border-radius-base);border:var(--el-border);box-sizing:border-box}.el-radio.is-bordered.is-checked{border-color:var(--el-color-primary)}.el-radio.is-bordered.is-disabled{cursor:not-allowed;border-color:var(--el-border-color-lighter)}.el-radio.is-bordered.el-radio--large{padding:0 19px 0 11px;border-radius:var(--el-border-radius-base)}.el-radio.is-bordered.el-radio--large .el-radio__label{font-size:var(--el-font-size-base)}.el-radio.is-bordered.el-radio--large .el-radio__inner{height:14px;width:14px}.el-radio.is-bordered.el-radio--small{padding:0 11px 0 7px;border-radius:var(--el-border-radius-base)}.el-radio.is-bordered.el-radio--small .el-radio__label{font-size:12px}.el-radio.is-bordered.el-radio--small .el-radio__inner{height:12px;width:12px}.el-radio:last-child{margin-right:0}.el-radio__input{white-space:nowrap;cursor:pointer;outline:0;display:inline-flex;position:relative;vertical-align:middle}.el-radio__input.is-disabled .el-radio__inner{background-color:var(--el-disabled-bg-color);border-color:var(--el-disabled-border-color);cursor:not-allowed}.el-radio__input.is-disabled .el-radio__inner::after{cursor:not-allowed;background-color:var(--el-disabled-bg-color)}.el-radio__input.is-disabled .el-radio__inner+.el-radio__label{cursor:not-allowed}.el-radio__input.is-disabled.is-checked .el-radio__inner{background-color:var(--el-disabled-bg-color);border-color:var(--el-disabled-border-color)}.el-radio__input.is-disabled.is-checked .el-radio__inner::after{background-color:var(--el-text-color-placeholder)}.el-radio__input.is-disabled+span.el-radio__label{color:var(--el-text-color-placeholder);cursor:not-allowed}.el-radio__input.is-checked .el-radio__inner{border-color:var(--el-color-primary);background:var(--el-color-primary)}.el-radio__input.is-checked .el-radio__inner::after{transform:translate(-50%,-50%) scale(1)}.el-radio__input.is-checked+.el-radio__label{color:var(--el-color-primary)}.el-radio__input.is-focus .el-radio__inner{border-color:var(--el-radio-input-border-color-hover)}.el-radio__inner{border:var(--el-radio-input-border);border-radius:var(--el-radio-input-border-radius);width:var(--el-radio-input-width);height:var(--el-radio-input-height);background-color:var(--el-radio-input-bg-color);position:relative;cursor:pointer;display:inline-block;box-sizing:border-box}.el-radio__inner:hover{border-color:var(--el-radio-input-border-color-hover)}.el-radio__inner::after{width:4px;height:4px;border-radius:var(--el-radio-input-border-radius);background-color:var(--el-color-white);content:"";position:absolute;left:50%;top:50%;transform:translate(-50%,-50%) scale(0);transition:transform .15s ease-in}.el-radio__original{opacity:0;outline:0;position:absolute;z-index:-1;top:0;left:0;right:0;bottom:0;margin:0}.el-radio__original:focus-visible+.el-radio__inner{outline:2px solid var(--el-radio-input-border-color-hover);outline-offset:1px;border-radius:var(--el-radio-input-border-radius)}.el-radio:focus:not(:focus-visible):not(.is-focus):not(:active):not(.is-disabled) .el-radio__inner{box-shadow:0 0 2px 2px var(--el-radio-input-border-color-hover)}.el-radio__label{font-size:var(--el-radio-font-size);padding-left:8px}.el-radio.el-radio--large .el-radio__label{font-size:14px}.el-radio.el-radio--large .el-radio__inner{width:14px;height:14px}.el-radio.el-radio--small .el-radio__label{font-size:12px}.el-radio.el-radio--small .el-radio__inner{width:12px;height:12px}.el-rate{--el-rate-height:20px;--el-rate-font-size:var(--el-font-size-base);--el-rate-icon-size:18px;--el-rate-icon-margin:6px;--el-rate-void-color:var(--el-border-color-darker);--el-rate-fill-color:#f7ba2a;--el-rate-disabled-void-color:var(--el-fill-color);--el-rate-text-color:var(--el-text-color-primary)}.el-rate{display:inline-flex;align-items:center;height:32px}.el-rate:active,.el-rate:focus{outline:0}.el-rate__item{cursor:pointer;display:inline-block;position:relative;font-size:0;vertical-align:middle;color:var(--el-rate-void-color);line-height:normal}.el-rate .el-rate__icon{position:relative;display:inline-block;font-size:var(--el-rate-icon-size);margin-right:var(--el-rate-icon-margin);transition:var(--el-transition-duration)}.el-rate .el-rate__icon.hover{transform:scale(1.15)}.el-rate .el-rate__icon .path2{position:absolute;left:0;top:0}.el-rate .el-rate__icon.is-active{color:var(--el-rate-fill-color)}.el-rate__decimal{position:absolute;top:0;left:0;display:inline-block;overflow:hidden;color:var(--el-rate-fill-color)}.el-rate__text{font-size:var(--el-rate-font-size);vertical-align:middle;color:var(--el-rate-text-color)}.el-rate--large{height:40px}.el-rate--small{height:24px}.el-rate.is-disabled .el-rate__item{cursor:auto;color:var(--el-rate-disabled-void-color)}.el-result{--el-result-padding:40px 30px;--el-result-icon-font-size:64px;--el-result-title-font-size:20px;--el-result-title-margin-top:20px;--el-result-subtitle-margin-top:10px;--el-result-extra-margin-top:30px}.el-result{display:flex;justify-content:center;align-items:center;flex-direction:column;text-align:center;box-sizing:border-box;padding:var(--el-result-padding)}.el-result__icon svg{width:var(--el-result-icon-font-size);height:var(--el-result-icon-font-size)}.el-result__title{margin-top:var(--el-result-title-margin-top)}.el-result__title p{margin:0;font-size:var(--el-result-title-font-size);color:var(--el-text-color-primary);line-height:1.3}.el-result__subtitle{margin-top:var(--el-result-subtitle-margin-top)}.el-result__subtitle p{margin:0;font-size:var(--el-font-size-base);color:var(--el-text-color-regular);line-height:1.3}.el-result__extra{margin-top:var(--el-result-extra-margin-top)}.el-result .icon-primary{--el-result-color:var(--el-color-primary);color:var(--el-result-color)}.el-result .icon-success{--el-result-color:var(--el-color-success);color:var(--el-result-color)}.el-result .icon-warning{--el-result-color:var(--el-color-warning);color:var(--el-result-color)}.el-result .icon-danger{--el-result-color:var(--el-color-danger);color:var(--el-result-color)}.el-result .icon-error{--el-result-color:var(--el-color-error);color:var(--el-result-color)}.el-result .icon-info{--el-result-color:var(--el-color-info);color:var(--el-result-color)}.el-row{display:flex;flex-wrap:wrap;position:relative;box-sizing:border-box}.el-row.is-justify-center{justify-content:center}.el-row.is-justify-end{justify-content:flex-end}.el-row.is-justify-space-between{justify-content:space-between}.el-row.is-justify-space-around{justify-content:space-around}.el-row.is-justify-space-evenly{justify-content:space-evenly}.el-row.is-align-middle{align-items:center}.el-row.is-align-bottom{align-items:flex-end}.el-scrollbar{--el-scrollbar-opacity:0.3;--el-scrollbar-bg-color:var(--el-text-color-secondary);--el-scrollbar-hover-opacity:0.5;--el-scrollbar-hover-bg-color:var(--el-text-color-secondary)}.el-scrollbar{overflow:hidden;position:relative;height:100%}.el-scrollbar__wrap{overflow:auto;height:100%}.el-scrollbar__wrap--hidden-default{scrollbar-width:none}.el-scrollbar__wrap--hidden-default::-webkit-scrollbar{display:none}.el-scrollbar__thumb{position:relative;display:block;width:0;height:0;cursor:pointer;border-radius:inherit;background-color:var(--el-scrollbar-bg-color,var(--el-text-color-secondary));transition:var(--el-transition-duration) background-color;opacity:var(--el-scrollbar-opacity,.3)}.el-scrollbar__thumb:hover{background-color:var(--el-scrollbar-hover-bg-color,var(--el-text-color-secondary));opacity:var(--el-scrollbar-hover-opacity,.5)}.el-scrollbar__bar{position:absolute;right:2px;bottom:2px;z-index:1;border-radius:4px}.el-scrollbar__bar.is-vertical{width:6px;top:2px}.el-scrollbar__bar.is-vertical>div{width:100%}.el-scrollbar__bar.is-horizontal{height:6px;left:2px}.el-scrollbar__bar.is-horizontal>div{height:100%}.el-scrollbar-fade-enter-active{transition:opacity 340ms ease-out}.el-scrollbar-fade-leave-active{transition:opacity 120ms ease-out}.el-scrollbar-fade-enter-from,.el-scrollbar-fade-leave-active{opacity:0}.el-select-dropdown{z-index:calc(var(--el-index-top) + 1);border-radius:var(--el-border-radius-base);box-sizing:border-box}.el-select-dropdown .el-scrollbar.is-empty .el-select-dropdown__list{padding:0}.el-select-dropdown__option-item.is-selected:not(.is-multiple).is-disabled{color:var(--el-text-color-disabled)}.el-select-dropdown__option-item.is-selected:not(.is-multiple).is-disabled::after{background-color:var(--el-text-color-disabled)}.el-select-dropdown__option-item:hover:not(.hover){background-color:transparent}.el-select-dropdown.is-multiple .el-select-dropdown__option-item.is-disabled.is-selected{color:var(--el-text-color-disabled)}.el-select-dropdown__empty{padding:10px 0;margin:0;text-align:center;color:var(--el-text-color-secondary);font-size:var(--el-select-font-size)}.el-select-dropdown__wrap{max-height:274px}.el-select-dropdown__list{list-style:none;margin:6px 0!important;padding:0!important;box-sizing:border-box}.el-select-dropdown__option-item{font-size:var(--el-select-font-size);padding:0 32px 0 20px;position:relative;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;color:var(--el-text-color-regular);height:34px;line-height:34px;box-sizing:border-box;cursor:pointer}.el-select-dropdown__option-item.is-disabled{color:var(--el-text-color-placeholder);cursor:not-allowed}.el-select-dropdown__option-item.is-disabled:hover{background-color:var(--el-bg-color)}.el-select-dropdown__option-item.is-selected{background-color:var(--el-fill-color-light);font-weight:700}.el-select-dropdown__option-item.is-selected:not(.is-multiple){color:var(--el-color-primary)}.el-select-dropdown__option-item.hover{background-color:var(--el-fill-color-light)!important}.el-select-dropdown__option-item:hover{background-color:var(--el-fill-color-light)}.el-select-dropdown.is-multiple .el-select-dropdown__option-item.is-selected{color:var(--el-color-primary);background-color:var(--el-bg-color-overlay)}.el-select-dropdown.is-multiple .el-select-dropdown__option-item.is-selected .el-icon{position:absolute;right:20px;top:0;height:inherit;font-size:12px}.el-select-dropdown.is-multiple .el-select-dropdown__option-item.is-selected .el-icon svg{height:inherit;vertical-align:middle}.el-select-group{margin:0;padding:0}.el-select-group__wrap{position:relative;list-style:none;margin:0;padding:0}.el-select-group__wrap:not(:last-of-type){padding-bottom:24px}.el-select-group__wrap:not(:last-of-type)::after{content:"";position:absolute;display:block;left:20px;right:20px;bottom:12px;height:1px;background:var(--el-border-color-light)}.el-select-group__split-dash{position:absolute;left:20px;right:20px;height:1px;background:var(--el-border-color-light)}.el-select-group__title{padding-left:20px;font-size:12px;color:var(--el-color-info);line-height:30px}.el-select-group .el-select-dropdown__item{padding-left:20px}.el-select-v2{--el-select-border-color-hover:var(--el-border-color-hover);--el-select-disabled-border:var(--el-disabled-border-color);--el-select-font-size:var(--el-font-size-base);--el-select-close-hover-color:var(--el-text-color-secondary);--el-select-input-color:var(--el-text-color-placeholder);--el-select-multiple-input-color:var(--el-text-color-regular);--el-select-input-focus-border-color:var(--el-color-primary);--el-select-input-font-size:14px}.el-select-v2{display:inline-block;position:relative;vertical-align:middle;font-size:14px}.el-select-v2__wrapper{display:flex;align-items:center;flex-wrap:wrap;position:relative;box-sizing:border-box;cursor:pointer;padding:1px 30px 1px 0;border:1px solid var(--el-border-color);border-radius:var(--el-border-radius-base);background-color:var(--el-fill-color-blank);transition:var(--el-transition-duration)}.el-select-v2__wrapper:hover{border-color:var(--el-text-color-placeholder)}.el-select-v2__wrapper.is-filterable{cursor:text}.el-select-v2__wrapper.is-focused{border-color:var(--el-color-primary)}.el-select-v2__wrapper.is-hovering:not(.is-focused){border-color:var(--el-border-color-hover)}.el-select-v2__wrapper.is-disabled{cursor:not-allowed;background-color:var(--el-fill-color-light);color:var(--el-text-color-placeholder);border-color:var(--el-select-disabled-border)}.el-select-v2__wrapper.is-disabled:hover{border-color:var(--el-select-disabled-border)}.el-select-v2__wrapper.is-disabled.is-focus{border-color:var(--el-input-focus-border-color)}.el-select-v2__wrapper.is-disabled .is-transparent{opacity:1;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.el-select-v2__wrapper.is-disabled .el-select-v2__caret{cursor:not-allowed}.el-select-v2__wrapper.is-disabled .el-select-v2__combobox-input{cursor:not-allowed}.el-select-v2__wrapper .el-select-v2__input-wrapper{box-sizing:border-box;position:relative;-webkit-margin-start:12px;margin-inline-start:12px;max-width:100%;overflow:hidden}.el-select-v2__wrapper,.el-select-v2__wrapper .el-select-v2__input-wrapper{line-height:32px}.el-select-v2__wrapper .el-select-v2__input-wrapper input{--el-input-inner-height:calc(var(--el-component-size, 32px) - 8px);height:var(--el-input-inner-height);line-height:var(--el-input-inner-height);min-width:4px;width:100%;background-color:transparent;-webkit-appearance:none;-moz-appearance:none;appearance:none;background:0 0;border:none;margin:2px 0;outline:0;padding:0}.el-select-v2 .el-select-v2__tags-text{display:inline-block;line-height:normal;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.el-select-v2__empty{padding:10px 0;margin:0;text-align:center;color:var(--el-text-color-secondary);font-size:14px}.el-select-v2__popper.el-popper{background:var(--el-bg-color-overlay);border:1px solid var(--el-border-color-light);box-shadow:var(--el-box-shadow-light)}.el-select-v2__popper.el-popper .el-popper__arrow::before{border:1px solid var(--el-border-color-light)}.el-select-v2__popper.el-popper[data-popper-placement^=top] .el-popper__arrow::before{border-top-color:transparent;border-left-color:transparent}.el-select-v2__popper.el-popper[data-popper-placement^=bottom] .el-popper__arrow::before{border-bottom-color:transparent;border-right-color:transparent}.el-select-v2__popper.el-popper[data-popper-placement^=left] .el-popper__arrow::before{border-left-color:transparent;border-bottom-color:transparent}.el-select-v2__popper.el-popper[data-popper-placement^=right] .el-popper__arrow::before{border-right-color:transparent;border-top-color:transparent}.el-select-v2--large .el-select-v2__wrapper .el-select-v2__combobox-input{height:32px}.el-select-v2--large .el-select-v2__caret{height:40px}.el-select-v2--large .el-select-v2__suffix{height:40px}.el-select-v2--large .el-select-v2__placeholder{font-size:14px;line-height:40px}.el-select-v2--small .el-select-v2__wrapper .el-select-v2__combobox-input{height:16px}.el-select-v2--small .el-select-v2__caret{height:24px}.el-select-v2--small .el-select-v2__suffix{height:24px}.el-select-v2--small .el-select-v2__placeholder{font-size:12px;line-height:24px}.el-select-v2 .el-select-v2__selection>span{display:inline-block}.el-select-v2:hover .el-select-v2__combobox-input{border-color:var(--el-select-border-color-hover)}.el-select-v2 .el-select__selection-text{text-overflow:ellipsis;display:inline-block;overflow-x:hidden;vertical-align:bottom}.el-select-v2 .el-select-v2__combobox-input{padding-right:35px;display:block;color:var(--el-text-color-regular)}.el-select-v2 .el-select-v2__combobox-input:focus{border-color:var(--el-select-input-focus-border-color)}.el-select-v2__input{border:none;outline:0;padding:0;margin-left:15px;color:var(--el-select-multiple-input-color);font-size:var(--el-select-font-size);-webkit-appearance:none;-moz-appearance:none;appearance:none;height:28px}.el-select-v2__input.is-small{height:14px}.el-select-v2__close{cursor:pointer;position:absolute;top:8px;z-index:var(--el-index-top);right:25px;color:var(--el-select-input-color);line-height:18px;font-size:var(--el-select-input-font-size)}.el-select-v2__close:hover{color:var(--el-select-close-hover-color)}.el-select-v2__suffix{display:inline-flex;position:absolute;right:12px;height:32px;top:50%;transform:translateY(-50%);color:var(--el-input-icon-color,var(--el-text-color-placeholder))}.el-select-v2__suffix .el-input__icon{height:inherit}.el-select-v2__caret{color:var(--el-select-input-color);font-size:var(--el-select-input-font-size);transition:var(--el-transition-duration);transform:rotateZ(180deg);cursor:pointer}.el-select-v2__caret.is-reverse{transform:rotateZ(0)}.el-select-v2__caret.is-show-close{font-size:var(--el-select-font-size);text-align:center;transform:rotateZ(180deg);border-radius:var(--el-border-radius-circle);color:var(--el-select-input-color);transition:var(--el-transition-color)}.el-select-v2__caret.is-show-close:hover{color:var(--el-select-close-hover-color)}.el-select-v2__caret.el-icon{height:inherit}.el-select-v2__caret.el-icon svg{vertical-align:middle}.el-select-v2__selection{white-space:normal;z-index:var(--el-index-normal);display:flex;align-items:center;flex-wrap:wrap}.el-select-v2__input-calculator{left:0;position:absolute;top:0;visibility:hidden;white-space:pre;z-index:999}.el-select-v2__selected-item{line-height:inherit;height:inherit;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;display:flex;flex-wrap:wrap}.el-select-v2__placeholder{position:absolute;top:50%;transform:translateY(-50%);-webkit-margin-start:12px;margin-inline-start:12px;width:calc(100% - 52px);overflow:hidden;text-overflow:ellipsis;white-space:nowrap;color:var(--el-input-text-color,var(--el-text-color-regular))}.el-select-v2__placeholder.is-transparent{color:var(--el-text-color-placeholder)}.el-select-v2 .el-select-v2__selection .el-tag{box-sizing:border-box;border-color:transparent;margin:2px 0 2px 6px;background-color:var(--el-fill-color)}.el-select-v2 .el-select-v2__selection .el-tag .el-icon-close{background-color:var(--el-text-color-placeholder);right:-7px;color:var(--el-color-white)}.el-select-v2 .el-select-v2__selection .el-tag .el-icon-close:hover{background-color:var(--el-text-color-secondary)}.el-select-v2 .el-select-v2__selection .el-tag .el-icon-close::before{display:block;transform:translate(0,.5px)}.el-select-v2.el-select-v2--small .el-select-v2__selection .el-tag{margin:1px 0 1px 6px;height:18px}.el-select-dropdown{z-index:calc(var(--el-index-top) + 1);border-radius:var(--el-border-radius-base);box-sizing:border-box}.el-select-dropdown.is-multiple .el-select-dropdown__item.selected{color:var(--el-color-primary);background-color:var(--el-bg-color-overlay)}.el-select-dropdown.is-multiple .el-select-dropdown__item.selected.hover{background-color:var(--el-fill-color-light)}.el-select-dropdown.is-multiple .el-select-dropdown__item.selected::after{content:"";position:absolute;top:50%;right:20px;border-top:none;border-right:none;background-repeat:no-repeat;background-position:center;background-color:var(--el-color-primary);-webkit-mask:url("data:image/svg+xml;utf8,%3Csvg class='icon' width='200' height='200' viewBox='0 0 1024 1024' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath fill='currentColor' d='M406.656 706.944L195.84 496.256a32 32 0 10-45.248 45.248l256 256 512-512a32 32 0 00-45.248-45.248L406.592 706.944z'%3E%3C/path%3E%3C/svg%3E") no-repeat;mask:url("data:image/svg+xml;utf8,%3Csvg class='icon' width='200' height='200' viewBox='0 0 1024 1024' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath fill='currentColor' d='M406.656 706.944L195.84 496.256a32 32 0 10-45.248 45.248l256 256 512-512a32 32 0 00-45.248-45.248L406.592 706.944z'%3E%3C/path%3E%3C/svg%3E") no-repeat;mask-size:100% 100%;-webkit-mask:url("data:image/svg+xml;utf8,%3Csvg class='icon' width='200' height='200' viewBox='0 0 1024 1024' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath fill='currentColor' d='M406.656 706.944L195.84 496.256a32 32 0 10-45.248 45.248l256 256 512-512a32 32 0 00-45.248-45.248L406.592 706.944z'%3E%3C/path%3E%3C/svg%3E") no-repeat;-webkit-mask-size:100% 100%;transform:translateY(-50%);width:12px;height:12px}.el-select-dropdown.is-multiple .el-select-dropdown__item.selected.is-disabled::after{background-color:var(--el-text-color-disabled)}.el-select-dropdown .el-select-dropdown__option-item.is-selected::after{content:"";position:absolute;top:50%;right:20px;border-top:none;border-right:none;background-repeat:no-repeat;background-position:center;background-color:var(--el-color-primary);-webkit-mask:url("data:image/svg+xml;utf8,%3Csvg class='icon' width='200' height='200' viewBox='0 0 1024 1024' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath fill='currentColor' d='M406.656 706.944L195.84 496.256a32 32 0 10-45.248 45.248l256 256 512-512a32 32 0 00-45.248-45.248L406.592 706.944z'%3E%3C/path%3E%3C/svg%3E") no-repeat;mask:url("data:image/svg+xml;utf8,%3Csvg class='icon' width='200' height='200' viewBox='0 0 1024 1024' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath fill='currentColor' d='M406.656 706.944L195.84 496.256a32 32 0 10-45.248 45.248l256 256 512-512a32 32 0 00-45.248-45.248L406.592 706.944z'%3E%3C/path%3E%3C/svg%3E") no-repeat;mask-size:100% 100%;-webkit-mask:url("data:image/svg+xml;utf8,%3Csvg class='icon' width='200' height='200' viewBox='0 0 1024 1024' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath fill='currentColor' d='M406.656 706.944L195.84 496.256a32 32 0 10-45.248 45.248l256 256 512-512a32 32 0 00-45.248-45.248L406.592 706.944z'%3E%3C/path%3E%3C/svg%3E") no-repeat;-webkit-mask-size:100% 100%;transform:translateY(-50%);width:12px;height:12px}.el-select-dropdown .el-scrollbar.is-empty .el-select-dropdown__list{padding:0}.el-select-dropdown .el-select-dropdown__item.is-disabled:hover{background-color:unset}.el-select-dropdown .el-select-dropdown__item.is-disabled.selected{color:var(--el-text-color-disabled)}.el-select-dropdown__empty{padding:10px 0;margin:0;text-align:center;color:var(--el-text-color-secondary);font-size:var(--el-select-font-size)}.el-select-dropdown__wrap{max-height:274px}.el-select-dropdown__list{list-style:none;padding:6px 0;margin:0;box-sizing:border-box}.el-select{--el-select-border-color-hover:var(--el-border-color-hover);--el-select-disabled-border:var(--el-disabled-border-color);--el-select-font-size:var(--el-font-size-base);--el-select-close-hover-color:var(--el-text-color-secondary);--el-select-input-color:var(--el-text-color-placeholder);--el-select-multiple-input-color:var(--el-text-color-regular);--el-select-input-focus-border-color:var(--el-color-primary);--el-select-input-font-size:14px}.el-select{display:inline-block;position:relative;vertical-align:middle;line-height:32px}.el-select__popper.el-popper{background:var(--el-bg-color-overlay);border:1px solid var(--el-border-color-light);box-shadow:var(--el-box-shadow-light)}.el-select__popper.el-popper .el-popper__arrow::before{border:1px solid var(--el-border-color-light)}.el-select__popper.el-popper[data-popper-placement^=top] .el-popper__arrow::before{border-top-color:transparent;border-left-color:transparent}.el-select__popper.el-popper[data-popper-placement^=bottom] .el-popper__arrow::before{border-bottom-color:transparent;border-right-color:transparent}.el-select__popper.el-popper[data-popper-placement^=left] .el-popper__arrow::before{border-left-color:transparent;border-bottom-color:transparent}.el-select__popper.el-popper[data-popper-placement^=right] .el-popper__arrow::before{border-right-color:transparent;border-top-color:transparent}.el-select .el-select-tags-wrapper.has-prefix{margin-left:6px}.el-select--large{line-height:40px}.el-select--large .el-select-tags-wrapper.has-prefix{margin-left:8px}.el-select--small{line-height:24px}.el-select--small .el-select-tags-wrapper.has-prefix{margin-left:4px}.el-select .el-select__tags>span{display:inline-block}.el-select:hover:not(.el-select--disabled) .el-input__wrapper{box-shadow:0 0 0 1px var(--el-select-border-color-hover) inset}.el-select .el-select__tags-text{display:inline-block;line-height:normal;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.el-select .el-input__wrapper{cursor:pointer}.el-select .el-input__wrapper.is-focus{box-shadow:0 0 0 1px var(--el-select-input-focus-border-color) inset!important}.el-select .el-input__inner{cursor:pointer}.el-select .el-input{display:flex}.el-select .el-input .el-select__caret{color:var(--el-select-input-color);font-size:var(--el-select-input-font-size);transition:transform var(--el-transition-duration);transform:rotateZ(0);cursor:pointer}.el-select .el-input .el-select__caret.is-reverse{transform:rotateZ(-180deg)}.el-select .el-input .el-select__caret.is-show-close{font-size:var(--el-select-font-size);text-align:center;transform:rotateZ(0);border-radius:var(--el-border-radius-circle);color:var(--el-select-input-color);transition:var(--el-transition-color)}.el-select .el-input .el-select__caret.is-show-close:hover{color:var(--el-select-close-hover-color)}.el-select .el-input .el-select__caret.el-icon{position:relative;height:inherit;z-index:2}.el-select .el-input.is-disabled .el-input__wrapper{cursor:not-allowed}.el-select .el-input.is-disabled .el-input__wrapper:hover{box-shadow:0 0 0 1px var(--el-select-disabled-border) inset}.el-select .el-input.is-disabled .el-input__inner{cursor:not-allowed}.el-select .el-input.is-disabled .el-select__caret{cursor:not-allowed}.el-select .el-input.is-focus .el-input__wrapper{box-shadow:0 0 0 1px var(--el-select-input-focus-border-color) inset!important}.el-select__input{border:none;outline:0;padding:0;margin-left:15px;color:var(--el-select-multiple-input-color);font-size:var(--el-select-font-size);-webkit-appearance:none;-moz-appearance:none;appearance:none;height:28px;background-color:transparent}.el-select__input.is-small{height:14px}.el-select__close{cursor:pointer;position:absolute;top:8px;z-index:var(--el-index-top);right:25px;color:var(--el-select-input-color);line-height:18px;font-size:var(--el-select-input-font-size)}.el-select__close:hover{color:var(--el-select-close-hover-color)}.el-select__tags{position:absolute;line-height:normal;top:50%;transform:translateY(-50%);white-space:normal;z-index:var(--el-index-normal);display:flex;align-items:center;flex-wrap:wrap;cursor:pointer}.el-select__tags .el-tag{box-sizing:border-box;border-color:transparent;margin:2px 6px 2px 0}.el-select__tags .el-tag:last-child{margin-right:0}.el-select__tags .el-tag .el-icon-close{background-color:var(--el-text-color-placeholder);right:-7px;top:0;color:#fff}.el-select__tags .el-tag .el-icon-close:hover{background-color:var(--el-text-color-secondary)}.el-select__tags .el-tag .el-icon-close::before{display:block;transform:translate(0,.5px)}.el-select__tags .el-tag--info{background-color:var(--el-fill-color)}.el-select__collapse-tags{white-space:normal;z-index:var(--el-index-normal);display:flex;align-items:center;flex-wrap:wrap;cursor:pointer}.el-select__collapse-tags .el-tag{box-sizing:border-box;border-color:transparent;margin:2px 6px 2px 0}.el-select__collapse-tags .el-tag:last-child{margin-right:0}.el-select__collapse-tags .el-tag .el-icon-close{background-color:var(--el-text-color-placeholder);right:-7px;top:0;color:#fff}.el-select__collapse-tags .el-tag .el-icon-close:hover{background-color:var(--el-text-color-secondary)}.el-select__collapse-tags .el-tag .el-icon-close::before{display:block;transform:translate(0,.5px)}.el-select__collapse-tags .el-tag--info{background-color:var(--el-fill-color)}.el-select__collapse-tag{line-height:inherit;height:inherit;display:flex}.el-skeleton{--el-skeleton-circle-size:var(--el-avatar-size)}.el-skeleton__item{background:var(--el-skeleton-color);display:inline-block;height:16px;border-radius:var(--el-border-radius-base);width:100%}.el-skeleton__circle{border-radius:50%;width:var(--el-skeleton-circle-size);height:var(--el-skeleton-circle-size);line-height:var(--el-skeleton-circle-size)}.el-skeleton__button{height:40px;width:64px;border-radius:4px}.el-skeleton__p{width:100%}.el-skeleton__p.is-last{width:61%}.el-skeleton__p.is-first{width:33%}.el-skeleton__text{width:100%;height:var(--el-font-size-small)}.el-skeleton__caption{height:var(--el-font-size-extra-small)}.el-skeleton__h1{height:var(--el-font-size-extra-large)}.el-skeleton__h3{height:var(--el-font-size-large)}.el-skeleton__h5{height:var(--el-font-size-medium)}.el-skeleton__image{width:unset;display:flex;align-items:center;justify-content:center;border-radius:0}.el-skeleton__image svg{color:var(--el-svg-monochrome-grey);fill:currentColor;width:22%;height:22%}.el-skeleton{--el-skeleton-color:var(--el-fill-color);--el-skeleton-to-color:var(--el-fill-color-darker)}@-webkit-keyframes el-skeleton-loading{0%{background-position:100% 50%}100%{background-position:0 50%}}@keyframes el-skeleton-loading{0%{background-position:100% 50%}100%{background-position:0 50%}}.el-skeleton{width:100%}.el-skeleton__first-line{height:16px;margin-top:16px;background:var(--el-skeleton-color)}.el-skeleton__paragraph{height:16px;margin-top:16px;background:var(--el-skeleton-color)}.el-skeleton.is-animated .el-skeleton__item{background:linear-gradient(90deg,var(--el-skeleton-color) 25%,var(--el-skeleton-to-color) 37%,var(--el-skeleton-color) 63%);background-size:400% 100%;-webkit-animation:el-skeleton-loading 1.4s ease infinite;animation:el-skeleton-loading 1.4s ease infinite}.el-slider{--el-slider-main-bg-color:var(--el-color-primary);--el-slider-runway-bg-color:var(--el-border-color-light);--el-slider-stop-bg-color:var(--el-color-white);--el-slider-disabled-color:var(--el-text-color-placeholder);--el-slider-border-radius:3px;--el-slider-height:6px;--el-slider-button-size:20px;--el-slider-button-wrapper-size:36px;--el-slider-button-wrapper-offset:-15px}.el-slider{width:100%;height:32px;display:flex;align-items:center}.el-slider__runway{flex:1;height:var(--el-slider-height);background-color:var(--el-slider-runway-bg-color);border-radius:var(--el-slider-border-radius);position:relative;cursor:pointer}.el-slider__runway.show-input{margin-right:30px;width:auto}.el-slider__runway.is-disabled{cursor:default}.el-slider__runway.is-disabled .el-slider__bar{background-color:var(--el-slider-disabled-color)}.el-slider__runway.is-disabled .el-slider__button{border-color:var(--el-slider-disabled-color)}.el-slider__runway.is-disabled .el-slider__button-wrapper.hover,.el-slider__runway.is-disabled .el-slider__button-wrapper:hover{cursor:not-allowed}.el-slider__runway.is-disabled .el-slider__button-wrapper.dragging{cursor:not-allowed}.el-slider__runway.is-disabled .el-slider__button.dragging,.el-slider__runway.is-disabled .el-slider__button.hover,.el-slider__runway.is-disabled .el-slider__button:hover{transform:scale(1)}.el-slider__runway.is-disabled .el-slider__button.hover,.el-slider__runway.is-disabled .el-slider__button:hover{cursor:not-allowed}.el-slider__runway.is-disabled .el-slider__button.dragging{cursor:not-allowed}.el-slider__input{flex-shrink:0;width:130px}.el-slider__bar{height:var(--el-slider-height);background-color:var(--el-slider-main-bg-color);border-top-left-radius:var(--el-slider-border-radius);border-bottom-left-radius:var(--el-slider-border-radius);position:absolute}.el-slider__button-wrapper{height:var(--el-slider-button-wrapper-size);width:var(--el-slider-button-wrapper-size);position:absolute;z-index:1;top:var(--el-slider-button-wrapper-offset);transform:translateX(-50%);background-color:transparent;text-align:center;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;line-height:normal;outline:0}.el-slider__button-wrapper::after{display:inline-block;content:"";height:100%;vertical-align:middle}.el-slider__button-wrapper.hover,.el-slider__button-wrapper:hover{cursor:-webkit-grab;cursor:grab}.el-slider__button-wrapper.dragging{cursor:-webkit-grabbing;cursor:grabbing}.el-slider__button{display:inline-block;width:var(--el-slider-button-size);height:var(--el-slider-button-size);vertical-align:middle;border:solid 2px var(--el-slider-main-bg-color);background-color:var(--el-color-white);border-radius:50%;box-sizing:border-box;transition:var(--el-transition-duration-fast);-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.el-slider__button.dragging,.el-slider__button.hover,.el-slider__button:hover{transform:scale(1.2)}.el-slider__button.hover,.el-slider__button:hover{cursor:-webkit-grab;cursor:grab}.el-slider__button.dragging{cursor:-webkit-grabbing;cursor:grabbing}.el-slider__stop{position:absolute;height:var(--el-slider-height);width:var(--el-slider-height);border-radius:var(--el-border-radius-circle);background-color:var(--el-slider-stop-bg-color);transform:translateX(-50%)}.el-slider__marks{top:0;left:12px;width:18px;height:100%}.el-slider__marks-text{position:absolute;transform:translateX(-50%);font-size:14px;color:var(--el-color-info);margin-top:15px;white-space:pre}.el-slider.is-vertical{position:relative;display:inline-flex;width:auto;height:100%;flex:0}.el-slider.is-vertical .el-slider__runway{width:var(--el-slider-height);height:100%;margin:0 16px}.el-slider.is-vertical .el-slider__bar{width:var(--el-slider-height);height:auto;border-radius:0 0 3px 3px}.el-slider.is-vertical .el-slider__button-wrapper{top:auto;left:var(--el-slider-button-wrapper-offset);transform:translateY(50%)}.el-slider.is-vertical .el-slider__stop{transform:translateY(50%)}.el-slider.is-vertical .el-slider__marks-text{margin-top:0;left:15px;transform:translateY(50%)}.el-slider--large{height:40px}.el-slider--small{height:24px}.el-space{display:inline-flex;vertical-align:top}.el-space__item{display:flex;flex-wrap:wrap}.el-space__item>*{flex:1}.el-space--vertical{flex-direction:column}.el-time-spinner{width:100%;white-space:nowrap}.el-spinner{display:inline-block;vertical-align:middle}.el-spinner-inner{-webkit-animation:rotate 2s linear infinite;animation:rotate 2s linear infinite;width:50px;height:50px}.el-spinner-inner .path{stroke:var(--el-border-color-lighter);stroke-linecap:round;-webkit-animation:dash 1.5s ease-in-out infinite;animation:dash 1.5s ease-in-out infinite}@-webkit-keyframes rotate{100%{transform:rotate(360deg)}}@keyframes rotate{100%{transform:rotate(360deg)}}@-webkit-keyframes dash{0%{stroke-dasharray:1,150;stroke-dashoffset:0}50%{stroke-dasharray:90,150;stroke-dashoffset:-35}100%{stroke-dasharray:90,150;stroke-dashoffset:-124}}@keyframes dash{0%{stroke-dasharray:1,150;stroke-dashoffset:0}50%{stroke-dasharray:90,150;stroke-dashoffset:-35}100%{stroke-dasharray:90,150;stroke-dashoffset:-124}}.el-step{position:relative;flex-shrink:1}.el-step:last-of-type .el-step__line{display:none}.el-step:last-of-type.is-flex{flex-basis:auto!important;flex-shrink:0;flex-grow:0}.el-step:last-of-type .el-step__description,.el-step:last-of-type .el-step__main{padding-right:0}.el-step__head{position:relative;width:100%}.el-step__head.is-process{color:var(--el-text-color-primary);border-color:var(--el-text-color-primary)}.el-step__head.is-wait{color:var(--el-text-color-placeholder);border-color:var(--el-text-color-placeholder)}.el-step__head.is-success{color:var(--el-color-success);border-color:var(--el-color-success)}.el-step__head.is-error{color:var(--el-color-danger);border-color:var(--el-color-danger)}.el-step__head.is-finish{color:var(--el-color-primary);border-color:var(--el-color-primary)}.el-step__icon{position:relative;z-index:1;display:inline-flex;justify-content:center;align-items:center;width:24px;height:24px;font-size:14px;box-sizing:border-box;background:var(--el-bg-color);transition:.15s ease-out}.el-step__icon.is-text{border-radius:50%;border:2px solid;border-color:inherit}.el-step__icon.is-icon{width:40px}.el-step__icon-inner{display:inline-block;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;text-align:center;font-weight:700;line-height:1;color:inherit}.el-step__icon-inner[class*=el-icon]:not(.is-status){font-size:25px;font-weight:400}.el-step__icon-inner.is-status{transform:translateY(1px)}.el-step__line{position:absolute;border-color:inherit;background-color:var(--el-text-color-placeholder)}.el-step__line-inner{display:block;border-width:1px;border-style:solid;border-color:inherit;transition:.15s ease-out;box-sizing:border-box;width:0;height:0}.el-step__main{white-space:normal;text-align:left}.el-step__title{font-size:16px;line-height:38px}.el-step__title.is-process{font-weight:700;color:var(--el-text-color-primary)}.el-step__title.is-wait{color:var(--el-text-color-placeholder)}.el-step__title.is-success{color:var(--el-color-success)}.el-step__title.is-error{color:var(--el-color-danger)}.el-step__title.is-finish{color:var(--el-color-primary)}.el-step__description{padding-right:10%;margin-top:-5px;font-size:12px;line-height:20px;font-weight:400}.el-step__description.is-process{color:var(--el-text-color-primary)}.el-step__description.is-wait{color:var(--el-text-color-placeholder)}.el-step__description.is-success{color:var(--el-color-success)}.el-step__description.is-error{color:var(--el-color-danger)}.el-step__description.is-finish{color:var(--el-color-primary)}.el-step.is-horizontal{display:inline-block}.el-step.is-horizontal .el-step__line{height:2px;top:11px;left:0;right:0}.el-step.is-vertical{display:flex}.el-step.is-vertical .el-step__head{flex-grow:0;width:24px}.el-step.is-vertical .el-step__main{padding-left:10px;flex-grow:1}.el-step.is-vertical .el-step__title{line-height:24px;padding-bottom:8px}.el-step.is-vertical .el-step__line{width:2px;top:0;bottom:0;left:11px}.el-step.is-vertical .el-step__icon.is-icon{width:24px}.el-step.is-center .el-step__head{text-align:center}.el-step.is-center .el-step__main{text-align:center}.el-step.is-center .el-step__description{padding-left:20%;padding-right:20%}.el-step.is-center .el-step__line{left:50%;right:-50%}.el-step.is-simple{display:flex;align-items:center}.el-step.is-simple .el-step__head{width:auto;font-size:0;padding-right:10px}.el-step.is-simple .el-step__icon{background:0 0;width:16px;height:16px;font-size:12px}.el-step.is-simple .el-step__icon-inner[class*=el-icon]:not(.is-status){font-size:18px}.el-step.is-simple .el-step__icon-inner.is-status{transform:scale(.8) translateY(1px)}.el-step.is-simple .el-step__main{position:relative;display:flex;align-items:stretch;flex-grow:1}.el-step.is-simple .el-step__title{font-size:16px;line-height:20px}.el-step.is-simple:not(:last-of-type) .el-step__title{max-width:50%;word-break:break-all}.el-step.is-simple .el-step__arrow{flex-grow:1;display:flex;align-items:center;justify-content:center}.el-step.is-simple .el-step__arrow::after,.el-step.is-simple .el-step__arrow::before{content:"";display:inline-block;position:absolute;height:15px;width:1px;background:var(--el-text-color-placeholder)}.el-step.is-simple .el-step__arrow::before{transform:rotate(-45deg) translateY(-4px);transform-origin:0 0}.el-step.is-simple .el-step__arrow::after{transform:rotate(45deg) translateY(4px);transform-origin:100% 100%}.el-step.is-simple:last-of-type .el-step__arrow{display:none}.el-steps{display:flex}.el-steps--simple{padding:13px 8%;border-radius:4px;background:var(--el-fill-color-light)}.el-steps--horizontal{white-space:nowrap}.el-steps--vertical{height:100%;flex-flow:column}.el-switch{--el-switch-on-color:var(--el-color-primary);--el-switch-off-color:var(--el-border-color)}.el-switch{display:inline-flex;align-items:center;position:relative;font-size:14px;line-height:20px;height:32px;vertical-align:middle}.el-switch.is-disabled .el-switch__core,.el-switch.is-disabled .el-switch__label{cursor:not-allowed}.el-switch__label{transition:var(--el-transition-duration-fast);height:20px;display:inline-block;font-size:14px;font-weight:500;cursor:pointer;vertical-align:middle;color:var(--el-text-color-primary)}.el-switch__label.is-active{color:var(--el-color-primary)}.el-switch__label--left{margin-right:10px}.el-switch__label--right{margin-left:10px}.el-switch__label *{line-height:1;font-size:14px;display:inline-block}.el-switch__label .el-icon{height:inherit}.el-switch__label .el-icon svg{vertical-align:middle}.el-switch__input{position:absolute;width:0;height:0;opacity:0;margin:0}.el-switch__input:focus-visible~.el-switch__core{outline:2px solid var(--el-switch-on-color);outline-offset:1px}.el-switch__core{display:inline-flex;position:relative;align-items:center;min-width:40px;height:20px;border:1px solid var(--el-switch-border-color,var(--el-switch-off-color));outline:0;border-radius:10px;box-sizing:border-box;background:var(--el-switch-off-color);cursor:pointer;transition:border-color var(--el-transition-duration),background-color var(--el-transition-duration)}.el-switch__core .el-switch__inner{width:100%;transition:all var(--el-transition-duration);height:16px;display:flex;justify-content:center;align-items:center;overflow:hidden;padding:0 4px 0 calc(16px + 2px)}.el-switch__core .el-switch__inner .is-icon,.el-switch__core .el-switch__inner .is-text{font-size:12px;color:var(--el-color-white);-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.el-switch__core .el-switch__action{position:absolute;left:1px;border-radius:var(--el-border-radius-circle);transition:all var(--el-transition-duration);width:16px;height:16px;background-color:var(--el-color-white);display:flex;justify-content:center;align-items:center;color:var(--el-switch-off-color)}.el-switch.is-checked .el-switch__core{border-color:var(--el-switch-border-color,var(--el-switch-on-color));background-color:var(--el-switch-on-color)}.el-switch.is-checked .el-switch__core .el-switch__action{left:calc(100% - 17px);color:var(--el-switch-on-color)}.el-switch.is-checked .el-switch__core .el-switch__inner{padding:0 calc(16px + 2px) 0 4px}.el-switch.is-disabled{opacity:.6}.el-switch--wide .el-switch__label.el-switch__label--left span{left:10px}.el-switch--wide .el-switch__label.el-switch__label--right span{right:10px}.el-switch .label-fade-enter-from,.el-switch .label-fade-leave-active{opacity:0}.el-switch--large{font-size:14px;line-height:24px;height:40px}.el-switch--large .el-switch__label{height:24px;font-size:14px}.el-switch--large .el-switch__label *{font-size:14px}.el-switch--large .el-switch__core{min-width:50px;height:24px;border-radius:12px}.el-switch--large .el-switch__core .el-switch__inner{height:20px;padding:0 6px 0 calc(20px + 2px)}.el-switch--large .el-switch__core .el-switch__action{width:20px;height:20px}.el-switch--large.is-checked .el-switch__core .el-switch__action{left:calc(100% - 21px)}.el-switch--large.is-checked .el-switch__core .el-switch__inner{padding:0 calc(20px + 2px) 0 6px}.el-switch--small{font-size:12px;line-height:16px;height:24px}.el-switch--small .el-switch__label{height:16px;font-size:12px}.el-switch--small .el-switch__label *{font-size:12px}.el-switch--small .el-switch__core{min-width:30px;height:16px;border-radius:8px}.el-switch--small .el-switch__core .el-switch__inner{height:12px;padding:0 2px 0 calc(12px + 2px)}.el-switch--small .el-switch__core .el-switch__action{width:12px;height:12px}.el-switch--small.is-checked .el-switch__core .el-switch__action{left:calc(100% - 13px)}.el-switch--small.is-checked .el-switch__core .el-switch__inner{padding:0 calc(12px + 2px) 0 2px}.el-table-column--selection .cell{padding-left:14px;padding-right:14px}.el-table-filter{border:solid 1px var(--el-border-color-lighter);border-radius:2px;background-color:#fff;box-shadow:var(--el-box-shadow-light);box-sizing:border-box}.el-table-filter__list{padding:5px 0;margin:0;list-style:none;min-width:100px}.el-table-filter__list-item{line-height:36px;padding:0 10px;cursor:pointer;font-size:var(--el-font-size-base)}.el-table-filter__list-item:hover{background-color:var(--el-color-primary-light-9);color:var(--el-color-primary)}.el-table-filter__list-item.is-active{background-color:var(--el-color-primary);color:#fff}.el-table-filter__content{min-width:100px}.el-table-filter__bottom{border-top:1px solid var(--el-border-color-lighter);padding:8px}.el-table-filter__bottom button{background:0 0;border:none;color:var(--el-text-color-regular);cursor:pointer;font-size:var(--el-font-size-small);padding:0 3px}.el-table-filter__bottom button:hover{color:var(--el-color-primary)}.el-table-filter__bottom button:focus{outline:0}.el-table-filter__bottom button.is-disabled{color:var(--el-disabled-text-color);cursor:not-allowed}.el-table-filter__wrap{max-height:280px}.el-table-filter__checkbox-group{padding:10px}.el-table-filter__checkbox-group label.el-checkbox{display:flex;align-items:center;margin-right:5px;margin-bottom:12px;margin-left:5px;height:unset}.el-table-filter__checkbox-group .el-checkbox:last-child{margin-bottom:0}.el-table{--el-table-border-color:var(--el-border-color-lighter);--el-table-border:1px solid var(--el-table-border-color);--el-table-text-color:var(--el-text-color-regular);--el-table-header-text-color:var(--el-text-color-secondary);--el-table-row-hover-bg-color:var(--el-fill-color-light);--el-table-current-row-bg-color:var(--el-color-primary-light-9);--el-table-header-bg-color:var(--el-bg-color);--el-table-fixed-box-shadow:var(--el-box-shadow-light);--el-table-bg-color:var(--el-fill-color-blank);--el-table-tr-bg-color:var(--el-fill-color-blank);--el-table-expanded-cell-bg-color:var(--el-fill-color-blank);--el-table-fixed-left-column:inset 10px 0 10px -10px rgba(0, 0, 0, 0.15);--el-table-fixed-right-column:inset -10px 0 10px -10px rgba(0, 0, 0, 0.15)}.el-table{position:relative;overflow:hidden;box-sizing:border-box;height:-webkit-fit-content;height:-moz-fit-content;height:fit-content;width:100%;max-width:100%;background-color:var(--el-table-bg-color);font-size:14px;color:var(--el-table-text-color)}.el-table__inner-wrapper{position:relative;display:flex;flex-direction:column;height:100%}.el-table__inner-wrapper::before{left:0;bottom:0;width:100%;height:1px}.el-table.has-footer.el-table--fluid-height tr:last-child td.el-table__cell,.el-table.has-footer.el-table--scrollable-y tr:last-child td.el-table__cell{border-bottom-color:transparent}.el-table__empty-block{position:-webkit-sticky;position:sticky;left:0;min-height:60px;text-align:center;width:100%;display:flex;justify-content:center;align-items:center}.el-table__empty-text{line-height:60px;width:50%;color:var(--el-text-color-secondary)}.el-table__expand-column .cell{padding:0;text-align:center;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.el-table__expand-icon{position:relative;cursor:pointer;color:var(--el-text-color-regular);font-size:12px;transition:transform var(--el-transition-duration-fast) ease-in-out;height:20px}.el-table__expand-icon--expanded{transform:rotate(90deg)}.el-table__expand-icon>.el-icon{font-size:12px}.el-table__expanded-cell{background-color:var(--el-table-expanded-cell-bg-color)}.el-table__expanded-cell[class*=cell]{padding:20px 50px}.el-table__expanded-cell:hover{background-color:transparent!important}.el-table__placeholder{display:inline-block;width:20px}.el-table__append-wrapper{overflow:hidden}.el-table--fit{border-right:0;border-bottom:0}.el-table--fit .el-table__cell.gutter{border-right-width:1px}.el-table thead{color:var(--el-table-header-text-color);font-weight:500}.el-table thead.is-group th.el-table__cell{background:var(--el-fill-color-light)}.el-table .el-table__cell{padding:8px 0;min-width:0;box-sizing:border-box;text-overflow:ellipsis;vertical-align:middle;position:relative;text-align:left;z-index:1}.el-table .el-table__cell.is-center{text-align:center}.el-table .el-table__cell.is-right{text-align:right}.el-table .el-table__cell.gutter{width:15px;border-right-width:0;border-bottom-width:0;padding:0}.el-table .el-table__cell.is-hidden>*{visibility:hidden}.el-table .cell{box-sizing:border-box;overflow:hidden;text-overflow:ellipsis;white-space:normal;word-break:break-all;line-height:23px;padding:0 12px}.el-table .cell.el-tooltip{white-space:nowrap;min-width:50px}.el-table--large{font-size:var(--el-font-size-base)}.el-table--large .el-table__cell{padding:12px 0}.el-table--large .cell{padding:0 16px}.el-table--small{font-size:12px}.el-table--small .el-table__cell{padding:4px 0}.el-table--small .cell{padding:0 8px}.el-table tr{background-color:var(--el-table-tr-bg-color)}.el-table tr input[type=checkbox]{margin:0}.el-table td.el-table__cell,.el-table th.el-table__cell.is-leaf{border-bottom:var(--el-table-border)}.el-table th.el-table__cell.is-sortable{cursor:pointer}.el-table th.el-table__cell{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;background-color:var(--el-table-header-bg-color)}.el-table th.el-table__cell>.cell.highlight{color:var(--el-color-primary)}.el-table th.el-table__cell.required>div::before{display:inline-block;content:"";width:8px;height:8px;border-radius:50%;background:#ff4d51;margin-right:5px;vertical-align:middle}.el-table td.el-table__cell div{box-sizing:border-box}.el-table td.el-table__cell.gutter{width:0}.el-table__footer-wrapper{border-top:var(--el-table-border)}.el-table--border .el-table__inner-wrapper::after,.el-table--border::after,.el-table--border::before,.el-table__inner-wrapper::before{content:"";position:absolute;background-color:var(--el-table-border-color);z-index:3}.el-table--border .el-table__inner-wrapper::after{left:0;top:0;width:100%;height:1px}.el-table--border::before{top:-1px;left:0;width:1px;height:100%}.el-table--border::after{top:-1px;right:0;width:1px;height:100%}.el-table--border .el-table__inner-wrapper{border-right:none;border-bottom:none}.el-table--border .el-table__footer-wrapper{position:relative;flex-shrink:0}.el-table--border .el-table__cell{border-right:var(--el-table-border)}.el-table--border th.el-table__cell.gutter:last-of-type{border-bottom:var(--el-table-border);border-bottom-width:1px}.el-table--border th.el-table__cell{border-bottom:var(--el-table-border)}.el-table--hidden{visibility:hidden}.el-table__body-wrapper,.el-table__footer-wrapper,.el-table__header-wrapper{width:100%}.el-table__body-wrapper tr td.el-table-fixed-column--left,.el-table__body-wrapper tr td.el-table-fixed-column--right,.el-table__body-wrapper tr th.el-table-fixed-column--left,.el-table__body-wrapper tr th.el-table-fixed-column--right,.el-table__footer-wrapper tr td.el-table-fixed-column--left,.el-table__footer-wrapper tr td.el-table-fixed-column--right,.el-table__footer-wrapper tr th.el-table-fixed-column--left,.el-table__footer-wrapper tr th.el-table-fixed-column--right,.el-table__header-wrapper tr td.el-table-fixed-column--left,.el-table__header-wrapper tr td.el-table-fixed-column--right,.el-table__header-wrapper tr th.el-table-fixed-column--left,.el-table__header-wrapper tr th.el-table-fixed-column--right{position:-webkit-sticky!important;position:sticky!important;z-index:2;background:var(--el-bg-color)}.el-table__body-wrapper tr td.el-table-fixed-column--left.is-first-column::before,.el-table__body-wrapper tr td.el-table-fixed-column--left.is-last-column::before,.el-table__body-wrapper tr td.el-table-fixed-column--right.is-first-column::before,.el-table__body-wrapper tr td.el-table-fixed-column--right.is-last-column::before,.el-table__body-wrapper tr th.el-table-fixed-column--left.is-first-column::before,.el-table__body-wrapper tr th.el-table-fixed-column--left.is-last-column::before,.el-table__body-wrapper tr th.el-table-fixed-column--right.is-first-column::before,.el-table__body-wrapper tr th.el-table-fixed-column--right.is-last-column::before,.el-table__footer-wrapper tr td.el-table-fixed-column--left.is-first-column::before,.el-table__footer-wrapper tr td.el-table-fixed-column--left.is-last-column::before,.el-table__footer-wrapper tr td.el-table-fixed-column--right.is-first-column::before,.el-table__footer-wrapper tr td.el-table-fixed-column--right.is-last-column::before,.el-table__footer-wrapper tr th.el-table-fixed-column--left.is-first-column::before,.el-table__footer-wrapper tr th.el-table-fixed-column--left.is-last-column::before,.el-table__footer-wrapper tr th.el-table-fixed-column--right.is-first-column::before,.el-table__footer-wrapper tr th.el-table-fixed-column--right.is-last-column::before,.el-table__header-wrapper tr td.el-table-fixed-column--left.is-first-column::before,.el-table__header-wrapper tr td.el-table-fixed-column--left.is-last-column::before,.el-table__header-wrapper tr td.el-table-fixed-column--right.is-first-column::before,.el-table__header-wrapper tr td.el-table-fixed-column--right.is-last-column::before,.el-table__header-wrapper tr th.el-table-fixed-column--left.is-first-column::before,.el-table__header-wrapper tr th.el-table-fixed-column--left.is-last-column::before,.el-table__header-wrapper tr th.el-table-fixed-column--right.is-first-column::before,.el-table__header-wrapper tr th.el-table-fixed-column--right.is-last-column::before{content:"";position:absolute;top:0;width:10px;bottom:-1px;overflow-x:hidden;overflow-y:hidden;box-shadow:none;touch-action:none;pointer-events:none}.el-table__body-wrapper tr td.el-table-fixed-column--left.is-first-column::before,.el-table__body-wrapper tr td.el-table-fixed-column--right.is-first-column::before,.el-table__body-wrapper tr th.el-table-fixed-column--left.is-first-column::before,.el-table__body-wrapper tr th.el-table-fixed-column--right.is-first-column::before,.el-table__footer-wrapper tr td.el-table-fixed-column--left.is-first-column::before,.el-table__footer-wrapper tr td.el-table-fixed-column--right.is-first-column::before,.el-table__footer-wrapper tr th.el-table-fixed-column--left.is-first-column::before,.el-table__footer-wrapper tr th.el-table-fixed-column--right.is-first-column::before,.el-table__header-wrapper tr td.el-table-fixed-column--left.is-first-column::before,.el-table__header-wrapper tr td.el-table-fixed-column--right.is-first-column::before,.el-table__header-wrapper tr th.el-table-fixed-column--left.is-first-column::before,.el-table__header-wrapper tr th.el-table-fixed-column--right.is-first-column::before{left:-10px}.el-table__body-wrapper tr td.el-table-fixed-column--left.is-last-column::before,.el-table__body-wrapper tr td.el-table-fixed-column--right.is-last-column::before,.el-table__body-wrapper tr th.el-table-fixed-column--left.is-last-column::before,.el-table__body-wrapper tr th.el-table-fixed-column--right.is-last-column::before,.el-table__footer-wrapper tr td.el-table-fixed-column--left.is-last-column::before,.el-table__footer-wrapper tr td.el-table-fixed-column--right.is-last-column::before,.el-table__footer-wrapper tr th.el-table-fixed-column--left.is-last-column::before,.el-table__footer-wrapper tr th.el-table-fixed-column--right.is-last-column::before,.el-table__header-wrapper tr td.el-table-fixed-column--left.is-last-column::before,.el-table__header-wrapper tr td.el-table-fixed-column--right.is-last-column::before,.el-table__header-wrapper tr th.el-table-fixed-column--left.is-last-column::before,.el-table__header-wrapper tr th.el-table-fixed-column--right.is-last-column::before{right:-10px;box-shadow:none}.el-table__body-wrapper tr td.el-table__fixed-right-patch,.el-table__body-wrapper tr th.el-table__fixed-right-patch,.el-table__footer-wrapper tr td.el-table__fixed-right-patch,.el-table__footer-wrapper tr th.el-table__fixed-right-patch,.el-table__header-wrapper tr td.el-table__fixed-right-patch,.el-table__header-wrapper tr th.el-table__fixed-right-patch{position:-webkit-sticky!important;position:sticky!important;z-index:2;background:#fff;right:0}.el-table__header-wrapper{flex-shrink:0}.el-table__header-wrapper tr th.el-table-fixed-column--left,.el-table__header-wrapper tr th.el-table-fixed-column--right{background-color:var(--el-table-header-bg-color)}.el-table__body,.el-table__footer,.el-table__header{table-layout:fixed;border-collapse:separate}.el-table__footer-wrapper,.el-table__header-wrapper{overflow:hidden}.el-table__footer-wrapper tbody td.el-table__cell,.el-table__header-wrapper tbody td.el-table__cell{background-color:var(--el-table-row-hover-bg-color);color:var(--el-table-text-color)}.el-table__body-wrapper .el-table-column--selection>.cell,.el-table__header-wrapper .el-table-column--selection>.cell{display:inline-flex;align-items:center;height:23px}.el-table__body-wrapper .el-table-column--selection .el-checkbox,.el-table__header-wrapper .el-table-column--selection .el-checkbox{height:unset}.el-table.is-scrolling-left .el-table-fixed-column--right.is-first-column::before{box-shadow:var(--el-table-fixed-right-column)}.el-table.is-scrolling-left.el-table--border .el-table-fixed-column--left.is-last-column.el-table__cell{border-right:var(--el-table-border)}.el-table.is-scrolling-left th.el-table-fixed-column--left{background-color:var(--el-table-header-bg-color)}.el-table.is-scrolling-right .el-table-fixed-column--left.is-last-column::before{box-shadow:var(--el-table-fixed-left-column)}.el-table.is-scrolling-right .el-table-fixed-column--left.is-last-column.el-table__cell{border-right:none}.el-table.is-scrolling-right th.el-table-fixed-column--right{background-color:var(--el-table-header-bg-color)}.el-table.is-scrolling-middle .el-table-fixed-column--left.is-last-column.el-table__cell{border-right:none}.el-table.is-scrolling-middle .el-table-fixed-column--right.is-first-column::before{box-shadow:var(--el-table-fixed-right-column)}.el-table.is-scrolling-middle .el-table-fixed-column--left.is-last-column::before{box-shadow:var(--el-table-fixed-left-column)}.el-table.is-scrolling-none .el-table-fixed-column--left.is-first-column::before,.el-table.is-scrolling-none .el-table-fixed-column--left.is-last-column::before,.el-table.is-scrolling-none .el-table-fixed-column--right.is-first-column::before,.el-table.is-scrolling-none .el-table-fixed-column--right.is-last-column::before{box-shadow:none}.el-table.is-scrolling-none th.el-table-fixed-column--left,.el-table.is-scrolling-none th.el-table-fixed-column--right{background-color:var(--el-table-header-bg-color)}.el-table__body-wrapper{overflow:hidden;position:relative;flex:1}.el-table__body-wrapper .el-scrollbar__bar{z-index:2}.el-table .caret-wrapper{display:inline-flex;flex-direction:column;align-items:center;height:14px;width:24px;vertical-align:middle;cursor:pointer;overflow:initial;position:relative}.el-table .sort-caret{width:0;height:0;border:solid 5px transparent;position:absolute;left:7px}.el-table .sort-caret.ascending{border-bottom-color:var(--el-text-color-placeholder);top:-5px}.el-table .sort-caret.descending{border-top-color:var(--el-text-color-placeholder);bottom:-3px}.el-table .ascending .sort-caret.ascending{border-bottom-color:var(--el-color-primary)}.el-table .descending .sort-caret.descending{border-top-color:var(--el-color-primary)}.el-table .hidden-columns{visibility:hidden;position:absolute;z-index:-1}.el-table--striped .el-table__body tr.el-table__row--striped td.el-table__cell{background:var(--el-fill-color-lighter)}.el-table--striped .el-table__body tr.el-table__row--striped.current-row td.el-table__cell{background-color:var(--el-table-current-row-bg-color)}.el-table__body tr.hover-row.current-row>td.el-table__cell,.el-table__body tr.hover-row.el-table__row--striped.current-row>td.el-table__cell,.el-table__body tr.hover-row.el-table__row--striped>td.el-table__cell,.el-table__body tr.hover-row>td.el-table__cell{background-color:var(--el-table-row-hover-bg-color)}.el-table__body tr.current-row>td.el-table__cell{background-color:var(--el-table-current-row-bg-color)}.el-table__column-resize-proxy{position:absolute;left:200px;top:0;bottom:0;width:0;border-left:var(--el-table-border);z-index:10}.el-table__column-filter-trigger{display:inline-block;cursor:pointer}.el-table__column-filter-trigger i{color:var(--el-color-info);font-size:14px;vertical-align:middle}.el-table__border-left-patch{top:0;left:0;width:1px;height:100%;z-index:3;position:absolute;background-color:var(--el-table-border-color)}.el-table__border-bottom-patch{left:0;height:1px;z-index:3;position:absolute;background-color:var(--el-table-border-color)}.el-table__border-right-patch{top:0;height:100%;width:1px;z-index:3;position:absolute;background-color:var(--el-table-border-color)}.el-table--enable-row-transition .el-table__body td.el-table__cell{transition:background-color .25s ease}.el-table--enable-row-hover .el-table__body tr:hover>td.el-table__cell{background-color:var(--el-table-row-hover-bg-color)}.el-table [class*=el-table__row--level] .el-table__expand-icon{display:inline-block;width:12px;line-height:12px;height:12px;text-align:center;margin-right:8px}.el-table .el-table.el-table--border .el-table__cell{border-right:var(--el-table-border)}.el-table:not(.el-table--border) .el-table__cell{border-right:none}.el-table:not(.el-table--border)>.el-table__inner-wrapper::after{content:none}.el-table-v2{--el-table-border-color:var(--el-border-color-lighter);--el-table-border:1px solid var(--el-table-border-color);--el-table-text-color:var(--el-text-color-regular);--el-table-header-text-color:var(--el-text-color-secondary);--el-table-row-hover-bg-color:var(--el-fill-color-light);--el-table-current-row-bg-color:var(--el-color-primary-light-9);--el-table-header-bg-color:var(--el-bg-color);--el-table-fixed-box-shadow:var(--el-box-shadow-light);--el-table-bg-color:var(--el-fill-color-blank);--el-table-tr-bg-color:var(--el-fill-color-blank);--el-table-expanded-cell-bg-color:var(--el-fill-color-blank);--el-table-fixed-left-column:inset 10px 0 10px -10px rgba(0, 0, 0, 0.15);--el-table-fixed-right-column:inset -10px 0 10px -10px rgba(0, 0, 0, 0.15)}.el-table-v2{font-size:14px}.el-table-v2 *{box-sizing:border-box}.el-table-v2__root{position:relative}.el-table-v2__root:hover .el-table-v2__main .el-virtual-scrollbar{opacity:1}.el-table-v2__main{display:flex;flex-direction:column-reverse;position:absolute;overflow:hidden;top:0;background-color:var(--el-bg-color);left:0}.el-table-v2__main .el-vl__horizontal,.el-table-v2__main .el-vl__vertical{z-index:2}.el-table-v2__left{display:flex;flex-direction:column-reverse;position:absolute;overflow:hidden;top:0;background-color:var(--el-bg-color);left:0;box-shadow:2px 0 4px 0 rgba(0,0,0,.06)}.el-table-v2__left .el-virtual-scrollbar{opacity:0}.el-table-v2__left .el-vl__horizontal,.el-table-v2__left .el-vl__vertical{z-index:-1}.el-table-v2__right{display:flex;flex-direction:column-reverse;position:absolute;overflow:hidden;top:0;background-color:var(--el-bg-color);right:0;box-shadow:-2px 0 4px 0 rgba(0,0,0,.06)}.el-table-v2__right .el-virtual-scrollbar{opacity:0}.el-table-v2__right .el-vl__horizontal,.el-table-v2__right .el-vl__vertical{z-index:-1}.el-table-v2__header-row{-webkit-padding-end:var(--el-table-scrollbar-size);padding-inline-end:var(--el-table-scrollbar-size)}.el-table-v2__row{-webkit-padding-end:var(--el-table-scrollbar-size);padding-inline-end:var(--el-table-scrollbar-size)}.el-table-v2__header-wrapper{overflow:hidden}.el-table-v2__header{position:relative;overflow:hidden}.el-table-v2__footer{position:absolute;left:0;right:0;bottom:0;overflow:hidden}.el-table-v2__empty{position:absolute;left:0}.el-table-v2__overlay{position:absolute;left:0;right:0;top:0;bottom:0;z-index:9999}.el-table-v2__header-row{display:flex;border-bottom:var(--el-table-border)}.el-table-v2__header-cell{display:flex;align-items:center;padding:0 8px;height:100%;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;overflow:hidden;background-color:var(--el-table-header-bg-color);color:var(--el-table-header-text-color);font-weight:700}.el-table-v2__header-cell.is-align-center{justify-content:center;text-align:center}.el-table-v2__header-cell.is-align-right{justify-content:flex-end;text-align:right}.el-table-v2__header-cell.is-sortable{cursor:pointer}.el-table-v2__header-cell:hover .el-icon{display:block}.el-table-v2__sort-icon{transition:opacity,display var(--el-transition-duration);opacity:.6;display:none}.el-table-v2__sort-icon.is-sorting{display:block;opacity:1}.el-table-v2__row{border-bottom:var(--el-table-border);display:flex;align-items:center;transition:background-color var(--el-transition-duration)}.el-table-v2__row.is-hovered{background-color:var(--el-table-row-hover-bg-color)}.el-table-v2__row:hover{background-color:var(--el-table-row-hover-bg-color)}.el-table-v2__row-cell{height:100%;overflow:hidden;display:flex;align-items:center;padding:0 8px}.el-table-v2__row-cell.is-align-center{justify-content:center;text-align:center}.el-table-v2__row-cell.is-align-right{justify-content:flex-end;text-align:right}.el-table-v2__expand-icon{margin:0 4px;cursor:pointer;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.el-table-v2__expand-icon svg{transition:transform var(--el-transition-duration)}.el-table-v2__expand-icon.is-expanded svg{transform:rotate(90deg)}.el-table-v2:not(.is-dynamic) .el-table-v2__cell-text{overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.el-table-v2.is-dynamic .el-table-v2__row{overflow:hidden;align-items:stretch}.el-table-v2.is-dynamic .el-table-v2__row .el-table-v2__row-cell{word-break:break-all}.el-tabs{--el-tabs-header-height:40px}.el-tabs__header{padding:0;position:relative;margin:0 0 15px}.el-tabs__active-bar{position:absolute;bottom:0;left:0;height:2px;background-color:var(--el-color-primary);z-index:1;transition:width var(--el-transition-duration) var(--el-transition-function-ease-in-out-bezier),transform var(--el-transition-duration) var(--el-transition-function-ease-in-out-bezier);list-style:none}.el-tabs__new-tab{display:flex;align-items:center;justify-content:center;float:right;border:1px solid var(--el-border-color);height:20px;width:20px;line-height:20px;margin:10px 0 10px 10px;border-radius:3px;text-align:center;font-size:12px;color:var(--el-text-color-primary);cursor:pointer;transition:all .15s}.el-tabs__new-tab .is-icon-plus{height:inherit;width:inherit;transform:scale(.8,.8)}.el-tabs__new-tab .is-icon-plus svg{vertical-align:middle}.el-tabs__new-tab:hover{color:var(--el-color-primary)}.el-tabs__nav-wrap{overflow:hidden;margin-bottom:-1px;position:relative}.el-tabs__nav-wrap::after{content:"";position:absolute;left:0;bottom:0;width:100%;height:2px;background-color:var(--el-border-color-light);z-index:var(--el-index-normal)}.el-tabs__nav-wrap.is-scrollable{padding:0 20px;box-sizing:border-box}.el-tabs__nav-scroll{overflow:hidden}.el-tabs__nav-next,.el-tabs__nav-prev{position:absolute;cursor:pointer;line-height:44px;font-size:12px;color:var(--el-text-color-secondary);width:20px;text-align:center}.el-tabs__nav-next{right:0}.el-tabs__nav-prev{left:0}.el-tabs__nav{white-space:nowrap;position:relative;transition:transform var(--el-transition-duration);float:left;z-index:calc(var(--el-index-normal) + 1)}.el-tabs__nav.is-stretch{min-width:100%;display:flex}.el-tabs__nav.is-stretch>*{flex:1;text-align:center}.el-tabs__item{padding:0 20px;height:var(--el-tabs-header-height);box-sizing:border-box;line-height:var(--el-tabs-header-height);display:inline-block;list-style:none;font-size:var(--el-font-size-base);font-weight:500;color:var(--el-text-color-primary);position:relative}.el-tabs__item:focus,.el-tabs__item:focus:active{outline:0}.el-tabs__item:focus-visible{box-shadow:0 0 2px 2px var(--el-color-primary) inset;border-radius:3px}.el-tabs__item .is-icon-close{border-radius:50%;text-align:center;transition:all var(--el-transition-duration) var(--el-transition-function-ease-in-out-bezier);margin-left:5px}.el-tabs__item .is-icon-close:before{transform:scale(.9);display:inline-block}.el-tabs__item .is-icon-close:hover{background-color:var(--el-text-color-placeholder);color:#fff}.el-tabs__item .is-icon-close svg{margin-top:1px}.el-tabs__item.is-active{color:var(--el-color-primary)}.el-tabs__item:hover{color:var(--el-color-primary);cursor:pointer}.el-tabs__item.is-disabled{color:var(--el-disabled-text-color);cursor:not-allowed}.el-tabs__content{overflow:hidden;position:relative}.el-tabs--card>.el-tabs__header{border-bottom:1px solid var(--el-border-color-light);height:var(--el-tabs-header-height)}.el-tabs--card>.el-tabs__header .el-tabs__nav-wrap::after{content:none}.el-tabs--card>.el-tabs__header .el-tabs__nav{border:1px solid var(--el-border-color-light);border-bottom:none;border-radius:4px 4px 0 0;box-sizing:border-box}.el-tabs--card>.el-tabs__header .el-tabs__active-bar{display:none}.el-tabs--card>.el-tabs__header .el-tabs__item .is-icon-close{position:relative;font-size:12px;width:0;height:14px;vertical-align:middle;line-height:15px;overflow:hidden;top:-1px;right:-2px;transform-origin:100% 50%}.el-tabs--card>.el-tabs__header .el-tabs__item{border-bottom:1px solid transparent;border-left:1px solid var(--el-border-color-light);transition:color var(--el-transition-duration) var(--el-transition-function-ease-in-out-bezier),padding var(--el-transition-duration) var(--el-transition-function-ease-in-out-bezier)}.el-tabs--card>.el-tabs__header .el-tabs__item:first-child{border-left:none}.el-tabs--card>.el-tabs__header .el-tabs__item.is-closable:hover{padding-left:13px;padding-right:13px}.el-tabs--card>.el-tabs__header .el-tabs__item.is-closable:hover .is-icon-close{width:14px}.el-tabs--card>.el-tabs__header .el-tabs__item.is-active{border-bottom-color:var(--el-bg-color)}.el-tabs--card>.el-tabs__header .el-tabs__item.is-active.is-closable{padding-left:20px;padding-right:20px}.el-tabs--card>.el-tabs__header .el-tabs__item.is-active.is-closable .is-icon-close{width:14px}.el-tabs--border-card{background:var(--el-bg-color-overlay);border:1px solid var(--el-border-color)}.el-tabs--border-card>.el-tabs__content{padding:15px}.el-tabs--border-card>.el-tabs__header{background-color:var(--el-fill-color-light);border-bottom:1px solid var(--el-border-color-light);margin:0}.el-tabs--border-card>.el-tabs__header .el-tabs__nav-wrap::after{content:none}.el-tabs--border-card>.el-tabs__header .el-tabs__item{transition:all var(--el-transition-duration) var(--el-transition-function-ease-in-out-bezier);border:1px solid transparent;margin-top:-1px;color:var(--el-text-color-secondary)}.el-tabs--border-card>.el-tabs__header .el-tabs__item:first-child{margin-left:-1px}.el-tabs--border-card>.el-tabs__header .el-tabs__item+.el-tabs__item{margin-left:-1px}.el-tabs--border-card>.el-tabs__header .el-tabs__item.is-active{color:var(--el-color-primary);background-color:var(--el-bg-color-overlay);border-right-color:var(--el-border-color);border-left-color:var(--el-border-color)}.el-tabs--border-card>.el-tabs__header .el-tabs__item:not(.is-disabled):hover{color:var(--el-color-primary)}.el-tabs--border-card>.el-tabs__header .el-tabs__item.is-disabled{color:var(--el-disabled-text-color)}.el-tabs--border-card>.el-tabs__header .is-scrollable .el-tabs__item:first-child{margin-left:0}.el-tabs--bottom .el-tabs__item.is-bottom:nth-child(2),.el-tabs--bottom .el-tabs__item.is-top:nth-child(2),.el-tabs--top .el-tabs__item.is-bottom:nth-child(2),.el-tabs--top .el-tabs__item.is-top:nth-child(2){padding-left:0}.el-tabs--bottom .el-tabs__item.is-bottom:last-child,.el-tabs--bottom .el-tabs__item.is-top:last-child,.el-tabs--top .el-tabs__item.is-bottom:last-child,.el-tabs--top .el-tabs__item.is-top:last-child{padding-right:0}.el-tabs--bottom .el-tabs--left>.el-tabs__header .el-tabs__item:nth-child(2),.el-tabs--bottom .el-tabs--right>.el-tabs__header .el-tabs__item:nth-child(2),.el-tabs--bottom.el-tabs--border-card>.el-tabs__header .el-tabs__item:nth-child(2),.el-tabs--bottom.el-tabs--card>.el-tabs__header .el-tabs__item:nth-child(2),.el-tabs--top .el-tabs--left>.el-tabs__header .el-tabs__item:nth-child(2),.el-tabs--top .el-tabs--right>.el-tabs__header .el-tabs__item:nth-child(2),.el-tabs--top.el-tabs--border-card>.el-tabs__header .el-tabs__item:nth-child(2),.el-tabs--top.el-tabs--card>.el-tabs__header .el-tabs__item:nth-child(2){padding-left:20px}.el-tabs--bottom .el-tabs--left>.el-tabs__header .el-tabs__item:last-child,.el-tabs--bottom .el-tabs--right>.el-tabs__header .el-tabs__item:last-child,.el-tabs--bottom.el-tabs--border-card>.el-tabs__header .el-tabs__item:last-child,.el-tabs--bottom.el-tabs--card>.el-tabs__header .el-tabs__item:last-child,.el-tabs--top .el-tabs--left>.el-tabs__header .el-tabs__item:last-child,.el-tabs--top .el-tabs--right>.el-tabs__header .el-tabs__item:last-child,.el-tabs--top.el-tabs--border-card>.el-tabs__header .el-tabs__item:last-child,.el-tabs--top.el-tabs--card>.el-tabs__header .el-tabs__item:last-child{padding-right:20px}.el-tabs--bottom .el-tabs__header.is-bottom{margin-bottom:0;margin-top:10px}.el-tabs--bottom.el-tabs--border-card .el-tabs__header.is-bottom{border-bottom:0;border-top:1px solid var(--el-border-color)}.el-tabs--bottom.el-tabs--border-card .el-tabs__nav-wrap.is-bottom{margin-top:-1px;margin-bottom:0}.el-tabs--bottom.el-tabs--border-card .el-tabs__item.is-bottom:not(.is-active){border:1px solid transparent}.el-tabs--bottom.el-tabs--border-card .el-tabs__item.is-bottom{margin:0 -1px -1px}.el-tabs--left,.el-tabs--right{overflow:hidden}.el-tabs--left .el-tabs__header.is-left,.el-tabs--left .el-tabs__header.is-right,.el-tabs--left .el-tabs__nav-scroll,.el-tabs--left .el-tabs__nav-wrap.is-left,.el-tabs--left .el-tabs__nav-wrap.is-right,.el-tabs--right .el-tabs__header.is-left,.el-tabs--right .el-tabs__header.is-right,.el-tabs--right .el-tabs__nav-scroll,.el-tabs--right .el-tabs__nav-wrap.is-left,.el-tabs--right .el-tabs__nav-wrap.is-right{height:100%}.el-tabs--left .el-tabs__active-bar.is-left,.el-tabs--left .el-tabs__active-bar.is-right,.el-tabs--right .el-tabs__active-bar.is-left,.el-tabs--right .el-tabs__active-bar.is-right{top:0;bottom:auto;width:2px;height:auto}.el-tabs--left .el-tabs__nav-wrap.is-left,.el-tabs--left .el-tabs__nav-wrap.is-right,.el-tabs--right .el-tabs__nav-wrap.is-left,.el-tabs--right .el-tabs__nav-wrap.is-right{margin-bottom:0}.el-tabs--left .el-tabs__nav-wrap.is-left>.el-tabs__nav-next,.el-tabs--left .el-tabs__nav-wrap.is-left>.el-tabs__nav-prev,.el-tabs--left .el-tabs__nav-wrap.is-right>.el-tabs__nav-next,.el-tabs--left .el-tabs__nav-wrap.is-right>.el-tabs__nav-prev,.el-tabs--right .el-tabs__nav-wrap.is-left>.el-tabs__nav-next,.el-tabs--right .el-tabs__nav-wrap.is-left>.el-tabs__nav-prev,.el-tabs--right .el-tabs__nav-wrap.is-right>.el-tabs__nav-next,.el-tabs--right .el-tabs__nav-wrap.is-right>.el-tabs__nav-prev{height:30px;line-height:30px;width:100%;text-align:center;cursor:pointer}.el-tabs--left .el-tabs__nav-wrap.is-left>.el-tabs__nav-next i,.el-tabs--left .el-tabs__nav-wrap.is-left>.el-tabs__nav-prev i,.el-tabs--left .el-tabs__nav-wrap.is-right>.el-tabs__nav-next i,.el-tabs--left .el-tabs__nav-wrap.is-right>.el-tabs__nav-prev i,.el-tabs--right .el-tabs__nav-wrap.is-left>.el-tabs__nav-next i,.el-tabs--right .el-tabs__nav-wrap.is-left>.el-tabs__nav-prev i,.el-tabs--right .el-tabs__nav-wrap.is-right>.el-tabs__nav-next i,.el-tabs--right .el-tabs__nav-wrap.is-right>.el-tabs__nav-prev i{transform:rotateZ(90deg)}.el-tabs--left .el-tabs__nav-wrap.is-left>.el-tabs__nav-prev,.el-tabs--left .el-tabs__nav-wrap.is-right>.el-tabs__nav-prev,.el-tabs--right .el-tabs__nav-wrap.is-left>.el-tabs__nav-prev,.el-tabs--right .el-tabs__nav-wrap.is-right>.el-tabs__nav-prev{left:auto;top:0}.el-tabs--left .el-tabs__nav-wrap.is-left>.el-tabs__nav-next,.el-tabs--left .el-tabs__nav-wrap.is-right>.el-tabs__nav-next,.el-tabs--right .el-tabs__nav-wrap.is-left>.el-tabs__nav-next,.el-tabs--right .el-tabs__nav-wrap.is-right>.el-tabs__nav-next{right:auto;bottom:0}.el-tabs--left .el-tabs__nav-wrap.is-left.is-scrollable,.el-tabs--left .el-tabs__nav-wrap.is-right.is-scrollable,.el-tabs--right .el-tabs__nav-wrap.is-left.is-scrollable,.el-tabs--right .el-tabs__nav-wrap.is-right.is-scrollable{padding:30px 0}.el-tabs--left .el-tabs__nav-wrap.is-left::after,.el-tabs--left .el-tabs__nav-wrap.is-right::after,.el-tabs--right .el-tabs__nav-wrap.is-left::after,.el-tabs--right .el-tabs__nav-wrap.is-right::after{height:100%;width:2px;bottom:auto;top:0}.el-tabs--left .el-tabs__nav.is-left,.el-tabs--left .el-tabs__nav.is-right,.el-tabs--right .el-tabs__nav.is-left,.el-tabs--right .el-tabs__nav.is-right{float:none}.el-tabs--left .el-tabs__item.is-left,.el-tabs--left .el-tabs__item.is-right,.el-tabs--right .el-tabs__item.is-left,.el-tabs--right .el-tabs__item.is-right{display:block}.el-tabs--left .el-tabs__header.is-left{float:left;margin-bottom:0;margin-right:10px}.el-tabs--left .el-tabs__nav-wrap.is-left{margin-right:-1px}.el-tabs--left .el-tabs__nav-wrap.is-left::after{left:auto;right:0}.el-tabs--left .el-tabs__active-bar.is-left{right:0;left:auto}.el-tabs--left .el-tabs__item.is-left{text-align:right}.el-tabs--left.el-tabs--card .el-tabs__active-bar.is-left{display:none}.el-tabs--left.el-tabs--card .el-tabs__item.is-left{border-left:none;border-right:1px solid var(--el-border-color-light);border-bottom:none;border-top:1px solid var(--el-border-color-light);text-align:left}.el-tabs--left.el-tabs--card .el-tabs__item.is-left:first-child{border-right:1px solid var(--el-border-color-light);border-top:none}.el-tabs--left.el-tabs--card .el-tabs__item.is-left.is-active{border:1px solid var(--el-border-color-light);border-right-color:#fff;border-left:none;border-bottom:none}.el-tabs--left.el-tabs--card .el-tabs__item.is-left.is-active:first-child{border-top:none}.el-tabs--left.el-tabs--card .el-tabs__item.is-left.is-active:last-child{border-bottom:none}.el-tabs--left.el-tabs--card .el-tabs__nav{border-radius:4px 0 0 4px;border-bottom:1px solid var(--el-border-color-light);border-right:none}.el-tabs--left.el-tabs--card .el-tabs__new-tab{float:none}.el-tabs--left.el-tabs--border-card .el-tabs__header.is-left{border-right:1px solid var(--el-border-color)}.el-tabs--left.el-tabs--border-card .el-tabs__item.is-left{border:1px solid transparent;margin:-1px 0 -1px -1px}.el-tabs--left.el-tabs--border-card .el-tabs__item.is-left.is-active{border-color:transparent;border-top-color:#d1dbe5;border-bottom-color:#d1dbe5}.el-tabs--right .el-tabs__header.is-right{float:right;margin-bottom:0;margin-left:10px}.el-tabs--right .el-tabs__nav-wrap.is-right{margin-left:-1px}.el-tabs--right .el-tabs__nav-wrap.is-right::after{left:0;right:auto}.el-tabs--right .el-tabs__active-bar.is-right{left:0}.el-tabs--right.el-tabs--card .el-tabs__active-bar.is-right{display:none}.el-tabs--right.el-tabs--card .el-tabs__item.is-right{border-bottom:none;border-top:1px solid var(--el-border-color-light)}.el-tabs--right.el-tabs--card .el-tabs__item.is-right:first-child{border-left:1px solid var(--el-border-color-light);border-top:none}.el-tabs--right.el-tabs--card .el-tabs__item.is-right.is-active{border:1px solid var(--el-border-color-light);border-left-color:#fff;border-right:none;border-bottom:none}.el-tabs--right.el-tabs--card .el-tabs__item.is-right.is-active:first-child{border-top:none}.el-tabs--right.el-tabs--card .el-tabs__item.is-right.is-active:last-child{border-bottom:none}.el-tabs--right.el-tabs--card .el-tabs__nav{border-radius:0 4px 4px 0;border-bottom:1px solid var(--el-border-color-light);border-left:none}.el-tabs--right.el-tabs--border-card .el-tabs__header.is-right{border-left:1px solid var(--el-border-color)}.el-tabs--right.el-tabs--border-card .el-tabs__item.is-right{border:1px solid transparent;margin:-1px -1px -1px 0}.el-tabs--right.el-tabs--border-card .el-tabs__item.is-right.is-active{border-color:transparent;border-top-color:#d1dbe5;border-bottom-color:#d1dbe5}.slideInLeft-transition,.slideInRight-transition{display:inline-block}.slideInRight-enter{-webkit-animation:slideInRight-enter var(--el-transition-duration);animation:slideInRight-enter var(--el-transition-duration)}.slideInRight-leave{position:absolute;left:0;right:0;-webkit-animation:slideInRight-leave var(--el-transition-duration);animation:slideInRight-leave var(--el-transition-duration)}.slideInLeft-enter{-webkit-animation:slideInLeft-enter var(--el-transition-duration);animation:slideInLeft-enter var(--el-transition-duration)}.slideInLeft-leave{position:absolute;left:0;right:0;-webkit-animation:slideInLeft-leave var(--el-transition-duration);animation:slideInLeft-leave var(--el-transition-duration)}@-webkit-keyframes slideInRight-enter{0%{opacity:0;transform-origin:0 0;transform:translateX(100%)}to{opacity:1;transform-origin:0 0;transform:translateX(0)}}@keyframes slideInRight-enter{0%{opacity:0;transform-origin:0 0;transform:translateX(100%)}to{opacity:1;transform-origin:0 0;transform:translateX(0)}}@-webkit-keyframes slideInRight-leave{0%{transform-origin:0 0;transform:translateX(0);opacity:1}100%{transform-origin:0 0;transform:translateX(100%);opacity:0}}@keyframes slideInRight-leave{0%{transform-origin:0 0;transform:translateX(0);opacity:1}100%{transform-origin:0 0;transform:translateX(100%);opacity:0}}@-webkit-keyframes slideInLeft-enter{0%{opacity:0;transform-origin:0 0;transform:translateX(-100%)}to{opacity:1;transform-origin:0 0;transform:translateX(0)}}@keyframes slideInLeft-enter{0%{opacity:0;transform-origin:0 0;transform:translateX(-100%)}to{opacity:1;transform-origin:0 0;transform:translateX(0)}}@-webkit-keyframes slideInLeft-leave{0%{transform-origin:0 0;transform:translateX(0);opacity:1}100%{transform-origin:0 0;transform:translateX(-100%);opacity:0}}@keyframes slideInLeft-leave{0%{transform-origin:0 0;transform:translateX(0);opacity:1}100%{transform-origin:0 0;transform:translateX(-100%);opacity:0}}.el-tag{--el-tag-font-size:12px;--el-tag-border-radius:4px;--el-tag-border-radius-rounded:9999px}.el-tag{--el-tag-bg-color:var(--el-color-primary-light-9);--el-tag-border-color:var(--el-color-primary-light-8);--el-tag-hover-color:var(--el-color-primary);--el-tag-text-color:var(--el-color-primary);background-color:var(--el-tag-bg-color);border-color:var(--el-tag-border-color);color:var(--el-tag-text-color);display:inline-flex;justify-content:center;align-items:center;height:24px;padding:0 9px;font-size:var(--el-tag-font-size);line-height:1;border-width:1px;border-style:solid;border-radius:var(--el-tag-border-radius);box-sizing:border-box;white-space:nowrap;--el-icon-size:14px}.el-tag.el-tag--primary{--el-tag-bg-color:var(--el-color-primary-light-9);--el-tag-border-color:var(--el-color-primary-light-8);--el-tag-hover-color:var(--el-color-primary)}.el-tag.el-tag--success{--el-tag-bg-color:var(--el-color-success-light-9);--el-tag-border-color:var(--el-color-success-light-8);--el-tag-hover-color:var(--el-color-success)}.el-tag.el-tag--warning{--el-tag-bg-color:var(--el-color-warning-light-9);--el-tag-border-color:var(--el-color-warning-light-8);--el-tag-hover-color:var(--el-color-warning)}.el-tag.el-tag--danger{--el-tag-bg-color:var(--el-color-danger-light-9);--el-tag-border-color:var(--el-color-danger-light-8);--el-tag-hover-color:var(--el-color-danger)}.el-tag.el-tag--error{--el-tag-bg-color:var(--el-color-error-light-9);--el-tag-border-color:var(--el-color-error-light-8);--el-tag-hover-color:var(--el-color-error)}.el-tag.el-tag--info{--el-tag-bg-color:var(--el-color-info-light-9);--el-tag-border-color:var(--el-color-info-light-8);--el-tag-hover-color:var(--el-color-info)}.el-tag.el-tag--primary{--el-tag-text-color:var(--el-color-primary)}.el-tag.el-tag--success{--el-tag-text-color:var(--el-color-success)}.el-tag.el-tag--warning{--el-tag-text-color:var(--el-color-warning)}.el-tag.el-tag--danger{--el-tag-text-color:var(--el-color-danger)}.el-tag.el-tag--error{--el-tag-text-color:var(--el-color-error)}.el-tag.el-tag--info{--el-tag-text-color:var(--el-color-info)}.el-tag.is-hit{border-color:var(--el-color-primary)}.el-tag.is-round{border-radius:var(--el-tag-border-radius-rounded)}.el-tag .el-tag__close{color:var(--el-tag-text-color)}.el-tag .el-tag__close:hover{color:var(--el-color-white);background-color:var(--el-tag-hover-color)}.el-tag .el-icon{border-radius:50%;cursor:pointer;font-size:calc(var(--el-icon-size) - 2px);height:var(--el-icon-size);width:var(--el-icon-size)}.el-tag .el-tag__close{margin-left:6px}.el-tag--dark{--el-tag-bg-color:var(--el-color-primary);--el-tag-border-color:var(--el-color-primary);--el-tag-hover-color:var(--el-color-primary-light-3);--el-tag-text-color:var(--el-color-white);--el-tag-text-color:var(--el-color-white)}.el-tag--dark.el-tag--primary{--el-tag-bg-color:var(--el-color-primary);--el-tag-border-color:var(--el-color-primary);--el-tag-hover-color:var(--el-color-primary-light-3)}.el-tag--dark.el-tag--success{--el-tag-bg-color:var(--el-color-success);--el-tag-border-color:var(--el-color-success);--el-tag-hover-color:var(--el-color-success-light-3)}.el-tag--dark.el-tag--warning{--el-tag-bg-color:var(--el-color-warning);--el-tag-border-color:var(--el-color-warning);--el-tag-hover-color:var(--el-color-warning-light-3)}.el-tag--dark.el-tag--danger{--el-tag-bg-color:var(--el-color-danger);--el-tag-border-color:var(--el-color-danger);--el-tag-hover-color:var(--el-color-danger-light-3)}.el-tag--dark.el-tag--error{--el-tag-bg-color:var(--el-color-error);--el-tag-border-color:var(--el-color-error);--el-tag-hover-color:var(--el-color-error-light-3)}.el-tag--dark.el-tag--info{--el-tag-bg-color:var(--el-color-info);--el-tag-border-color:var(--el-color-info);--el-tag-hover-color:var(--el-color-info-light-3)}.el-tag--dark.el-tag--primary{--el-tag-text-color:var(--el-color-white)}.el-tag--dark.el-tag--success{--el-tag-text-color:var(--el-color-white)}.el-tag--dark.el-tag--warning{--el-tag-text-color:var(--el-color-white)}.el-tag--dark.el-tag--danger{--el-tag-text-color:var(--el-color-white)}.el-tag--dark.el-tag--error{--el-tag-text-color:var(--el-color-white)}.el-tag--dark.el-tag--info{--el-tag-text-color:var(--el-color-white)}.el-tag--plain{--el-tag-bg-color:var(--el-fill-color-blank);--el-tag-border-color:var(--el-color-primary-light-5);--el-tag-hover-color:var(--el-color-primary);--el-tag-bg-color:var(--el-fill-color-blank)}.el-tag--plain.el-tag--primary{--el-tag-bg-color:var(--el-fill-color-blank);--el-tag-border-color:var(--el-color-primary-light-5);--el-tag-hover-color:var(--el-color-primary)}.el-tag--plain.el-tag--success{--el-tag-bg-color:var(--el-fill-color-blank);--el-tag-border-color:var(--el-color-success-light-5);--el-tag-hover-color:var(--el-color-success)}.el-tag--plain.el-tag--warning{--el-tag-bg-color:var(--el-fill-color-blank);--el-tag-border-color:var(--el-color-warning-light-5);--el-tag-hover-color:var(--el-color-warning)}.el-tag--plain.el-tag--danger{--el-tag-bg-color:var(--el-fill-color-blank);--el-tag-border-color:var(--el-color-danger-light-5);--el-tag-hover-color:var(--el-color-danger)}.el-tag--plain.el-tag--error{--el-tag-bg-color:var(--el-fill-color-blank);--el-tag-border-color:var(--el-color-error-light-5);--el-tag-hover-color:var(--el-color-error)}.el-tag--plain.el-tag--info{--el-tag-bg-color:var(--el-fill-color-blank);--el-tag-border-color:var(--el-color-info-light-5);--el-tag-hover-color:var(--el-color-info)}.el-tag.is-closable{padding-right:5px}.el-tag--large{padding:0 11px;height:32px;--el-icon-size:16px}.el-tag--large .el-tag__close{margin-left:8px}.el-tag--large.is-closable{padding-right:7px}.el-tag--small{padding:0 7px;height:20px;--el-icon-size:12px}.el-tag--small .el-tag__close{margin-left:4px}.el-tag--small.is-closable{padding-right:3px}.el-tag--small .el-icon-close{transform:scale(.8)}.el-tag.el-tag--primary.is-hit{border-color:var(--el-color-primary)}.el-tag.el-tag--success.is-hit{border-color:var(--el-color-success)}.el-tag.el-tag--warning.is-hit{border-color:var(--el-color-warning)}.el-tag.el-tag--danger.is-hit{border-color:var(--el-color-danger)}.el-tag.el-tag--error.is-hit{border-color:var(--el-color-error)}.el-tag.el-tag--info.is-hit{border-color:var(--el-color-info)}.time-select{margin:5px 0;min-width:0}.time-select .el-picker-panel__content{max-height:200px;margin:0}.time-select-item{padding:8px 10px;font-size:14px;line-height:20px}.time-select-item.disabled{color:var(--el-datepicker-border-color);cursor:not-allowed}.time-select-item:hover{background-color:var(--el-fill-color-light);font-weight:700;cursor:pointer}.time-select .time-select-item.selected:not(.disabled){color:var(--el-color-primary);font-weight:700}.el-timeline-item{position:relative;padding-bottom:20px}.el-timeline-item__wrapper{position:relative;padding-left:28px;top:-3px}.el-timeline-item__tail{position:absolute;left:4px;height:100%;border-left:2px solid var(--el-timeline-node-color)}.el-timeline-item .el-timeline-item__icon{color:var(--el-color-white);font-size:var(--el-font-size-small)}.el-timeline-item__node{position:absolute;background-color:var(--el-timeline-node-color);border-color:var(--el-timeline-node-color);border-radius:50%;box-sizing:border-box;display:flex;justify-content:center;align-items:center}.el-timeline-item__node--normal{left:-1px;width:var(--el-timeline-node-size-normal);height:var(--el-timeline-node-size-normal)}.el-timeline-item__node--large{left:-2px;width:var(--el-timeline-node-size-large);height:var(--el-timeline-node-size-large)}.el-timeline-item__node.is-hollow{background:var(--el-color-white);border-style:solid;border-width:2px}.el-timeline-item__node--primary{background-color:var(--el-color-primary);border-color:var(--el-color-primary)}.el-timeline-item__node--success{background-color:var(--el-color-success);border-color:var(--el-color-success)}.el-timeline-item__node--warning{background-color:var(--el-color-warning);border-color:var(--el-color-warning)}.el-timeline-item__node--danger{background-color:var(--el-color-danger);border-color:var(--el-color-danger)}.el-timeline-item__node--info{background-color:var(--el-color-info);border-color:var(--el-color-info)}.el-timeline-item__dot{position:absolute;display:flex;justify-content:center;align-items:center}.el-timeline-item__content{color:var(--el-text-color-primary)}.el-timeline-item__timestamp{color:var(--el-text-color-secondary);line-height:1;font-size:var(--el-font-size-small)}.el-timeline-item__timestamp.is-top{margin-bottom:8px;padding-top:4px}.el-timeline-item__timestamp.is-bottom{margin-top:8px}.el-timeline{--el-timeline-node-size-normal:12px;--el-timeline-node-size-large:14px;--el-timeline-node-color:var(--el-border-color-light)}.el-timeline{margin:0;font-size:var(--el-font-size-base);list-style:none}.el-timeline .el-timeline-item:last-child .el-timeline-item__tail{display:none}.el-timeline .el-timeline-item__center{display:flex;align-items:center}.el-timeline .el-timeline-item__center .el-timeline-item__wrapper{width:100%}.el-timeline .el-timeline-item__center .el-timeline-item__tail{top:0}.el-timeline .el-timeline-item__center:first-child .el-timeline-item__tail{height:calc(50% + 10px);top:calc(50% - 10px)}.el-timeline .el-timeline-item__center:last-child .el-timeline-item__tail{display:block;height:calc(50% - 10px)}.el-tooltip-v2__content{--el-tooltip-v2-padding:5px 10px;--el-tooltip-v2-border-radius:4px;--el-tooltip-v2-border-color:var(--el-border-color);border-radius:var(--el-tooltip-v2-border-radius);color:var(--el-color-black);background-color:var(--el-color-white);padding:var(--el-tooltip-v2-padding);border:1px solid var(--el-border-color)}.el-tooltip-v2__arrow{position:absolute;color:var(--el-color-white);width:var(--el-tooltip-v2-arrow-width);height:var(--el-tooltip-v2-arrow-height);pointer-events:none;left:var(--el-tooltip-v2-arrow-x);top:var(--el-tooltip-v2-arrow-y)}.el-tooltip-v2__arrow::before{content:"";width:0;height:0;border:var(--el-tooltip-v2-arrow-border-width) solid transparent;position:absolute}.el-tooltip-v2__arrow::after{content:"";width:0;height:0;border:var(--el-tooltip-v2-arrow-border-width) solid transparent;position:absolute}.el-tooltip-v2__content[data-side^=top] .el-tooltip-v2__arrow{bottom:0}.el-tooltip-v2__content[data-side^=top] .el-tooltip-v2__arrow::before{border-top-color:var(--el-color-white);border-top-width:var(--el-tooltip-v2-arrow-border-width);border-bottom:0;top:calc(100% - 1px)}.el-tooltip-v2__content[data-side^=top] .el-tooltip-v2__arrow::after{border-top-color:var(--el-border-color);border-top-width:var(--el-tooltip-v2-arrow-border-width);border-bottom:0;top:100%;z-index:-1}.el-tooltip-v2__content[data-side^=bottom] .el-tooltip-v2__arrow{top:0}.el-tooltip-v2__content[data-side^=bottom] .el-tooltip-v2__arrow::before{border-bottom-color:var(--el-color-white);border-bottom-width:var(--el-tooltip-v2-arrow-border-width);border-top:0;bottom:calc(100% - 1px)}.el-tooltip-v2__content[data-side^=bottom] .el-tooltip-v2__arrow::after{border-bottom-color:var(--el-border-color);border-bottom-width:var(--el-tooltip-v2-arrow-border-width);border-top:0;bottom:100%;z-index:-1}.el-tooltip-v2__content[data-side^=left] .el-tooltip-v2__arrow{right:0}.el-tooltip-v2__content[data-side^=left] .el-tooltip-v2__arrow::before{border-left-color:var(--el-color-white);border-left-width:var(--el-tooltip-v2-arrow-border-width);border-right:0;left:calc(100% - 1px)}.el-tooltip-v2__content[data-side^=left] .el-tooltip-v2__arrow::after{border-left-color:var(--el-border-color);border-left-width:var(--el-tooltip-v2-arrow-border-width);border-right:0;left:100%;z-index:-1}.el-tooltip-v2__content[data-side^=right] .el-tooltip-v2__arrow{left:0}.el-tooltip-v2__content[data-side^=right] .el-tooltip-v2__arrow::before{border-right-color:var(--el-color-white);border-right-width:var(--el-tooltip-v2-arrow-border-width);border-left:0;right:calc(100% - 1px)}.el-tooltip-v2__content[data-side^=right] .el-tooltip-v2__arrow::after{border-right-color:var(--el-border-color);border-right-width:var(--el-tooltip-v2-arrow-border-width);border-left:0;right:100%;z-index:-1}.el-tooltip-v2__content.is-dark{--el-tooltip-v2-border-color:transparent;background-color:var(--el-color-black);color:var(--el-color-white);border-color:transparent}.el-tooltip-v2__content.is-dark .el-tooltip-v2__arrow{background-color:var(--el-color-black);border-color:transparent}.el-transfer{--el-transfer-border-color:var(--el-border-color-lighter);--el-transfer-border-radius:var(--el-border-radius-base);--el-transfer-panel-width:200px;--el-transfer-panel-header-height:40px;--el-transfer-panel-header-bg-color:var(--el-fill-color-light);--el-transfer-panel-footer-height:40px;--el-transfer-panel-body-height:278px;--el-transfer-item-height:30px;--el-transfer-filter-height:32px}.el-transfer{font-size:var(--el-font-size-base)}.el-transfer__buttons{display:inline-block;vertical-align:middle;padding:0 30px}.el-transfer__button{vertical-align:top}.el-transfer__button:nth-child(2){margin:0 0 0 10px}.el-transfer__button i,.el-transfer__button span{font-size:14px}.el-transfer__button .el-icon+span{margin-left:0}.el-transfer-panel{overflow:hidden;background:var(--el-bg-color-overlay);display:inline-block;text-align:left;vertical-align:middle;width:var(--el-transfer-panel-width);max-height:100%;box-sizing:border-box;position:relative}.el-transfer-panel__body{height:var(--el-transfer-panel-body-height);border-left:1px solid var(--el-transfer-border-color);border-right:1px solid var(--el-transfer-border-color);border-bottom:1px solid var(--el-transfer-border-color);border-bottom-left-radius:var(--el-transfer-border-radius);border-bottom-right-radius:var(--el-transfer-border-radius);overflow:hidden}.el-transfer-panel__body.is-with-footer{border-bottom:none;border-bottom-left-radius:0;border-bottom-right-radius:0}.el-transfer-panel__list{margin:0;padding:6px 0;list-style:none;height:var(--el-transfer-panel-body-height);overflow:auto;box-sizing:border-box}.el-transfer-panel__list.is-filterable{height:calc(100% - var(--el-transfer-filter-height) - 30px);padding-top:0}.el-transfer-panel__item{height:var(--el-transfer-item-height);line-height:var(--el-transfer-item-height);padding-left:15px;display:block!important}.el-transfer-panel__item+.el-transfer-panel__item{margin-left:0}.el-transfer-panel__item.el-checkbox{color:var(--el-text-color-regular)}.el-transfer-panel__item:hover{color:var(--el-color-primary)}.el-transfer-panel__item.el-checkbox .el-checkbox__label{width:100%;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;display:block;box-sizing:border-box;padding-left:22px;line-height:var(--el-transfer-item-height)}.el-transfer-panel__item .el-checkbox__input{position:absolute;top:8px}.el-transfer-panel__filter{text-align:center;margin:15px;box-sizing:border-box;width:auto}.el-transfer-panel__filter .el-input__inner{height:var(--el-transfer-filter-height);width:100%;font-size:12px;display:inline-block;box-sizing:border-box;border-radius:calc(var(--el-transfer-filter-height)/ 2)}.el-transfer-panel__filter .el-icon-circle-close{cursor:pointer}.el-transfer-panel .el-transfer-panel__header{display:flex;align-items:center;height:var(--el-transfer-panel-header-height);background:var(--el-transfer-panel-header-bg-color);margin:0;padding-left:15px;border:1px solid var(--el-transfer-border-color);border-top-left-radius:var(--el-transfer-border-radius);border-top-right-radius:var(--el-transfer-border-radius);box-sizing:border-box;color:var(--el-color-black)}.el-transfer-panel .el-transfer-panel__header .el-checkbox{position:relative;display:flex;width:100%;align-items:center}.el-transfer-panel .el-transfer-panel__header .el-checkbox .el-checkbox__label{font-size:16px;color:var(--el-text-color-primary);font-weight:400}.el-transfer-panel .el-transfer-panel__header .el-checkbox .el-checkbox__label span{position:absolute;right:15px;top:50%;transform:translate3d(0,-50%,0);color:var(--el-text-color-secondary);font-size:12px;font-weight:400}.el-transfer-panel .el-transfer-panel__footer{height:var(--el-transfer-panel-footer-height);background:var(--el-bg-color-overlay);margin:0;padding:0;border:1px solid var(--el-transfer-border-color);border-bottom-left-radius:var(--el-transfer-border-radius);border-bottom-right-radius:var(--el-transfer-border-radius)}.el-transfer-panel .el-transfer-panel__footer::after{display:inline-block;content:"";height:100%;vertical-align:middle}.el-transfer-panel .el-transfer-panel__footer .el-checkbox{padding-left:20px;color:var(--el-text-color-regular)}.el-transfer-panel .el-transfer-panel__empty{margin:0;height:var(--el-transfer-item-height);line-height:var(--el-transfer-item-height);padding:6px 15px 0;color:var(--el-text-color-secondary);text-align:center}.el-transfer-panel .el-checkbox__label{padding-left:8px}.el-transfer-panel .el-checkbox__inner{height:14px;width:14px;border-radius:3px}.el-transfer-panel .el-checkbox__inner::after{height:6px;width:3px;left:4px}.el-tree{--el-tree-node-hover-bg-color:var(--el-fill-color-light);--el-tree-text-color:var(--el-text-color-regular);--el-tree-expand-icon-color:var(--el-text-color-placeholder)}.el-tree{position:relative;cursor:default;background:var(--el-fill-color-blank);color:var(--el-tree-text-color);font-size:var(--el-font-size-base)}.el-tree__empty-block{position:relative;min-height:60px;text-align:center;width:100%;height:100%}.el-tree__empty-text{position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);color:var(--el-text-color-secondary);font-size:var(--el-font-size-base)}.el-tree__drop-indicator{position:absolute;left:0;right:0;height:1px;background-color:var(--el-color-primary)}.el-tree-node{white-space:nowrap;outline:0}.el-tree-node:focus>.el-tree-node__content{background-color:var(--el-tree-node-hover-bg-color)}.el-tree-node.is-drop-inner>.el-tree-node__content .el-tree-node__label{background-color:var(--el-color-primary);color:#fff}.el-tree-node__content{display:flex;align-items:center;height:26px;cursor:pointer}.el-tree-node__content>.el-tree-node__expand-icon{padding:6px;box-sizing:content-box}.el-tree-node__content>label.el-checkbox{margin-right:8px}.el-tree-node__content:hover{background-color:var(--el-tree-node-hover-bg-color)}.el-tree.is-dragging .el-tree-node__content{cursor:move}.el-tree.is-dragging .el-tree-node__content *{pointer-events:none}.el-tree.is-dragging.is-drop-not-allow .el-tree-node__content{cursor:not-allowed}.el-tree-node__expand-icon{cursor:pointer;color:var(--el-tree-expand-icon-color);font-size:12px;transform:rotate(0);transition:transform var(--el-transition-duration) ease-in-out}.el-tree-node__expand-icon.expanded{transform:rotate(90deg)}.el-tree-node__expand-icon.is-leaf{color:transparent;cursor:default}.el-tree-node__expand-icon.is-hidden{visibility:hidden}.el-tree-node__loading-icon{margin-right:8px;font-size:var(--el-font-size-base);color:var(--el-tree-expand-icon-color)}.el-tree-node>.el-tree-node__children{overflow:hidden;background-color:transparent}.el-tree-node.is-expanded>.el-tree-node__children{display:block}.el-tree--highlight-current .el-tree-node.is-current>.el-tree-node__content{background-color:var(--el-color-primary-light-9)}.el-tree-select{--el-tree-node-hover-bg-color:var(--el-fill-color-light);--el-tree-text-color:var(--el-text-color-regular);--el-tree-expand-icon-color:var(--el-text-color-placeholder)}.el-tree-select__popper .el-tree-node__expand-icon{margin-left:8px}.el-tree-select__popper .el-tree-node.is-checked>.el-tree-node__content .el-select-dropdown__item.selected::after{content:none}.el-tree-select__popper .el-select-dropdown__item{flex:1;background:0 0!important;padding-left:0;height:20px;line-height:20px}.el-upload{--el-upload-dragger-padding-horizontal:40px;--el-upload-dragger-padding-vertical:10px}.el-upload{display:inline-flex;justify-content:center;align-items:center;cursor:pointer;outline:0}.el-upload__input{display:none}.el-upload__tip{font-size:12px;color:var(--el-text-color-regular);margin-top:7px}.el-upload iframe{position:absolute;z-index:-1;top:0;left:0;opacity:0}.el-upload--picture-card{--el-upload-picture-card-size:148px;background-color:var(--el-fill-color-lighter);border:1px dashed var(--el-border-color-darker);border-radius:6px;box-sizing:border-box;width:var(--el-upload-picture-card-size);height:var(--el-upload-picture-card-size);cursor:pointer;vertical-align:top;display:inline-flex;justify-content:center;align-items:center}.el-upload--picture-card i{font-size:28px;color:var(--el-text-color-secondary)}.el-upload--picture-card:hover{border-color:var(--el-color-primary);color:var(--el-color-primary)}.el-upload.is-drag{display:block}.el-upload:focus{border-color:var(--el-color-primary);color:var(--el-color-primary)}.el-upload:focus .el-upload-dragger{border-color:var(--el-color-primary)}.el-upload-dragger{padding:var(--el-upload-dragger-padding-horizontal) var(--el-upload-dragger-padding-vertical);background-color:var(--el-fill-color-blank);border:1px dashed var(--el-border-color);border-radius:6px;box-sizing:border-box;text-align:center;cursor:pointer;position:relative;overflow:hidden}.el-upload-dragger .el-icon--upload{font-size:67px;color:var(--el-text-color-placeholder);margin-bottom:16px;line-height:50px}.el-upload-dragger+.el-upload__tip{text-align:center}.el-upload-dragger~.el-upload__files{border-top:var(--el-border);margin-top:7px;padding-top:5px}.el-upload-dragger .el-upload__text{color:var(--el-text-color-regular);font-size:14px;text-align:center}.el-upload-dragger .el-upload__text em{color:var(--el-color-primary);font-style:normal}.el-upload-dragger:hover{border-color:var(--el-color-primary)}.el-upload-dragger.is-dragover{padding:calc(var(--el-upload-dragger-padding-horizontal) - 1px) calc(var(--el-upload-dragger-padding-vertical) - 1px);background-color:var(--el-color-primary-light-9);border:2px dashed var(--el-color-primary)}.el-upload-list{margin:10px 0 0;padding:0;list-style:none;position:relative}.el-upload-list__item{transition:all .5s cubic-bezier(.55,0,.1,1);font-size:14px;color:var(--el-text-color-regular);margin-bottom:5px;position:relative;box-sizing:border-box;border-radius:4px;width:100%}.el-upload-list__item .el-progress{position:absolute;top:20px;width:100%}.el-upload-list__item .el-progress__text{position:absolute;right:0;top:-13px}.el-upload-list__item .el-progress-bar{margin-right:0;padding-right:0}.el-upload-list__item .el-icon--upload-success{color:var(--el-color-success)}.el-upload-list__item .el-icon--close{display:none;position:absolute;right:5px;top:50%;cursor:pointer;opacity:.75;color:var(--el-text-color-regular);transition:opacity var(--el-transition-duration);transform:translateY(-50%)}.el-upload-list__item .el-icon--close:hover{opacity:1;color:var(--el-color-primary)}.el-upload-list__item .el-icon--close-tip{display:none;position:absolute;top:1px;right:5px;font-size:12px;cursor:pointer;opacity:1;color:var(--el-color-primary);font-style:normal}.el-upload-list__item:hover{background-color:var(--el-fill-color-light)}.el-upload-list__item:hover .el-icon--close{display:inline-flex}.el-upload-list__item:hover .el-progress__text{display:none}.el-upload-list__item .el-upload-list__item-info{display:inline-flex;justify-content:center;flex-direction:column;width:calc(100% - 30px);margin-left:4px}.el-upload-list__item.is-success .el-upload-list__item-status-label{display:inline-flex}.el-upload-list__item.is-success .el-upload-list__item-name:focus,.el-upload-list__item.is-success .el-upload-list__item-name:hover{color:var(--el-color-primary);cursor:pointer}.el-upload-list__item.is-success:focus:not(:hover) .el-icon--close-tip{display:inline-block}.el-upload-list__item.is-success:active,.el-upload-list__item.is-success:not(.focusing):focus{outline-width:0}.el-upload-list__item.is-success:active .el-icon--close-tip,.el-upload-list__item.is-success:not(.focusing):focus .el-icon--close-tip{display:none}.el-upload-list__item.is-success:focus .el-upload-list__item-status-label,.el-upload-list__item.is-success:hover .el-upload-list__item-status-label{display:none;opacity:0}.el-upload-list.is-disabled .el-upload-list__item-status-label,.el-upload-list.is-disabled .el-upload-list__item:hover{display:block}.el-upload-list__item-name{color:var(--el-text-color-regular);display:inline-flex;text-align:center;align-items:center;padding:0 4px;transition:color var(--el-transition-duration);font-size:var(--el-font-size-base)}.el-upload-list__item-name .el-icon{margin-right:6px;color:var(--el-text-color-secondary)}.el-upload-list__item-file-name{overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.el-upload-list__item-status-label{position:absolute;right:5px;top:0;line-height:inherit;display:none;height:100%;justify-content:center;align-items:center;transition:opacity var(--el-transition-duration)}.el-upload-list__item-delete{position:absolute;right:10px;top:0;font-size:12px;color:var(--el-text-color-regular);display:none}.el-upload-list__item-delete:hover{color:var(--el-color-primary)}.el-upload-list--picture-card{--el-upload-list-picture-card-size:148px;display:inline-flex;flex-wrap:wrap;margin:0}.el-upload-list--picture-card .el-upload-list__item{overflow:hidden;background-color:var(--el-fill-color-blank);border:1px solid var(--el-border-color);border-radius:6px;box-sizing:border-box;width:var(--el-upload-list-picture-card-size);height:var(--el-upload-list-picture-card-size);margin:0 8px 8px 0;padding:0;display:inline-flex}.el-upload-list--picture-card .el-upload-list__item .el-icon--check,.el-upload-list--picture-card .el-upload-list__item .el-icon--circle-check{color:#fff}.el-upload-list--picture-card .el-upload-list__item .el-icon--close{display:none}.el-upload-list--picture-card .el-upload-list__item:hover .el-upload-list__item-status-label{opacity:0;display:block}.el-upload-list--picture-card .el-upload-list__item:hover .el-progress__text{display:block}.el-upload-list--picture-card .el-upload-list__item .el-upload-list__item-name{display:none}.el-upload-list--picture-card .el-upload-list__item-thumbnail{width:100%;height:100%;-o-object-fit:contain;object-fit:contain}.el-upload-list--picture-card .el-upload-list__item-status-label{right:-15px;top:-6px;width:40px;height:24px;background:var(--el-color-success);text-align:center;transform:rotate(45deg)}.el-upload-list--picture-card .el-upload-list__item-status-label i{font-size:12px;margin-top:11px;transform:rotate(-45deg)}.el-upload-list--picture-card .el-upload-list__item-actions{position:absolute;width:100%;height:100%;left:0;top:0;cursor:default;display:inline-flex;justify-content:center;align-items:center;color:#fff;opacity:0;font-size:20px;background-color:var(--el-overlay-color-lighter);transition:opacity var(--el-transition-duration)}.el-upload-list--picture-card .el-upload-list__item-actions span{display:none;cursor:pointer}.el-upload-list--picture-card .el-upload-list__item-actions span+span{margin-left:1rem}.el-upload-list--picture-card .el-upload-list__item-actions .el-upload-list__item-delete{position:static;font-size:inherit;color:inherit}.el-upload-list--picture-card .el-upload-list__item-actions:hover{opacity:1}.el-upload-list--picture-card .el-upload-list__item-actions:hover span{display:inline-flex}.el-upload-list--picture-card .el-progress{top:50%;left:50%;transform:translate(-50%,-50%);bottom:auto;width:126px}.el-upload-list--picture-card .el-progress .el-progress__text{top:50%}.el-upload-list--picture .el-upload-list__item{overflow:hidden;z-index:0;background-color:var(--el-fill-color-blank);border:1px solid var(--el-border-color);border-radius:6px;box-sizing:border-box;margin-top:10px;padding:10px;display:flex;align-items:center}.el-upload-list--picture .el-upload-list__item .el-icon--check,.el-upload-list--picture .el-upload-list__item .el-icon--circle-check{color:#fff}.el-upload-list--picture .el-upload-list__item:hover .el-upload-list__item-status-label{opacity:0;display:block}.el-upload-list--picture .el-upload-list__item:hover .el-progress__text{display:block}.el-upload-list--picture .el-upload-list__item.is-success .el-upload-list__item-name i{display:none}.el-upload-list--picture .el-upload-list__item .el-icon--close{top:5px;transform:translateY(0)}.el-upload-list--picture .el-upload-list__item-thumbnail{display:inline-flex;justify-content:center;align-items:center;width:70px;height:70px;-o-object-fit:contain;object-fit:contain;position:relative;z-index:1;background-color:var(--el-color-white)}.el-upload-list--picture .el-upload-list__item-status-label{position:absolute;right:-17px;top:-7px;width:46px;height:26px;background:var(--el-color-success);text-align:center;transform:rotate(45deg)}.el-upload-list--picture .el-upload-list__item-status-label i{font-size:12px;margin-top:12px;transform:rotate(-45deg)}.el-upload-list--picture .el-progress{position:relative;top:-7px}.el-upload-cover{position:absolute;left:0;top:0;width:100%;height:100%;overflow:hidden;z-index:10;cursor:default}.el-upload-cover::after{display:inline-block;content:"";height:100%;vertical-align:middle}.el-upload-cover img{display:block;width:100%;height:100%}.el-upload-cover__label{right:-15px;top:-6px;width:40px;height:24px;background:var(--el-color-success);text-align:center;transform:rotate(45deg)}.el-upload-cover__label i{font-size:12px;margin-top:11px;transform:rotate(-45deg);color:#fff}.el-upload-cover__progress{display:inline-block;vertical-align:middle;position:static;width:243px}.el-upload-cover__progress+.el-upload__inner{opacity:0}.el-upload-cover__content{position:absolute;top:0;left:0;width:100%;height:100%}.el-upload-cover__interact{position:absolute;bottom:0;left:0;width:100%;height:100%;background-color:var(--el-overlay-color-light);text-align:center}.el-upload-cover__interact .btn{display:inline-block;color:#fff;font-size:14px;cursor:pointer;vertical-align:middle;transition:var(--el-transition-md-fade);margin-top:60px}.el-upload-cover__interact .btn i{margin-top:0}.el-upload-cover__interact .btn span{opacity:0;transition:opacity .15s linear}.el-upload-cover__interact .btn:not(:first-child){margin-left:35px}.el-upload-cover__interact .btn:hover{transform:translateY(-13px)}.el-upload-cover__interact .btn:hover span{opacity:1}.el-upload-cover__interact .btn i{color:#fff;display:block;font-size:24px;line-height:inherit;margin:0 auto 5px}.el-upload-cover__title{position:absolute;bottom:0;left:0;background-color:#fff;height:36px;width:100%;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;font-weight:400;text-align:left;padding:0 10px;margin:0;line-height:36px;font-size:14px;color:var(--el-text-color-primary)}.el-upload-cover+.el-upload__inner{opacity:0;position:relative;z-index:1}.el-vl__wrapper{position:relative}.el-vl__wrapper:hover .el-virtual-scrollbar{opacity:1}.el-vl__wrapper.always-on .el-virtual-scrollbar{opacity:1}.el-vl__window{scrollbar-width:none}.el-vl__window::-webkit-scrollbar{display:none}.el-virtual-scrollbar{opacity:0;transition:opacity 340ms ease-out}.el-virtual-scrollbar.always-on{opacity:1}.el-vg__wrapper{position:relative}.el-popper{--el-popper-border-radius:var(--el-popover-border-radius, 4px)}.el-popper{position:absolute;border-radius:var(--el-popper-border-radius);padding:5px 11px;z-index:2000;font-size:12px;line-height:20px;min-width:10px;word-wrap:break-word;visibility:visible}.el-popper.is-dark{color:var(--el-bg-color);background:var(--el-text-color-primary);border:1px solid var(--el-text-color-primary)}.el-popper.is-dark .el-popper__arrow::before{border:1px solid var(--el-text-color-primary);background:var(--el-text-color-primary);right:0}.el-popper.is-light{background:var(--el-bg-color-overlay);border:1px solid var(--el-border-color-light)}.el-popper.is-light .el-popper__arrow::before{border:1px solid var(--el-border-color-light);background:var(--el-bg-color-overlay);right:0}.el-popper.is-pure{padding:0}.el-popper__arrow{position:absolute;width:10px;height:10px;z-index:-1}.el-popper__arrow::before{position:absolute;width:10px;height:10px;z-index:-1;content:" ";transform:rotate(45deg);background:var(--el-text-color-primary);box-sizing:border-box}.el-popper[data-popper-placement^=top]>.el-popper__arrow{bottom:-5px}.el-popper[data-popper-placement^=top]>.el-popper__arrow::before{border-bottom-right-radius:2px}.el-popper[data-popper-placement^=bottom]>.el-popper__arrow{top:-5px}.el-popper[data-popper-placement^=bottom]>.el-popper__arrow::before{border-top-left-radius:2px}.el-popper[data-popper-placement^=left]>.el-popper__arrow{right:-5px}.el-popper[data-popper-placement^=left]>.el-popper__arrow::before{border-top-right-radius:2px}.el-popper[data-popper-placement^=right]>.el-popper__arrow{left:-5px}.el-popper[data-popper-placement^=right]>.el-popper__arrow::before{border-bottom-left-radius:2px}.el-popper[data-popper-placement^=top] .el-popper__arrow::before{border-top-color:transparent!important;border-left-color:transparent!important}.el-popper[data-popper-placement^=bottom] .el-popper__arrow::before{border-bottom-color:transparent!important;border-right-color:transparent!important}.el-popper[data-popper-placement^=left] .el-popper__arrow::before{border-left-color:transparent!important;border-bottom-color:transparent!important}.el-popper[data-popper-placement^=right] .el-popper__arrow::before{border-right-color:transparent!important;border-top-color:transparent!important}.el-select-dropdown__item{font-size:var(--el-font-size-base);padding:0 32px 0 20px;position:relative;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;color:var(--el-text-color-regular);height:34px;line-height:34px;box-sizing:border-box;cursor:pointer}.el-select-dropdown__item.is-disabled{color:var(--el-text-color-placeholder);cursor:not-allowed}.el-select-dropdown__item.hover,.el-select-dropdown__item:hover{background-color:var(--el-fill-color-light)}.el-select-dropdown__item.selected{color:var(--el-color-primary);font-weight:700}.el-statistic{--el-statistic-title-font-weight:400;--el-statistic-title-font-size:var(--el-font-size-extra-small);--el-statistic-title-color:var(--el-text-color-regular);--el-statistic-content-font-weight:400;--el-statistic-content-font-size:var(--el-font-size-extra-large);--el-statistic-content-color:var(--el-text-color-primary)}.el-statistic__head{font-weight:var(--el-statistic-title-font-weight);font-size:var(--el-statistic-title-font-size);color:var(--el-statistic-title-color);line-height:20px;margin-bottom:4px}.el-statistic__content{font-weight:var(--el-statistic-content-font-weight);font-size:var(--el-statistic-content-font-size);color:var(--el-statistic-content-color)}.el-statistic__value{display:inline-block}.el-statistic__prefix{margin-right:4px;display:inline-block}.el-statistic__suffix{margin-left:4px;display:inline-block}`, hv = `/* http://meyerweb.com/eric/tools/css/reset/
   v5.0.1 | 20191019
   License: none (public domain)
*/

html, body, div, span, applet, object, iframe,
h1, h2, h3, h4, h5, h6, p, blockquote, pre,
a, abbr, acronym, address, big, cite, code,
del, dfn, em, img, ins, kbd, q, s, samp,
small, strike, strong, sub, sup, tt, var,
b, u, i, center,
dl, dt, dd, menu, ol, ul, li,
fieldset, form, label, legend,
table, caption, tbody, tfoot, thead, tr, th, td,
article, aside, canvas, details, embed,
figure, figcaption, footer, header, hgroup,
main, menu, nav, output, ruby, section, summary,
time, mark, audio, video {
	margin: 0;
	padding: 0;
	border: 0;
	font-size: 100%;
	font: inherit;
	vertical-align: baseline;
}
/* HTML5 display-role reset for older browsers */
article, aside, details, figcaption, figure,
footer, header, hgroup, main, menu, nav, section {
	display: block;
}
/* HTML5 hidden-attribute fix for newer browsers */
*[hidden] {
    display: none;
}
body {
	line-height: 1;
}
menu, ol, ul {
	list-style: none;
}
blockquote, q {
	quotes: none;
}
blockquote:before, blockquote:after,
q:before, q:after {
	content: '';
	content: none;
}
table {
	border-collapse: collapse;
	border-spacing: 0;
}
`;
function Br(r, e) {
  const t = /* @__PURE__ */ Object.create(null), l = r.split(",");
  for (let i = 0; i < l.length; i++)
    t[l[i]] = !0;
  return e ? (i) => !!t[i.toLowerCase()] : (i) => !!t[i];
}
function ss(r) {
  if (ee(r)) {
    const e = {};
    for (let t = 0; t < r.length; t++) {
      const l = r[t], i = $e(l) ? gv(l) : ss(l);
      if (i)
        for (const o in i)
          e[o] = i[o];
    }
    return e;
  } else {
    if ($e(r))
      return r;
    if (ve(r))
      return r;
  }
}
const pv = /;(?![^(]*\))/g, uv = /:([^]+)/, fv = /\/\*.*?\*\//gs;
function gv(r) {
  const e = {};
  return r.replace(fv, "").split(pv).forEach((t) => {
    if (t) {
      const l = t.split(uv);
      l.length > 1 && (e[l[0].trim()] = l[1].trim());
    }
  }), e;
}
function io(r) {
  let e = "";
  if ($e(r))
    e = r;
  else if (ee(r))
    for (let t = 0; t < r.length; t++) {
      const l = io(r[t]);
      l && (e += l + " ");
    }
  else if (ve(r))
    for (const t in r)
      r[t] && (e += t + " ");
  return e.trim();
}
const mv = "html,body,base,head,link,meta,style,title,address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,summary,template,blockquote,iframe,tfoot", bv = "svg,animate,animateMotion,animateTransform,circle,clipPath,color-profile,defs,desc,discard,ellipse,feBlend,feColorMatrix,feComponentTransfer,feComposite,feConvolveMatrix,feDiffuseLighting,feDisplacementMap,feDistanceLight,feDropShadow,feFlood,feFuncA,feFuncB,feFuncG,feFuncR,feGaussianBlur,feImage,feMerge,feMergeNode,feMorphology,feOffset,fePointLight,feSpecularLighting,feSpotLight,feTile,feTurbulence,filter,foreignObject,g,hatch,hatchpath,image,line,linearGradient,marker,mask,mesh,meshgradient,meshpatch,meshrow,metadata,mpath,path,pattern,polygon,polyline,radialGradient,rect,set,solidcolor,stop,switch,symbol,text,textPath,title,tspan,unknown,use,view", Ov = /* @__PURE__ */ Br(mv), vv = /* @__PURE__ */ Br(bv), xv = "itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly", _v = /* @__PURE__ */ Br(xv);
function mf(r) {
  return !!r || r === "";
}
const be = {}.NODE_ENV !== "production" ? Object.freeze({}) : {}, Wl = {}.NODE_ENV !== "production" ? Object.freeze([]) : [], Me = () => {
}, bf = () => !1, wv = /^on[^a-z]/, oo = (r) => wv.test(r), xn = (r) => r.startsWith("onUpdate:"), Ve = Object.assign, Kc = (r, e) => {
  const t = r.indexOf(e);
  t > -1 && r.splice(t, 1);
}, yv = Object.prototype.hasOwnProperty, ne = (r, e) => yv.call(r, e), ee = Array.isArray, Nl = (r) => as(r) === "[object Map]", kv = (r) => as(r) === "[object Set]", te = (r) => typeof r == "function", $e = (r) => typeof r == "string", Jc = (r) => typeof r == "symbol", ve = (r) => r !== null && typeof r == "object", ed = (r) => ve(r) && te(r.then) && te(r.catch), Sv = Object.prototype.toString, as = (r) => Sv.call(r), td = (r) => as(r).slice(8, -1), Qv = (r) => as(r) === "[object Object]", rd = (r) => $e(r) && r !== "NaN" && r[0] !== "-" && "" + parseInt(r, 10) === r, Ho = /* @__PURE__ */ Br(
  // the leading comma is intentional so empty string "" is also included
  ",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted"
), $v = /* @__PURE__ */ Br("bind,cloak,else-if,else,for,html,if,model,on,once,pre,show,slot,text,memo"), cs = (r) => {
  const e = /* @__PURE__ */ Object.create(null);
  return (t) => e[t] || (e[t] = r(t));
}, Pv = /-(\w)/g, Ll = cs((r) => r.replace(Pv, (e, t) => t ? t.toUpperCase() : "")), Cv = /\B([A-Z])/g, Rr = cs((r) => r.replace(Cv, "-$1").toLowerCase()), no = cs((r) => r.charAt(0).toUpperCase() + r.slice(1)), el = cs((r) => r ? `on${no(r)}` : ""), Zi = (r, e) => !Object.is(r, e), di = (r, e) => {
  for (let t = 0; t < r.length; t++)
    r[t](e);
}, _n = (r, e, t) => {
  Object.defineProperty(r, e, {
    configurable: !0,
    enumerable: !1,
    value: t
  });
}, Of = (r) => {
  const e = parseFloat(r);
  return isNaN(e) ? r : e;
};
let ph;
const vf = () => ph || (ph = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : typeof global < "u" ? global : {});
function wn(r, ...e) {
  console.warn(`[Vue warn] ${r}`, ...e);
}
let Ot;
class Tv {
  constructor(e = !1) {
    this.detached = e, this.active = !0, this.effects = [], this.cleanups = [], this.parent = Ot, !e && Ot && (this.index = (Ot.scopes || (Ot.scopes = [])).push(this) - 1);
  }
  run(e) {
    if (this.active) {
      const t = Ot;
      try {
        return Ot = this, e();
      } finally {
        Ot = t;
      }
    } else
      ({}).NODE_ENV !== "production" && wn("cannot run an inactive effect scope.");
  }
  /**
   * This should only be called on non-detached scopes
   * @internal
   */
  on() {
    Ot = this;
  }
  /**
   * This should only be called on non-detached scopes
   * @internal
   */
  off() {
    Ot = this.parent;
  }
  stop(e) {
    if (this.active) {
      let t, l;
      for (t = 0, l = this.effects.length; t < l; t++)
        this.effects[t].stop();
      for (t = 0, l = this.cleanups.length; t < l; t++)
        this.cleanups[t]();
      if (this.scopes)
        for (t = 0, l = this.scopes.length; t < l; t++)
          this.scopes[t].stop(!0);
      if (!this.detached && this.parent && !e) {
        const i = this.parent.scopes.pop();
        i && i !== this && (this.parent.scopes[this.index] = i, i.index = this.index);
      }
      this.parent = void 0, this.active = !1;
    }
  }
}
function zv(r, e = Ot) {
  e && e.active && e.effects.push(r);
}
function Xv() {
  return Ot;
}
function Av(r) {
  Ot ? Ot.cleanups.push(r) : {}.NODE_ENV !== "production" && wn("onScopeDispose() is called when there is no active effect scope to be associated with.");
}
const Ri = (r) => {
  const e = new Set(r);
  return e.w = 0, e.n = 0, e;
}, xf = (r) => (r.w & Dr) > 0, _f = (r) => (r.n & Dr) > 0, Ev = ({ deps: r }) => {
  if (r.length)
    for (let e = 0; e < r.length; e++)
      r[e].w |= Dr;
}, Vv = (r) => {
  const { deps: e } = r;
  if (e.length) {
    let t = 0;
    for (let l = 0; l < e.length; l++) {
      const i = e[l];
      xf(i) && !_f(i) ? i.delete(r) : e[t++] = i, i.w &= ~Dr, i.n &= ~Dr;
    }
    e.length = t;
  }
}, Aa = /* @__PURE__ */ new WeakMap();
let _i = 0, Dr = 1;
const Ea = 30;
let ot;
const cl = Symbol({}.NODE_ENV !== "production" ? "iterate" : ""), Va = Symbol({}.NODE_ENV !== "production" ? "Map key iterate" : "");
class ld {
  constructor(e, t = null, l) {
    this.fn = e, this.scheduler = t, this.active = !0, this.deps = [], this.parent = void 0, zv(this, l);
  }
  run() {
    if (!this.active)
      return this.fn();
    let e = ot, t = Ar;
    for (; e; ) {
      if (e === this)
        return;
      e = e.parent;
    }
    try {
      return this.parent = ot, ot = this, Ar = !0, Dr = 1 << ++_i, _i <= Ea ? Ev(this) : uh(this), this.fn();
    } finally {
      _i <= Ea && Vv(this), Dr = 1 << --_i, ot = this.parent, Ar = t, this.parent = void 0, this.deferStop && this.stop();
    }
  }
  stop() {
    ot === this ? this.deferStop = !0 : this.active && (uh(this), this.onStop && this.onStop(), this.active = !1);
  }
}
function uh(r) {
  const { deps: e } = r;
  if (e.length) {
    for (let t = 0; t < e.length; t++)
      e[t].delete(r);
    e.length = 0;
  }
}
let Ar = !0;
const wf = [];
function _l() {
  wf.push(Ar), Ar = !1;
}
function wl() {
  const r = wf.pop();
  Ar = r === void 0 ? !0 : r;
}
function gt(r, e, t) {
  if (Ar && ot) {
    let l = Aa.get(r);
    l || Aa.set(r, l = /* @__PURE__ */ new Map());
    let i = l.get(t);
    i || l.set(t, i = Ri());
    const o = {}.NODE_ENV !== "production" ? { effect: ot, target: r, type: e, key: t } : void 0;
    Za(i, o);
  }
}
function Za(r, e) {
  let t = !1;
  _i <= Ea ? _f(r) || (r.n |= Dr, t = !xf(r)) : t = !r.has(ot), t && (r.add(ot), ot.deps.push(r), {}.NODE_ENV !== "production" && ot.onTrack && ot.onTrack(Object.assign({ effect: ot }, e)));
}
function ur(r, e, t, l, i, o) {
  const n = Aa.get(r);
  if (!n)
    return;
  let s = [];
  if (e === "clear")
    s = [...n.values()];
  else if (t === "length" && ee(r)) {
    const c = Of(l);
    n.forEach((d, h) => {
      (h === "length" || h >= c) && s.push(d);
    });
  } else
    switch (t !== void 0 && s.push(n.get(t)), e) {
      case "add":
        ee(r) ? rd(t) && s.push(n.get("length")) : (s.push(n.get(cl)), Nl(r) && s.push(n.get(Va)));
        break;
      case "delete":
        ee(r) || (s.push(n.get(cl)), Nl(r) && s.push(n.get(Va)));
        break;
      case "set":
        Nl(r) && s.push(n.get(cl));
        break;
    }
  const a = {}.NODE_ENV !== "production" ? { target: r, type: e, key: t, newValue: l, oldValue: i, oldTarget: o } : void 0;
  if (s.length === 1)
    s[0] && ({}.NODE_ENV !== "production" ? El(s[0], a) : El(s[0]));
  else {
    const c = [];
    for (const d of s)
      d && c.push(...d);
    ({}).NODE_ENV !== "production" ? El(Ri(c), a) : El(Ri(c));
  }
}
function El(r, e) {
  const t = ee(r) ? r : [...r];
  for (const l of t)
    l.computed && fh(l, e);
  for (const l of t)
    l.computed || fh(l, e);
}
function fh(r, e) {
  (r !== ot || r.allowRecurse) && ({}.NODE_ENV !== "production" && r.onTrigger && r.onTrigger(Ve({ effect: r }, e)), r.scheduler ? r.scheduler() : r.run());
}
const Zv = /* @__PURE__ */ Br("__proto__,__v_isRef,__isVue"), yf = new Set(
  /* @__PURE__ */ Object.getOwnPropertyNames(Symbol).filter((r) => r !== "arguments" && r !== "caller").map((r) => Symbol[r]).filter(Jc)
), Rv = /* @__PURE__ */ ds(), Dv = /* @__PURE__ */ ds(!1, !0), Wv = /* @__PURE__ */ ds(!0), Nv = /* @__PURE__ */ ds(!0, !0), gh = /* @__PURE__ */ Mv();
function Mv() {
  const r = {};
  return ["includes", "indexOf", "lastIndexOf"].forEach((e) => {
    r[e] = function(...t) {
      const l = oe(this);
      for (let o = 0, n = this.length; o < n; o++)
        gt(l, "get", o + "");
      const i = l[e](...t);
      return i === -1 || i === !1 ? l[e](...t.map(oe)) : i;
    };
  }), ["push", "pop", "shift", "unshift", "splice"].forEach((e) => {
    r[e] = function(...t) {
      _l();
      const l = oe(this)[e].apply(this, t);
      return wl(), l;
    };
  }), r;
}
function ds(r = !1, e = !1) {
  return function(l, i, o) {
    if (i === "__v_isReactive")
      return !r;
    if (i === "__v_isReadonly")
      return r;
    if (i === "__v_isShallow")
      return e;
    if (i === "__v_raw" && o === (r ? e ? zf : Tf : e ? Cf : Pf).get(l))
      return l;
    const n = ee(l);
    if (!r && n && ne(gh, i))
      return Reflect.get(gh, i, o);
    const s = Reflect.get(l, i, o);
    return (Jc(i) ? yf.has(i) : Zv(i)) || (r || gt(l, "get", i), e) ? s : je(s) ? n && rd(i) ? s : s.value : ve(s) ? r ? od(s) : us(s) : s;
  };
}
const Yv = /* @__PURE__ */ kf(), jv = /* @__PURE__ */ kf(!0);
function kf(r = !1) {
  return function(t, l, i, o) {
    let n = t[l];
    if (Wr(n) && je(n) && !je(i))
      return !1;
    if (!r && (!yn(i) && !Wr(i) && (n = oe(n), i = oe(i)), !ee(t) && je(n) && !je(i)))
      return n.value = i, !0;
    const s = ee(t) && rd(l) ? Number(l) < t.length : ne(t, l), a = Reflect.set(t, l, i, o);
    return t === oe(o) && (s ? Zi(i, n) && ur(t, "set", l, i, n) : ur(t, "add", l, i)), a;
  };
}
function Iv(r, e) {
  const t = ne(r, e), l = r[e], i = Reflect.deleteProperty(r, e);
  return i && t && ur(r, "delete", e, void 0, l), i;
}
function Uv(r, e) {
  const t = Reflect.has(r, e);
  return (!Jc(e) || !yf.has(e)) && gt(r, "has", e), t;
}
function qv(r) {
  return gt(r, "iterate", ee(r) ? "length" : cl), Reflect.ownKeys(r);
}
const Sf = {
  get: Rv,
  set: Yv,
  deleteProperty: Iv,
  has: Uv,
  ownKeys: qv
}, Qf = {
  get: Wv,
  set(r, e) {
    return {}.NODE_ENV !== "production" && wn(`Set operation on key "${String(e)}" failed: target is readonly.`, r), !0;
  },
  deleteProperty(r, e) {
    return {}.NODE_ENV !== "production" && wn(`Delete operation on key "${String(e)}" failed: target is readonly.`, r), !0;
  }
}, Bv = /* @__PURE__ */ Ve({}, Sf, {
  get: Dv,
  set: jv
}), Lv = /* @__PURE__ */ Ve({}, Qf, {
  get: Nv
}), id = (r) => r, hs = (r) => Reflect.getPrototypeOf(r);
function wo(r, e, t = !1, l = !1) {
  r = r.__v_raw;
  const i = oe(r), o = oe(e);
  t || (e !== o && gt(i, "get", e), gt(i, "get", o));
  const { has: n } = hs(i), s = l ? id : t ? nd : Di;
  if (n.call(i, e))
    return s(r.get(e));
  if (n.call(i, o))
    return s(r.get(o));
  r !== i && r.get(e);
}
function yo(r, e = !1) {
  const t = this.__v_raw, l = oe(t), i = oe(r);
  return e || (r !== i && gt(l, "has", r), gt(l, "has", i)), r === i ? t.has(r) : t.has(r) || t.has(i);
}
function ko(r, e = !1) {
  return r = r.__v_raw, !e && gt(oe(r), "iterate", cl), Reflect.get(r, "size", r);
}
function mh(r) {
  r = oe(r);
  const e = oe(this);
  return hs(e).has.call(e, r) || (e.add(r), ur(e, "add", r, r)), this;
}
function bh(r, e) {
  e = oe(e);
  const t = oe(this), { has: l, get: i } = hs(t);
  let o = l.call(t, r);
  o ? {}.NODE_ENV !== "production" && $f(t, l, r) : (r = oe(r), o = l.call(t, r));
  const n = i.call(t, r);
  return t.set(r, e), o ? Zi(e, n) && ur(t, "set", r, e, n) : ur(t, "add", r, e), this;
}
function Oh(r) {
  const e = oe(this), { has: t, get: l } = hs(e);
  let i = t.call(e, r);
  i ? {}.NODE_ENV !== "production" && $f(e, t, r) : (r = oe(r), i = t.call(e, r));
  const o = l ? l.call(e, r) : void 0, n = e.delete(r);
  return i && ur(e, "delete", r, void 0, o), n;
}
function vh() {
  const r = oe(this), e = r.size !== 0, t = {}.NODE_ENV !== "production" ? Nl(r) ? new Map(r) : new Set(r) : void 0, l = r.clear();
  return e && ur(r, "clear", void 0, void 0, t), l;
}
function So(r, e) {
  return function(l, i) {
    const o = this, n = o.__v_raw, s = oe(n), a = e ? id : r ? nd : Di;
    return !r && gt(s, "iterate", cl), n.forEach((c, d) => l.call(i, a(c), a(d), o));
  };
}
function Qo(r, e, t) {
  return function(...l) {
    const i = this.__v_raw, o = oe(i), n = Nl(o), s = r === "entries" || r === Symbol.iterator && n, a = r === "keys" && n, c = i[r](...l), d = t ? id : e ? nd : Di;
    return !e && gt(o, "iterate", a ? Va : cl), {
      // iterator protocol
      next() {
        const { value: h, done: p } = c.next();
        return p ? { value: h, done: p } : {
          value: s ? [d(h[0]), d(h[1])] : d(h),
          done: p
        };
      },
      // iterable protocol
      [Symbol.iterator]() {
        return this;
      }
    };
  };
}
function vr(r) {
  return function(...e) {
    if ({}.NODE_ENV !== "production") {
      const t = e[0] ? `on key "${e[0]}" ` : "";
      console.warn(`${no(r)} operation ${t}failed: target is readonly.`, oe(this));
    }
    return r === "delete" ? !1 : this;
  };
}
function Gv() {
  const r = {
    get(o) {
      return wo(this, o);
    },
    get size() {
      return ko(this);
    },
    has: yo,
    add: mh,
    set: bh,
    delete: Oh,
    clear: vh,
    forEach: So(!1, !1)
  }, e = {
    get(o) {
      return wo(this, o, !1, !0);
    },
    get size() {
      return ko(this);
    },
    has: yo,
    add: mh,
    set: bh,
    delete: Oh,
    clear: vh,
    forEach: So(!1, !0)
  }, t = {
    get(o) {
      return wo(this, o, !0);
    },
    get size() {
      return ko(this, !0);
    },
    has(o) {
      return yo.call(this, o, !0);
    },
    add: vr(
      "add"
      /* TriggerOpTypes.ADD */
    ),
    set: vr(
      "set"
      /* TriggerOpTypes.SET */
    ),
    delete: vr(
      "delete"
      /* TriggerOpTypes.DELETE */
    ),
    clear: vr(
      "clear"
      /* TriggerOpTypes.CLEAR */
    ),
    forEach: So(!0, !1)
  }, l = {
    get(o) {
      return wo(this, o, !0, !0);
    },
    get size() {
      return ko(this, !0);
    },
    has(o) {
      return yo.call(this, o, !0);
    },
    add: vr(
      "add"
      /* TriggerOpTypes.ADD */
    ),
    set: vr(
      "set"
      /* TriggerOpTypes.SET */
    ),
    delete: vr(
      "delete"
      /* TriggerOpTypes.DELETE */
    ),
    clear: vr(
      "clear"
      /* TriggerOpTypes.CLEAR */
    ),
    forEach: So(!0, !0)
  };
  return ["keys", "values", "entries", Symbol.iterator].forEach((o) => {
    r[o] = Qo(o, !1, !1), t[o] = Qo(o, !0, !1), e[o] = Qo(o, !1, !0), l[o] = Qo(o, !0, !0);
  }), [
    r,
    t,
    e,
    l
  ];
}
const [Fv, Hv, Kv, Jv] = /* @__PURE__ */ Gv();
function ps(r, e) {
  const t = e ? r ? Jv : Kv : r ? Hv : Fv;
  return (l, i, o) => i === "__v_isReactive" ? !r : i === "__v_isReadonly" ? r : i === "__v_raw" ? l : Reflect.get(ne(t, i) && i in l ? t : l, i, o);
}
const e0 = {
  get: /* @__PURE__ */ ps(!1, !1)
}, t0 = {
  get: /* @__PURE__ */ ps(!1, !0)
}, r0 = {
  get: /* @__PURE__ */ ps(!0, !1)
}, l0 = {
  get: /* @__PURE__ */ ps(!0, !0)
};
function $f(r, e, t) {
  const l = oe(t);
  if (l !== t && e.call(r, l)) {
    const i = td(r);
    console.warn(`Reactive ${i} contains both the raw and reactive versions of the same object${i === "Map" ? " as keys" : ""}, which can lead to inconsistencies. Avoid differentiating between the raw and reactive versions of an object and only use the reactive version if possible.`);
  }
}
const Pf = /* @__PURE__ */ new WeakMap(), Cf = /* @__PURE__ */ new WeakMap(), Tf = /* @__PURE__ */ new WeakMap(), zf = /* @__PURE__ */ new WeakMap();
function i0(r) {
  switch (r) {
    case "Object":
    case "Array":
      return 1;
    case "Map":
    case "Set":
    case "WeakMap":
    case "WeakSet":
      return 2;
    default:
      return 0;
  }
}
function o0(r) {
  return r.__v_skip || !Object.isExtensible(r) ? 0 : i0(td(r));
}
function us(r) {
  return Wr(r) ? r : fs(r, !1, Sf, e0, Pf);
}
function n0(r) {
  return fs(r, !1, Bv, t0, Cf);
}
function od(r) {
  return fs(r, !0, Qf, r0, Tf);
}
function Vl(r) {
  return fs(r, !0, Lv, l0, zf);
}
function fs(r, e, t, l, i) {
  if (!ve(r))
    return {}.NODE_ENV !== "production" && console.warn(`value cannot be made reactive: ${String(r)}`), r;
  if (r.__v_raw && !(e && r.__v_isReactive))
    return r;
  const o = i.get(r);
  if (o)
    return o;
  const n = o0(r);
  if (n === 0)
    return r;
  const s = new Proxy(r, n === 2 ? l : t);
  return i.set(r, s), s;
}
function dl(r) {
  return Wr(r) ? dl(r.__v_raw) : !!(r && r.__v_isReactive);
}
function Wr(r) {
  return !!(r && r.__v_isReadonly);
}
function yn(r) {
  return !!(r && r.__v_isShallow);
}
function Ra(r) {
  return dl(r) || Wr(r);
}
function oe(r) {
  const e = r && r.__v_raw;
  return e ? oe(e) : r;
}
function Xf(r) {
  return _n(r, "__v_skip", !0), r;
}
const Di = (r) => ve(r) ? us(r) : r, nd = (r) => ve(r) ? od(r) : r;
function Af(r) {
  Ar && ot && (r = oe(r), {}.NODE_ENV !== "production" ? Za(r.dep || (r.dep = Ri()), {
    target: r,
    type: "get",
    key: "value"
  }) : Za(r.dep || (r.dep = Ri())));
}
function Ef(r, e) {
  r = oe(r), r.dep && ({}.NODE_ENV !== "production" ? El(r.dep, {
    target: r,
    type: "set",
    key: "value",
    newValue: e
  }) : El(r.dep));
}
function je(r) {
  return !!(r && r.__v_isRef === !0);
}
function ke(r) {
  return Zf(r, !1);
}
function Vf(r) {
  return Zf(r, !0);
}
function Zf(r, e) {
  return je(r) ? r : new s0(r, e);
}
class s0 {
  constructor(e, t) {
    this.__v_isShallow = t, this.dep = void 0, this.__v_isRef = !0, this._rawValue = t ? e : oe(e), this._value = t ? e : Di(e);
  }
  get value() {
    return Af(this), this._value;
  }
  set value(e) {
    const t = this.__v_isShallow || yn(e) || Wr(e);
    e = t ? e : oe(e), Zi(e, this._rawValue) && (this._rawValue = e, this._value = t ? e : Di(e), Ef(this, e));
  }
}
function De(r) {
  return je(r) ? r.value : r;
}
const a0 = {
  get: (r, e, t) => De(Reflect.get(r, e, t)),
  set: (r, e, t, l) => {
    const i = r[e];
    return je(i) && !je(t) ? (i.value = t, !0) : Reflect.set(r, e, t, l);
  }
};
function Rf(r) {
  return dl(r) ? r : new Proxy(r, a0);
}
var Df;
class c0 {
  constructor(e, t, l, i) {
    this._setter = t, this.dep = void 0, this.__v_isRef = !0, this[Df] = !1, this._dirty = !0, this.effect = new ld(e, () => {
      this._dirty || (this._dirty = !0, Ef(this));
    }), this.effect.computed = this, this.effect.active = this._cacheable = !i, this.__v_isReadonly = l;
  }
  get value() {
    const e = oe(this);
    return Af(e), (e._dirty || !e._cacheable) && (e._dirty = !1, e._value = e.effect.run()), e._value;
  }
  set value(e) {
    this._setter(e);
  }
}
Df = "__v_isReadonly";
function d0(r, e, t = !1) {
  let l, i;
  const o = te(r);
  o ? (l = r, i = {}.NODE_ENV !== "production" ? () => {
    console.warn("Write operation failed: computed value is readonly");
  } : Me) : (l = r.get, i = r.set);
  const n = new c0(l, i, o || !i, t);
  return {}.NODE_ENV !== "production" && e && !t && (n.effect.onTrack = e.onTrack, n.effect.onTrigger = e.onTrigger), n;
}
const hl = [];
function Ko(r) {
  hl.push(r);
}
function Jo() {
  hl.pop();
}
function X(r, ...e) {
  if ({}.NODE_ENV === "production")
    return;
  _l();
  const t = hl.length ? hl[hl.length - 1].component : null, l = t && t.appContext.config.warnHandler, i = h0();
  if (l)
    dr(l, t, 11, [
      r + e.join(""),
      t && t.proxy,
      i.map(({ vnode: o }) => `at <${_s(t, o.type)}>`).join(`
`),
      i
    ]);
  else {
    const o = [`[Vue warn]: ${r}`, ...e];
    i.length && o.push(`
`, ...p0(i)), console.warn(...o);
  }
  wl();
}
function h0() {
  let r = hl[hl.length - 1];
  if (!r)
    return [];
  const e = [];
  for (; r; ) {
    const t = e[0];
    t && t.vnode === r ? t.recurseCount++ : e.push({
      vnode: r,
      recurseCount: 0
    });
    const l = r.component && r.component.parent;
    r = l && l.vnode;
  }
  return e;
}
function p0(r) {
  const e = [];
  return r.forEach((t, l) => {
    e.push(...l === 0 ? [] : [`
`], ...u0(t));
  }), e;
}
function u0({ vnode: r, recurseCount: e }) {
  const t = e > 0 ? `... (${e} recursive calls)` : "", l = r.component ? r.component.parent == null : !1, i = ` at <${_s(r.component, r.type, l)}`, o = ">" + t;
  return r.props ? [i, ...f0(r.props), o] : [i + o];
}
function f0(r) {
  const e = [], t = Object.keys(r);
  return t.slice(0, 3).forEach((l) => {
    e.push(...Wf(l, r[l]));
  }), t.length > 3 && e.push(" ..."), e;
}
function Wf(r, e, t) {
  return $e(e) ? (e = JSON.stringify(e), t ? e : [`${r}=${e}`]) : typeof e == "number" || typeof e == "boolean" || e == null ? t ? e : [`${r}=${e}`] : je(e) ? (e = Wf(r, oe(e.value), !0), t ? e : [`${r}=Ref<`, e, ">"]) : te(e) ? [`${r}=fn${e.name ? `<${e.name}>` : ""}`] : (e = oe(e), t ? e : [`${r}=`, e]);
}
const sd = {
  sp: "serverPrefetch hook",
  bc: "beforeCreate hook",
  c: "created hook",
  bm: "beforeMount hook",
  m: "mounted hook",
  bu: "beforeUpdate hook",
  u: "updated",
  bum: "beforeUnmount hook",
  um: "unmounted hook",
  a: "activated hook",
  da: "deactivated hook",
  ec: "errorCaptured hook",
  rtc: "renderTracked hook",
  rtg: "renderTriggered hook",
  [
    0
    /* ErrorCodes.SETUP_FUNCTION */
  ]: "setup function",
  [
    1
    /* ErrorCodes.RENDER_FUNCTION */
  ]: "render function",
  [
    2
    /* ErrorCodes.WATCH_GETTER */
  ]: "watcher getter",
  [
    3
    /* ErrorCodes.WATCH_CALLBACK */
  ]: "watcher callback",
  [
    4
    /* ErrorCodes.WATCH_CLEANUP */
  ]: "watcher cleanup function",
  [
    5
    /* ErrorCodes.NATIVE_EVENT_HANDLER */
  ]: "native event handler",
  [
    6
    /* ErrorCodes.COMPONENT_EVENT_HANDLER */
  ]: "component event handler",
  [
    7
    /* ErrorCodes.VNODE_HOOK */
  ]: "vnode hook",
  [
    8
    /* ErrorCodes.DIRECTIVE_HOOK */
  ]: "directive hook",
  [
    9
    /* ErrorCodes.TRANSITION_HOOK */
  ]: "transition hook",
  [
    10
    /* ErrorCodes.APP_ERROR_HANDLER */
  ]: "app errorHandler",
  [
    11
    /* ErrorCodes.APP_WARN_HANDLER */
  ]: "app warnHandler",
  [
    12
    /* ErrorCodes.FUNCTION_REF */
  ]: "ref function",
  [
    13
    /* ErrorCodes.ASYNC_COMPONENT_LOADER */
  ]: "async component loader",
  [
    14
    /* ErrorCodes.SCHEDULER */
  ]: "scheduler flush. This is likely a Vue internals bug. Please open an issue at https://new-issue.vuejs.org/?repo=vuejs/core"
};
function dr(r, e, t, l) {
  let i;
  try {
    i = l ? r(...l) : r();
  } catch (o) {
    gs(o, e, t);
  }
  return i;
}
function Dt(r, e, t, l) {
  if (te(r)) {
    const o = dr(r, e, t, l);
    return o && ed(o) && o.catch((n) => {
      gs(n, e, t);
    }), o;
  }
  const i = [];
  for (let o = 0; o < r.length; o++)
    i.push(Dt(r[o], e, t, l));
  return i;
}
function gs(r, e, t, l = !0) {
  const i = e ? e.vnode : null;
  if (e) {
    let o = e.parent;
    const n = e.proxy, s = {}.NODE_ENV !== "production" ? sd[t] : t;
    for (; o; ) {
      const c = o.ec;
      if (c) {
        for (let d = 0; d < c.length; d++)
          if (c[d](r, n, s) === !1)
            return;
      }
      o = o.parent;
    }
    const a = e.appContext.config.errorHandler;
    if (a) {
      dr(a, null, 10, [r, n, s]);
      return;
    }
  }
  g0(r, t, i, l);
}
function g0(r, e, t, l = !0) {
  if ({}.NODE_ENV !== "production") {
    const i = sd[e];
    if (t && Ko(t), X(`Unhandled error${i ? ` during execution of ${i}` : ""}`), t && Jo(), l)
      throw r;
    console.error(r);
  } else
    console.error(r);
}
let Wi = !1, Da = !1;
const He = [];
let Gt = 0;
const Ml = [];
let Bt = null, _r = 0;
const Nf = /* @__PURE__ */ Promise.resolve();
let ad = null;
const m0 = 100;
function so(r) {
  const e = ad || Nf;
  return r ? e.then(this ? r.bind(this) : r) : e;
}
function b0(r) {
  let e = Gt + 1, t = He.length;
  for (; e < t; ) {
    const l = e + t >>> 1;
    Ni(He[l]) < r ? e = l + 1 : t = l;
  }
  return e;
}
function ms(r) {
  (!He.length || !He.includes(r, Wi && r.allowRecurse ? Gt + 1 : Gt)) && (r.id == null ? He.push(r) : He.splice(b0(r.id), 0, r), Mf());
}
function Mf() {
  !Wi && !Da && (Da = !0, ad = Nf.then(If));
}
function O0(r) {
  const e = He.indexOf(r);
  e > Gt && He.splice(e, 1);
}
function Yf(r) {
  ee(r) ? Ml.push(...r) : (!Bt || !Bt.includes(r, r.allowRecurse ? _r + 1 : _r)) && Ml.push(r), Mf();
}
function xh(r, e = Wi ? Gt + 1 : 0) {
  for ({}.NODE_ENV !== "production" && (r = r || /* @__PURE__ */ new Map()); e < He.length; e++) {
    const t = He[e];
    if (t && t.pre) {
      if ({}.NODE_ENV !== "production" && cd(r, t))
        continue;
      He.splice(e, 1), e--, t();
    }
  }
}
function jf(r) {
  if (Ml.length) {
    const e = [...new Set(Ml)];
    if (Ml.length = 0, Bt) {
      Bt.push(...e);
      return;
    }
    for (Bt = e, {}.NODE_ENV !== "production" && (r = r || /* @__PURE__ */ new Map()), Bt.sort((t, l) => Ni(t) - Ni(l)), _r = 0; _r < Bt.length; _r++)
      ({}).NODE_ENV !== "production" && cd(r, Bt[_r]) || Bt[_r]();
    Bt = null, _r = 0;
  }
}
const Ni = (r) => r.id == null ? 1 / 0 : r.id, v0 = (r, e) => {
  const t = Ni(r) - Ni(e);
  if (t === 0) {
    if (r.pre && !e.pre)
      return -1;
    if (e.pre && !r.pre)
      return 1;
  }
  return t;
};
function If(r) {
  Da = !1, Wi = !0, {}.NODE_ENV !== "production" && (r = r || /* @__PURE__ */ new Map()), He.sort(v0);
  const e = {}.NODE_ENV !== "production" ? (t) => cd(r, t) : Me;
  try {
    for (Gt = 0; Gt < He.length; Gt++) {
      const t = He[Gt];
      if (t && t.active !== !1) {
        if ({}.NODE_ENV !== "production" && e(t))
          continue;
        dr(
          t,
          null,
          14
          /* ErrorCodes.SCHEDULER */
        );
      }
    }
  } finally {
    Gt = 0, He.length = 0, jf(r), Wi = !1, ad = null, (He.length || Ml.length) && If(r);
  }
}
function cd(r, e) {
  if (!r.has(e))
    r.set(e, 1);
  else {
    const t = r.get(e);
    if (t > m0) {
      const l = e.ownerInstance, i = l && _g(l.type);
      return X(`Maximum recursive updates exceeded${i ? ` in component <${i}>` : ""}. This means you have a reactive effect that is mutating its own dependencies and thus recursively triggering itself. Possible sources include component template, render function, updated hook or watcher source function.`), !0;
    } else
      r.set(e, t + 1);
  }
}
let pl = !1;
const Tl = /* @__PURE__ */ new Set();
({}).NODE_ENV !== "production" && (vf().__VUE_HMR_RUNTIME__ = {
  createRecord: qs(Uf),
  rerender: qs(w0),
  reload: qs(y0)
});
const ml = /* @__PURE__ */ new Map();
function x0(r) {
  const e = r.type.__hmrId;
  let t = ml.get(e);
  t || (Uf(e, r.type), t = ml.get(e)), t.instances.add(r);
}
function _0(r) {
  ml.get(r.type.__hmrId).instances.delete(r);
}
function Uf(r, e) {
  return ml.has(r) ? !1 : (ml.set(r, {
    initialDef: Ci(e),
    instances: /* @__PURE__ */ new Set()
  }), !0);
}
function Ci(r) {
  return wg(r) ? r.__vccOpts : r;
}
function w0(r, e) {
  const t = ml.get(r);
  t && (t.initialDef.render = e, [...t.instances].forEach((l) => {
    e && (l.render = e, Ci(l.type).render = e), l.renderCache = [], pl = !0, l.update(), pl = !1;
  }));
}
function y0(r, e) {
  const t = ml.get(r);
  if (!t)
    return;
  e = Ci(e), _h(t.initialDef, e);
  const l = [...t.instances];
  for (const i of l) {
    const o = Ci(i.type);
    Tl.has(o) || (o !== t.initialDef && _h(o, e), Tl.add(o)), i.appContext.optionsCache.delete(i.type), i.ceReload ? (Tl.add(o), i.ceReload(e.styles), Tl.delete(o)) : i.parent ? ms(i.parent.update) : i.appContext.reload ? i.appContext.reload() : typeof window < "u" ? window.location.reload() : console.warn("[HMR] Root or manually mounted instance modified. Full reload required.");
  }
  Yf(() => {
    for (const i of l)
      Tl.delete(Ci(i.type));
  });
}
function _h(r, e) {
  Ve(r, e);
  for (const t in r)
    t !== "__file" && !(t in e) && delete r[t];
}
function qs(r) {
  return (e, t) => {
    try {
      return r(e, t);
    } catch (l) {
      console.error(l), console.warn("[HMR] Something went wrong during Vue component hot-reload. Full reload required.");
    }
  };
}
let Ft, wi = [], Wa = !1;
function ao(r, ...e) {
  Ft ? Ft.emit(r, ...e) : Wa || wi.push({ event: r, args: e });
}
function qf(r, e) {
  var t, l;
  Ft = r, Ft ? (Ft.enabled = !0, wi.forEach(({ event: i, args: o }) => Ft.emit(i, ...o)), wi = []) : /* handle late devtools injection - only do this if we are in an actual */ /* browser environment to avoid the timer handle stalling test runner exit */ /* (#4815) */ typeof window < "u" && // some envs mock window but not fully
  window.HTMLElement && // also exclude jsdom
  !(!((l = (t = window.navigator) === null || t === void 0 ? void 0 : t.userAgent) === null || l === void 0) && l.includes("jsdom")) ? ((e.__VUE_DEVTOOLS_HOOK_REPLAY__ = e.__VUE_DEVTOOLS_HOOK_REPLAY__ || []).push((o) => {
    qf(o, e);
  }), setTimeout(() => {
    Ft || (e.__VUE_DEVTOOLS_HOOK_REPLAY__ = null, Wa = !0, wi = []);
  }, 3e3)) : (Wa = !0, wi = []);
}
function k0(r, e) {
  ao("app:init", r, e, {
    Fragment: kt,
    Text: ho,
    Comment: ft,
    Static: tn
  });
}
function S0(r) {
  ao("app:unmount", r);
}
const Q0 = /* @__PURE__ */ dd(
  "component:added"
  /* DevtoolsHooks.COMPONENT_ADDED */
), Bf = /* @__PURE__ */ dd(
  "component:updated"
  /* DevtoolsHooks.COMPONENT_UPDATED */
), $0 = /* @__PURE__ */ dd(
  "component:removed"
  /* DevtoolsHooks.COMPONENT_REMOVED */
), P0 = (r) => {
  Ft && typeof Ft.cleanupBuffer == "function" && // remove the component if it wasn't buffered
  !Ft.cleanupBuffer(r) && $0(r);
};
function dd(r) {
  return (e) => {
    ao(r, e.appContext.app, e.uid, e.parent ? e.parent.uid : void 0, e);
  };
}
const C0 = /* @__PURE__ */ Lf(
  "perf:start"
  /* DevtoolsHooks.PERFORMANCE_START */
), T0 = /* @__PURE__ */ Lf(
  "perf:end"
  /* DevtoolsHooks.PERFORMANCE_END */
);
function Lf(r) {
  return (e, t, l) => {
    ao(r, e.appContext.app, e.uid, e, t, l);
  };
}
function z0(r, e, t) {
  ao("component:emit", r.appContext.app, r, e, t);
}
function X0(r, e, ...t) {
  if (r.isUnmounted)
    return;
  const l = r.vnode.props || be;
  if ({}.NODE_ENV !== "production") {
    const { emitsOptions: d, propsOptions: [h] } = r;
    if (d)
      if (!(e in d))
        (!h || !(el(e) in h)) && X(`Component emitted event "${e}" but it is neither declared in the emits option nor as an "${el(e)}" prop.`);
      else {
        const p = d[e];
        te(p) && (p(...t) || X(`Invalid event arguments: event validation failed for event "${e}".`));
      }
  }
  let i = t;
  const o = e.startsWith("update:"), n = o && e.slice(7);
  if (n && n in l) {
    const d = `${n === "modelValue" ? "model" : n}Modifiers`, { number: h, trim: p } = l[d] || be;
    p && (i = t.map((u) => $e(u) ? u.trim() : u)), h && (i = t.map(Of));
  }
  if ({}.NODE_ENV !== "production" && z0(r, e, i), {}.NODE_ENV !== "production") {
    const d = e.toLowerCase();
    d !== e && l[el(d)] && X(`Event "${d}" is emitted in component ${_s(r, r.type)} but the handler is registered for "${e}". Note that HTML attributes are case-insensitive and you cannot use v-on to listen to camelCase events when using in-DOM templates. You should probably use "${Rr(e)}" instead of "${e}".`);
  }
  let s, a = l[s = el(e)] || // also try camelCase event handler (#2249)
  l[s = el(Ll(e))];
  !a && o && (a = l[s = el(Rr(e))]), a && Dt(a, r, 6, i);
  const c = l[s + "Once"];
  if (c) {
    if (!r.emitted)
      r.emitted = {};
    else if (r.emitted[s])
      return;
    r.emitted[s] = !0, Dt(c, r, 6, i);
  }
}
function Gf(r, e, t = !1) {
  const l = e.emitsCache, i = l.get(r);
  if (i !== void 0)
    return i;
  const o = r.emits;
  let n = {}, s = !1;
  if (!te(r)) {
    const a = (c) => {
      const d = Gf(c, e, !0);
      d && (s = !0, Ve(n, d));
    };
    !t && e.mixins.length && e.mixins.forEach(a), r.extends && a(r.extends), r.mixins && r.mixins.forEach(a);
  }
  return !o && !s ? (ve(r) && l.set(r, null), null) : (ee(o) ? o.forEach((a) => n[a] = null) : Ve(n, o), ve(r) && l.set(r, n), n);
}
function bs(r, e) {
  return !r || !oo(e) ? !1 : (e = e.slice(2).replace(/Once$/, ""), ne(r, e[0].toLowerCase() + e.slice(1)) || ne(r, Rr(e)) || ne(r, e));
}
let Ie = null, Ff = null;
function kn(r) {
  const e = Ie;
  return Ie = r, Ff = r && r.type.__scopeId || null, e;
}
function zl(r, e = Ie, t) {
  if (!e || r._n)
    return r;
  const l = (...i) => {
    l._d && zh(-1);
    const o = kn(e);
    let n;
    try {
      n = r(...i);
    } finally {
      kn(o), l._d && zh(1);
    }
    return {}.NODE_ENV !== "production" && Bf(e), n;
  };
  return l._n = !0, l._c = !0, l._d = !0, l;
}
let Na = !1;
function Sn() {
  Na = !0;
}
function Bs(r) {
  const { type: e, vnode: t, proxy: l, withProxy: i, props: o, propsOptions: [n], slots: s, attrs: a, emit: c, render: d, renderCache: h, data: p, setupState: u, ctx: f, inheritAttrs: m } = r;
  let O, x;
  const Q = kn(r);
  ({}).NODE_ENV !== "production" && (Na = !1);
  try {
    if (t.shapeFlag & 4) {
      const C = i || l;
      O = Vt(d.call(C, C, h, o, u, p, f)), x = a;
    } else {
      const C = e;
      ({}).NODE_ENV !== "production" && a === o && Sn(), O = Vt(C.length > 1 ? C(o, {}.NODE_ENV !== "production" ? {
        get attrs() {
          return Sn(), a;
        },
        slots: s,
        emit: c
      } : { attrs: a, slots: s, emit: c }) : C(
        o,
        null
        /* we know it doesn't need it */
      )), x = e.props ? a : E0(a);
    }
  } catch (C) {
    zi.length = 0, gs(
      C,
      r,
      1
      /* ErrorCodes.RENDER_FUNCTION */
    ), O = ce(ft);
  }
  let P = O, y;
  if ({}.NODE_ENV !== "production" && O.patchFlag > 0 && O.patchFlag & 2048 && ([P, y] = A0(O)), x && m !== !1) {
    const C = Object.keys(x), { shapeFlag: Z } = P;
    if (C.length) {
      if (Z & 7)
        n && C.some(xn) && (x = V0(x, n)), P = Nr(P, x);
      else if ({}.NODE_ENV !== "production" && !Na && P.type !== ft) {
        const G = Object.keys(a), W = [], D = [];
        for (let R = 0, F = G.length; R < F; R++) {
          const J = G[R];
          oo(J) ? xn(J) || W.push(J[2].toLowerCase() + J.slice(3)) : D.push(J);
        }
        D.length && X(`Extraneous non-props attributes (${D.join(", ")}) were passed to component but could not be automatically inherited because component renders fragment or text root nodes.`), W.length && X(`Extraneous non-emits event listeners (${W.join(", ")}) were passed to component but could not be automatically inherited because component renders fragment or text root nodes. If the listener is intended to be a component custom event listener only, declare it using the "emits" option.`);
      }
    }
  }
  return t.dirs && ({}.NODE_ENV !== "production" && !wh(P) && X("Runtime directive used on component with non-element root node. The directives will not function as intended."), P = Nr(P), P.dirs = P.dirs ? P.dirs.concat(t.dirs) : t.dirs), t.transition && ({}.NODE_ENV !== "production" && !wh(P) && X("Component inside <Transition> renders non-element root node that cannot be animated."), P.transition = t.transition), {}.NODE_ENV !== "production" && y ? y(P) : O = P, kn(Q), O;
}
const A0 = (r) => {
  const e = r.children, t = r.dynamicChildren, l = Hf(e);
  if (!l)
    return [r, void 0];
  const i = e.indexOf(l), o = t ? t.indexOf(l) : -1, n = (s) => {
    e[i] = s, t && (o > -1 ? t[o] = s : s.patchFlag > 0 && (r.dynamicChildren = [...t, s]));
  };
  return [Vt(l), n];
};
function Hf(r) {
  let e;
  for (let t = 0; t < r.length; t++) {
    const l = r[t];
    if (bl(l)) {
      if (l.type !== ft || l.children === "v-if") {
        if (e)
          return;
        e = l;
      }
    } else
      return;
  }
  return e;
}
const E0 = (r) => {
  let e;
  for (const t in r)
    (t === "class" || t === "style" || oo(t)) && ((e || (e = {}))[t] = r[t]);
  return e;
}, V0 = (r, e) => {
  const t = {};
  for (const l in r)
    (!xn(l) || !(l.slice(9) in e)) && (t[l] = r[l]);
  return t;
}, wh = (r) => r.shapeFlag & 7 || r.type === ft;
function Z0(r, e, t) {
  const { props: l, children: i, component: o } = r, { props: n, children: s, patchFlag: a } = e, c = o.emitsOptions;
  if ({}.NODE_ENV !== "production" && (i || s) && pl || e.dirs || e.transition)
    return !0;
  if (t && a >= 0) {
    if (a & 1024)
      return !0;
    if (a & 16)
      return l ? yh(l, n, c) : !!n;
    if (a & 8) {
      const d = e.dynamicProps;
      for (let h = 0; h < d.length; h++) {
        const p = d[h];
        if (n[p] !== l[p] && !bs(c, p))
          return !0;
      }
    }
  } else
    return (i || s) && (!s || !s.$stable) ? !0 : l === n ? !1 : l ? n ? yh(l, n, c) : !0 : !!n;
  return !1;
}
function yh(r, e, t) {
  const l = Object.keys(e);
  if (l.length !== Object.keys(r).length)
    return !0;
  for (let i = 0; i < l.length; i++) {
    const o = l[i];
    if (e[o] !== r[o] && !bs(t, o))
      return !0;
  }
  return !1;
}
function R0({ vnode: r, parent: e }, t) {
  for (; e && e.subTree === r; )
    (r = e.vnode).el = t, e = e.parent;
}
const D0 = (r) => r.__isSuspense;
function W0(r, e) {
  e && e.pendingBranch ? ee(r) ? e.effects.push(...r) : e.effects.push(r) : Yf(r);
}
function Kf(r, e) {
  if (!Ye)
    ({}).NODE_ENV !== "production" && X("provide() can only be used inside setup().");
  else {
    let t = Ye.provides;
    const l = Ye.parent && Ye.parent.provides;
    l === t && (t = Ye.provides = Object.create(l)), t[r] = e;
  }
}
function Er(r, e, t = !1) {
  const l = Ye || Ie;
  if (l) {
    const i = l.parent == null ? l.vnode.appContext && l.vnode.appContext.provides : l.parent.provides;
    if (i && r in i)
      return i[r];
    if (arguments.length > 1)
      return t && te(e) ? e.call(l.proxy) : e;
    ({}).NODE_ENV !== "production" && X(`injection "${String(r)}" not found.`);
  } else
    ({}).NODE_ENV !== "production" && X("inject() can only be used inside setup() or functional components.");
}
function N0(r, e) {
  return hd(r, null, e);
}
const $o = {};
function ut(r, e, t) {
  return {}.NODE_ENV !== "production" && !te(e) && X("`watch(fn, options?)` signature has been moved to a separate API. Use `watchEffect(fn, options?)` instead. `watch` now only supports `watch(source, cb, options?) signature."), hd(r, e, t);
}
function hd(r, e, { immediate: t, deep: l, flush: i, onTrack: o, onTrigger: n } = be) {
  ({}).NODE_ENV !== "production" && !e && (t !== void 0 && X('watch() "immediate" option is only respected when using the watch(source, callback, options?) signature.'), l !== void 0 && X('watch() "deep" option is only respected when using the watch(source, callback, options?) signature.'));
  const s = (y) => {
    X("Invalid watch source: ", y, "A watch source can only be a getter/effect function, a ref, a reactive object, or an array of these types.");
  }, a = Ye;
  let c, d = !1, h = !1;
  if (je(r) ? (c = () => r.value, d = yn(r)) : dl(r) ? (c = () => r, l = !0) : ee(r) ? (h = !0, d = r.some((y) => dl(y) || yn(y)), c = () => r.map((y) => {
    if (je(y))
      return y.value;
    if (dl(y))
      return nl(y);
    if (te(y))
      return dr(
        y,
        a,
        2
        /* ErrorCodes.WATCH_GETTER */
      );
    ({}).NODE_ENV !== "production" && s(y);
  })) : te(r) ? e ? c = () => dr(
    r,
    a,
    2
    /* ErrorCodes.WATCH_GETTER */
  ) : c = () => {
    if (!(a && a.isUnmounted))
      return p && p(), Dt(r, a, 3, [u]);
  } : (c = Me, {}.NODE_ENV !== "production" && s(r)), e && l) {
    const y = c;
    c = () => nl(y());
  }
  let p, u = (y) => {
    p = Q.onStop = () => {
      dr(
        y,
        a,
        4
        /* ErrorCodes.WATCH_CLEANUP */
      );
    };
  }, f;
  if (Yi)
    if (u = Me, e ? t && Dt(e, a, 3, [
      c(),
      h ? [] : void 0,
      u
    ]) : c(), i === "sync") {
      const y = Ix();
      f = y.__watcherHandles || (y.__watcherHandles = []);
    } else
      return Me;
  let m = h ? new Array(r.length).fill($o) : $o;
  const O = () => {
    if (Q.active)
      if (e) {
        const y = Q.run();
        (l || d || (h ? y.some((C, Z) => Zi(C, m[Z])) : Zi(y, m))) && (p && p(), Dt(e, a, 3, [
          y,
          // pass undefined as the old value when it's changed for the first time
          m === $o ? void 0 : h && m[0] === $o ? [] : m,
          u
        ]), m = y);
      } else
        Q.run();
  };
  O.allowRecurse = !!e;
  let x;
  i === "sync" ? x = O : i === "post" ? x = () => dt(O, a && a.suspense) : (O.pre = !0, a && (O.id = a.uid), x = () => ms(O));
  const Q = new ld(c, x);
  ({}).NODE_ENV !== "production" && (Q.onTrack = o, Q.onTrigger = n), e ? t ? O() : m = Q.run() : i === "post" ? dt(Q.run.bind(Q), a && a.suspense) : Q.run();
  const P = () => {
    Q.stop(), a && a.scope && Kc(a.scope.effects, Q);
  };
  return f && f.push(P), P;
}
function M0(r, e, t) {
  const l = this.proxy, i = $e(r) ? r.includes(".") ? Jf(l, r) : () => l[r] : r.bind(l, l);
  let o;
  te(e) ? o = e : (o = e.handler, t = e);
  const n = Ye;
  Gl(this);
  const s = hd(i, o.bind(l), t);
  return n ? Gl(n) : fl(), s;
}
function Jf(r, e) {
  const t = e.split(".");
  return () => {
    let l = r;
    for (let i = 0; i < t.length && l; i++)
      l = l[t[i]];
    return l;
  };
}
function nl(r, e) {
  if (!ve(r) || r.__v_skip || (e = e || /* @__PURE__ */ new Set(), e.has(r)))
    return r;
  if (e.add(r), je(r))
    nl(r.value, e);
  else if (ee(r))
    for (let t = 0; t < r.length; t++)
      nl(r[t], e);
  else if (kv(r) || Nl(r))
    r.forEach((t) => {
      nl(t, e);
    });
  else if (Qv(r))
    for (const t in r)
      nl(r[t], e);
  return r;
}
function Wt(r) {
  return te(r) ? { setup: r, name: r.name } : r;
}
const Ti = (r) => !!r.type.__asyncLoader, pd = (r) => r.type.__isKeepAlive;
function Y0(r, e) {
  eg(r, "a", e);
}
function j0(r, e) {
  eg(r, "da", e);
}
function eg(r, e, t = Ye) {
  const l = r.__wdc || (r.__wdc = () => {
    let i = t;
    for (; i; ) {
      if (i.isDeactivated)
        return;
      i = i.parent;
    }
    return r();
  });
  if (Os(e, l, t), t) {
    let i = t.parent;
    for (; i && i.parent; )
      pd(i.parent.vnode) && I0(l, e, t, i), i = i.parent;
  }
}
function I0(r, e, t, l) {
  const i = Os(
    e,
    r,
    l,
    !0
    /* prepend */
  );
  ud(() => {
    Kc(l[e], i);
  }, t);
}
function Os(r, e, t = Ye, l = !1) {
  if (t) {
    const i = t[r] || (t[r] = []), o = e.__weh || (e.__weh = (...n) => {
      if (t.isUnmounted)
        return;
      _l(), Gl(t);
      const s = Dt(e, t, r, n);
      return fl(), wl(), s;
    });
    return l ? i.unshift(o) : i.push(o), o;
  } else if ({}.NODE_ENV !== "production") {
    const i = el(sd[r].replace(/ hook$/, ""));
    X(`${i} is called when there is no active component instance to be associated with. Lifecycle injection APIs can only be used during execution of setup(). If you are using async setup(), make sure to register lifecycle hooks before the first await statement.`);
  }
}
const gr = (r) => (e, t = Ye) => (
  // post-create lifecycle registrations are noops during SSR (except for serverPrefetch)
  (!Yi || r === "sp") && Os(r, (...l) => e(...l), t)
), U0 = gr(
  "bm"
  /* LifecycleHooks.BEFORE_MOUNT */
), co = gr(
  "m"
  /* LifecycleHooks.MOUNTED */
), q0 = gr(
  "bu"
  /* LifecycleHooks.BEFORE_UPDATE */
), tg = gr(
  "u"
  /* LifecycleHooks.UPDATED */
), B0 = gr(
  "bum"
  /* LifecycleHooks.BEFORE_UNMOUNT */
), ud = gr(
  "um"
  /* LifecycleHooks.UNMOUNTED */
), L0 = gr(
  "sp"
  /* LifecycleHooks.SERVER_PREFETCH */
), G0 = gr(
  "rtg"
  /* LifecycleHooks.RENDER_TRIGGERED */
), F0 = gr(
  "rtc"
  /* LifecycleHooks.RENDER_TRACKED */
);
function H0(r, e = Ye) {
  Os("ec", r, e);
}
function rg(r) {
  $v(r) && X("Do not use built-in directive ids as custom directive id: " + r);
}
function K0(r, e) {
  const t = Ie;
  if (t === null)
    return {}.NODE_ENV !== "production" && X("withDirectives can only be used inside render functions."), r;
  const l = xs(t) || t.proxy, i = r.dirs || (r.dirs = []);
  for (let o = 0; o < e.length; o++) {
    let [n, s, a, c = be] = e[o];
    n && (te(n) && (n = {
      mounted: n,
      updated: n
    }), n.deep && nl(s), i.push({
      dir: n,
      instance: l,
      value: s,
      oldValue: void 0,
      arg: a,
      modifiers: c
    }));
  }
  return r;
}
function Fr(r, e, t, l) {
  const i = r.dirs, o = e && e.dirs;
  for (let n = 0; n < i.length; n++) {
    const s = i[n];
    o && (s.oldValue = o[n].value);
    let a = s.dir[l];
    a && (_l(), Dt(a, t, 8, [
      r.el,
      s,
      r,
      e
    ]), wl());
  }
}
const J0 = Symbol();
function fd(r, e, t = {}, l, i) {
  if (Ie.isCE || Ie.parent && Ti(Ie.parent) && Ie.parent.isCE)
    return e !== "default" && (t.name = e), ce("slot", t, l && l());
  let o = r[e];
  ({}).NODE_ENV !== "production" && o && o.length > 1 && (X("SSR-optimized slot function detected in a non-SSR-optimized render function. You need to mark this component with $dynamic-slots in the parent template."), o = () => []), o && o._c && (o._d = !1), Tt();
  const n = o && lg(o(t)), s = Od(
    kt,
    {
      key: t.key || // slot content array of a dynamic conditional slot may have a branch
      // key attached in the `createSlots` helper, respect that
      n && n.key || `_${e}`
    },
    n || (l ? l() : []),
    n && r._ === 1 ? 64 : -2
    /* PatchFlags.BAIL */
  );
  return !i && s.scopeId && (s.slotScopeIds = [s.scopeId + "-s"]), o && o._c && (o._d = !0), s;
}
function lg(r) {
  return r.some((e) => bl(e) ? !(e.type === ft || e.type === kt && !lg(e.children)) : !0) ? r : null;
}
const Ma = (r) => r ? Og(r) ? xs(r) || r.proxy : Ma(r.parent) : null, ul = (
  // Move PURE marker to new line to workaround compiler discarding it
  // due to type annotation
  /* @__PURE__ */ Ve(/* @__PURE__ */ Object.create(null), {
    $: (r) => r,
    $el: (r) => r.vnode.el,
    $data: (r) => r.data,
    $props: (r) => ({}).NODE_ENV !== "production" ? Vl(r.props) : r.props,
    $attrs: (r) => ({}).NODE_ENV !== "production" ? Vl(r.attrs) : r.attrs,
    $slots: (r) => ({}).NODE_ENV !== "production" ? Vl(r.slots) : r.slots,
    $refs: (r) => ({}).NODE_ENV !== "production" ? Vl(r.refs) : r.refs,
    $parent: (r) => Ma(r.parent),
    $root: (r) => Ma(r.root),
    $emit: (r) => r.emit,
    $options: (r) => md(r),
    $forceUpdate: (r) => r.f || (r.f = () => ms(r.update)),
    $nextTick: (r) => r.n || (r.n = so.bind(r.proxy)),
    $watch: (r) => M0.bind(r)
  })
), gd = (r) => r === "_" || r === "$", Ls = (r, e) => r !== be && !r.__isScriptSetup && ne(r, e), ig = {
  get({ _: r }, e) {
    const { ctx: t, setupState: l, data: i, props: o, accessCache: n, type: s, appContext: a } = r;
    if ({}.NODE_ENV !== "production" && e === "__isVue")
      return !0;
    let c;
    if (e[0] !== "$") {
      const u = n[e];
      if (u !== void 0)
        switch (u) {
          case 1:
            return l[e];
          case 2:
            return i[e];
          case 4:
            return t[e];
          case 3:
            return o[e];
        }
      else {
        if (Ls(l, e))
          return n[e] = 1, l[e];
        if (i !== be && ne(i, e))
          return n[e] = 2, i[e];
        if (
          // only cache other properties when instance has declared (thus stable)
          // props
          (c = r.propsOptions[0]) && ne(c, e)
        )
          return n[e] = 3, o[e];
        if (t !== be && ne(t, e))
          return n[e] = 4, t[e];
        Ya && (n[e] = 0);
      }
    }
    const d = ul[e];
    let h, p;
    if (d)
      return e === "$attrs" && (gt(r, "get", e), {}.NODE_ENV !== "production" && Sn()), d(r);
    if (
      // css module (injected by vue-loader)
      (h = s.__cssModules) && (h = h[e])
    )
      return h;
    if (t !== be && ne(t, e))
      return n[e] = 4, t[e];
    if (
      // global properties
      p = a.config.globalProperties, ne(p, e)
    )
      return p[e];
    ({}).NODE_ENV !== "production" && Ie && (!$e(e) || // #1091 avoid internal isRef/isVNode checks on component instance leading
    // to infinite warning loop
    e.indexOf("__v") !== 0) && (i !== be && gd(e[0]) && ne(i, e) ? X(`Property ${JSON.stringify(e)} must be accessed via $data because it starts with a reserved character ("$" or "_") and is not proxied on the render context.`) : r === Ie && X(`Property ${JSON.stringify(e)} was accessed during render but is not defined on instance.`));
  },
  set({ _: r }, e, t) {
    const { data: l, setupState: i, ctx: o } = r;
    return Ls(i, e) ? (i[e] = t, !0) : {}.NODE_ENV !== "production" && i.__isScriptSetup && ne(i, e) ? (X(`Cannot mutate <script setup> binding "${e}" from Options API.`), !1) : l !== be && ne(l, e) ? (l[e] = t, !0) : ne(r.props, e) ? ({}.NODE_ENV !== "production" && X(`Attempting to mutate prop "${e}". Props are readonly.`), !1) : e[0] === "$" && e.slice(1) in r ? ({}.NODE_ENV !== "production" && X(`Attempting to mutate public property "${e}". Properties starting with $ are reserved and readonly.`), !1) : ({}.NODE_ENV !== "production" && e in r.appContext.config.globalProperties ? Object.defineProperty(o, e, {
      enumerable: !0,
      configurable: !0,
      value: t
    }) : o[e] = t, !0);
  },
  has({ _: { data: r, setupState: e, accessCache: t, ctx: l, appContext: i, propsOptions: o } }, n) {
    let s;
    return !!t[n] || r !== be && ne(r, n) || Ls(e, n) || (s = o[0]) && ne(s, n) || ne(l, n) || ne(ul, n) || ne(i.config.globalProperties, n);
  },
  defineProperty(r, e, t) {
    return t.get != null ? r._.accessCache[e] = 0 : ne(t, "value") && this.set(r, e, t.value, null), Reflect.defineProperty(r, e, t);
  }
};
({}).NODE_ENV !== "production" && (ig.ownKeys = (r) => (X("Avoid app logic that relies on enumerating keys on a component instance. The keys will be empty in production mode to avoid performance overhead."), Reflect.ownKeys(r)));
function ex(r) {
  const e = {};
  return Object.defineProperty(e, "_", {
    configurable: !0,
    enumerable: !1,
    get: () => r
  }), Object.keys(ul).forEach((t) => {
    Object.defineProperty(e, t, {
      configurable: !0,
      enumerable: !1,
      get: () => ul[t](r),
      // intercepted by the proxy so no need for implementation,
      // but needed to prevent set errors
      set: Me
    });
  }), e;
}
function tx(r) {
  const { ctx: e, propsOptions: [t] } = r;
  t && Object.keys(t).forEach((l) => {
    Object.defineProperty(e, l, {
      enumerable: !0,
      configurable: !0,
      get: () => r.props[l],
      set: Me
    });
  });
}
function rx(r) {
  const { ctx: e, setupState: t } = r;
  Object.keys(oe(t)).forEach((l) => {
    if (!t.__isScriptSetup) {
      if (gd(l[0])) {
        X(`setup() return property ${JSON.stringify(l)} should not start with "$" or "_" which are reserved prefixes for Vue internals.`);
        return;
      }
      Object.defineProperty(e, l, {
        enumerable: !0,
        configurable: !0,
        get: () => t[l],
        set: Me
      });
    }
  });
}
function lx() {
  const r = /* @__PURE__ */ Object.create(null);
  return (e, t) => {
    r[t] ? X(`${e} property "${t}" is already defined in ${r[t]}.`) : r[t] = e;
  };
}
let Ya = !0;
function ix(r) {
  const e = md(r), t = r.proxy, l = r.ctx;
  Ya = !1, e.beforeCreate && kh(
    e.beforeCreate,
    r,
    "bc"
    /* LifecycleHooks.BEFORE_CREATE */
  );
  const {
    // state
    data: i,
    computed: o,
    methods: n,
    watch: s,
    provide: a,
    inject: c,
    // lifecycle
    created: d,
    beforeMount: h,
    mounted: p,
    beforeUpdate: u,
    updated: f,
    activated: m,
    deactivated: O,
    beforeDestroy: x,
    beforeUnmount: Q,
    destroyed: P,
    unmounted: y,
    render: C,
    renderTracked: Z,
    renderTriggered: G,
    errorCaptured: W,
    serverPrefetch: D,
    // public API
    expose: R,
    inheritAttrs: F,
    // assets
    components: J,
    directives: ie,
    filters: fe
  } = e, ae = {}.NODE_ENV !== "production" ? lx() : null;
  if ({}.NODE_ENV !== "production") {
    const [K] = r.propsOptions;
    if (K)
      for (const q in K)
        ae("Props", q);
  }
  if (c && ox(c, l, ae, r.appContext.config.unwrapInjectedRef), n)
    for (const K in n) {
      const q = n[K];
      te(q) ? ({}.NODE_ENV !== "production" ? Object.defineProperty(l, K, {
        value: q.bind(t),
        configurable: !0,
        enumerable: !0,
        writable: !0
      }) : l[K] = q.bind(t), {}.NODE_ENV !== "production" && ae("Methods", K)) : {}.NODE_ENV !== "production" && X(`Method "${K}" has type "${typeof q}" in the component definition. Did you reference the function correctly?`);
    }
  if (i) {
    ({}).NODE_ENV !== "production" && !te(i) && X("The data option must be a function. Plain object usage is no longer supported.");
    const K = i.call(t, t);
    if ({}.NODE_ENV !== "production" && ed(K) && X("data() returned a Promise - note data() cannot be async; If you intend to perform data fetching before component renders, use async setup() + <Suspense>."), !ve(K))
      ({}).NODE_ENV !== "production" && X("data() should return an object.");
    else if (r.data = us(K), {}.NODE_ENV !== "production")
      for (const q in K)
        ae("Data", q), gd(q[0]) || Object.defineProperty(l, q, {
          configurable: !0,
          enumerable: !0,
          get: () => K[q],
          set: Me
        });
  }
  if (Ya = !0, o)
    for (const K in o) {
      const q = o[K], he = te(q) ? q.bind(t, t) : te(q.get) ? q.get.bind(t, t) : Me;
      ({}).NODE_ENV !== "production" && he === Me && X(`Computed property "${K}" has no getter.`);
      const et = !te(q) && te(q.set) ? q.set.bind(t) : {}.NODE_ENV !== "production" ? () => {
        X(`Write operation failed: computed property "${K}" is readonly.`);
      } : Me, tt = Mr({
        get: he,
        set: et
      });
      Object.defineProperty(l, K, {
        enumerable: !0,
        configurable: !0,
        get: () => tt.value,
        set: (rt) => tt.value = rt
      }), {}.NODE_ENV !== "production" && ae("Computed", K);
    }
  if (s)
    for (const K in s)
      og(s[K], l, t, K);
  if (a) {
    const K = te(a) ? a.call(t) : a;
    Reflect.ownKeys(K).forEach((q) => {
      Kf(q, K[q]);
    });
  }
  d && kh(
    d,
    r,
    "c"
    /* LifecycleHooks.CREATED */
  );
  function H(K, q) {
    ee(q) ? q.forEach((he) => K(he.bind(t))) : q && K(q.bind(t));
  }
  if (H(U0, h), H(co, p), H(q0, u), H(tg, f), H(Y0, m), H(j0, O), H(H0, W), H(F0, Z), H(G0, G), H(B0, Q), H(ud, y), H(L0, D), ee(R))
    if (R.length) {
      const K = r.exposed || (r.exposed = {});
      R.forEach((q) => {
        Object.defineProperty(K, q, {
          get: () => t[q],
          set: (he) => t[q] = he
        });
      });
    } else
      r.exposed || (r.exposed = {});
  C && r.render === Me && (r.render = C), F != null && (r.inheritAttrs = F), J && (r.components = J), ie && (r.directives = ie);
}
function ox(r, e, t = Me, l = !1) {
  ee(r) && (r = ja(r));
  for (const i in r) {
    const o = r[i];
    let n;
    ve(o) ? "default" in o ? n = Er(
      o.from || i,
      o.default,
      !0
      /* treat default function as factory */
    ) : n = Er(o.from || i) : n = Er(o), je(n) ? l ? Object.defineProperty(e, i, {
      enumerable: !0,
      configurable: !0,
      get: () => n.value,
      set: (s) => n.value = s
    }) : ({}.NODE_ENV !== "production" && X(`injected property "${i}" is a ref and will be auto-unwrapped and no longer needs \`.value\` in the next minor release. To opt-in to the new behavior now, set \`app.config.unwrapInjectedRef = true\` (this config is temporary and will not be needed in the future.)`), e[i] = n) : e[i] = n, {}.NODE_ENV !== "production" && t("Inject", i);
  }
}
function kh(r, e, t) {
  Dt(ee(r) ? r.map((l) => l.bind(e.proxy)) : r.bind(e.proxy), e, t);
}
function og(r, e, t, l) {
  const i = l.includes(".") ? Jf(t, l) : () => t[l];
  if ($e(r)) {
    const o = e[r];
    te(o) ? ut(i, o) : {}.NODE_ENV !== "production" && X(`Invalid watch handler specified by key "${r}"`, o);
  } else if (te(r))
    ut(i, r.bind(t));
  else if (ve(r))
    if (ee(r))
      r.forEach((o) => og(o, e, t, l));
    else {
      const o = te(r.handler) ? r.handler.bind(t) : e[r.handler];
      te(o) ? ut(i, o, r) : {}.NODE_ENV !== "production" && X(`Invalid watch handler specified by key "${r.handler}"`, o);
    }
  else
    ({}).NODE_ENV !== "production" && X(`Invalid watch option: "${l}"`, r);
}
function md(r) {
  const e = r.type, { mixins: t, extends: l } = e, { mixins: i, optionsCache: o, config: { optionMergeStrategies: n } } = r.appContext, s = o.get(e);
  let a;
  return s ? a = s : !i.length && !t && !l ? a = e : (a = {}, i.length && i.forEach((c) => Qn(a, c, n, !0)), Qn(a, e, n)), ve(e) && o.set(e, a), a;
}
function Qn(r, e, t, l = !1) {
  const { mixins: i, extends: o } = e;
  o && Qn(r, o, t, !0), i && i.forEach((n) => Qn(r, n, t, !0));
  for (const n in e)
    if (l && n === "expose")
      ({}).NODE_ENV !== "production" && X('"expose" option is ignored when declared in mixins or extends. It should only be declared in the base component itself.');
    else {
      const s = nx[n] || t && t[n];
      r[n] = s ? s(r[n], e[n]) : e[n];
    }
  return r;
}
const nx = {
  data: Sh,
  props: tl,
  emits: tl,
  // objects
  methods: tl,
  computed: tl,
  // lifecycle
  beforeCreate: it,
  created: it,
  beforeMount: it,
  mounted: it,
  beforeUpdate: it,
  updated: it,
  beforeDestroy: it,
  beforeUnmount: it,
  destroyed: it,
  unmounted: it,
  activated: it,
  deactivated: it,
  errorCaptured: it,
  serverPrefetch: it,
  // assets
  components: tl,
  directives: tl,
  // watch
  watch: ax,
  // provide / inject
  provide: Sh,
  inject: sx
};
function Sh(r, e) {
  return e ? r ? function() {
    return Ve(te(r) ? r.call(this, this) : r, te(e) ? e.call(this, this) : e);
  } : e : r;
}
function sx(r, e) {
  return tl(ja(r), ja(e));
}
function ja(r) {
  if (ee(r)) {
    const e = {};
    for (let t = 0; t < r.length; t++)
      e[r[t]] = r[t];
    return e;
  }
  return r;
}
function it(r, e) {
  return r ? [...new Set([].concat(r, e))] : e;
}
function tl(r, e) {
  return r ? Ve(Ve(/* @__PURE__ */ Object.create(null), r), e) : e;
}
function ax(r, e) {
  if (!r)
    return e;
  if (!e)
    return r;
  const t = Ve(/* @__PURE__ */ Object.create(null), r);
  for (const l in e)
    t[l] = it(r[l], e[l]);
  return t;
}
function cx(r, e, t, l = !1) {
  const i = {}, o = {};
  _n(o, vs, 1), r.propsDefaults = /* @__PURE__ */ Object.create(null), ng(r, e, i, o);
  for (const n in r.propsOptions[0])
    n in i || (i[n] = void 0);
  ({}).NODE_ENV !== "production" && ag(e || {}, i, r), t ? r.props = l ? i : n0(i) : r.type.props ? r.props = i : r.props = o, r.attrs = o;
}
function dx(r) {
  for (; r; ) {
    if (r.type.__hmrId)
      return !0;
    r = r.parent;
  }
}
function hx(r, e, t, l) {
  const { props: i, attrs: o, vnode: { patchFlag: n } } = r, s = oe(i), [a] = r.propsOptions;
  let c = !1;
  if (
    // always force full diff in dev
    // - #1942 if hmr is enabled with sfc component
    // - vite#872 non-sfc component used by sfc component
    !({}.NODE_ENV !== "production" && dx(r)) && (l || n > 0) && !(n & 16)
  ) {
    if (n & 8) {
      const d = r.vnode.dynamicProps;
      for (let h = 0; h < d.length; h++) {
        let p = d[h];
        if (bs(r.emitsOptions, p))
          continue;
        const u = e[p];
        if (a)
          if (ne(o, p))
            u !== o[p] && (o[p] = u, c = !0);
          else {
            const f = Ll(p);
            i[f] = Ia(
              a,
              s,
              f,
              u,
              r,
              !1
              /* isAbsent */
            );
          }
        else
          u !== o[p] && (o[p] = u, c = !0);
      }
    }
  } else {
    ng(r, e, i, o) && (c = !0);
    let d;
    for (const h in s)
      (!e || // for camelCase
      !ne(e, h) && // it's possible the original props was passed in as kebab-case
      // and converted to camelCase (#955)
      ((d = Rr(h)) === h || !ne(e, d))) && (a ? t && // for camelCase
      (t[h] !== void 0 || // for kebab-case
      t[d] !== void 0) && (i[h] = Ia(
        a,
        s,
        h,
        void 0,
        r,
        !0
        /* isAbsent */
      )) : delete i[h]);
    if (o !== s)
      for (const h in o)
        (!e || !ne(e, h)) && (delete o[h], c = !0);
  }
  c && ur(r, "set", "$attrs"), {}.NODE_ENV !== "production" && ag(e || {}, i, r);
}
function ng(r, e, t, l) {
  const [i, o] = r.propsOptions;
  let n = !1, s;
  if (e)
    for (let a in e) {
      if (Ho(a))
        continue;
      const c = e[a];
      let d;
      i && ne(i, d = Ll(a)) ? !o || !o.includes(d) ? t[d] = c : (s || (s = {}))[d] = c : bs(r.emitsOptions, a) || (!(a in l) || c !== l[a]) && (l[a] = c, n = !0);
    }
  if (o) {
    const a = oe(t), c = s || be;
    for (let d = 0; d < o.length; d++) {
      const h = o[d];
      t[h] = Ia(i, a, h, c[h], r, !ne(c, h));
    }
  }
  return n;
}
function Ia(r, e, t, l, i, o) {
  const n = r[t];
  if (n != null) {
    const s = ne(n, "default");
    if (s && l === void 0) {
      const a = n.default;
      if (n.type !== Function && te(a)) {
        const { propsDefaults: c } = i;
        t in c ? l = c[t] : (Gl(i), l = c[t] = a.call(null, e), fl());
      } else
        l = a;
    }
    n[
      0
      /* BooleanFlags.shouldCast */
    ] && (o && !s ? l = !1 : n[
      1
      /* BooleanFlags.shouldCastTrue */
    ] && (l === "" || l === Rr(t)) && (l = !0));
  }
  return l;
}
function sg(r, e, t = !1) {
  const l = e.propsCache, i = l.get(r);
  if (i)
    return i;
  const o = r.props, n = {}, s = [];
  let a = !1;
  if (!te(r)) {
    const d = (h) => {
      a = !0;
      const [p, u] = sg(h, e, !0);
      Ve(n, p), u && s.push(...u);
    };
    !t && e.mixins.length && e.mixins.forEach(d), r.extends && d(r.extends), r.mixins && r.mixins.forEach(d);
  }
  if (!o && !a)
    return ve(r) && l.set(r, Wl), Wl;
  if (ee(o))
    for (let d = 0; d < o.length; d++) {
      ({}).NODE_ENV !== "production" && !$e(o[d]) && X("props must be strings when using array syntax.", o[d]);
      const h = Ll(o[d]);
      Qh(h) && (n[h] = be);
    }
  else if (o) {
    ({}).NODE_ENV !== "production" && !ve(o) && X("invalid props options", o);
    for (const d in o) {
      const h = Ll(d);
      if (Qh(h)) {
        const p = o[d], u = n[h] = ee(p) || te(p) ? { type: p } : Object.assign({}, p);
        if (u) {
          const f = Ph(Boolean, u.type), m = Ph(String, u.type);
          u[
            0
            /* BooleanFlags.shouldCast */
          ] = f > -1, u[
            1
            /* BooleanFlags.shouldCastTrue */
          ] = m < 0 || f < m, (f > -1 || ne(u, "default")) && s.push(h);
        }
      }
    }
  }
  const c = [n, s];
  return ve(r) && l.set(r, c), c;
}
function Qh(r) {
  return r[0] !== "$" ? !0 : ({}.NODE_ENV !== "production" && X(`Invalid prop name: "${r}" is a reserved property.`), !1);
}
function Ua(r) {
  const e = r && r.toString().match(/^\s*function (\w+)/);
  return e ? e[1] : r === null ? "null" : "";
}
function $h(r, e) {
  return Ua(r) === Ua(e);
}
function Ph(r, e) {
  return ee(e) ? e.findIndex((t) => $h(t, r)) : te(e) && $h(e, r) ? 0 : -1;
}
function ag(r, e, t) {
  const l = oe(e), i = t.propsOptions[0];
  for (const o in i) {
    let n = i[o];
    n != null && px(o, l[o], n, !ne(r, o) && !ne(r, Rr(o)));
  }
}
function px(r, e, t, l) {
  const { type: i, required: o, validator: n } = t;
  if (o && l) {
    X('Missing required prop: "' + r + '"');
    return;
  }
  if (!(e == null && !t.required)) {
    if (i != null && i !== !0) {
      let s = !1;
      const a = ee(i) ? i : [i], c = [];
      for (let d = 0; d < a.length && !s; d++) {
        const { valid: h, expectedType: p } = fx(e, a[d]);
        c.push(p || ""), s = h;
      }
      if (!s) {
        X(gx(r, e, c));
        return;
      }
    }
    n && !n(e) && X('Invalid prop: custom validator check failed for prop "' + r + '".');
  }
}
const ux = /* @__PURE__ */ Br("String,Number,Boolean,Function,Symbol,BigInt");
function fx(r, e) {
  let t;
  const l = Ua(e);
  if (ux(l)) {
    const i = typeof r;
    t = i === l.toLowerCase(), !t && i === "object" && (t = r instanceof e);
  } else
    l === "Object" ? t = ve(r) : l === "Array" ? t = ee(r) : l === "null" ? t = r === null : t = r instanceof e;
  return {
    valid: t,
    expectedType: l
  };
}
function gx(r, e, t) {
  let l = `Invalid prop: type check failed for prop "${r}". Expected ${t.map(no).join(" | ")}`;
  const i = t[0], o = td(e), n = Ch(e, i), s = Ch(e, o);
  return t.length === 1 && Th(i) && !mx(i, o) && (l += ` with value ${n}`), l += `, got ${o} `, Th(o) && (l += `with value ${s}.`), l;
}
function Ch(r, e) {
  return e === "String" ? `"${r}"` : e === "Number" ? `${Number(r)}` : `${r}`;
}
function Th(r) {
  return ["string", "number", "boolean"].some((t) => r.toLowerCase() === t);
}
function mx(...r) {
  return r.some((e) => e.toLowerCase() === "boolean");
}
const cg = (r) => r[0] === "_" || r === "$stable", bd = (r) => ee(r) ? r.map(Vt) : [Vt(r)], bx = (r, e, t) => {
  if (e._n)
    return e;
  const l = zl((...i) => ({}.NODE_ENV !== "production" && Ye && X(`Slot "${r}" invoked outside of the render function: this will not track dependencies used in the slot. Invoke the slot function inside the render function instead.`), bd(e(...i))), t);
  return l._c = !1, l;
}, dg = (r, e, t) => {
  const l = r._ctx;
  for (const i in r) {
    if (cg(i))
      continue;
    const o = r[i];
    if (te(o))
      e[i] = bx(i, o, l);
    else if (o != null) {
      ({}).NODE_ENV !== "production" && X(`Non-function value encountered for slot "${i}". Prefer function slots for better performance.`);
      const n = bd(o);
      e[i] = () => n;
    }
  }
}, hg = (r, e) => {
  ({}).NODE_ENV !== "production" && !pd(r.vnode) && X("Non-function value encountered for default slot. Prefer function slots for better performance.");
  const t = bd(e);
  r.slots.default = () => t;
}, Ox = (r, e) => {
  if (r.vnode.shapeFlag & 32) {
    const t = e._;
    t ? (r.slots = oe(e), _n(e, "_", t)) : dg(e, r.slots = {});
  } else
    r.slots = {}, e && hg(r, e);
  _n(r.slots, vs, 1);
}, vx = (r, e, t) => {
  const { vnode: l, slots: i } = r;
  let o = !0, n = be;
  if (l.shapeFlag & 32) {
    const s = e._;
    s ? {}.NODE_ENV !== "production" && pl ? Ve(i, e) : t && s === 1 ? o = !1 : (Ve(i, e), !t && s === 1 && delete i._) : (o = !e.$stable, dg(e, i)), n = e;
  } else
    e && (hg(r, e), n = { default: 1 });
  if (o)
    for (const s in i)
      !cg(s) && !(s in n) && delete i[s];
};
function pg() {
  return {
    app: null,
    config: {
      isNativeTag: bf,
      performance: !1,
      globalProperties: {},
      optionMergeStrategies: {},
      errorHandler: void 0,
      warnHandler: void 0,
      compilerOptions: {}
    },
    mixins: [],
    components: {},
    directives: {},
    provides: /* @__PURE__ */ Object.create(null),
    optionsCache: /* @__PURE__ */ new WeakMap(),
    propsCache: /* @__PURE__ */ new WeakMap(),
    emitsCache: /* @__PURE__ */ new WeakMap()
  };
}
let xx = 0;
function _x(r, e) {
  return function(l, i = null) {
    te(l) || (l = Object.assign({}, l)), i != null && !ve(i) && ({}.NODE_ENV !== "production" && X("root props passed to app.mount() must be an object."), i = null);
    const o = pg(), n = /* @__PURE__ */ new Set();
    let s = !1;
    const a = o.app = {
      _uid: xx++,
      _component: l,
      _props: i,
      _container: null,
      _context: o,
      _instance: null,
      version: Eh,
      get config() {
        return o.config;
      },
      set config(c) {
        ({}).NODE_ENV !== "production" && X("app.config cannot be replaced. Modify individual options instead.");
      },
      use(c, ...d) {
        return n.has(c) ? {}.NODE_ENV !== "production" && X("Plugin has already been applied to target app.") : c && te(c.install) ? (n.add(c), c.install(a, ...d)) : te(c) ? (n.add(c), c(a, ...d)) : {}.NODE_ENV !== "production" && X('A plugin must either be a function or an object with an "install" function.'), a;
      },
      mixin(c) {
        return o.mixins.includes(c) ? {}.NODE_ENV !== "production" && X("Mixin has already been applied to target app" + (c.name ? `: ${c.name}` : "")) : o.mixins.push(c), a;
      },
      component(c, d) {
        return {}.NODE_ENV !== "production" && Ba(c, o.config), d ? ({}.NODE_ENV !== "production" && o.components[c] && X(`Component "${c}" has already been registered in target app.`), o.components[c] = d, a) : o.components[c];
      },
      directive(c, d) {
        return {}.NODE_ENV !== "production" && rg(c), d ? ({}.NODE_ENV !== "production" && o.directives[c] && X(`Directive "${c}" has already been registered in target app.`), o.directives[c] = d, a) : o.directives[c];
      },
      mount(c, d, h) {
        if (s)
          ({}).NODE_ENV !== "production" && X("App has already been mounted.\nIf you want to remount the same app, move your app creation logic into a factory function and create fresh app instances for each mount - e.g. `const createMyApp = () => createApp(App)`");
        else {
          ({}).NODE_ENV !== "production" && c.__vue_app__ && X("There is already an app instance mounted on the host container.\n If you want to mount another app on the same host container, you need to unmount the previous app by calling `app.unmount()` first.");
          const p = ce(l, i);
          return p.appContext = o, {}.NODE_ENV !== "production" && (o.reload = () => {
            r(Nr(p), c, h);
          }), d && e ? e(p, c) : r(p, c, h), s = !0, a._container = c, c.__vue_app__ = a, {}.NODE_ENV !== "production" && (a._instance = p.component, k0(a, Eh)), xs(p.component) || p.component.proxy;
        }
      },
      unmount() {
        s ? (r(null, a._container), {}.NODE_ENV !== "production" && (a._instance = null, S0(a)), delete a._container.__vue_app__) : {}.NODE_ENV !== "production" && X("Cannot unmount an app that is not mounted.");
      },
      provide(c, d) {
        return {}.NODE_ENV !== "production" && c in o.provides && X(`App already provides property with key "${String(c)}". It will be overwritten with the new value.`), o.provides[c] = d, a;
      }
    };
    return a;
  };
}
function qa(r, e, t, l, i = !1) {
  if (ee(r)) {
    r.forEach((p, u) => qa(p, e && (ee(e) ? e[u] : e), t, l, i));
    return;
  }
  if (Ti(l) && !i)
    return;
  const o = l.shapeFlag & 4 ? xs(l.component) || l.component.proxy : l.el, n = i ? null : o, { i: s, r: a } = r;
  if ({}.NODE_ENV !== "production" && !s) {
    X("Missing ref owner context. ref cannot be used on hoisted vnodes. A vnode with ref must be created inside the render function.");
    return;
  }
  const c = e && e.r, d = s.refs === be ? s.refs = {} : s.refs, h = s.setupState;
  if (c != null && c !== a && ($e(c) ? (d[c] = null, ne(h, c) && (h[c] = null)) : je(c) && (c.value = null)), te(a))
    dr(a, s, 12, [n, d]);
  else {
    const p = $e(a), u = je(a);
    if (p || u) {
      const f = () => {
        if (r.f) {
          const m = p ? ne(h, a) ? h[a] : d[a] : a.value;
          i ? ee(m) && Kc(m, o) : ee(m) ? m.includes(o) || m.push(o) : p ? (d[a] = [o], ne(h, a) && (h[a] = d[a])) : (a.value = [o], r.k && (d[r.k] = a.value));
        } else
          p ? (d[a] = n, ne(h, a) && (h[a] = n)) : u ? (a.value = n, r.k && (d[r.k] = n)) : {}.NODE_ENV !== "production" && X("Invalid template ref type:", a, `(${typeof a})`);
      };
      n ? (f.id = -1, dt(f, t)) : f();
    } else
      ({}).NODE_ENV !== "production" && X("Invalid template ref type:", a, `(${typeof a})`);
  }
}
let hi, Sr;
function sr(r, e) {
  r.appContext.config.performance && $n() && Sr.mark(`vue-${e}-${r.uid}`), {}.NODE_ENV !== "production" && C0(r, e, $n() ? Sr.now() : Date.now());
}
function ar(r, e) {
  if (r.appContext.config.performance && $n()) {
    const t = `vue-${e}-${r.uid}`, l = t + ":end";
    Sr.mark(l), Sr.measure(`<${_s(r, r.type)}> ${e}`, t, l), Sr.clearMarks(t), Sr.clearMarks(l);
  }
  ({}).NODE_ENV !== "production" && T0(r, e, $n() ? Sr.now() : Date.now());
}
function $n() {
  return hi !== void 0 || (typeof window < "u" && window.performance ? (hi = !0, Sr = window.performance) : hi = !1), hi;
}
function wx() {
  const r = [];
  if ({}.NODE_ENV !== "production" && r.length) {
    const e = r.length > 1;
    console.warn(`Feature flag${e ? "s" : ""} ${r.join(", ")} ${e ? "are" : "is"} not explicitly defined. You are running the esm-bundler build of Vue, which expects these compile-time feature flags to be globally injected via the bundler config in order to get better tree-shaking in the production bundle.

For more details, see https://link.vuejs.org/feature-flags.`);
  }
}
const dt = W0;
function yx(r) {
  return kx(r);
}
function kx(r, e) {
  wx();
  const t = vf();
  t.__VUE__ = !0, {}.NODE_ENV !== "production" && qf(t.__VUE_DEVTOOLS_GLOBAL_HOOK__, t);
  const { insert: l, remove: i, patchProp: o, createElement: n, createText: s, createComment: a, setText: c, setElementText: d, parentNode: h, nextSibling: p, setScopeId: u = Me, insertStaticContent: f } = r, m = (g, b, _, S = null, k = null, z = null, V = !1, T = null, A = {}.NODE_ENV !== "production" && pl ? !1 : !!b.dynamicChildren) => {
    if (g === b)
      return;
    g && !pi(g, b) && (S = _o(g), Xe(g, k, z, !0), g = null), b.patchFlag === -2 && (A = !1, b.dynamicChildren = null);
    const { type: $, ref: U, shapeFlag: N } = b;
    switch ($) {
      case ho:
        O(g, b, _, S);
        break;
      case ft:
        x(g, b, _, S);
        break;
      case tn:
        g == null ? Q(b, _, S, V) : {}.NODE_ENV !== "production" && P(g, b, _, V);
        break;
      case kt:
        ie(g, b, _, S, k, z, V, T, A);
        break;
      default:
        N & 1 ? Z(g, b, _, S, k, z, V, T, A) : N & 6 ? fe(g, b, _, S, k, z, V, T, A) : N & 64 || N & 128 ? $.process(g, b, _, S, k, z, V, T, A, $l) : {}.NODE_ENV !== "production" && X("Invalid VNode type:", $, `(${typeof $})`);
    }
    U != null && k && qa(U, g && g.ref, z, b || g, !b);
  }, O = (g, b, _, S) => {
    if (g == null)
      l(b.el = s(b.children), _, S);
    else {
      const k = b.el = g.el;
      b.children !== g.children && c(k, b.children);
    }
  }, x = (g, b, _, S) => {
    g == null ? l(b.el = a(b.children || ""), _, S) : b.el = g.el;
  }, Q = (g, b, _, S) => {
    [g.el, g.anchor] = f(g.children, b, _, S, g.el, g.anchor);
  }, P = (g, b, _, S) => {
    if (b.children !== g.children) {
      const k = p(g.anchor);
      C(g), [b.el, b.anchor] = f(b.children, _, k, S);
    } else
      b.el = g.el, b.anchor = g.anchor;
  }, y = ({ el: g, anchor: b }, _, S) => {
    let k;
    for (; g && g !== b; )
      k = p(g), l(g, _, S), g = k;
    l(b, _, S);
  }, C = ({ el: g, anchor: b }) => {
    let _;
    for (; g && g !== b; )
      _ = p(g), i(g), g = _;
    i(b);
  }, Z = (g, b, _, S, k, z, V, T, A) => {
    V = V || b.type === "svg", g == null ? G(b, _, S, k, z, V, T, A) : R(g, b, k, z, V, T, A);
  }, G = (g, b, _, S, k, z, V, T) => {
    let A, $;
    const { type: U, props: N, shapeFlag: L, transition: re, dirs: de } = g;
    if (A = g.el = n(g.type, z, N && N.is, N), L & 8 ? d(A, g.children) : L & 16 && D(g.children, A, null, S, k, z && U !== "foreignObject", V, T), de && Fr(g, null, S, "created"), N) {
      for (const me in N)
        me !== "value" && !Ho(me) && o(A, me, null, N[me], z, g.children, S, k, nr);
      "value" in N && o(A, "value", null, N.value), ($ = N.onVnodeBeforeMount) && Yt($, S, g);
    }
    W(A, g, g.scopeId, V, S), {}.NODE_ENV !== "production" && (Object.defineProperty(A, "__vnode", {
      value: g,
      enumerable: !1
    }), Object.defineProperty(A, "__vueParentComponent", {
      value: S,
      enumerable: !1
    })), de && Fr(g, null, S, "beforeMount");
    const Oe = (!k || k && !k.pendingBranch) && re && !re.persisted;
    Oe && re.beforeEnter(A), l(A, b, _), (($ = N && N.onVnodeMounted) || Oe || de) && dt(() => {
      $ && Yt($, S, g), Oe && re.enter(A), de && Fr(g, null, S, "mounted");
    }, k);
  }, W = (g, b, _, S, k) => {
    if (_ && u(g, _), S)
      for (let z = 0; z < S.length; z++)
        u(g, S[z]);
    if (k) {
      let z = k.subTree;
      if ({}.NODE_ENV !== "production" && z.patchFlag > 0 && z.patchFlag & 2048 && (z = Hf(z.children) || z), b === z) {
        const V = k.vnode;
        W(g, V, V.scopeId, V.slotScopeIds, k.parent);
      }
    }
  }, D = (g, b, _, S, k, z, V, T, A = 0) => {
    for (let $ = A; $ < g.length; $++) {
      const U = g[$] = T ? wr(g[$]) : Vt(g[$]);
      m(null, U, b, _, S, k, z, V, T);
    }
  }, R = (g, b, _, S, k, z, V) => {
    const T = b.el = g.el;
    let { patchFlag: A, dynamicChildren: $, dirs: U } = b;
    A |= g.patchFlag & 16;
    const N = g.props || be, L = b.props || be;
    let re;
    _ && Hr(_, !1), (re = L.onVnodeBeforeUpdate) && Yt(re, _, b, g), U && Fr(b, g, _, "beforeUpdate"), _ && Hr(_, !0), {}.NODE_ENV !== "production" && pl && (A = 0, V = !1, $ = null);
    const de = k && b.type !== "foreignObject";
    if ($ ? (F(g.dynamicChildren, $, T, _, S, de, z), {}.NODE_ENV !== "production" && _ && _.type.__hmrId && en(g, b)) : V || he(g, b, T, null, _, S, de, z, !1), A > 0) {
      if (A & 16)
        J(T, b, N, L, _, S, k);
      else if (A & 2 && N.class !== L.class && o(T, "class", null, L.class, k), A & 4 && o(T, "style", N.style, L.style, k), A & 8) {
        const Oe = b.dynamicProps;
        for (let me = 0; me < Oe.length; me++) {
          const Ee = Oe[me], Xt = N[Ee], Pl = L[Ee];
          (Pl !== Xt || Ee === "value") && o(T, Ee, Xt, Pl, k, g.children, _, S, nr);
        }
      }
      A & 1 && g.children !== b.children && d(T, b.children);
    } else
      !V && $ == null && J(T, b, N, L, _, S, k);
    ((re = L.onVnodeUpdated) || U) && dt(() => {
      re && Yt(re, _, b, g), U && Fr(b, g, _, "updated");
    }, S);
  }, F = (g, b, _, S, k, z, V) => {
    for (let T = 0; T < b.length; T++) {
      const A = g[T], $ = b[T], U = (
        // oldVNode may be an errored async setup() component inside Suspense
        // which will not have a mounted element
        A.el && // - In the case of a Fragment, we need to provide the actual parent
        // of the Fragment itself so it can move its children.
        (A.type === kt || // - In the case of different nodes, there is going to be a replacement
        // which also requires the correct parent container
        !pi(A, $) || // - In the case of a component, it could contain anything.
        A.shapeFlag & 70) ? h(A.el) : (
          // In other cases, the parent container is not actually used so we
          // just pass the block element here to avoid a DOM parentNode call.
          _
        )
      );
      m(A, $, U, null, S, k, z, V, !0);
    }
  }, J = (g, b, _, S, k, z, V) => {
    if (_ !== S) {
      if (_ !== be)
        for (const T in _)
          !Ho(T) && !(T in S) && o(g, T, _[T], null, V, b.children, k, z, nr);
      for (const T in S) {
        if (Ho(T))
          continue;
        const A = S[T], $ = _[T];
        A !== $ && T !== "value" && o(g, T, $, A, V, b.children, k, z, nr);
      }
      "value" in S && o(g, "value", _.value, S.value);
    }
  }, ie = (g, b, _, S, k, z, V, T, A) => {
    const $ = b.el = g ? g.el : s(""), U = b.anchor = g ? g.anchor : s("");
    let { patchFlag: N, dynamicChildren: L, slotScopeIds: re } = b;
    ({}).NODE_ENV !== "production" && // #5523 dev root fragment may inherit directives
    (pl || N & 2048) && (N = 0, A = !1, L = null), re && (T = T ? T.concat(re) : re), g == null ? (l($, _, S), l(U, _, S), D(b.children, _, U, k, z, V, T, A)) : N > 0 && N & 64 && L && // #2715 the previous fragment could've been a BAILed one as a result
    // of renderSlot() with no valid children
    g.dynamicChildren ? (F(g.dynamicChildren, L, _, k, z, V, T), {}.NODE_ENV !== "production" && k && k.type.__hmrId ? en(g, b) : (
      // #2080 if the stable fragment has a key, it's a <template v-for> that may
      //  get moved around. Make sure all root level vnodes inherit el.
      // #2134 or if it's a component root, it may also get moved around
      // as the component is being moved.
      (b.key != null || k && b === k.subTree) && en(
        g,
        b,
        !0
        /* shallow */
      )
    )) : he(g, b, _, U, k, z, V, T, A);
  }, fe = (g, b, _, S, k, z, V, T, A) => {
    b.slotScopeIds = T, g == null ? b.shapeFlag & 512 ? k.ctx.activate(b, _, S, V, A) : ae(b, _, S, k, z, V, A) : H(g, b, A);
  }, ae = (g, b, _, S, k, z, V) => {
    const T = g.component = Ex(g, S, k);
    if ({}.NODE_ENV !== "production" && T.type.__hmrId && x0(T), {}.NODE_ENV !== "production" && (Ko(g), sr(T, "mount")), pd(g) && (T.ctx.renderer = $l), {}.NODE_ENV !== "production" && sr(T, "init"), Zx(T), {}.NODE_ENV !== "production" && ar(T, "init"), T.asyncDep) {
      if (k && k.registerDep(T, K), !g.el) {
        const A = T.subTree = ce(ft);
        x(null, A, b, _);
      }
      return;
    }
    K(T, g, b, _, k, z, V), {}.NODE_ENV !== "production" && (Jo(), ar(T, "mount"));
  }, H = (g, b, _) => {
    const S = b.component = g.component;
    if (Z0(g, b, _))
      if (S.asyncDep && !S.asyncResolved) {
        ({}).NODE_ENV !== "production" && Ko(b), q(S, b, _), {}.NODE_ENV !== "production" && Jo();
        return;
      } else
        S.next = b, O0(S.update), S.update();
    else
      b.el = g.el, S.vnode = b;
  }, K = (g, b, _, S, k, z, V) => {
    const T = () => {
      if (g.isMounted) {
        let { next: U, bu: N, u: L, parent: re, vnode: de } = g, Oe = U, me;
        ({}).NODE_ENV !== "production" && Ko(U || g.vnode), Hr(g, !1), U ? (U.el = de.el, q(g, U, V)) : U = de, N && di(N), (me = U.props && U.props.onVnodeBeforeUpdate) && Yt(me, re, U, de), Hr(g, !0), {}.NODE_ENV !== "production" && sr(g, "render");
        const Ee = Bs(g);
        ({}).NODE_ENV !== "production" && ar(g, "render");
        const Xt = g.subTree;
        g.subTree = Ee, {}.NODE_ENV !== "production" && sr(g, "patch"), m(
          Xt,
          Ee,
          // parent may have changed if it's in a teleport
          h(Xt.el),
          // anchor may have changed if it's in a fragment
          _o(Xt),
          g,
          k,
          z
        ), {}.NODE_ENV !== "production" && ar(g, "patch"), U.el = Ee.el, Oe === null && R0(g, Ee.el), L && dt(L, k), (me = U.props && U.props.onVnodeUpdated) && dt(() => Yt(me, re, U, de), k), {}.NODE_ENV !== "production" && Bf(g), {}.NODE_ENV !== "production" && Jo();
      } else {
        let U;
        const { el: N, props: L } = b, { bm: re, m: de, parent: Oe } = g, me = Ti(b);
        if (Hr(g, !1), re && di(re), !me && (U = L && L.onVnodeBeforeMount) && Yt(U, Oe, b), Hr(g, !0), N && Us) {
          const Ee = () => {
            ({}).NODE_ENV !== "production" && sr(g, "render"), g.subTree = Bs(g), {}.NODE_ENV !== "production" && ar(g, "render"), {}.NODE_ENV !== "production" && sr(g, "hydrate"), Us(N, g.subTree, g, k, null), {}.NODE_ENV !== "production" && ar(g, "hydrate");
          };
          me ? b.type.__asyncLoader().then(
            // note: we are moving the render call into an async callback,
            // which means it won't track dependencies - but it's ok because
            // a server-rendered async wrapper is already in resolved state
            // and it will never need to change.
            () => !g.isUnmounted && Ee()
          ) : Ee();
        } else {
          ({}).NODE_ENV !== "production" && sr(g, "render");
          const Ee = g.subTree = Bs(g);
          ({}).NODE_ENV !== "production" && ar(g, "render"), {}.NODE_ENV !== "production" && sr(g, "patch"), m(null, Ee, _, S, g, k, z), {}.NODE_ENV !== "production" && ar(g, "patch"), b.el = Ee.el;
        }
        if (de && dt(de, k), !me && (U = L && L.onVnodeMounted)) {
          const Ee = b;
          dt(() => Yt(U, Oe, Ee), k);
        }
        (b.shapeFlag & 256 || Oe && Ti(Oe.vnode) && Oe.vnode.shapeFlag & 256) && g.a && dt(g.a, k), g.isMounted = !0, {}.NODE_ENV !== "production" && Q0(g), b = _ = S = null;
      }
    }, A = g.effect = new ld(
      T,
      () => ms($),
      g.scope
      // track it in component's effect scope
    ), $ = g.update = () => A.run();
    $.id = g.uid, Hr(g, !0), {}.NODE_ENV !== "production" && (A.onTrack = g.rtc ? (U) => di(g.rtc, U) : void 0, A.onTrigger = g.rtg ? (U) => di(g.rtg, U) : void 0, $.ownerInstance = g), $();
  }, q = (g, b, _) => {
    b.component = g;
    const S = g.vnode.props;
    g.vnode = b, g.next = null, hx(g, b.props, S, _), vx(g, b.children, _), _l(), xh(), wl();
  }, he = (g, b, _, S, k, z, V, T, A = !1) => {
    const $ = g && g.children, U = g ? g.shapeFlag : 0, N = b.children, { patchFlag: L, shapeFlag: re } = b;
    if (L > 0) {
      if (L & 128) {
        tt($, N, _, S, k, z, V, T, A);
        return;
      } else if (L & 256) {
        et($, N, _, S, k, z, V, T, A);
        return;
      }
    }
    re & 8 ? (U & 16 && nr($, k, z), N !== $ && d(_, N)) : U & 16 ? re & 16 ? tt($, N, _, S, k, z, V, T, A) : nr($, k, z, !0) : (U & 8 && d(_, ""), re & 16 && D(N, _, S, k, z, V, T, A));
  }, et = (g, b, _, S, k, z, V, T, A) => {
    g = g || Wl, b = b || Wl;
    const $ = g.length, U = b.length, N = Math.min($, U);
    let L;
    for (L = 0; L < N; L++) {
      const re = b[L] = A ? wr(b[L]) : Vt(b[L]);
      m(g[L], re, _, null, k, z, V, T, A);
    }
    $ > U ? nr(g, k, z, !0, !1, N) : D(b, _, S, k, z, V, T, A, N);
  }, tt = (g, b, _, S, k, z, V, T, A) => {
    let $ = 0;
    const U = b.length;
    let N = g.length - 1, L = U - 1;
    for (; $ <= N && $ <= L; ) {
      const re = g[$], de = b[$] = A ? wr(b[$]) : Vt(b[$]);
      if (pi(re, de))
        m(re, de, _, null, k, z, V, T, A);
      else
        break;
      $++;
    }
    for (; $ <= N && $ <= L; ) {
      const re = g[N], de = b[L] = A ? wr(b[L]) : Vt(b[L]);
      if (pi(re, de))
        m(re, de, _, null, k, z, V, T, A);
      else
        break;
      N--, L--;
    }
    if ($ > N) {
      if ($ <= L) {
        const re = L + 1, de = re < U ? b[re].el : S;
        for (; $ <= L; )
          m(null, b[$] = A ? wr(b[$]) : Vt(b[$]), _, de, k, z, V, T, A), $++;
      }
    } else if ($ > L)
      for (; $ <= N; )
        Xe(g[$], k, z, !0), $++;
    else {
      const re = $, de = $, Oe = /* @__PURE__ */ new Map();
      for ($ = de; $ <= L; $++) {
        const lt = b[$] = A ? wr(b[$]) : Vt(b[$]);
        lt.key != null && ({}.NODE_ENV !== "production" && Oe.has(lt.key) && X("Duplicate keys found during update:", JSON.stringify(lt.key), "Make sure keys are unique."), Oe.set(lt.key, $));
      }
      let me, Ee = 0;
      const Xt = L - de + 1;
      let Pl = !1, ch = 0;
      const ci = new Array(Xt);
      for ($ = 0; $ < Xt; $++)
        ci[$] = 0;
      for ($ = re; $ <= N; $++) {
        const lt = g[$];
        if (Ee >= Xt) {
          Xe(lt, k, z, !0);
          continue;
        }
        let Mt;
        if (lt.key != null)
          Mt = Oe.get(lt.key);
        else
          for (me = de; me <= L; me++)
            if (ci[me - de] === 0 && pi(lt, b[me])) {
              Mt = me;
              break;
            }
        Mt === void 0 ? Xe(lt, k, z, !0) : (ci[Mt - de] = $ + 1, Mt >= ch ? ch = Mt : Pl = !0, m(lt, b[Mt], _, null, k, z, V, T, A), Ee++);
      }
      const dh = Pl ? Sx(ci) : Wl;
      for (me = dh.length - 1, $ = Xt - 1; $ >= 0; $--) {
        const lt = de + $, Mt = b[lt], hh = lt + 1 < U ? b[lt + 1].el : S;
        ci[$] === 0 ? m(null, Mt, _, hh, k, z, V, T, A) : Pl && (me < 0 || $ !== dh[me] ? rt(
          Mt,
          _,
          hh,
          2
          /* MoveType.REORDER */
        ) : me--);
      }
    }
  }, rt = (g, b, _, S, k = null) => {
    const { el: z, type: V, transition: T, children: A, shapeFlag: $ } = g;
    if ($ & 6) {
      rt(g.component.subTree, b, _, S);
      return;
    }
    if ($ & 128) {
      g.suspense.move(b, _, S);
      return;
    }
    if ($ & 64) {
      V.move(g, b, _, $l);
      return;
    }
    if (V === kt) {
      l(z, b, _);
      for (let N = 0; N < A.length; N++)
        rt(A[N], b, _, S);
      l(g.anchor, b, _);
      return;
    }
    if (V === tn) {
      y(g, b, _);
      return;
    }
    if (S !== 2 && $ & 1 && T)
      if (S === 0)
        T.beforeEnter(z), l(z, b, _), dt(() => T.enter(z), k);
      else {
        const { leave: N, delayLeave: L, afterLeave: re } = T, de = () => l(z, b, _), Oe = () => {
          N(z, () => {
            de(), re && re();
          });
        };
        L ? L(z, de, Oe) : Oe();
      }
    else
      l(z, b, _);
  }, Xe = (g, b, _, S = !1, k = !1) => {
    const { type: z, props: V, ref: T, children: A, dynamicChildren: $, shapeFlag: U, patchFlag: N, dirs: L } = g;
    if (T != null && qa(T, null, _, g, !0), U & 256) {
      b.ctx.deactivate(g);
      return;
    }
    const re = U & 1 && L, de = !Ti(g);
    let Oe;
    if (de && (Oe = V && V.onVnodeBeforeUnmount) && Yt(Oe, b, g), U & 6)
      cv(g.component, _, S);
    else {
      if (U & 128) {
        g.suspense.unmount(_, S);
        return;
      }
      re && Fr(g, null, b, "beforeUnmount"), U & 64 ? g.type.remove(g, b, _, k, $l, S) : $ && // #1153: fast path should not be taken for non-stable (v-for) fragments
      (z !== kt || N > 0 && N & 64) ? nr($, b, _, !1, !0) : (z === kt && N & 384 || !k && U & 16) && nr(A, b, _), S && Ql(g);
    }
    (de && (Oe = V && V.onVnodeUnmounted) || re) && dt(() => {
      Oe && Yt(Oe, b, g), re && Fr(g, null, b, "unmounted");
    }, _);
  }, Ql = (g) => {
    const { type: b, el: _, anchor: S, transition: k } = g;
    if (b === kt) {
      ({}).NODE_ENV !== "production" && g.patchFlag > 0 && g.patchFlag & 2048 && k && !k.persisted ? g.children.forEach((V) => {
        V.type === ft ? i(V.el) : Ql(V);
      }) : av(_, S);
      return;
    }
    if (b === tn) {
      C(g);
      return;
    }
    const z = () => {
      i(_), k && !k.persisted && k.afterLeave && k.afterLeave();
    };
    if (g.shapeFlag & 1 && k && !k.persisted) {
      const { leave: V, delayLeave: T } = k, A = () => V(_, z);
      T ? T(g.el, z, A) : A();
    } else
      z();
  }, av = (g, b) => {
    let _;
    for (; g !== b; )
      _ = p(g), i(g), g = _;
    i(b);
  }, cv = (g, b, _) => {
    ({}).NODE_ENV !== "production" && g.type.__hmrId && _0(g);
    const { bum: S, scope: k, update: z, subTree: V, um: T } = g;
    S && di(S), k.stop(), z && (z.active = !1, Xe(V, g, b, _)), T && dt(T, b), dt(() => {
      g.isUnmounted = !0;
    }, b), b && b.pendingBranch && !b.isUnmounted && g.asyncDep && !g.asyncResolved && g.suspenseId === b.pendingId && (b.deps--, b.deps === 0 && b.resolve()), {}.NODE_ENV !== "production" && P0(g);
  }, nr = (g, b, _, S = !1, k = !1, z = 0) => {
    for (let V = z; V < g.length; V++)
      Xe(g[V], b, _, S, k);
  }, _o = (g) => g.shapeFlag & 6 ? _o(g.component.subTree) : g.shapeFlag & 128 ? g.suspense.next() : p(g.anchor || g.el), ah = (g, b, _) => {
    g == null ? b._vnode && Xe(b._vnode, null, null, !0) : m(b._vnode || null, g, b, null, null, null, _), xh(), jf(), b._vnode = g;
  }, $l = {
    p: m,
    um: Xe,
    m: rt,
    r: Ql,
    mt: ae,
    mc: D,
    pc: he,
    pbc: F,
    n: _o,
    o: r
  };
  let Is, Us;
  return e && ([Is, Us] = e($l)), {
    render: ah,
    hydrate: Is,
    createApp: _x(ah, Is)
  };
}
function Hr({ effect: r, update: e }, t) {
  r.allowRecurse = e.allowRecurse = t;
}
function en(r, e, t = !1) {
  const l = r.children, i = e.children;
  if (ee(l) && ee(i))
    for (let o = 0; o < l.length; o++) {
      const n = l[o];
      let s = i[o];
      s.shapeFlag & 1 && !s.dynamicChildren && ((s.patchFlag <= 0 || s.patchFlag === 32) && (s = i[o] = wr(i[o]), s.el = n.el), t || en(n, s)), s.type === ho && (s.el = n.el), {}.NODE_ENV !== "production" && s.type === ft && !s.el && (s.el = n.el);
    }
}
function Sx(r) {
  const e = r.slice(), t = [0];
  let l, i, o, n, s;
  const a = r.length;
  for (l = 0; l < a; l++) {
    const c = r[l];
    if (c !== 0) {
      if (i = t[t.length - 1], r[i] < c) {
        e[l] = i, t.push(l);
        continue;
      }
      for (o = 0, n = t.length - 1; o < n; )
        s = o + n >> 1, r[t[s]] < c ? o = s + 1 : n = s;
      c < r[t[o]] && (o > 0 && (e[l] = t[o - 1]), t[o] = l);
    }
  }
  for (o = t.length, n = t[o - 1]; o-- > 0; )
    t[o] = n, n = e[n];
  return t;
}
const Qx = (r) => r.__isTeleport, kt = Symbol({}.NODE_ENV !== "production" ? "Fragment" : void 0), ho = Symbol({}.NODE_ENV !== "production" ? "Text" : void 0), ft = Symbol({}.NODE_ENV !== "production" ? "Comment" : void 0), tn = Symbol({}.NODE_ENV !== "production" ? "Static" : void 0), zi = [];
let Zt = null;
function Tt(r = !1) {
  zi.push(Zt = r ? null : []);
}
function $x() {
  zi.pop(), Zt = zi[zi.length - 1] || null;
}
let Mi = 1;
function zh(r) {
  Mi += r;
}
function ug(r) {
  return r.dynamicChildren = Mi > 0 ? Zt || Wl : null, $x(), Mi > 0 && Zt && Zt.push(r), r;
}
function mr(r, e, t, l, i, o) {
  return ug(ni(
    r,
    e,
    t,
    l,
    i,
    o,
    !0
    /* isBlock */
  ));
}
function Od(r, e, t, l, i) {
  return ug(ce(
    r,
    e,
    t,
    l,
    i,
    !0
    /* isBlock: prevent a block from tracking itself */
  ));
}
function bl(r) {
  return r ? r.__v_isVNode === !0 : !1;
}
function pi(r, e) {
  return {}.NODE_ENV !== "production" && e.shapeFlag & 6 && Tl.has(e.type) ? (r.shapeFlag &= -257, e.shapeFlag &= -513, !1) : r.type === e.type && r.key === e.key;
}
const Px = (...r) => gg(...r), vs = "__vInternal", fg = ({ key: r }) => r ?? null, rn = ({ ref: r, ref_key: e, ref_for: t }) => r != null ? $e(r) || je(r) || te(r) ? { i: Ie, r, k: e, f: !!t } : r : null;
function ni(r, e = null, t = null, l = 0, i = null, o = r === kt ? 0 : 1, n = !1, s = !1) {
  const a = {
    __v_isVNode: !0,
    __v_skip: !0,
    type: r,
    props: e,
    key: e && fg(e),
    ref: e && rn(e),
    scopeId: Ff,
    slotScopeIds: null,
    children: t,
    component: null,
    suspense: null,
    ssContent: null,
    ssFallback: null,
    dirs: null,
    transition: null,
    el: null,
    anchor: null,
    target: null,
    targetAnchor: null,
    staticCount: 0,
    shapeFlag: o,
    patchFlag: l,
    dynamicProps: i,
    dynamicChildren: null,
    appContext: null,
    ctx: Ie
  };
  return s ? (vd(a, t), o & 128 && r.normalize(a)) : t && (a.shapeFlag |= $e(t) ? 8 : 16), {}.NODE_ENV !== "production" && a.key !== a.key && X("VNode created with invalid key (NaN). VNode type:", a.type), Mi > 0 && // avoid a block node from tracking itself
  !n && // has current parent block
  Zt && // presence of a patch flag indicates this node needs patching on updates.
  // component nodes also should always be patched, because even if the
  // component doesn't need to update, it needs to persist the instance on to
  // the next vnode so that it can be properly unmounted later.
  (a.patchFlag > 0 || o & 6) && // the EVENTS flag is only for hydration and if it is the only flag, the
  // vnode should not be considered dynamic due to handler caching.
  a.patchFlag !== 32 && Zt.push(a), a;
}
const ce = {}.NODE_ENV !== "production" ? Px : gg;
function gg(r, e = null, t = null, l = 0, i = null, o = !1) {
  if ((!r || r === J0) && ({}.NODE_ENV !== "production" && !r && X(`Invalid vnode type when creating vnode: ${r}.`), r = ft), bl(r)) {
    const s = Nr(
      r,
      e,
      !0
      /* mergeRef: true */
    );
    return t && vd(s, t), Mi > 0 && !o && Zt && (s.shapeFlag & 6 ? Zt[Zt.indexOf(r)] = s : Zt.push(s)), s.patchFlag |= -2, s;
  }
  if (wg(r) && (r = r.__vccOpts), e) {
    e = Cx(e);
    let { class: s, style: a } = e;
    s && !$e(s) && (e.class = io(s)), ve(a) && (Ra(a) && !ee(a) && (a = Ve({}, a)), e.style = ss(a));
  }
  const n = $e(r) ? 1 : D0(r) ? 128 : Qx(r) ? 64 : ve(r) ? 4 : te(r) ? 2 : 0;
  return {}.NODE_ENV !== "production" && n & 4 && Ra(r) && (r = oe(r), X("Vue received a Component which was made a reactive object. This can lead to unnecessary performance overhead, and should be avoided by marking the component with `markRaw` or using `shallowRef` instead of `ref`.", `
Component that was made reactive: `, r)), ni(r, e, t, l, i, n, o, !0);
}
function Cx(r) {
  return r ? Ra(r) || vs in r ? Ve({}, r) : r : null;
}
function Nr(r, e, t = !1) {
  const { props: l, ref: i, patchFlag: o, children: n } = r, s = e ? bg(l || {}, e) : l;
  return {
    __v_isVNode: !0,
    __v_skip: !0,
    type: r.type,
    props: s,
    key: s && fg(s),
    ref: e && e.ref ? (
      // #2078 in the case of <component :is="vnode" ref="extra"/>
      // if the vnode itself already has a ref, cloneVNode will need to merge
      // the refs so the single vnode can be set on multiple refs
      t && i ? ee(i) ? i.concat(rn(e)) : [i, rn(e)] : rn(e)
    ) : i,
    scopeId: r.scopeId,
    slotScopeIds: r.slotScopeIds,
    children: {}.NODE_ENV !== "production" && o === -1 && ee(n) ? n.map(mg) : n,
    target: r.target,
    targetAnchor: r.targetAnchor,
    staticCount: r.staticCount,
    shapeFlag: r.shapeFlag,
    // if the vnode is cloned with extra props, we can no longer assume its
    // existing patch flag to be reliable and need to add the FULL_PROPS flag.
    // note: preserve flag for fragments since they use the flag for children
    // fast paths only.
    patchFlag: e && r.type !== kt ? o === -1 ? 16 : o | 16 : o,
    dynamicProps: r.dynamicProps,
    dynamicChildren: r.dynamicChildren,
    appContext: r.appContext,
    dirs: r.dirs,
    transition: r.transition,
    // These should technically only be non-null on mounted VNodes. However,
    // they *should* be copied for kept-alive vnodes. So we just always copy
    // them since them being non-null during a mount doesn't affect the logic as
    // they will simply be overwritten.
    component: r.component,
    suspense: r.suspense,
    ssContent: r.ssContent && Nr(r.ssContent),
    ssFallback: r.ssFallback && Nr(r.ssFallback),
    el: r.el,
    anchor: r.anchor,
    ctx: r.ctx
  };
}
function mg(r) {
  const e = Nr(r);
  return ee(r.children) && (e.children = r.children.map(mg)), e;
}
function Tx(r = " ", e = 0) {
  return ce(ho, null, r, e);
}
function zx(r = "", e = !1) {
  return e ? (Tt(), Od(ft, null, r)) : ce(ft, null, r);
}
function Vt(r) {
  return r == null || typeof r == "boolean" ? ce(ft) : ee(r) ? ce(
    kt,
    null,
    // #3666, avoid reference pollution when reusing vnode
    r.slice()
  ) : typeof r == "object" ? wr(r) : ce(ho, null, String(r));
}
function wr(r) {
  return r.el === null && r.patchFlag !== -1 || r.memo ? r : Nr(r);
}
function vd(r, e) {
  let t = 0;
  const { shapeFlag: l } = r;
  if (e == null)
    e = null;
  else if (ee(e))
    t = 16;
  else if (typeof e == "object")
    if (l & 65) {
      const i = e.default;
      i && (i._c && (i._d = !1), vd(r, i()), i._c && (i._d = !0));
      return;
    } else {
      t = 32;
      const i = e._;
      !i && !(vs in e) ? e._ctx = Ie : i === 3 && Ie && (Ie.slots._ === 1 ? e._ = 1 : (e._ = 2, r.patchFlag |= 1024));
    }
  else
    te(e) ? (e = { default: e, _ctx: Ie }, t = 32) : (e = String(e), l & 64 ? (t = 16, e = [Tx(e)]) : t = 8);
  r.children = e, r.shapeFlag |= t;
}
function bg(...r) {
  const e = {};
  for (let t = 0; t < r.length; t++) {
    const l = r[t];
    for (const i in l)
      if (i === "class")
        e.class !== l.class && (e.class = io([e.class, l.class]));
      else if (i === "style")
        e.style = ss([e.style, l.style]);
      else if (oo(i)) {
        const o = e[i], n = l[i];
        n && o !== n && !(ee(o) && o.includes(n)) && (e[i] = o ? [].concat(o, n) : n);
      } else
        i !== "" && (e[i] = l[i]);
  }
  return e;
}
function Yt(r, e, t, l = null) {
  Dt(r, e, 7, [
    t,
    l
  ]);
}
const Xx = pg();
let Ax = 0;
function Ex(r, e, t) {
  const l = r.type, i = (e ? e.appContext : r.appContext) || Xx, o = {
    uid: Ax++,
    vnode: r,
    type: l,
    parent: e,
    appContext: i,
    root: null,
    next: null,
    subTree: null,
    effect: null,
    update: null,
    scope: new Tv(
      !0
      /* detached */
    ),
    render: null,
    proxy: null,
    exposed: null,
    exposeProxy: null,
    withProxy: null,
    provides: e ? e.provides : Object.create(i.provides),
    accessCache: null,
    renderCache: [],
    // local resolved assets
    components: null,
    directives: null,
    // resolved props and emits options
    propsOptions: sg(l, i),
    emitsOptions: Gf(l, i),
    // emit
    emit: null,
    emitted: null,
    // props default value
    propsDefaults: be,
    // inheritAttrs
    inheritAttrs: l.inheritAttrs,
    // state
    ctx: be,
    data: be,
    props: be,
    attrs: be,
    slots: be,
    refs: be,
    setupState: be,
    setupContext: null,
    // suspense related
    suspense: t,
    suspenseId: t ? t.pendingId : 0,
    asyncDep: null,
    asyncResolved: !1,
    // lifecycle hooks
    // not using enums here because it results in computed properties
    isMounted: !1,
    isUnmounted: !1,
    isDeactivated: !1,
    bc: null,
    c: null,
    bm: null,
    m: null,
    bu: null,
    u: null,
    um: null,
    bum: null,
    da: null,
    a: null,
    rtg: null,
    rtc: null,
    ec: null,
    sp: null
  };
  return {}.NODE_ENV !== "production" ? o.ctx = ex(o) : o.ctx = { _: o }, o.root = e ? e.root : o, o.emit = X0.bind(null, o), r.ce && r.ce(o), o;
}
let Ye = null;
const yl = () => Ye || Ie, Gl = (r) => {
  Ye = r, r.scope.on();
}, fl = () => {
  Ye && Ye.scope.off(), Ye = null;
}, Vx = /* @__PURE__ */ Br("slot,component");
function Ba(r, e) {
  const t = e.isNativeTag || bf;
  (Vx(r) || t(r)) && X("Do not use built-in or reserved HTML elements as component id: " + r);
}
function Og(r) {
  return r.vnode.shapeFlag & 4;
}
let Yi = !1;
function Zx(r, e = !1) {
  Yi = e;
  const { props: t, children: l } = r.vnode, i = Og(r);
  cx(r, t, i, e), Ox(r, l);
  const o = i ? Rx(r, e) : void 0;
  return Yi = !1, o;
}
function Rx(r, e) {
  var t;
  const l = r.type;
  if ({}.NODE_ENV !== "production") {
    if (l.name && Ba(l.name, r.appContext.config), l.components) {
      const o = Object.keys(l.components);
      for (let n = 0; n < o.length; n++)
        Ba(o[n], r.appContext.config);
    }
    if (l.directives) {
      const o = Object.keys(l.directives);
      for (let n = 0; n < o.length; n++)
        rg(o[n]);
    }
    l.compilerOptions && Dx() && X('"compilerOptions" is only supported when using a build of Vue that includes the runtime compiler. Since you are using a runtime-only build, the options should be passed via your build tool config instead.');
  }
  r.accessCache = /* @__PURE__ */ Object.create(null), r.proxy = Xf(new Proxy(r.ctx, ig)), {}.NODE_ENV !== "production" && tx(r);
  const { setup: i } = l;
  if (i) {
    const o = r.setupContext = i.length > 1 ? xg(r) : null;
    Gl(r), _l();
    const n = dr(i, r, 0, [{}.NODE_ENV !== "production" ? Vl(r.props) : r.props, o]);
    if (wl(), fl(), ed(n)) {
      if (n.then(fl, fl), e)
        return n.then((s) => {
          Xh(r, s, e);
        }).catch((s) => {
          gs(
            s,
            r,
            0
            /* ErrorCodes.SETUP_FUNCTION */
          );
        });
      if (r.asyncDep = n, {}.NODE_ENV !== "production" && !r.suspense) {
        const s = (t = l.name) !== null && t !== void 0 ? t : "Anonymous";
        X(`Component <${s}>: setup function returned a promise, but no <Suspense> boundary was found in the parent component tree. A component with async setup() must be nested in a <Suspense> in order to be rendered.`);
      }
    } else
      Xh(r, n, e);
  } else
    vg(r, e);
}
function Xh(r, e, t) {
  te(e) ? r.type.__ssrInlineRender ? r.ssrRender = e : r.render = e : ve(e) ? ({}.NODE_ENV !== "production" && bl(e) && X("setup() should not return VNodes directly - return a render function instead."), {}.NODE_ENV !== "production" && (r.devtoolsRawSetupState = e), r.setupState = Rf(e), {}.NODE_ENV !== "production" && rx(r)) : {}.NODE_ENV !== "production" && e !== void 0 && X(`setup() should return an object. Received: ${e === null ? "null" : typeof e}`), vg(r, t);
}
let La;
const Dx = () => !La;
function vg(r, e, t) {
  const l = r.type;
  if (!r.render) {
    if (!e && La && !l.render) {
      const i = l.template || md(r).template;
      if (i) {
        ({}).NODE_ENV !== "production" && sr(r, "compile");
        const { isCustomElement: o, compilerOptions: n } = r.appContext.config, { delimiters: s, compilerOptions: a } = l, c = Ve(Ve({
          isCustomElement: o,
          delimiters: s
        }, n), a);
        l.render = La(i, c), {}.NODE_ENV !== "production" && ar(r, "compile");
      }
    }
    r.render = l.render || Me;
  }
  Gl(r), _l(), ix(r), wl(), fl(), {}.NODE_ENV !== "production" && !l.render && r.render === Me && !e && (l.template ? X(
    'Component provided template option but runtime compilation is not supported in this build of Vue. Configure your bundler to alias "vue" to "vue/dist/vue.esm-bundler.js".'
    /* should not happen */
  ) : X("Component is missing template or render function."));
}
function Ah(r) {
  return new Proxy(r.attrs, {}.NODE_ENV !== "production" ? {
    get(e, t) {
      return Sn(), gt(r, "get", "$attrs"), e[t];
    },
    set() {
      return X("setupContext.attrs is readonly."), !1;
    },
    deleteProperty() {
      return X("setupContext.attrs is readonly."), !1;
    }
  } : {
    get(e, t) {
      return gt(r, "get", "$attrs"), e[t];
    }
  });
}
function xg(r) {
  const e = (l) => {
    ({}).NODE_ENV !== "production" && r.exposed && X("expose() should be called only once per setup()."), r.exposed = l || {};
  };
  let t;
  return {}.NODE_ENV !== "production" ? Object.freeze({
    get attrs() {
      return t || (t = Ah(r));
    },
    get slots() {
      return Vl(r.slots);
    },
    get emit() {
      return (l, ...i) => r.emit(l, ...i);
    },
    expose: e
  }) : {
    get attrs() {
      return t || (t = Ah(r));
    },
    slots: r.slots,
    emit: r.emit,
    expose: e
  };
}
function xs(r) {
  if (r.exposed)
    return r.exposeProxy || (r.exposeProxy = new Proxy(Rf(Xf(r.exposed)), {
      get(e, t) {
        if (t in e)
          return e[t];
        if (t in ul)
          return ul[t](r);
      },
      has(e, t) {
        return t in e || t in ul;
      }
    }));
}
const Wx = /(?:^|[-_])(\w)/g, Nx = (r) => r.replace(Wx, (e) => e.toUpperCase()).replace(/[-_]/g, "");
function _g(r, e = !0) {
  return te(r) ? r.displayName || r.name : r.name || e && r.__name;
}
function _s(r, e, t = !1) {
  let l = _g(e);
  if (!l && e.__file) {
    const i = e.__file.match(/([^/\\]+)\.\w+$/);
    i && (l = i[1]);
  }
  if (!l && r && r.parent) {
    const i = (o) => {
      for (const n in o)
        if (o[n] === e)
          return n;
    };
    l = i(r.components || r.parent.type.components) || i(r.appContext.components);
  }
  return l ? Nx(l) : t ? "App" : "Anonymous";
}
function wg(r) {
  return te(r) && "__vccOpts" in r;
}
const Mr = (r, e) => d0(r, e, Yi);
function Mx() {
  return Yx().slots;
}
function Yx() {
  const r = yl();
  return {}.NODE_ENV !== "production" && !r && X("useContext() called without active instance."), r.setupContext || (r.setupContext = xg(r));
}
const jx = Symbol({}.NODE_ENV !== "production" ? "ssrContext" : ""), Ix = () => {
  {
    const r = Er(jx);
    return r || {}.NODE_ENV !== "production" && X("Server rendering context not provided. Make sure to only call useSSRContext() conditionally in the server build."), r;
  }
};
function Gs(r) {
  return !!(r && r.__v_isShallow);
}
function Ux() {
  if ({}.NODE_ENV === "production" || typeof window > "u")
    return;
  const r = { style: "color:#3ba776" }, e = { style: "color:#0b1bc9" }, t = { style: "color:#b62e24" }, l = { style: "color:#9d288c" }, i = {
    header(h) {
      return ve(h) ? h.__isVue ? ["div", r, "VueInstance"] : je(h) ? [
        "div",
        {},
        ["span", r, d(h)],
        "<",
        s(h.value),
        ">"
      ] : dl(h) ? [
        "div",
        {},
        ["span", r, Gs(h) ? "ShallowReactive" : "Reactive"],
        "<",
        s(h),
        `>${Wr(h) ? " (readonly)" : ""}`
      ] : Wr(h) ? [
        "div",
        {},
        ["span", r, Gs(h) ? "ShallowReadonly" : "Readonly"],
        "<",
        s(h),
        ">"
      ] : null : null;
    },
    hasBody(h) {
      return h && h.__isVue;
    },
    body(h) {
      if (h && h.__isVue)
        return [
          "div",
          {},
          ...o(h.$)
        ];
    }
  };
  function o(h) {
    const p = [];
    h.type.props && h.props && p.push(n("props", oe(h.props))), h.setupState !== be && p.push(n("setup", h.setupState)), h.data !== be && p.push(n("data", oe(h.data)));
    const u = a(h, "computed");
    u && p.push(n("computed", u));
    const f = a(h, "inject");
    return f && p.push(n("injected", f)), p.push([
      "div",
      {},
      [
        "span",
        {
          style: l.style + ";opacity:0.66"
        },
        "$ (internal): "
      ],
      ["object", { object: h }]
    ]), p;
  }
  function n(h, p) {
    return p = Ve({}, p), Object.keys(p).length ? [
      "div",
      { style: "line-height:1.25em;margin-bottom:0.6em" },
      [
        "div",
        {
          style: "color:#476582"
        },
        h
      ],
      [
        "div",
        {
          style: "padding-left:1.25em"
        },
        ...Object.keys(p).map((u) => [
          "div",
          {},
          ["span", l, u + ": "],
          s(p[u], !1)
        ])
      ]
    ] : ["span", {}];
  }
  function s(h, p = !0) {
    return typeof h == "number" ? ["span", e, h] : typeof h == "string" ? ["span", t, JSON.stringify(h)] : typeof h == "boolean" ? ["span", l, h] : ve(h) ? ["object", { object: p ? oe(h) : h }] : ["span", t, String(h)];
  }
  function a(h, p) {
    const u = h.type;
    if (te(u))
      return;
    const f = {};
    for (const m in h.ctx)
      c(u, m, p) && (f[m] = h.ctx[m]);
    return f;
  }
  function c(h, p, u) {
    const f = h[u];
    if (ee(f) && f.includes(p) || ve(f) && p in f || h.extends && c(h.extends, p, u) || h.mixins && h.mixins.some((m) => c(m, p, u)))
      return !0;
  }
  function d(h) {
    return Gs(h) ? "ShallowRef" : h.effect ? "ComputedRef" : "Ref";
  }
  window.devtoolsFormatters ? window.devtoolsFormatters.push(i) : window.devtoolsFormatters = [i];
}
const Eh = "3.2.45", qx = "http://www.w3.org/2000/svg", rl = typeof document < "u" ? document : null, Vh = rl && /* @__PURE__ */ rl.createElement("template"), Bx = {
  insert: (r, e, t) => {
    e.insertBefore(r, t || null);
  },
  remove: (r) => {
    const e = r.parentNode;
    e && e.removeChild(r);
  },
  createElement: (r, e, t, l) => {
    const i = e ? rl.createElementNS(qx, r) : rl.createElement(r, t ? { is: t } : void 0);
    return r === "select" && l && l.multiple != null && i.setAttribute("multiple", l.multiple), i;
  },
  createText: (r) => rl.createTextNode(r),
  createComment: (r) => rl.createComment(r),
  setText: (r, e) => {
    r.nodeValue = e;
  },
  setElementText: (r, e) => {
    r.textContent = e;
  },
  parentNode: (r) => r.parentNode,
  nextSibling: (r) => r.nextSibling,
  querySelector: (r) => rl.querySelector(r),
  setScopeId(r, e) {
    r.setAttribute(e, "");
  },
  // __UNSAFE__
  // Reason: innerHTML.
  // Static content here can only come from compiled templates.
  // As long as the user only uses trusted templates, this is safe.
  insertStaticContent(r, e, t, l, i, o) {
    const n = t ? t.previousSibling : e.lastChild;
    if (i && (i === o || i.nextSibling))
      for (; e.insertBefore(i.cloneNode(!0), t), !(i === o || !(i = i.nextSibling)); )
        ;
    else {
      Vh.innerHTML = l ? `<svg>${r}</svg>` : r;
      const s = Vh.content;
      if (l) {
        const a = s.firstChild;
        for (; a.firstChild; )
          s.appendChild(a.firstChild);
        s.removeChild(a);
      }
      e.insertBefore(s, t);
    }
    return [
      // first
      n ? n.nextSibling : e.firstChild,
      // last
      t ? t.previousSibling : e.lastChild
    ];
  }
};
function Lx(r, e, t) {
  const l = r._vtc;
  l && (e = (e ? [e, ...l] : [...l]).join(" ")), e == null ? r.removeAttribute("class") : t ? r.setAttribute("class", e) : r.className = e;
}
function Gx(r, e, t) {
  const l = r.style, i = $e(t);
  if (t && !i) {
    for (const o in t)
      Ga(l, o, t[o]);
    if (e && !$e(e))
      for (const o in e)
        t[o] == null && Ga(l, o, "");
  } else {
    const o = l.display;
    i ? e !== t && (l.cssText = t) : e && r.removeAttribute("style"), "_vod" in r && (l.display = o);
  }
}
const Fx = /[^\\];\s*$/, Zh = /\s*!important$/;
function Ga(r, e, t) {
  if (ee(t))
    t.forEach((l) => Ga(r, e, l));
  else if (t == null && (t = ""), {}.NODE_ENV !== "production" && Fx.test(t) && X(`Unexpected semicolon at the end of '${e}' style value: '${t}'`), e.startsWith("--"))
    r.setProperty(e, t);
  else {
    const l = Hx(r, e);
    Zh.test(t) ? r.setProperty(Rr(l), t.replace(Zh, ""), "important") : r[l] = t;
  }
}
const Rh = ["Webkit", "Moz", "ms"], Fs = {};
function Hx(r, e) {
  const t = Fs[e];
  if (t)
    return t;
  let l = Ll(e);
  if (l !== "filter" && l in r)
    return Fs[e] = l;
  l = no(l);
  for (let i = 0; i < Rh.length; i++) {
    const o = Rh[i] + l;
    if (o in r)
      return Fs[e] = o;
  }
  return e;
}
const Dh = "http://www.w3.org/1999/xlink";
function Kx(r, e, t, l, i) {
  if (l && e.startsWith("xlink:"))
    t == null ? r.removeAttributeNS(Dh, e.slice(6, e.length)) : r.setAttributeNS(Dh, e, t);
  else {
    const o = _v(e);
    t == null || o && !mf(t) ? r.removeAttribute(e) : r.setAttribute(e, o ? "" : t);
  }
}
function Jx(r, e, t, l, i, o, n) {
  if (e === "innerHTML" || e === "textContent") {
    l && n(l, i, o), r[e] = t ?? "";
    return;
  }
  if (e === "value" && r.tagName !== "PROGRESS" && // custom elements may use _value internally
  !r.tagName.includes("-")) {
    r._value = t;
    const a = t ?? "";
    (r.value !== a || // #4956: always set for OPTION elements because its value falls back to
    // textContent if no value attribute is present. And setting .value for
    // OPTION has no side effect
    r.tagName === "OPTION") && (r.value = a), t == null && r.removeAttribute(e);
    return;
  }
  let s = !1;
  if (t === "" || t == null) {
    const a = typeof r[e];
    a === "boolean" ? t = mf(t) : t == null && a === "string" ? (t = "", s = !0) : a === "number" && (t = 0, s = !0);
  }
  try {
    r[e] = t;
  } catch (a) {
    ({}).NODE_ENV !== "production" && !s && X(`Failed setting prop "${e}" on <${r.tagName.toLowerCase()}>: value ${t} is invalid.`, a);
  }
  s && r.removeAttribute(e);
}
function e_(r, e, t, l) {
  r.addEventListener(e, t, l);
}
function t_(r, e, t, l) {
  r.removeEventListener(e, t, l);
}
function r_(r, e, t, l, i = null) {
  const o = r._vei || (r._vei = {}), n = o[e];
  if (l && n)
    n.value = l;
  else {
    const [s, a] = l_(e);
    if (l) {
      const c = o[e] = n_(l, i);
      e_(r, s, c, a);
    } else
      n && (t_(r, s, n, a), o[e] = void 0);
  }
}
const Wh = /(?:Once|Passive|Capture)$/;
function l_(r) {
  let e;
  if (Wh.test(r)) {
    e = {};
    let l;
    for (; l = r.match(Wh); )
      r = r.slice(0, r.length - l[0].length), e[l[0].toLowerCase()] = !0;
  }
  return [r[2] === ":" ? r.slice(3) : Rr(r.slice(2)), e];
}
let Hs = 0;
const i_ = /* @__PURE__ */ Promise.resolve(), o_ = () => Hs || (i_.then(() => Hs = 0), Hs = Date.now());
function n_(r, e) {
  const t = (l) => {
    if (!l._vts)
      l._vts = Date.now();
    else if (l._vts <= t.attached)
      return;
    Dt(s_(l, t.value), e, 5, [l]);
  };
  return t.value = r, t.attached = o_(), t;
}
function s_(r, e) {
  if (ee(e)) {
    const t = r.stopImmediatePropagation;
    return r.stopImmediatePropagation = () => {
      t.call(r), r._stopped = !0;
    }, e.map((l) => (i) => !i._stopped && l && l(i));
  } else
    return e;
}
const Nh = /^on[a-z]/, a_ = (r, e, t, l, i = !1, o, n, s, a) => {
  e === "class" ? Lx(r, l, i) : e === "style" ? Gx(r, t, l) : oo(e) ? xn(e) || r_(r, e, t, l, n) : (e[0] === "." ? (e = e.slice(1), !0) : e[0] === "^" ? (e = e.slice(1), !1) : c_(r, e, l, i)) ? Jx(r, e, l, o, n, s, a) : (e === "true-value" ? r._trueValue = l : e === "false-value" && (r._falseValue = l), Kx(r, e, l, i));
};
function c_(r, e, t, l) {
  return l ? !!(e === "innerHTML" || e === "textContent" || e in r && Nh.test(e) && te(t)) : e === "spellcheck" || e === "draggable" || e === "translate" || e === "form" || e === "list" && r.tagName === "INPUT" || e === "type" && r.tagName === "TEXTAREA" || Nh.test(e) && $e(t) ? !1 : e in r;
}
const d_ = {
  beforeMount(r, { value: e }, { transition: t }) {
    r._vod = r.style.display === "none" ? "" : r.style.display, t && e ? t.beforeEnter(r) : ui(r, e);
  },
  mounted(r, { value: e }, { transition: t }) {
    t && e && t.enter(r);
  },
  updated(r, { value: e, oldValue: t }, { transition: l }) {
    !e != !t && (l ? e ? (l.beforeEnter(r), ui(r, !0), l.enter(r)) : l.leave(r, () => {
      ui(r, !1);
    }) : ui(r, e));
  },
  beforeUnmount(r, { value: e }) {
    ui(r, e);
  }
};
function ui(r, e) {
  r.style.display = e ? r._vod : "none";
}
const h_ = /* @__PURE__ */ Ve({ patchProp: a_ }, Bx);
let Mh;
function p_() {
  return Mh || (Mh = yx(h_));
}
const u_ = (...r) => {
  const e = p_().createApp(...r);
  ({}).NODE_ENV !== "production" && (f_(e), g_(e));
  const { mount: t } = e;
  return e.mount = (l) => {
    const i = m_(l);
    if (!i)
      return;
    const o = e._component;
    !te(o) && !o.render && !o.template && (o.template = i.innerHTML), i.innerHTML = "";
    const n = t(i, !1, i instanceof SVGElement);
    return i instanceof Element && (i.removeAttribute("v-cloak"), i.setAttribute("data-v-app", "")), n;
  }, e;
};
function f_(r) {
  Object.defineProperty(r.config, "isNativeTag", {
    value: (e) => Ov(e) || vv(e),
    writable: !1
  });
}
function g_(r) {
  {
    const e = r.config.isCustomElement;
    Object.defineProperty(r.config, "isCustomElement", {
      get() {
        return e;
      },
      set() {
        X("The `isCustomElement` config option is deprecated. Use `compilerOptions.isCustomElement` instead.");
      }
    });
    const t = r.config.compilerOptions, l = 'The `compilerOptions` config option is only respected when using a build of Vue.js that includes the runtime compiler (aka "full build"). Since you are using the runtime-only build, `compilerOptions` must be passed to `@vue/compiler-dom` in the build setup instead.\n- For vue-loader: pass it via vue-loader\'s `compilerOptions` loader option.\n- For vue-cli: see https://cli.vuejs.org/guide/webpack.html#modifying-options-of-a-loader\n- For vite: pass it via @vitejs/plugin-vue options. See https://github.com/vitejs/vite/tree/main/packages/plugin-vue#example-for-passing-options-to-vuecompiler-dom';
    Object.defineProperty(r.config, "compilerOptions", {
      get() {
        return X(l), t;
      },
      set() {
        X(l);
      }
    });
  }
}
function m_(r) {
  if ($e(r)) {
    const e = document.querySelector(r);
    return {}.NODE_ENV !== "production" && !e && X(`Failed to mount app: mount target selector "${r}" returned null.`), e;
  }
  return {}.NODE_ENV !== "production" && window.ShadowRoot && r instanceof window.ShadowRoot && r.mode === "closed" && X('mounting on a ShadowRoot with `{mode: "closed"}` may lead to unpredictable bugs'), r;
}
function b_() {
  Ux();
}
({}).NODE_ENV !== "production" && b_();
function O_(r) {
  for (var e = -1, t = r == null ? 0 : r.length, l = {}; ++e < t; ) {
    var i = r[e];
    l[i[0]] = i[1];
  }
  return l;
}
var v_ = Object.defineProperty, x_ = Object.defineProperties, __ = Object.getOwnPropertyDescriptors, Yh = Object.getOwnPropertySymbols, w_ = Object.prototype.hasOwnProperty, y_ = Object.prototype.propertyIsEnumerable, jh = (r, e, t) => e in r ? v_(r, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : r[e] = t, k_ = (r, e) => {
  for (var t in e || (e = {}))
    w_.call(e, t) && jh(r, t, e[t]);
  if (Yh)
    for (var t of Yh(e))
      y_.call(e, t) && jh(r, t, e[t]);
  return r;
}, S_ = (r, e) => x_(r, __(e));
function Ih(r, e) {
  var t;
  const l = Vf();
  return N0(() => {
    l.value = r();
  }, S_(k_({}, e), {
    flush: (t = e == null ? void 0 : e.flush) != null ? t : "sync"
  })), od(l);
}
var Uh;
const xd = typeof window < "u", yg = (r) => typeof r == "number", Q_ = (r) => typeof r == "string", $_ = () => {
};
xd && ((Uh = window == null ? void 0 : window.navigator) != null && Uh.userAgent) && /iP(ad|hone|od)/.test(window.navigator.userAgent);
function P_(r) {
  return typeof r == "function" ? r() : De(r);
}
function C_(r) {
  return r;
}
function kg(r) {
  return Xv() ? (Av(r), !0) : !1;
}
function T_(r, e = !0) {
  yl() ? co(r) : e ? r() : so(r);
}
function Sg(r) {
  var e;
  const t = P_(r);
  return (e = t == null ? void 0 : t.$el) != null ? e : t;
}
const _d = xd ? window : void 0, z_ = xd ? window.document : void 0;
function Fa(...r) {
  let e, t, l, i;
  if (Q_(r[0]) || Array.isArray(r[0]) ? ([t, l, i] = r, e = _d) : [e, t, l, i] = r, !e)
    return $_;
  Array.isArray(t) || (t = [t]), Array.isArray(l) || (l = [l]);
  const o = [], n = () => {
    o.forEach((d) => d()), o.length = 0;
  }, s = (d, h, p) => (d.addEventListener(h, p, i), () => d.removeEventListener(h, p, i)), a = ut(() => Sg(e), (d) => {
    n(), d && o.push(...t.flatMap((h) => l.map((p) => s(d, h, p))));
  }, { immediate: !0, flush: "post" }), c = () => {
    a(), n();
  };
  return kg(c), c;
}
function X_(r, e = !1) {
  const t = ke(), l = () => t.value = Boolean(r());
  return l(), T_(l, e), t;
}
const Ha = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {}, Ka = "__vueuse_ssr_handlers__";
Ha[Ka] = Ha[Ka] || {};
Ha[Ka];
function A_({ document: r = z_ } = {}) {
  if (!r)
    return ke("visible");
  const e = ke(r.visibilityState);
  return Fa(r, "visibilitychange", () => {
    e.value = r.visibilityState;
  }), e;
}
var qh = Object.getOwnPropertySymbols, E_ = Object.prototype.hasOwnProperty, V_ = Object.prototype.propertyIsEnumerable, Z_ = (r, e) => {
  var t = {};
  for (var l in r)
    E_.call(r, l) && e.indexOf(l) < 0 && (t[l] = r[l]);
  if (r != null && qh)
    for (var l of qh(r))
      e.indexOf(l) < 0 && V_.call(r, l) && (t[l] = r[l]);
  return t;
};
function Qg(r, e, t = {}) {
  const l = t, { window: i = _d } = l, o = Z_(l, ["window"]);
  let n;
  const s = X_(() => i && "ResizeObserver" in i), a = () => {
    n && (n.disconnect(), n = void 0);
  }, c = ut(() => Sg(r), (h) => {
    a(), s.value && i && h && (n = new ResizeObserver(e), n.observe(h, o));
  }, { immediate: !0, flush: "post" }), d = () => {
    a(), c();
  };
  return kg(d), {
    isSupported: s,
    stop: d
  };
}
var Bh;
(function(r) {
  r.UP = "UP", r.RIGHT = "RIGHT", r.DOWN = "DOWN", r.LEFT = "LEFT", r.NONE = "NONE";
})(Bh || (Bh = {}));
var R_ = Object.defineProperty, Lh = Object.getOwnPropertySymbols, D_ = Object.prototype.hasOwnProperty, W_ = Object.prototype.propertyIsEnumerable, Gh = (r, e, t) => e in r ? R_(r, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : r[e] = t, N_ = (r, e) => {
  for (var t in e || (e = {}))
    D_.call(e, t) && Gh(r, t, e[t]);
  if (Lh)
    for (var t of Lh(e))
      W_.call(e, t) && Gh(r, t, e[t]);
  return r;
};
const M_ = {
  easeInSine: [0.12, 0, 0.39, 0],
  easeOutSine: [0.61, 1, 0.88, 1],
  easeInOutSine: [0.37, 0, 0.63, 1],
  easeInQuad: [0.11, 0, 0.5, 0],
  easeOutQuad: [0.5, 1, 0.89, 1],
  easeInOutQuad: [0.45, 0, 0.55, 1],
  easeInCubic: [0.32, 0, 0.67, 0],
  easeOutCubic: [0.33, 1, 0.68, 1],
  easeInOutCubic: [0.65, 0, 0.35, 1],
  easeInQuart: [0.5, 0, 0.75, 0],
  easeOutQuart: [0.25, 1, 0.5, 1],
  easeInOutQuart: [0.76, 0, 0.24, 1],
  easeInQuint: [0.64, 0, 0.78, 0],
  easeOutQuint: [0.22, 1, 0.36, 1],
  easeInOutQuint: [0.83, 0, 0.17, 1],
  easeInExpo: [0.7, 0, 0.84, 0],
  easeOutExpo: [0.16, 1, 0.3, 1],
  easeInOutExpo: [0.87, 0, 0.13, 1],
  easeInCirc: [0.55, 0, 1, 0.45],
  easeOutCirc: [0, 0.55, 0.45, 1],
  easeInOutCirc: [0.85, 0, 0.15, 1],
  easeInBack: [0.36, 0, 0.66, -0.56],
  easeOutBack: [0.34, 1.56, 0.64, 1],
  easeInOutBack: [0.68, -0.6, 0.32, 1.6]
};
N_({
  linear: C_
}, M_);
function Y_({ window: r = _d } = {}) {
  if (!r)
    return ke(!1);
  const e = ke(r.document.hasFocus());
  return Fa(r, "blur", () => {
    e.value = !1;
  }), Fa(r, "focus", () => {
    e.value = !0;
  }), e;
}
const Ja = (r) => r === void 0, j_ = (r) => $e(r) ? !Number.isNaN(Number(r)) : !1, Qr = (r) => no(r);
class $g extends Error {
  constructor(e) {
    super(e), this.name = "ElementPlusError";
  }
}
function wd(r, e) {
  throw new $g(`[${r}] ${e}`);
}
function Pg(r, e) {
  if ({}.NODE_ENV !== "production") {
    const t = $e(r) ? new $g(`[${r}] ${e}`) : r;
    console.warn(t);
  }
}
const I_ = "utils/dom/style";
function U_(r, e = "px") {
  if (!r)
    return "";
  if (yg(r) || j_(r))
    return `${r}${e}`;
  if ($e(r))
    return r;
  Pg(I_, "binding value must be a string or number");
}
/*! Element Plus Icons Vue v2.0.10 */
var ws = (r, e) => {
  let t = r.__vccOpts || r;
  for (let [l, i] of e)
    t[l] = i;
  return t;
}, q_ = {
  name: "ArrowLeft"
}, B_ = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
}, L_ = /* @__PURE__ */ ni("path", {
  fill: "currentColor",
  d: "M609.408 149.376 277.76 489.6a32 32 0 0 0 0 44.672l331.648 340.352a29.12 29.12 0 0 0 41.728 0 30.592 30.592 0 0 0 0-42.752L339.264 511.936l311.872-319.872a30.592 30.592 0 0 0 0-42.688 29.12 29.12 0 0 0-41.728 0z"
}, null, -1), G_ = [
  L_
];
function F_(r, e, t, l, i, o) {
  return Tt(), mr("svg", B_, G_);
}
var H_ = /* @__PURE__ */ ws(q_, [["render", F_], ["__file", "arrow-left.vue"]]), K_ = {
  name: "ArrowRight"
}, J_ = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
}, e1 = /* @__PURE__ */ ni("path", {
  fill: "currentColor",
  d: "M340.864 149.312a30.592 30.592 0 0 0 0 42.752L652.736 512 340.864 831.872a30.592 30.592 0 0 0 0 42.752 29.12 29.12 0 0 0 41.728 0L714.24 534.336a32 32 0 0 0 0-44.672L382.592 149.376a29.12 29.12 0 0 0-41.728 0z"
}, null, -1), t1 = [
  e1
];
function r1(r, e, t, l, i, o) {
  return Tt(), mr("svg", J_, t1);
}
var l1 = /* @__PURE__ */ ws(K_, [["render", r1], ["__file", "arrow-right.vue"]]), i1 = {
  name: "Close"
}, o1 = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
}, n1 = /* @__PURE__ */ ni("path", {
  fill: "currentColor",
  d: "M764.288 214.592 512 466.88 259.712 214.592a31.936 31.936 0 0 0-45.12 45.12L466.752 512 214.528 764.224a31.936 31.936 0 1 0 45.12 45.184L512 557.184l252.288 252.288a31.936 31.936 0 0 0 45.12-45.12L557.12 512.064l252.288-252.352a31.936 31.936 0 1 0-45.12-45.184z"
}, null, -1), s1 = [
  n1
];
function a1(r, e, t, l, i, o) {
  return Tt(), mr("svg", o1, s1);
}
var c1 = /* @__PURE__ */ ws(i1, [["render", a1], ["__file", "close.vue"]]), d1 = {
  name: "Plus"
}, h1 = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
}, p1 = /* @__PURE__ */ ni("path", {
  fill: "currentColor",
  d: "M480 480V128a32 32 0 0 1 64 0v352h352a32 32 0 1 1 0 64H544v352a32 32 0 1 1-64 0V544H128a32 32 0 0 1 0-64h352z"
}, null, -1), u1 = [
  p1
];
function f1(r, e, t, l, i, o) {
  return Tt(), mr("svg", h1, u1);
}
var g1 = /* @__PURE__ */ ws(d1, [["render", f1], ["__file", "plus.vue"]]);
const Cg = "__epPropKey", ys = (r) => r, m1 = (r) => ve(r) && !!r[Cg], b1 = (r, e) => {
  if (!ve(r) || m1(r))
    return r;
  const { values: t, required: l, default: i, type: o, validator: n } = r, a = {
    type: o,
    required: !!l,
    validator: t || n ? (c) => {
      let d = !1, h = [];
      if (t && (h = Array.from(t), ne(r, "default") && h.push(i), d || (d = h.includes(c))), n && (d || (d = n(c))), !d && h.length > 0) {
        const p = [...new Set(h)].map((u) => JSON.stringify(u)).join(", ");
        X(`Invalid prop: validation failed${e ? ` for prop "${e}"` : ""}. Expected one of [${p}], got value ${JSON.stringify(c)}.`);
      }
      return d;
    } : void 0,
    [Cg]: !0
  };
  return ne(r, "default") && (a.default = i), a;
}, po = (r) => O_(Object.entries(r).map(([e, t]) => [
  e,
  b1(t, e)
])), Tg = (r, e) => {
  if (r.install = (t) => {
    for (const l of [r, ...Object.values(e ?? {})])
      t.component(l.name, l);
  }, e)
    for (const [t, l] of Object.entries(e))
      r[t] = l;
  return r;
}, O1 = (r) => (r.install = Me, r), ln = {
  tab: "Tab",
  enter: "Enter",
  space: "Space",
  left: "ArrowLeft",
  up: "ArrowUp",
  right: "ArrowRight",
  down: "ArrowDown",
  esc: "Escape",
  delete: "Delete",
  backspace: "Backspace",
  numpadEnter: "NumpadEnter",
  pageUp: "PageUp",
  pageDown: "PageDown",
  home: "Home",
  end: "End"
}, zg = "update:modelValue", on = (r) => {
  const e = ee(r) ? r : [r], t = [];
  return e.forEach((l) => {
    var i;
    ee(l) ? t.push(...on(l)) : bl(l) && ee(l.children) ? t.push(...on(l.children)) : (t.push(l), bl(l) && ((i = l.component) != null && i.subTree) && t.push(...on(l.component.subTree)));
  }), t;
}, Xg = (r) => r, v1 = Symbol(), ks = Symbol("tabsRootContextKey"), Fh = ke();
function x1(r, e = void 0) {
  const t = yl() ? Er(v1, Fh) : Fh;
  return r ? Mr(() => {
    var l, i;
    return (i = (l = t.value) == null ? void 0 : l[r]) != null ? i : e;
  }) : t;
}
const _1 = ({ from: r, replacement: e, scope: t, version: l, ref: i, type: o = "API" }, n) => {
  ut(() => De(n), (s) => {
    s && Pg(t, `[${o}] ${r} is about to be deprecated in version ${l}, please use ${e} instead.
For more detail, please visit: ${i}
`);
  }, {
    immediate: !0
  });
}, w1 = "el", y1 = "is-", Kr = (r, e, t, l, i) => {
  let o = `${r}-${e}`;
  return t && (o += `-${t}`), l && (o += `__${l}`), i && (o += `--${i}`), o;
}, uo = (r) => {
  const e = x1("namespace", w1);
  return {
    namespace: e,
    b: (f = "") => Kr(e.value, r, f, "", ""),
    e: (f) => f ? Kr(e.value, r, "", f, "") : "",
    m: (f) => f ? Kr(e.value, r, "", "", f) : "",
    be: (f, m) => f && m ? Kr(e.value, r, f, m, "") : "",
    em: (f, m) => f && m ? Kr(e.value, r, "", f, m) : "",
    bm: (f, m) => f && m ? Kr(e.value, r, f, "", m) : "",
    bem: (f, m, O) => f && m && O ? Kr(e.value, r, f, m, O) : "",
    is: (f, ...m) => {
      const O = m.length >= 1 ? m[0] : !0;
      return f && O ? `${y1}${f}` : "";
    },
    cssVar: (f) => {
      const m = {};
      for (const O in f)
        f[O] && (m[`--${e.value}-${O}`] = f[O]);
      return m;
    },
    cssVarName: (f) => `--${e.value}-${f}`,
    cssVarBlock: (f) => {
      const m = {};
      for (const O in f)
        f[O] && (m[`--${e.value}-${r}-${O}`] = f[O]);
      return m;
    },
    cssVarBlockName: (f) => `--${e.value}-${r}-${f}`
  };
}, k1 = (r, e, t) => on(r.subTree).filter((o) => {
  var n;
  return bl(o) && ((n = o.type) == null ? void 0 : n.name) === e && !!o.component;
}).map((o) => o.component.uid).map((o) => t[o]).filter((o) => !!o), S1 = (r, e) => {
  const t = {}, l = Vf([]);
  return {
    children: l,
    addChild: (n) => {
      t[n.uid] = n, l.value = k1(r, e, t);
    },
    removeChild: (n) => {
      delete t[n], l.value = l.value.filter((s) => s.uid !== n);
    }
  };
};
var yd = (r, e) => {
  const t = r.__vccOpts || r;
  for (const [l, i] of e)
    t[l] = i;
  return t;
};
const Q1 = po({
  size: {
    type: ys([Number, String])
  },
  color: {
    type: String
  }
}), $1 = Wt({
  name: "ElIcon",
  inheritAttrs: !1
}), P1 = /* @__PURE__ */ Wt({
  ...$1,
  props: Q1,
  setup(r) {
    const e = r, t = uo("icon"), l = Mr(() => {
      const { size: i, color: o } = e;
      return !i && !o ? {} : {
        fontSize: Ja(i) ? void 0 : U_(i),
        "--color": o
      };
    });
    return (i, o) => (Tt(), mr("i", bg({
      class: De(t).b(),
      style: De(l)
    }, i.$attrs), [
      fd(i.$slots, "default")
    ], 16));
  }
});
var C1 = /* @__PURE__ */ yd(P1, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/icon/src/icon.vue"]]);
const nn = Tg(C1), T1 = po({
  tabs: {
    type: ys(Array),
    default: () => Xg([])
  }
}), Ag = "ElTabBar", z1 = Wt({
  name: Ag
}), X1 = /* @__PURE__ */ Wt({
  ...z1,
  props: T1,
  setup(r, { expose: e }) {
    const t = r, l = yl(), i = Er(ks);
    i || wd(Ag, "<el-tabs><el-tab-bar /></el-tabs>");
    const o = uo("tabs"), n = ke(), s = ke(), a = () => {
      let d = 0, h = 0;
      const p = ["top", "bottom"].includes(i.props.tabPosition) ? "width" : "height", u = p === "width" ? "x" : "y", f = u === "x" ? "left" : "top";
      return t.tabs.every((m) => {
        var O, x;
        const Q = (x = (O = l.parent) == null ? void 0 : O.refs) == null ? void 0 : x[`tab-${m.uid}`];
        if (!Q)
          return !1;
        if (!m.active)
          return !0;
        d = Q[`offset${Qr(f)}`], h = Q[`client${Qr(p)}`];
        const P = window.getComputedStyle(Q);
        return p === "width" && (t.tabs.length > 1 && (h -= Number.parseFloat(P.paddingLeft) + Number.parseFloat(P.paddingRight)), d += Number.parseFloat(P.paddingLeft)), !1;
      }), {
        [p]: `${h}px`,
        transform: `translate${Qr(u)}(${d}px)`
      };
    }, c = () => s.value = a();
    return ut(() => t.tabs, async () => {
      await so(), c();
    }, { immediate: !0 }), Qg(n, () => c()), e({
      ref: n,
      update: c
    }), (d, h) => (Tt(), mr("div", {
      ref_key: "barRef",
      ref: n,
      class: io([De(o).e("active-bar"), De(o).is(De(i).props.tabPosition)]),
      style: ss(s.value)
    }, null, 6));
  }
});
var A1 = /* @__PURE__ */ yd(X1, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/tabs/src/tab-bar.vue"]]);
const E1 = po({
  panes: {
    type: ys(Array),
    default: () => Xg([])
  },
  currentName: {
    type: [String, Number],
    default: ""
  },
  editable: Boolean,
  type: {
    type: String,
    values: ["card", "border-card", ""],
    default: ""
  },
  stretch: Boolean
}), V1 = {
  tabClick: (r, e, t) => t instanceof Event,
  tabRemove: (r, e) => e instanceof Event
}, Hh = "ElTabNav", Z1 = Wt({
  name: Hh,
  props: E1,
  emits: V1,
  setup(r, {
    expose: e,
    emit: t
  }) {
    const l = yl(), i = Er(ks);
    i || wd(Hh, "<el-tabs><tab-nav /></el-tabs>");
    const o = uo("tabs"), n = A_(), s = Y_(), a = ke(), c = ke(), d = ke(), h = ke(!1), p = ke(0), u = ke(!1), f = ke(!0), m = Mr(() => ["top", "bottom"].includes(i.props.tabPosition) ? "width" : "height"), O = Mr(() => ({
      transform: `translate${m.value === "width" ? "X" : "Y"}(-${p.value}px)`
    })), x = () => {
      if (!a.value)
        return;
      const W = a.value[`offset${Qr(m.value)}`], D = p.value;
      if (!D)
        return;
      const R = D > W ? D - W : 0;
      p.value = R;
    }, Q = () => {
      if (!a.value || !c.value)
        return;
      const W = c.value[`offset${Qr(m.value)}`], D = a.value[`offset${Qr(m.value)}`], R = p.value;
      if (W - R <= D)
        return;
      const F = W - R > D * 2 ? R + D : W - D;
      p.value = F;
    }, P = async () => {
      const W = c.value;
      if (!h.value || !d.value || !a.value || !W)
        return;
      await so();
      const D = d.value.querySelector(".is-active");
      if (!D)
        return;
      const R = a.value, F = ["top", "bottom"].includes(i.props.tabPosition), J = D.getBoundingClientRect(), ie = R.getBoundingClientRect(), fe = F ? W.offsetWidth - ie.width : W.offsetHeight - ie.height, ae = p.value;
      let H = ae;
      F ? (J.left < ie.left && (H = ae - (ie.left - J.left)), J.right > ie.right && (H = ae + J.right - ie.right)) : (J.top < ie.top && (H = ae - (ie.top - J.top)), J.bottom > ie.bottom && (H = ae + (J.bottom - ie.bottom))), H = Math.max(H, 0), p.value = Math.min(H, fe);
    }, y = () => {
      if (!c.value || !a.value)
        return;
      const W = c.value[`offset${Qr(m.value)}`], D = a.value[`offset${Qr(m.value)}`], R = p.value;
      if (D < W) {
        const F = p.value;
        h.value = h.value || {}, h.value.prev = F, h.value.next = F + D < W, W - F < D && (p.value = W - D);
      } else
        h.value = !1, R > 0 && (p.value = 0);
    }, C = (W) => {
      const D = W.code, {
        up: R,
        down: F,
        left: J,
        right: ie
      } = ln;
      if (![R, F, J, ie].includes(D))
        return;
      const fe = Array.from(W.currentTarget.querySelectorAll("[role=tab]:not(.is-disabled)")), ae = fe.indexOf(W.target);
      let H;
      D === J || D === R ? ae === 0 ? H = fe.length - 1 : H = ae - 1 : ae < fe.length - 1 ? H = ae + 1 : H = 0, fe[H].focus({
        preventScroll: !0
      }), fe[H].click(), Z();
    }, Z = () => {
      f.value && (u.value = !0);
    }, G = () => u.value = !1;
    return ut(n, (W) => {
      W === "hidden" ? f.value = !1 : W === "visible" && setTimeout(() => f.value = !0, 50);
    }), ut(s, (W) => {
      W ? setTimeout(() => f.value = !0, 50) : f.value = !1;
    }), Qg(d, y), co(() => setTimeout(() => P(), 0)), tg(() => y()), e({
      scrollToActiveTab: P,
      removeFocus: G
    }), ut(() => r.panes, () => l.update(), {
      flush: "post"
    }), () => {
      const W = h.value ? [ce("span", {
        class: [o.e("nav-prev"), o.is("disabled", !h.value.prev)],
        onClick: x
      }, [ce(nn, null, {
        default: () => [ce(H_, null, null)]
      })]), ce("span", {
        class: [o.e("nav-next"), o.is("disabled", !h.value.next)],
        onClick: Q
      }, [ce(nn, null, {
        default: () => [ce(l1, null, null)]
      })])] : null, D = r.panes.map((R, F) => {
        var J, ie, fe, ae;
        const H = R.uid, K = R.props.disabled, q = (ie = (J = R.props.name) != null ? J : R.index) != null ? ie : `${F}`, he = !K && (R.isClosable || r.editable);
        R.index = `${F}`;
        const et = he ? ce(nn, {
          class: "is-icon-close",
          onClick: (Xe) => t("tabRemove", R, Xe)
        }, {
          default: () => [ce(c1, null, null)]
        }) : null, tt = ((ae = (fe = R.slots).label) == null ? void 0 : ae.call(fe)) || R.props.label, rt = !K && R.active ? 0 : -1;
        return ce("div", {
          ref: `tab-${H}`,
          class: [o.e("item"), o.is(i.props.tabPosition), o.is("active", R.active), o.is("disabled", K), o.is("closable", he), o.is("focus", u.value)],
          id: `tab-${q}`,
          key: `tab-${H}`,
          "aria-controls": `pane-${q}`,
          role: "tab",
          "aria-selected": R.active,
          tabindex: rt,
          onFocus: () => Z(),
          onBlur: () => G(),
          onClick: (Xe) => {
            G(), t("tabClick", R, q, Xe);
          },
          onKeydown: (Xe) => {
            he && (Xe.code === ln.delete || Xe.code === ln.backspace) && t("tabRemove", R, Xe);
          }
        }, [tt, et]);
      });
      return ce("div", {
        ref: d,
        class: [o.e("nav-wrap"), o.is("scrollable", !!h.value), o.is(i.props.tabPosition)]
      }, [W, ce("div", {
        class: o.e("nav-scroll"),
        ref: a
      }, [ce("div", {
        class: [o.e("nav"), o.is(i.props.tabPosition), o.is("stretch", r.stretch && ["top", "bottom"].includes(i.props.tabPosition))],
        ref: c,
        style: O.value,
        role: "tablist",
        onKeydown: C
      }, [r.type ? null : ce(A1, {
        tabs: [...r.panes]
      }, null), D])])]);
    };
  }
}), R1 = po({
  type: {
    type: String,
    values: ["card", "border-card", ""],
    default: ""
  },
  activeName: {
    type: [String, Number]
  },
  closable: Boolean,
  addable: Boolean,
  modelValue: {
    type: [String, Number]
  },
  editable: Boolean,
  tabPosition: {
    type: String,
    values: ["top", "right", "bottom", "left"],
    default: "top"
  },
  beforeLeave: {
    type: ys(Function),
    default: () => !0
  },
  stretch: Boolean
}), Ks = (r) => $e(r) || yg(r), D1 = {
  [zg]: (r) => Ks(r),
  tabClick: (r, e) => e instanceof Event,
  tabChange: (r) => Ks(r),
  edit: (r, e) => ["remove", "add"].includes(e),
  tabRemove: (r) => Ks(r),
  tabAdd: () => !0
};
var W1 = Wt({
  name: "ElTabs",
  props: R1,
  emits: D1,
  setup(r, {
    emit: e,
    slots: t,
    expose: l
  }) {
    var i, o;
    const n = uo("tabs"), {
      children: s,
      addChild: a,
      removeChild: c
    } = S1(yl(), "ElTabPane"), d = ke(), h = ke((o = (i = r.modelValue) != null ? i : r.activeName) != null ? o : "0"), p = (x) => {
      h.value = x, e(zg, x), e("tabChange", x);
    }, u = async (x) => {
      var Q, P, y;
      if (!(h.value === x || Ja(x)))
        try {
          await ((Q = r.beforeLeave) == null ? void 0 : Q.call(r, x, h.value)) !== !1 && (p(x), (y = (P = d.value) == null ? void 0 : P.removeFocus) == null || y.call(P));
        } catch {
        }
    }, f = (x, Q, P) => {
      x.props.disabled || (u(Q), e("tabClick", x, P));
    }, m = (x, Q) => {
      x.props.disabled || Ja(x.props.name) || (Q.stopPropagation(), e("edit", x.props.name, "remove"), e("tabRemove", x.props.name));
    }, O = () => {
      e("edit", void 0, "add"), e("tabAdd");
    };
    return _1({
      from: '"activeName"',
      replacement: '"model-value" or "v-model"',
      scope: "ElTabs",
      version: "2.3.0",
      ref: "https://element-plus.org/en-US/component/tabs.html#attributes",
      type: "Attribute"
    }, Mr(() => !!r.activeName)), ut(() => r.activeName, (x) => u(x)), ut(() => r.modelValue, (x) => u(x)), ut(h, async () => {
      var x;
      await so(), (x = d.value) == null || x.scrollToActiveTab();
    }), Kf(ks, {
      props: r,
      currentName: h,
      registerPane: a,
      unregisterPane: c
    }), l({
      currentName: h
    }), () => {
      const x = r.editable || r.addable ? ce("span", {
        class: n.e("new-tab"),
        tabindex: "0",
        onClick: O,
        onKeydown: (y) => {
          y.code === ln.enter && O();
        }
      }, [ce(nn, {
        class: n.is("icon-plus")
      }, {
        default: () => [ce(g1, null, null)]
      })]) : null, Q = ce("div", {
        class: [n.e("header"), n.is(r.tabPosition)]
      }, [x, ce(Z1, {
        ref: d,
        currentName: h.value,
        editable: r.editable,
        type: r.type,
        panes: s.value,
        stretch: r.stretch,
        onTabClick: f,
        onTabRemove: m
      }, null)]), P = ce("div", {
        class: n.e("content")
      }, [fd(t, "default")]);
      return ce("div", {
        class: [n.b(), n.m(r.tabPosition), {
          [n.m("card")]: r.type === "card",
          [n.m("border-card")]: r.type === "border-card"
        }]
      }, [...r.tabPosition !== "bottom" ? [Q, P] : [P, Q]]);
    };
  }
});
const N1 = po({
  label: {
    type: String,
    default: ""
  },
  name: {
    type: [String, Number]
  },
  closable: Boolean,
  disabled: Boolean,
  lazy: Boolean
}), M1 = ["id", "aria-hidden", "aria-labelledby"], Eg = "ElTabPane", Y1 = Wt({
  name: Eg
}), j1 = /* @__PURE__ */ Wt({
  ...Y1,
  props: N1,
  setup(r) {
    const e = r, t = yl(), l = Mx(), i = Er(ks);
    i || wd(Eg, "usage: <el-tabs><el-tab-pane /></el-tabs/>");
    const o = uo("tab-pane"), n = ke(), s = Mr(() => e.closable || i.props.closable), a = Ih(() => {
      var u;
      return i.currentName.value === ((u = e.name) != null ? u : n.value);
    }), c = ke(a.value), d = Mr(() => {
      var u;
      return (u = e.name) != null ? u : n.value;
    }), h = Ih(() => !e.lazy || c.value || a.value);
    ut(a, (u) => {
      u && (c.value = !0);
    });
    const p = us({
      uid: t.uid,
      slots: l,
      props: e,
      paneName: d,
      active: a,
      index: n,
      isClosable: s
    });
    return co(() => {
      i.registerPane(p);
    }), ud(() => {
      i.unregisterPane(p.uid);
    }), (u, f) => De(h) ? K0((Tt(), mr("div", {
      key: 0,
      id: `pane-${De(d)}`,
      class: io(De(o).b()),
      role: "tabpanel",
      "aria-hidden": !De(a),
      "aria-labelledby": `tab-${De(d)}`
    }, [
      fd(u.$slots, "default")
    ], 10, M1)), [
      [d_, De(a)]
    ]) : zx("v-if", !0);
  }
});
var Vg = /* @__PURE__ */ yd(j1, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/tabs/src/tab-pane.vue"]]);
const I1 = Tg(W1, {
  TabPane: Vg
}), Po = O1(Vg);
class ue {
  /**
  @internal
  */
  constructor() {
  }
  /**
  Get the line description around the given position.
  */
  lineAt(e) {
    if (e < 0 || e > this.length)
      throw new RangeError(`Invalid position ${e} in document of length ${this.length}`);
    return this.lineInner(e, !1, 1, 0);
  }
  /**
  Get the description for the given (1-based) line number.
  */
  line(e) {
    if (e < 1 || e > this.lines)
      throw new RangeError(`Invalid line number ${e} in ${this.lines}-line document`);
    return this.lineInner(e, !0, 1, 0);
  }
  /**
  Replace a range of the text with the given content.
  */
  replace(e, t, l) {
    let i = [];
    return this.decompose(
      0,
      e,
      i,
      2
      /* Open.To */
    ), l.length && l.decompose(
      0,
      l.length,
      i,
      3
      /* Open.To */
    ), this.decompose(
      t,
      this.length,
      i,
      1
      /* Open.From */
    ), Ht.from(i, this.length - (t - e) + l.length);
  }
  /**
  Append another document to this one.
  */
  append(e) {
    return this.replace(this.length, this.length, e);
  }
  /**
  Retrieve the text between the given points.
  */
  slice(e, t = this.length) {
    let l = [];
    return this.decompose(e, t, l, 0), Ht.from(l, t - e);
  }
  /**
  Test whether this text is equal to another instance.
  */
  eq(e) {
    if (e == this)
      return !0;
    if (e.length != this.length || e.lines != this.lines)
      return !1;
    let t = this.scanIdentical(e, 1), l = this.length - this.scanIdentical(e, -1), i = new Xi(this), o = new Xi(e);
    for (let n = t, s = t; ; ) {
      if (i.next(n), o.next(n), n = 0, i.lineBreak != o.lineBreak || i.done != o.done || i.value != o.value)
        return !1;
      if (s += i.value.length, i.done || s >= l)
        return !0;
    }
  }
  /**
  Iterate over the text. When `dir` is `-1`, iteration happens
  from end to start. This will return lines and the breaks between
  them as separate strings.
  */
  iter(e = 1) {
    return new Xi(this, e);
  }
  /**
  Iterate over a range of the text. When `from` > `to`, the
  iterator will run in reverse.
  */
  iterRange(e, t = this.length) {
    return new Zg(this, e, t);
  }
  /**
  Return a cursor that iterates over the given range of lines,
  _without_ returning the line breaks between, and yielding empty
  strings for empty lines.
  
  When `from` and `to` are given, they should be 1-based line numbers.
  */
  iterLines(e, t) {
    let l;
    if (e == null)
      l = this.iter();
    else {
      t == null && (t = this.lines + 1);
      let i = this.line(e).from;
      l = this.iterRange(i, Math.max(i, t == this.lines + 1 ? this.length : t <= 1 ? 0 : this.line(t - 1).to));
    }
    return new Rg(l);
  }
  /**
  @internal
  */
  toString() {
    return this.sliceString(0);
  }
  /**
  Convert the document to an array of lines (which can be
  deserialized again via [`Text.of`](https://codemirror.net/6/docs/ref/#state.Text^of)).
  */
  toJSON() {
    let e = [];
    return this.flatten(e), e;
  }
  /**
  Create a `Text` instance for the given array of lines.
  */
  static of(e) {
    if (e.length == 0)
      throw new RangeError("A document must have at least one line");
    return e.length == 1 && !e[0] ? ue.empty : e.length <= 32 ? new Ae(e) : Ht.from(Ae.split(e, []));
  }
}
class Ae extends ue {
  constructor(e, t = U1(e)) {
    super(), this.text = e, this.length = t;
  }
  get lines() {
    return this.text.length;
  }
  get children() {
    return null;
  }
  lineInner(e, t, l, i) {
    for (let o = 0; ; o++) {
      let n = this.text[o], s = i + n.length;
      if ((t ? l : s) >= e)
        return new q1(i, s, l, n);
      i = s + 1, l++;
    }
  }
  decompose(e, t, l, i) {
    let o = e <= 0 && t >= this.length ? this : new Ae(Kh(this.text, e, t), Math.min(t, this.length) - Math.max(0, e));
    if (i & 1) {
      let n = l.pop(), s = sn(o.text, n.text.slice(), 0, o.length);
      if (s.length <= 32)
        l.push(new Ae(s, n.length + o.length));
      else {
        let a = s.length >> 1;
        l.push(new Ae(s.slice(0, a)), new Ae(s.slice(a)));
      }
    } else
      l.push(o);
  }
  replace(e, t, l) {
    if (!(l instanceof Ae))
      return super.replace(e, t, l);
    let i = sn(this.text, sn(l.text, Kh(this.text, 0, e)), t), o = this.length + l.length - (t - e);
    return i.length <= 32 ? new Ae(i, o) : Ht.from(Ae.split(i, []), o);
  }
  sliceString(e, t = this.length, l = `
`) {
    let i = "";
    for (let o = 0, n = 0; o <= t && n < this.text.length; n++) {
      let s = this.text[n], a = o + s.length;
      o > e && n && (i += l), e < a && t > o && (i += s.slice(Math.max(0, e - o), t - o)), o = a + 1;
    }
    return i;
  }
  flatten(e) {
    for (let t of this.text)
      e.push(t);
  }
  scanIdentical() {
    return 0;
  }
  static split(e, t) {
    let l = [], i = -1;
    for (let o of e)
      l.push(o), i += o.length + 1, l.length == 32 && (t.push(new Ae(l, i)), l = [], i = -1);
    return i > -1 && t.push(new Ae(l, i)), t;
  }
}
class Ht extends ue {
  constructor(e, t) {
    super(), this.children = e, this.length = t, this.lines = 0;
    for (let l of e)
      this.lines += l.lines;
  }
  lineInner(e, t, l, i) {
    for (let o = 0; ; o++) {
      let n = this.children[o], s = i + n.length, a = l + n.lines - 1;
      if ((t ? a : s) >= e)
        return n.lineInner(e, t, l, i);
      i = s + 1, l = a + 1;
    }
  }
  decompose(e, t, l, i) {
    for (let o = 0, n = 0; n <= t && o < this.children.length; o++) {
      let s = this.children[o], a = n + s.length;
      if (e <= a && t >= n) {
        let c = i & ((n <= e ? 1 : 0) | (a >= t ? 2 : 0));
        n >= e && a <= t && !c ? l.push(s) : s.decompose(e - n, t - n, l, c);
      }
      n = a + 1;
    }
  }
  replace(e, t, l) {
    if (l.lines < this.lines)
      for (let i = 0, o = 0; i < this.children.length; i++) {
        let n = this.children[i], s = o + n.length;
        if (e >= o && t <= s) {
          let a = n.replace(e - o, t - o, l), c = this.lines - n.lines + a.lines;
          if (a.lines < c >> 5 - 1 && a.lines > c >> 5 + 1) {
            let d = this.children.slice();
            return d[i] = a, new Ht(d, this.length - (t - e) + l.length);
          }
          return super.replace(o, s, a);
        }
        o = s + 1;
      }
    return super.replace(e, t, l);
  }
  sliceString(e, t = this.length, l = `
`) {
    let i = "";
    for (let o = 0, n = 0; o < this.children.length && n <= t; o++) {
      let s = this.children[o], a = n + s.length;
      n > e && o && (i += l), e < a && t > n && (i += s.sliceString(e - n, t - n, l)), n = a + 1;
    }
    return i;
  }
  flatten(e) {
    for (let t of this.children)
      t.flatten(e);
  }
  scanIdentical(e, t) {
    if (!(e instanceof Ht))
      return 0;
    let l = 0, [i, o, n, s] = t > 0 ? [0, 0, this.children.length, e.children.length] : [this.children.length - 1, e.children.length - 1, -1, -1];
    for (; ; i += t, o += t) {
      if (i == n || o == s)
        return l;
      let a = this.children[i], c = e.children[o];
      if (a != c)
        return l + a.scanIdentical(c, t);
      l += a.length + 1;
    }
  }
  static from(e, t = e.reduce((l, i) => l + i.length + 1, -1)) {
    let l = 0;
    for (let u of e)
      l += u.lines;
    if (l < 32) {
      let u = [];
      for (let f of e)
        f.flatten(u);
      return new Ae(u, t);
    }
    let i = Math.max(
      32,
      l >> 5
      /* Tree.BranchShift */
    ), o = i << 1, n = i >> 1, s = [], a = 0, c = -1, d = [];
    function h(u) {
      let f;
      if (u.lines > o && u instanceof Ht)
        for (let m of u.children)
          h(m);
      else
        u.lines > n && (a > n || !a) ? (p(), s.push(u)) : u instanceof Ae && a && (f = d[d.length - 1]) instanceof Ae && u.lines + f.lines <= 32 ? (a += u.lines, c += u.length + 1, d[d.length - 1] = new Ae(f.text.concat(u.text), f.length + 1 + u.length)) : (a + u.lines > i && p(), a += u.lines, c += u.length + 1, d.push(u));
    }
    function p() {
      a != 0 && (s.push(d.length == 1 ? d[0] : Ht.from(d, c)), c = -1, a = d.length = 0);
    }
    for (let u of e)
      h(u);
    return p(), s.length == 1 ? s[0] : new Ht(s, t);
  }
}
ue.empty = /* @__PURE__ */ new Ae([""], 0);
function U1(r) {
  let e = -1;
  for (let t of r)
    e += t.length + 1;
  return e;
}
function sn(r, e, t = 0, l = 1e9) {
  for (let i = 0, o = 0, n = !0; o < r.length && i <= l; o++) {
    let s = r[o], a = i + s.length;
    a >= t && (a > l && (s = s.slice(0, l - i)), i < t && (s = s.slice(t - i)), n ? (e[e.length - 1] += s, n = !1) : e.push(s)), i = a + 1;
  }
  return e;
}
function Kh(r, e, t) {
  return sn(r, [""], e, t);
}
class Xi {
  constructor(e, t = 1) {
    this.dir = t, this.done = !1, this.lineBreak = !1, this.value = "", this.nodes = [e], this.offsets = [t > 0 ? 1 : (e instanceof Ae ? e.text.length : e.children.length) << 1];
  }
  nextInner(e, t) {
    for (this.done = this.lineBreak = !1; ; ) {
      let l = this.nodes.length - 1, i = this.nodes[l], o = this.offsets[l], n = o >> 1, s = i instanceof Ae ? i.text.length : i.children.length;
      if (n == (t > 0 ? s : 0)) {
        if (l == 0)
          return this.done = !0, this.value = "", this;
        t > 0 && this.offsets[l - 1]++, this.nodes.pop(), this.offsets.pop();
      } else if ((o & 1) == (t > 0 ? 0 : 1)) {
        if (this.offsets[l] += t, e == 0)
          return this.lineBreak = !0, this.value = `
`, this;
        e--;
      } else if (i instanceof Ae) {
        let a = i.text[n + (t < 0 ? -1 : 0)];
        if (this.offsets[l] += t, a.length > Math.max(0, e))
          return this.value = e == 0 ? a : t > 0 ? a.slice(e) : a.slice(0, a.length - e), this;
        e -= a.length;
      } else {
        let a = i.children[n + (t < 0 ? -1 : 0)];
        e > a.length ? (e -= a.length, this.offsets[l] += t) : (t < 0 && this.offsets[l]--, this.nodes.push(a), this.offsets.push(t > 0 ? 1 : (a instanceof Ae ? a.text.length : a.children.length) << 1));
      }
    }
  }
  next(e = 0) {
    return e < 0 && (this.nextInner(-e, -this.dir), e = this.value.length), this.nextInner(e, this.dir);
  }
}
class Zg {
  constructor(e, t, l) {
    this.value = "", this.done = !1, this.cursor = new Xi(e, t > l ? -1 : 1), this.pos = t > l ? e.length : 0, this.from = Math.min(t, l), this.to = Math.max(t, l);
  }
  nextInner(e, t) {
    if (t < 0 ? this.pos <= this.from : this.pos >= this.to)
      return this.value = "", this.done = !0, this;
    e += Math.max(0, t < 0 ? this.pos - this.to : this.from - this.pos);
    let l = t < 0 ? this.pos - this.from : this.to - this.pos;
    e > l && (e = l), l -= e;
    let { value: i } = this.cursor.next(e);
    return this.pos += (i.length + e) * t, this.value = i.length <= l ? i : t < 0 ? i.slice(i.length - l) : i.slice(0, l), this.done = !this.value, this;
  }
  next(e = 0) {
    return e < 0 ? e = Math.max(e, this.from - this.pos) : e > 0 && (e = Math.min(e, this.to - this.pos)), this.nextInner(e, this.cursor.dir);
  }
  get lineBreak() {
    return this.cursor.lineBreak && this.value != "";
  }
}
class Rg {
  constructor(e) {
    this.inner = e, this.afterBreak = !0, this.value = "", this.done = !1;
  }
  next(e = 0) {
    let { done: t, lineBreak: l, value: i } = this.inner.next(e);
    return t ? (this.done = !0, this.value = "") : l ? this.afterBreak ? this.value = "" : (this.afterBreak = !0, this.next()) : (this.value = i, this.afterBreak = !1), this;
  }
  get lineBreak() {
    return !1;
  }
}
typeof Symbol < "u" && (ue.prototype[Symbol.iterator] = function() {
  return this.iter();
}, Xi.prototype[Symbol.iterator] = Zg.prototype[Symbol.iterator] = Rg.prototype[Symbol.iterator] = function() {
  return this;
});
class q1 {
  /**
  @internal
  */
  constructor(e, t, l, i) {
    this.from = e, this.to = t, this.number = l, this.text = i;
  }
  /**
  The length of the line (not including any line break after it).
  */
  get length() {
    return this.to - this.from;
  }
}
let Yl = /* @__PURE__ */ "lc,34,7n,7,7b,19,,,,2,,2,,,20,b,1c,l,g,,2t,7,2,6,2,2,,4,z,,u,r,2j,b,1m,9,9,,o,4,,9,,3,,5,17,3,3b,f,,w,1j,,,,4,8,4,,3,7,a,2,t,,1m,,,,2,4,8,,9,,a,2,q,,2,2,1l,,4,2,4,2,2,3,3,,u,2,3,,b,2,1l,,4,5,,2,4,,k,2,m,6,,,1m,,,2,,4,8,,7,3,a,2,u,,1n,,,,c,,9,,14,,3,,1l,3,5,3,,4,7,2,b,2,t,,1m,,2,,2,,3,,5,2,7,2,b,2,s,2,1l,2,,,2,4,8,,9,,a,2,t,,20,,4,,2,3,,,8,,29,,2,7,c,8,2q,,2,9,b,6,22,2,r,,,,,,1j,e,,5,,2,5,b,,10,9,,2u,4,,6,,2,2,2,p,2,4,3,g,4,d,,2,2,6,,f,,jj,3,qa,3,t,3,t,2,u,2,1s,2,,7,8,,2,b,9,,19,3,3b,2,y,,3a,3,4,2,9,,6,3,63,2,2,,1m,,,7,,,,,2,8,6,a,2,,1c,h,1r,4,1c,7,,,5,,14,9,c,2,w,4,2,2,,3,1k,,,2,3,,,3,1m,8,2,2,48,3,,d,,7,4,,6,,3,2,5i,1m,,5,ek,,5f,x,2da,3,3x,,2o,w,fe,6,2x,2,n9w,4,,a,w,2,28,2,7k,,3,,4,,p,2,5,,47,2,q,i,d,,12,8,p,b,1a,3,1c,,2,4,2,2,13,,1v,6,2,2,2,2,c,,8,,1b,,1f,,,3,2,2,5,2,,,16,2,8,,6m,,2,,4,,fn4,,kh,g,g,g,a6,2,gt,,6a,,45,5,1ae,3,,2,5,4,14,3,4,,4l,2,fx,4,ar,2,49,b,4w,,1i,f,1k,3,1d,4,2,2,1x,3,10,5,,8,1q,,c,2,1g,9,a,4,2,,2n,3,2,,,2,6,,4g,,3,8,l,2,1l,2,,,,,m,,e,7,3,5,5f,8,2,3,,,n,,29,,2,6,,,2,,,2,,2,6j,,2,4,6,2,,2,r,2,2d,8,2,,,2,2y,,,,2,6,,,2t,3,2,4,,5,77,9,,2,6t,,a,2,,,4,,40,4,2,2,4,,w,a,14,6,2,4,8,,9,6,2,3,1a,d,,2,ba,7,,6,,,2a,m,2,7,,2,,2,3e,6,3,,,2,,7,,,20,2,3,,,,9n,2,f0b,5,1n,7,t4,,1r,4,29,,f5k,2,43q,,,3,4,5,8,8,2,7,u,4,44,3,1iz,1j,4,1e,8,,e,,m,5,,f,11s,7,,h,2,7,,2,,5,79,7,c5,4,15s,7,31,7,240,5,gx7k,2o,3k,6o".split(",").map((r) => r ? parseInt(r, 36) : 1);
for (let r = 1; r < Yl.length; r++)
  Yl[r] += Yl[r - 1];
function B1(r) {
  for (let e = 1; e < Yl.length; e += 2)
    if (Yl[e] > r)
      return Yl[e - 1] <= r;
  return !1;
}
function Jh(r) {
  return r >= 127462 && r <= 127487;
}
const ep = 8205;
function nt(r, e, t = !0, l = !0) {
  return (t ? Dg : L1)(r, e, l);
}
function Dg(r, e, t) {
  if (e == r.length)
    return e;
  e && Wg(r.charCodeAt(e)) && Ng(r.charCodeAt(e - 1)) && e--;
  let l = Be(r, e);
  for (e += xt(l); e < r.length; ) {
    let i = Be(r, e);
    if (l == ep || i == ep || t && B1(i))
      e += xt(i), l = i;
    else if (Jh(i)) {
      let o = 0, n = e - 2;
      for (; n >= 0 && Jh(Be(r, n)); )
        o++, n -= 2;
      if (o % 2 == 0)
        break;
      e += 2;
    } else
      break;
  }
  return e;
}
function L1(r, e, t) {
  for (; e > 0; ) {
    let l = Dg(r, e - 2, t);
    if (l < e)
      return l;
    e--;
  }
  return 0;
}
function Wg(r) {
  return r >= 56320 && r < 57344;
}
function Ng(r) {
  return r >= 55296 && r < 56320;
}
function Be(r, e) {
  let t = r.charCodeAt(e);
  if (!Ng(t) || e + 1 == r.length)
    return t;
  let l = r.charCodeAt(e + 1);
  return Wg(l) ? (t - 55296 << 10) + (l - 56320) + 65536 : t;
}
function kd(r) {
  return r <= 65535 ? String.fromCharCode(r) : (r -= 65536, String.fromCharCode((r >> 10) + 55296, (r & 1023) + 56320));
}
function xt(r) {
  return r < 65536 ? 1 : 2;
}
const ec = /\r\n?|\n/;
var Ge = /* @__PURE__ */ function(r) {
  return r[r.Simple = 0] = "Simple", r[r.TrackDel = 1] = "TrackDel", r[r.TrackBefore = 2] = "TrackBefore", r[r.TrackAfter = 3] = "TrackAfter", r;
}(Ge || (Ge = {}));
class tr {
  // Sections are encoded as pairs of integers. The first is the
  // length in the current document, and the second is -1 for
  // unaffected sections, and the length of the replacement content
  // otherwise. So an insertion would be (0, n>0), a deletion (n>0,
  // 0), and a replacement two positive numbers.
  /**
  @internal
  */
  constructor(e) {
    this.sections = e;
  }
  /**
  The length of the document before the change.
  */
  get length() {
    let e = 0;
    for (let t = 0; t < this.sections.length; t += 2)
      e += this.sections[t];
    return e;
  }
  /**
  The length of the document after the change.
  */
  get newLength() {
    let e = 0;
    for (let t = 0; t < this.sections.length; t += 2) {
      let l = this.sections[t + 1];
      e += l < 0 ? this.sections[t] : l;
    }
    return e;
  }
  /**
  False when there are actual changes in this set.
  */
  get empty() {
    return this.sections.length == 0 || this.sections.length == 2 && this.sections[1] < 0;
  }
  /**
  Iterate over the unchanged parts left by these changes. `posA`
  provides the position of the range in the old document, `posB`
  the new position in the changed document.
  */
  iterGaps(e) {
    for (let t = 0, l = 0, i = 0; t < this.sections.length; ) {
      let o = this.sections[t++], n = this.sections[t++];
      n < 0 ? (e(l, i, o), i += o) : i += n, l += o;
    }
  }
  /**
  Iterate over the ranges changed by these changes. (See
  [`ChangeSet.iterChanges`](https://codemirror.net/6/docs/ref/#state.ChangeSet.iterChanges) for a
  variant that also provides you with the inserted text.)
  `fromA`/`toA` provides the extent of the change in the starting
  document, `fromB`/`toB` the extent of the replacement in the
  changed document.
  
  When `individual` is true, adjacent changes (which are kept
  separate for [position mapping](https://codemirror.net/6/docs/ref/#state.ChangeDesc.mapPos)) are
  reported separately.
  */
  iterChangedRanges(e, t = !1) {
    tc(this, e, t);
  }
  /**
  Get a description of the inverted form of these changes.
  */
  get invertedDesc() {
    let e = [];
    for (let t = 0; t < this.sections.length; ) {
      let l = this.sections[t++], i = this.sections[t++];
      i < 0 ? e.push(l, i) : e.push(i, l);
    }
    return new tr(e);
  }
  /**
  Compute the combined effect of applying another set of changes
  after this one. The length of the document after this set should
  match the length before `other`.
  */
  composeDesc(e) {
    return this.empty ? e : e.empty ? this : Mg(this, e);
  }
  /**
  Map this description, which should start with the same document
  as `other`, over another set of changes, so that it can be
  applied after it. When `before` is true, map as if the changes
  in `other` happened before the ones in `this`.
  */
  mapDesc(e, t = !1) {
    return e.empty ? this : rc(this, e, t);
  }
  mapPos(e, t = -1, l = Ge.Simple) {
    let i = 0, o = 0;
    for (let n = 0; n < this.sections.length; ) {
      let s = this.sections[n++], a = this.sections[n++], c = i + s;
      if (a < 0) {
        if (c > e)
          return o + (e - i);
        o += s;
      } else {
        if (l != Ge.Simple && c >= e && (l == Ge.TrackDel && i < e && c > e || l == Ge.TrackBefore && i < e || l == Ge.TrackAfter && c > e))
          return null;
        if (c > e || c == e && t < 0 && !s)
          return e == i || t < 0 ? o : o + a;
        o += a;
      }
      i = c;
    }
    if (e > i)
      throw new RangeError(`Position ${e} is out of range for changeset of length ${i}`);
    return o;
  }
  /**
  Check whether these changes touch a given range. When one of the
  changes entirely covers the range, the string `"cover"` is
  returned.
  */
  touchesRange(e, t = e) {
    for (let l = 0, i = 0; l < this.sections.length && i <= t; ) {
      let o = this.sections[l++], n = this.sections[l++], s = i + o;
      if (n >= 0 && i <= t && s >= e)
        return i < e && s > t ? "cover" : !0;
      i = s;
    }
    return !1;
  }
  /**
  @internal
  */
  toString() {
    let e = "";
    for (let t = 0; t < this.sections.length; ) {
      let l = this.sections[t++], i = this.sections[t++];
      e += (e ? " " : "") + l + (i >= 0 ? ":" + i : "");
    }
    return e;
  }
  /**
  Serialize this change desc to a JSON-representable value.
  */
  toJSON() {
    return this.sections;
  }
  /**
  Create a change desc from its JSON representation (as produced
  by [`toJSON`](https://codemirror.net/6/docs/ref/#state.ChangeDesc.toJSON).
  */
  static fromJSON(e) {
    if (!Array.isArray(e) || e.length % 2 || e.some((t) => typeof t != "number"))
      throw new RangeError("Invalid JSON representation of ChangeDesc");
    return new tr(e);
  }
  /**
  @internal
  */
  static create(e) {
    return new tr(e);
  }
}
class Re extends tr {
  constructor(e, t) {
    super(e), this.inserted = t;
  }
  /**
  Apply the changes to a document, returning the modified
  document.
  */
  apply(e) {
    if (this.length != e.length)
      throw new RangeError("Applying change set to a document with the wrong length");
    return tc(this, (t, l, i, o, n) => e = e.replace(i, i + (l - t), n), !1), e;
  }
  mapDesc(e, t = !1) {
    return rc(this, e, t, !0);
  }
  /**
  Given the document as it existed _before_ the changes, return a
  change set that represents the inverse of this set, which could
  be used to go from the document created by the changes back to
  the document as it existed before the changes.
  */
  invert(e) {
    let t = this.sections.slice(), l = [];
    for (let i = 0, o = 0; i < t.length; i += 2) {
      let n = t[i], s = t[i + 1];
      if (s >= 0) {
        t[i] = s, t[i + 1] = n;
        let a = i >> 1;
        for (; l.length < a; )
          l.push(ue.empty);
        l.push(n ? e.slice(o, o + n) : ue.empty);
      }
      o += n;
    }
    return new Re(t, l);
  }
  /**
  Combine two subsequent change sets into a single set. `other`
  must start in the document produced by `this`. If `this` goes
  `docA` → `docB` and `other` represents `docB` → `docC`, the
  returned value will represent the change `docA` → `docC`.
  */
  compose(e) {
    return this.empty ? e : e.empty ? this : Mg(this, e, !0);
  }
  /**
  Given another change set starting in the same document, maps this
  change set over the other, producing a new change set that can be
  applied to the document produced by applying `other`. When
  `before` is `true`, order changes as if `this` comes before
  `other`, otherwise (the default) treat `other` as coming first.
  
  Given two changes `A` and `B`, `A.compose(B.map(A))` and
  `B.compose(A.map(B, true))` will produce the same document. This
  provides a basic form of [operational
  transformation](https://en.wikipedia.org/wiki/Operational_transformation),
  and can be used for collaborative editing.
  */
  map(e, t = !1) {
    return e.empty ? this : rc(this, e, t, !0);
  }
  /**
  Iterate over the changed ranges in the document, calling `f` for
  each, with the range in the original document (`fromA`-`toA`)
  and the range that replaces it in the new document
  (`fromB`-`toB`).
  
  When `individual` is true, adjacent changes are reported
  separately.
  */
  iterChanges(e, t = !1) {
    tc(this, e, t);
  }
  /**
  Get a [change description](https://codemirror.net/6/docs/ref/#state.ChangeDesc) for this change
  set.
  */
  get desc() {
    return tr.create(this.sections);
  }
  /**
  @internal
  */
  filter(e) {
    let t = [], l = [], i = [], o = new ji(this);
    e:
      for (let n = 0, s = 0; ; ) {
        let a = n == e.length ? 1e9 : e[n++];
        for (; s < a || s == a && o.len == 0; ) {
          if (o.done)
            break e;
          let d = Math.min(o.len, a - s);
          Fe(i, d, -1);
          let h = o.ins == -1 ? -1 : o.off == 0 ? o.ins : 0;
          Fe(t, d, h), h > 0 && Pr(l, t, o.text), o.forward(d), s += d;
        }
        let c = e[n++];
        for (; s < c; ) {
          if (o.done)
            break e;
          let d = Math.min(o.len, c - s);
          Fe(t, d, -1), Fe(i, d, o.ins == -1 ? -1 : o.off == 0 ? o.ins : 0), o.forward(d), s += d;
        }
      }
    return {
      changes: new Re(t, l),
      filtered: tr.create(i)
    };
  }
  /**
  Serialize this change set to a JSON-representable value.
  */
  toJSON() {
    let e = [];
    for (let t = 0; t < this.sections.length; t += 2) {
      let l = this.sections[t], i = this.sections[t + 1];
      i < 0 ? e.push(l) : i == 0 ? e.push([l]) : e.push([l].concat(this.inserted[t >> 1].toJSON()));
    }
    return e;
  }
  /**
  Create a change set for the given changes, for a document of the
  given length, using `lineSep` as line separator.
  */
  static of(e, t, l) {
    let i = [], o = [], n = 0, s = null;
    function a(d = !1) {
      if (!d && !i.length)
        return;
      n < t && Fe(i, t - n, -1);
      let h = new Re(i, o);
      s = s ? s.compose(h.map(s)) : h, i = [], o = [], n = 0;
    }
    function c(d) {
      if (Array.isArray(d))
        for (let h of d)
          c(h);
      else if (d instanceof Re) {
        if (d.length != t)
          throw new RangeError(`Mismatched change set length (got ${d.length}, expected ${t})`);
        a(), s = s ? s.compose(d.map(s)) : d;
      } else {
        let { from: h, to: p = h, insert: u } = d;
        if (h > p || h < 0 || p > t)
          throw new RangeError(`Invalid change range ${h} to ${p} (in doc of length ${t})`);
        let f = u ? typeof u == "string" ? ue.of(u.split(l || ec)) : u : ue.empty, m = f.length;
        if (h == p && m == 0)
          return;
        h < n && a(), h > n && Fe(i, h - n, -1), Fe(i, p - h, m), Pr(o, i, f), n = p;
      }
    }
    return c(e), a(!s), s;
  }
  /**
  Create an empty changeset of the given length.
  */
  static empty(e) {
    return new Re(e ? [e, -1] : [], []);
  }
  /**
  Create a changeset from its JSON representation (as produced by
  [`toJSON`](https://codemirror.net/6/docs/ref/#state.ChangeSet.toJSON).
  */
  static fromJSON(e) {
    if (!Array.isArray(e))
      throw new RangeError("Invalid JSON representation of ChangeSet");
    let t = [], l = [];
    for (let i = 0; i < e.length; i++) {
      let o = e[i];
      if (typeof o == "number")
        t.push(o, -1);
      else {
        if (!Array.isArray(o) || typeof o[0] != "number" || o.some((n, s) => s && typeof n != "string"))
          throw new RangeError("Invalid JSON representation of ChangeSet");
        if (o.length == 1)
          t.push(o[0], 0);
        else {
          for (; l.length < i; )
            l.push(ue.empty);
          l[i] = ue.of(o.slice(1)), t.push(o[0], l[i].length);
        }
      }
    }
    return new Re(t, l);
  }
  /**
  @internal
  */
  static createSet(e, t) {
    return new Re(e, t);
  }
}
function Fe(r, e, t, l = !1) {
  if (e == 0 && t <= 0)
    return;
  let i = r.length - 2;
  i >= 0 && t <= 0 && t == r[i + 1] ? r[i] += e : e == 0 && r[i] == 0 ? r[i + 1] += t : l ? (r[i] += e, r[i + 1] += t) : r.push(e, t);
}
function Pr(r, e, t) {
  if (t.length == 0)
    return;
  let l = e.length - 2 >> 1;
  if (l < r.length)
    r[r.length - 1] = r[r.length - 1].append(t);
  else {
    for (; r.length < l; )
      r.push(ue.empty);
    r.push(t);
  }
}
function tc(r, e, t) {
  let l = r.inserted;
  for (let i = 0, o = 0, n = 0; n < r.sections.length; ) {
    let s = r.sections[n++], a = r.sections[n++];
    if (a < 0)
      i += s, o += s;
    else {
      let c = i, d = o, h = ue.empty;
      for (; c += s, d += a, a && l && (h = h.append(l[n - 2 >> 1])), !(t || n == r.sections.length || r.sections[n + 1] < 0); )
        s = r.sections[n++], a = r.sections[n++];
      e(i, c, o, d, h), i = c, o = d;
    }
  }
}
function rc(r, e, t, l = !1) {
  let i = [], o = l ? [] : null, n = new ji(r), s = new ji(e);
  for (let a = -1; ; )
    if (n.ins == -1 && s.ins == -1) {
      let c = Math.min(n.len, s.len);
      Fe(i, c, -1), n.forward(c), s.forward(c);
    } else if (s.ins >= 0 && (n.ins < 0 || a == n.i || n.off == 0 && (s.len < n.len || s.len == n.len && !t))) {
      let c = s.len;
      for (Fe(i, s.ins, -1); c; ) {
        let d = Math.min(n.len, c);
        n.ins >= 0 && a < n.i && n.len <= d && (Fe(i, 0, n.ins), o && Pr(o, i, n.text), a = n.i), n.forward(d), c -= d;
      }
      s.next();
    } else if (n.ins >= 0) {
      let c = 0, d = n.len;
      for (; d; )
        if (s.ins == -1) {
          let h = Math.min(d, s.len);
          c += h, d -= h, s.forward(h);
        } else if (s.ins == 0 && s.len < d)
          d -= s.len, s.next();
        else
          break;
      Fe(i, c, a < n.i ? n.ins : 0), o && a < n.i && Pr(o, i, n.text), a = n.i, n.forward(n.len - d);
    } else {
      if (n.done && s.done)
        return o ? Re.createSet(i, o) : tr.create(i);
      throw new Error("Mismatched change set lengths");
    }
}
function Mg(r, e, t = !1) {
  let l = [], i = t ? [] : null, o = new ji(r), n = new ji(e);
  for (let s = !1; ; ) {
    if (o.done && n.done)
      return i ? Re.createSet(l, i) : tr.create(l);
    if (o.ins == 0)
      Fe(l, o.len, 0, s), o.next();
    else if (n.len == 0 && !n.done)
      Fe(l, 0, n.ins, s), i && Pr(i, l, n.text), n.next();
    else {
      if (o.done || n.done)
        throw new Error("Mismatched change set lengths");
      {
        let a = Math.min(o.len2, n.len), c = l.length;
        if (o.ins == -1) {
          let d = n.ins == -1 ? -1 : n.off ? 0 : n.ins;
          Fe(l, a, d, s), i && d && Pr(i, l, n.text);
        } else
          n.ins == -1 ? (Fe(l, o.off ? 0 : o.len, a, s), i && Pr(i, l, o.textBit(a))) : (Fe(l, o.off ? 0 : o.len, n.off ? 0 : n.ins, s), i && !n.off && Pr(i, l, n.text));
        s = (o.ins > a || n.ins >= 0 && n.len > a) && (s || l.length > c), o.forward2(a), n.forward(a);
      }
    }
  }
}
class ji {
  constructor(e) {
    this.set = e, this.i = 0, this.next();
  }
  next() {
    let { sections: e } = this.set;
    this.i < e.length ? (this.len = e[this.i++], this.ins = e[this.i++]) : (this.len = 0, this.ins = -2), this.off = 0;
  }
  get done() {
    return this.ins == -2;
  }
  get len2() {
    return this.ins < 0 ? this.len : this.ins;
  }
  get text() {
    let { inserted: e } = this.set, t = this.i - 2 >> 1;
    return t >= e.length ? ue.empty : e[t];
  }
  textBit(e) {
    let { inserted: t } = this.set, l = this.i - 2 >> 1;
    return l >= t.length && !e ? ue.empty : t[l].slice(this.off, e == null ? void 0 : this.off + e);
  }
  forward(e) {
    e == this.len ? this.next() : (this.len -= e, this.off += e);
  }
  forward2(e) {
    this.ins == -1 ? this.forward(e) : e == this.ins ? this.next() : (this.ins -= e, this.off += e);
  }
}
class sl {
  constructor(e, t, l) {
    this.from = e, this.to = t, this.flags = l;
  }
  /**
  The anchor of the range—the side that doesn't move when you
  extend it.
  */
  get anchor() {
    return this.flags & 16 ? this.to : this.from;
  }
  /**
  The head of the range, which is moved when the range is
  [extended](https://codemirror.net/6/docs/ref/#state.SelectionRange.extend).
  */
  get head() {
    return this.flags & 16 ? this.from : this.to;
  }
  /**
  True when `anchor` and `head` are at the same position.
  */
  get empty() {
    return this.from == this.to;
  }
  /**
  If this is a cursor that is explicitly associated with the
  character on one of its sides, this returns the side. -1 means
  the character before its position, 1 the character after, and 0
  means no association.
  */
  get assoc() {
    return this.flags & 4 ? -1 : this.flags & 8 ? 1 : 0;
  }
  /**
  The bidirectional text level associated with this cursor, if
  any.
  */
  get bidiLevel() {
    let e = this.flags & 3;
    return e == 3 ? null : e;
  }
  /**
  The goal column (stored vertical offset) associated with a
  cursor. This is used to preserve the vertical position when
  [moving](https://codemirror.net/6/docs/ref/#view.EditorView.moveVertically) across
  lines of different length.
  */
  get goalColumn() {
    let e = this.flags >> 5;
    return e == 33554431 ? void 0 : e;
  }
  /**
  Map this range through a change, producing a valid range in the
  updated document.
  */
  map(e, t = -1) {
    let l, i;
    return this.empty ? l = i = e.mapPos(this.from, t) : (l = e.mapPos(this.from, 1), i = e.mapPos(this.to, -1)), l == this.from && i == this.to ? this : new sl(l, i, this.flags);
  }
  /**
  Extend this range to cover at least `from` to `to`.
  */
  extend(e, t = e) {
    if (e <= this.anchor && t >= this.anchor)
      return w.range(e, t);
    let l = Math.abs(e - this.anchor) > Math.abs(t - this.anchor) ? e : t;
    return w.range(this.anchor, l);
  }
  /**
  Compare this range to another range.
  */
  eq(e) {
    return this.anchor == e.anchor && this.head == e.head;
  }
  /**
  Return a JSON-serializable object representing the range.
  */
  toJSON() {
    return { anchor: this.anchor, head: this.head };
  }
  /**
  Convert a JSON representation of a range to a `SelectionRange`
  instance.
  */
  static fromJSON(e) {
    if (!e || typeof e.anchor != "number" || typeof e.head != "number")
      throw new RangeError("Invalid JSON representation for SelectionRange");
    return w.range(e.anchor, e.head);
  }
  /**
  @internal
  */
  static create(e, t, l) {
    return new sl(e, t, l);
  }
}
class w {
  constructor(e, t) {
    this.ranges = e, this.mainIndex = t;
  }
  /**
  Map a selection through a change. Used to adjust the selection
  position for changes.
  */
  map(e, t = -1) {
    return e.empty ? this : w.create(this.ranges.map((l) => l.map(e, t)), this.mainIndex);
  }
  /**
  Compare this selection to another selection.
  */
  eq(e) {
    if (this.ranges.length != e.ranges.length || this.mainIndex != e.mainIndex)
      return !1;
    for (let t = 0; t < this.ranges.length; t++)
      if (!this.ranges[t].eq(e.ranges[t]))
        return !1;
    return !0;
  }
  /**
  Get the primary selection range. Usually, you should make sure
  your code applies to _all_ ranges, by using methods like
  [`changeByRange`](https://codemirror.net/6/docs/ref/#state.EditorState.changeByRange).
  */
  get main() {
    return this.ranges[this.mainIndex];
  }
  /**
  Make sure the selection only has one range. Returns a selection
  holding only the main range from this selection.
  */
  asSingle() {
    return this.ranges.length == 1 ? this : new w([this.main], 0);
  }
  /**
  Extend this selection with an extra range.
  */
  addRange(e, t = !0) {
    return w.create([e].concat(this.ranges), t ? 0 : this.mainIndex + 1);
  }
  /**
  Replace a given range with another range, and then normalize the
  selection to merge and sort ranges if necessary.
  */
  replaceRange(e, t = this.mainIndex) {
    let l = this.ranges.slice();
    return l[t] = e, w.create(l, this.mainIndex);
  }
  /**
  Convert this selection to an object that can be serialized to
  JSON.
  */
  toJSON() {
    return { ranges: this.ranges.map((e) => e.toJSON()), main: this.mainIndex };
  }
  /**
  Create a selection from a JSON representation.
  */
  static fromJSON(e) {
    if (!e || !Array.isArray(e.ranges) || typeof e.main != "number" || e.main >= e.ranges.length)
      throw new RangeError("Invalid JSON representation for EditorSelection");
    return new w(e.ranges.map((t) => sl.fromJSON(t)), e.main);
  }
  /**
  Create a selection holding a single range.
  */
  static single(e, t = e) {
    return new w([w.range(e, t)], 0);
  }
  /**
  Sort and merge the given set of ranges, creating a valid
  selection.
  */
  static create(e, t = 0) {
    if (e.length == 0)
      throw new RangeError("A selection needs at least one range");
    for (let l = 0, i = 0; i < e.length; i++) {
      let o = e[i];
      if (o.empty ? o.from <= l : o.from < l)
        return w.normalized(e.slice(), t);
      l = o.to;
    }
    return new w(e, t);
  }
  /**
  Create a cursor selection range at the given position. You can
  safely ignore the optional arguments in most situations.
  */
  static cursor(e, t = 0, l, i) {
    return sl.create(e, e, (t == 0 ? 0 : t < 0 ? 4 : 8) | (l == null ? 3 : Math.min(2, l)) | (i ?? 33554431) << 5);
  }
  /**
  Create a selection range.
  */
  static range(e, t, l, i) {
    let o = (l ?? 33554431) << 5 | (i == null ? 3 : Math.min(2, i));
    return t < e ? sl.create(t, e, 24 | o) : sl.create(e, t, (t > e ? 4 : 0) | o);
  }
  /**
  @internal
  */
  static normalized(e, t = 0) {
    let l = e[t];
    e.sort((i, o) => i.from - o.from), t = e.indexOf(l);
    for (let i = 1; i < e.length; i++) {
      let o = e[i], n = e[i - 1];
      if (o.empty ? o.from <= n.to : o.from < n.to) {
        let s = n.from, a = Math.max(o.to, n.to);
        i <= t && t--, e.splice(--i, 2, o.anchor > o.head ? w.range(a, s) : w.range(s, a));
      }
    }
    return new w(e, t);
  }
}
function Yg(r, e) {
  for (let t of r.ranges)
    if (t.to > e)
      throw new RangeError("Selection points outside of document");
}
let Sd = 0;
class Y {
  constructor(e, t, l, i, o) {
    this.combine = e, this.compareInput = t, this.compare = l, this.isStatic = i, this.id = Sd++, this.default = e([]), this.extensions = typeof o == "function" ? o(this) : o;
  }
  /**
  Define a new facet.
  */
  static define(e = {}) {
    return new Y(e.combine || ((t) => t), e.compareInput || ((t, l) => t === l), e.compare || (e.combine ? (t, l) => t === l : Qd), !!e.static, e.enables);
  }
  /**
  Returns an extension that adds the given value to this facet.
  */
  of(e) {
    return new an([], this, 0, e);
  }
  /**
  Create an extension that computes a value for the facet from a
  state. You must take care to declare the parts of the state that
  this value depends on, since your function is only called again
  for a new state when one of those parts changed.
  
  In cases where your value depends only on a single field, you'll
  want to use the [`from`](https://codemirror.net/6/docs/ref/#state.Facet.from) method instead.
  */
  compute(e, t) {
    if (this.isStatic)
      throw new Error("Can't compute a static facet");
    return new an(e, this, 1, t);
  }
  /**
  Create an extension that computes zero or more values for this
  facet from a state.
  */
  computeN(e, t) {
    if (this.isStatic)
      throw new Error("Can't compute a static facet");
    return new an(e, this, 2, t);
  }
  from(e, t) {
    return t || (t = (l) => l), this.compute([e], (l) => t(l.field(e)));
  }
}
function Qd(r, e) {
  return r == e || r.length == e.length && r.every((t, l) => t === e[l]);
}
class an {
  constructor(e, t, l, i) {
    this.dependencies = e, this.facet = t, this.type = l, this.value = i, this.id = Sd++;
  }
  dynamicSlot(e) {
    var t;
    let l = this.value, i = this.facet.compareInput, o = this.id, n = e[o] >> 1, s = this.type == 2, a = !1, c = !1, d = [];
    for (let h of this.dependencies)
      h == "doc" ? a = !0 : h == "selection" ? c = !0 : ((t = e[h.id]) !== null && t !== void 0 ? t : 1) & 1 || d.push(e[h.id]);
    return {
      create(h) {
        return h.values[n] = l(h), 1;
      },
      update(h, p) {
        if (a && p.docChanged || c && (p.docChanged || p.selection) || lc(h, d)) {
          let u = l(h);
          if (s ? !tp(u, h.values[n], i) : !i(u, h.values[n]))
            return h.values[n] = u, 1;
        }
        return 0;
      },
      reconfigure: (h, p) => {
        let u, f = p.config.address[o];
        if (f != null) {
          let m = Cn(p, f);
          if (this.dependencies.every((O) => O instanceof Y ? p.facet(O) === h.facet(O) : O instanceof Ue ? p.field(O, !1) == h.field(O, !1) : !0) || (s ? tp(u = l(h), m, i) : i(u = l(h), m)))
            return h.values[n] = m, 0;
        } else
          u = l(h);
        return h.values[n] = u, 1;
      }
    };
  }
}
function tp(r, e, t) {
  if (r.length != e.length)
    return !1;
  for (let l = 0; l < r.length; l++)
    if (!t(r[l], e[l]))
      return !1;
  return !0;
}
function lc(r, e) {
  let t = !1;
  for (let l of e)
    Ai(r, l) & 1 && (t = !0);
  return t;
}
function G1(r, e, t) {
  let l = t.map((a) => r[a.id]), i = t.map((a) => a.type), o = l.filter((a) => !(a & 1)), n = r[e.id] >> 1;
  function s(a) {
    let c = [];
    for (let d = 0; d < l.length; d++) {
      let h = Cn(a, l[d]);
      if (i[d] == 2)
        for (let p of h)
          c.push(p);
      else
        c.push(h);
    }
    return e.combine(c);
  }
  return {
    create(a) {
      for (let c of l)
        Ai(a, c);
      return a.values[n] = s(a), 1;
    },
    update(a, c) {
      if (!lc(a, o))
        return 0;
      let d = s(a);
      return e.compare(d, a.values[n]) ? 0 : (a.values[n] = d, 1);
    },
    reconfigure(a, c) {
      let d = lc(a, l), h = c.config.facets[e.id], p = c.facet(e);
      if (h && !d && Qd(t, h))
        return a.values[n] = p, 0;
      let u = s(a);
      return e.compare(u, p) ? (a.values[n] = p, 0) : (a.values[n] = u, 1);
    }
  };
}
const rp = /* @__PURE__ */ Y.define({ static: !0 });
class Ue {
  constructor(e, t, l, i, o) {
    this.id = e, this.createF = t, this.updateF = l, this.compareF = i, this.spec = o, this.provides = void 0;
  }
  /**
  Define a state field.
  */
  static define(e) {
    let t = new Ue(Sd++, e.create, e.update, e.compare || ((l, i) => l === i), e);
    return e.provide && (t.provides = e.provide(t)), t;
  }
  create(e) {
    let t = e.facet(rp).find((l) => l.field == this);
    return ((t == null ? void 0 : t.create) || this.createF)(e);
  }
  /**
  @internal
  */
  slot(e) {
    let t = e[this.id] >> 1;
    return {
      create: (l) => (l.values[t] = this.create(l), 1),
      update: (l, i) => {
        let o = l.values[t], n = this.updateF(o, i);
        return this.compareF(o, n) ? 0 : (l.values[t] = n, 1);
      },
      reconfigure: (l, i) => i.config.address[this.id] != null ? (l.values[t] = i.field(this), 0) : (l.values[t] = this.create(l), 1)
    };
  }
  /**
  Returns an extension that enables this field and overrides the
  way it is initialized. Can be useful when you need to provide a
  non-default starting value for the field.
  */
  init(e) {
    return [this, rp.of({ field: this, create: e })];
  }
  /**
  State field instances can be used as
  [`Extension`](https://codemirror.net/6/docs/ref/#state.Extension) values to enable the field in a
  given state.
  */
  get extension() {
    return this;
  }
}
const ll = { lowest: 4, low: 3, default: 2, high: 1, highest: 0 };
function fi(r) {
  return (e) => new jg(e, r);
}
const kl = {
  /**
  The highest precedence level, for extensions that should end up
  near the start of the precedence ordering.
  */
  highest: /* @__PURE__ */ fi(ll.highest),
  /**
  A higher-than-default precedence, for extensions that should
  come before those with default precedence.
  */
  high: /* @__PURE__ */ fi(ll.high),
  /**
  The default precedence, which is also used for extensions
  without an explicit precedence.
  */
  default: /* @__PURE__ */ fi(ll.default),
  /**
  A lower-than-default precedence.
  */
  low: /* @__PURE__ */ fi(ll.low),
  /**
  The lowest precedence level. Meant for things that should end up
  near the end of the extension order.
  */
  lowest: /* @__PURE__ */ fi(ll.lowest)
};
class jg {
  constructor(e, t) {
    this.inner = e, this.prec = t;
  }
}
class Ss {
  /**
  Create an instance of this compartment to add to your [state
  configuration](https://codemirror.net/6/docs/ref/#state.EditorStateConfig.extensions).
  */
  of(e) {
    return new ic(this, e);
  }
  /**
  Create an [effect](https://codemirror.net/6/docs/ref/#state.TransactionSpec.effects) that
  reconfigures this compartment.
  */
  reconfigure(e) {
    return Ss.reconfigure.of({ compartment: this, extension: e });
  }
  /**
  Get the current content of the compartment in the state, or
  `undefined` if it isn't present.
  */
  get(e) {
    return e.config.compartments.get(this);
  }
}
class ic {
  constructor(e, t) {
    this.compartment = e, this.inner = t;
  }
}
class Pn {
  constructor(e, t, l, i, o, n) {
    for (this.base = e, this.compartments = t, this.dynamicSlots = l, this.address = i, this.staticValues = o, this.facets = n, this.statusTemplate = []; this.statusTemplate.length < l.length; )
      this.statusTemplate.push(
        0
        /* SlotStatus.Unresolved */
      );
  }
  staticFacet(e) {
    let t = this.address[e.id];
    return t == null ? e.default : this.staticValues[t >> 1];
  }
  static resolve(e, t, l) {
    let i = [], o = /* @__PURE__ */ Object.create(null), n = /* @__PURE__ */ new Map();
    for (let p of F1(e, t, n))
      p instanceof Ue ? i.push(p) : (o[p.facet.id] || (o[p.facet.id] = [])).push(p);
    let s = /* @__PURE__ */ Object.create(null), a = [], c = [];
    for (let p of i)
      s[p.id] = c.length << 1, c.push((u) => p.slot(u));
    let d = l == null ? void 0 : l.config.facets;
    for (let p in o) {
      let u = o[p], f = u[0].facet, m = d && d[p] || [];
      if (u.every(
        (O) => O.type == 0
        /* Provider.Static */
      ))
        if (s[f.id] = a.length << 1 | 1, Qd(m, u))
          a.push(l.facet(f));
        else {
          let O = f.combine(u.map((x) => x.value));
          a.push(l && f.compare(O, l.facet(f)) ? l.facet(f) : O);
        }
      else {
        for (let O of u)
          O.type == 0 ? (s[O.id] = a.length << 1 | 1, a.push(O.value)) : (s[O.id] = c.length << 1, c.push((x) => O.dynamicSlot(x)));
        s[f.id] = c.length << 1, c.push((O) => G1(O, f, u));
      }
    }
    let h = c.map((p) => p(s));
    return new Pn(e, n, h, s, a, o);
  }
}
function F1(r, e, t) {
  let l = [[], [], [], [], []], i = /* @__PURE__ */ new Map();
  function o(n, s) {
    let a = i.get(n);
    if (a != null) {
      if (a <= s)
        return;
      let c = l[a].indexOf(n);
      c > -1 && l[a].splice(c, 1), n instanceof ic && t.delete(n.compartment);
    }
    if (i.set(n, s), Array.isArray(n))
      for (let c of n)
        o(c, s);
    else if (n instanceof ic) {
      if (t.has(n.compartment))
        throw new RangeError("Duplicate use of compartment in extensions");
      let c = e.get(n.compartment) || n.inner;
      t.set(n.compartment, c), o(c, s);
    } else if (n instanceof jg)
      o(n.inner, n.prec);
    else if (n instanceof Ue)
      l[s].push(n), n.provides && o(n.provides, s);
    else if (n instanceof an)
      l[s].push(n), n.facet.extensions && o(n.facet.extensions, ll.default);
    else {
      let c = n.extension;
      if (!c)
        throw new Error(`Unrecognized extension value in extension set (${n}). This sometimes happens because multiple instances of @codemirror/state are loaded, breaking instanceof checks.`);
      o(c, s);
    }
  }
  return o(r, ll.default), l.reduce((n, s) => n.concat(s));
}
function Ai(r, e) {
  if (e & 1)
    return 2;
  let t = e >> 1, l = r.status[t];
  if (l == 4)
    throw new Error("Cyclic dependency between fields and/or facets");
  if (l & 2)
    return l;
  r.status[t] = 4;
  let i = r.computeSlot(r, r.config.dynamicSlots[t]);
  return r.status[t] = 2 | i;
}
function Cn(r, e) {
  return e & 1 ? r.config.staticValues[e >> 1] : r.values[e >> 1];
}
const Ig = /* @__PURE__ */ Y.define(), Ug = /* @__PURE__ */ Y.define({
  combine: (r) => r.some((e) => e),
  static: !0
}), qg = /* @__PURE__ */ Y.define({
  combine: (r) => r.length ? r[0] : void 0,
  static: !0
}), Bg = /* @__PURE__ */ Y.define(), Lg = /* @__PURE__ */ Y.define(), Gg = /* @__PURE__ */ Y.define(), Fg = /* @__PURE__ */ Y.define({
  combine: (r) => r.length ? r[0] : !1
});
class Lr {
  /**
  @internal
  */
  constructor(e, t) {
    this.type = e, this.value = t;
  }
  /**
  Define a new type of annotation.
  */
  static define() {
    return new H1();
  }
}
class H1 {
  /**
  Create an instance of this annotation.
  */
  of(e) {
    return new Lr(this, e);
  }
}
class K1 {
  /**
  @internal
  */
  constructor(e) {
    this.map = e;
  }
  /**
  Create a [state effect](https://codemirror.net/6/docs/ref/#state.StateEffect) instance of this
  type.
  */
  of(e) {
    return new le(this, e);
  }
}
class le {
  /**
  @internal
  */
  constructor(e, t) {
    this.type = e, this.value = t;
  }
  /**
  Map this effect through a position mapping. Will return
  `undefined` when that ends up deleting the effect.
  */
  map(e) {
    let t = this.type.map(this.value, e);
    return t === void 0 ? void 0 : t == this.value ? this : new le(this.type, t);
  }
  /**
  Tells you whether this effect object is of a given
  [type](https://codemirror.net/6/docs/ref/#state.StateEffectType).
  */
  is(e) {
    return this.type == e;
  }
  /**
  Define a new effect type. The type parameter indicates the type
  of values that his effect holds.
  */
  static define(e = {}) {
    return new K1(e.map || ((t) => t));
  }
  /**
  Map an array of effects through a change set.
  */
  static mapEffects(e, t) {
    if (!e.length)
      return e;
    let l = [];
    for (let i of e) {
      let o = i.map(t);
      o && l.push(o);
    }
    return l;
  }
}
le.reconfigure = /* @__PURE__ */ le.define();
le.appendConfig = /* @__PURE__ */ le.define();
class We {
  constructor(e, t, l, i, o, n) {
    this.startState = e, this.changes = t, this.selection = l, this.effects = i, this.annotations = o, this.scrollIntoView = n, this._doc = null, this._state = null, l && Yg(l, t.newLength), o.some((s) => s.type == We.time) || (this.annotations = o.concat(We.time.of(Date.now())));
  }
  /**
  @internal
  */
  static create(e, t, l, i, o, n) {
    return new We(e, t, l, i, o, n);
  }
  /**
  The new document produced by the transaction. Contrary to
  [`.state`](https://codemirror.net/6/docs/ref/#state.Transaction.state)`.doc`, accessing this won't
  force the entire new state to be computed right away, so it is
  recommended that [transaction
  filters](https://codemirror.net/6/docs/ref/#state.EditorState^transactionFilter) use this getter
  when they need to look at the new document.
  */
  get newDoc() {
    return this._doc || (this._doc = this.changes.apply(this.startState.doc));
  }
  /**
  The new selection produced by the transaction. If
  [`this.selection`](https://codemirror.net/6/docs/ref/#state.Transaction.selection) is undefined,
  this will [map](https://codemirror.net/6/docs/ref/#state.EditorSelection.map) the start state's
  current selection through the changes made by the transaction.
  */
  get newSelection() {
    return this.selection || this.startState.selection.map(this.changes);
  }
  /**
  The new state created by the transaction. Computed on demand
  (but retained for subsequent access), so it is recommended not to
  access it in [transaction
  filters](https://codemirror.net/6/docs/ref/#state.EditorState^transactionFilter) when possible.
  */
  get state() {
    return this._state || this.startState.applyTransaction(this), this._state;
  }
  /**
  Get the value of the given annotation type, if any.
  */
  annotation(e) {
    for (let t of this.annotations)
      if (t.type == e)
        return t.value;
  }
  /**
  Indicates whether the transaction changed the document.
  */
  get docChanged() {
    return !this.changes.empty;
  }
  /**
  Indicates whether this transaction reconfigures the state
  (through a [configuration compartment](https://codemirror.net/6/docs/ref/#state.Compartment) or
  with a top-level configuration
  [effect](https://codemirror.net/6/docs/ref/#state.StateEffect^reconfigure).
  */
  get reconfigured() {
    return this.startState.config != this.state.config;
  }
  /**
  Returns true if the transaction has a [user
  event](https://codemirror.net/6/docs/ref/#state.Transaction^userEvent) annotation that is equal to
  or more specific than `event`. For example, if the transaction
  has `"select.pointer"` as user event, `"select"` and
  `"select.pointer"` will match it.
  */
  isUserEvent(e) {
    let t = this.annotation(We.userEvent);
    return !!(t && (t == e || t.length > e.length && t.slice(0, e.length) == e && t[e.length] == "."));
  }
}
We.time = /* @__PURE__ */ Lr.define();
We.userEvent = /* @__PURE__ */ Lr.define();
We.addToHistory = /* @__PURE__ */ Lr.define();
We.remote = /* @__PURE__ */ Lr.define();
function J1(r, e) {
  let t = [];
  for (let l = 0, i = 0; ; ) {
    let o, n;
    if (l < r.length && (i == e.length || e[i] >= r[l]))
      o = r[l++], n = r[l++];
    else if (i < e.length)
      o = e[i++], n = e[i++];
    else
      return t;
    !t.length || t[t.length - 1] < o ? t.push(o, n) : t[t.length - 1] < n && (t[t.length - 1] = n);
  }
}
function Hg(r, e, t) {
  var l;
  let i, o, n;
  return t ? (i = e.changes, o = Re.empty(e.changes.length), n = r.changes.compose(e.changes)) : (i = e.changes.map(r.changes), o = r.changes.mapDesc(e.changes, !0), n = r.changes.compose(i)), {
    changes: n,
    selection: e.selection ? e.selection.map(o) : (l = r.selection) === null || l === void 0 ? void 0 : l.map(i),
    effects: le.mapEffects(r.effects, i).concat(le.mapEffects(e.effects, o)),
    annotations: r.annotations.length ? r.annotations.concat(e.annotations) : e.annotations,
    scrollIntoView: r.scrollIntoView || e.scrollIntoView
  };
}
function oc(r, e, t) {
  let l = e.selection, i = jl(e.annotations);
  return e.userEvent && (i = i.concat(We.userEvent.of(e.userEvent))), {
    changes: e.changes instanceof Re ? e.changes : Re.of(e.changes || [], t, r.facet(qg)),
    selection: l && (l instanceof w ? l : w.single(l.anchor, l.head)),
    effects: jl(e.effects),
    annotations: i,
    scrollIntoView: !!e.scrollIntoView
  };
}
function Kg(r, e, t) {
  let l = oc(r, e.length ? e[0] : {}, r.doc.length);
  e.length && e[0].filter === !1 && (t = !1);
  for (let o = 1; o < e.length; o++) {
    e[o].filter === !1 && (t = !1);
    let n = !!e[o].sequential;
    l = Hg(l, oc(r, e[o], n ? l.changes.newLength : r.doc.length), n);
  }
  let i = We.create(r, l.changes, l.selection, l.effects, l.annotations, l.scrollIntoView);
  return tw(t ? ew(i) : i);
}
function ew(r) {
  let e = r.startState, t = !0;
  for (let i of e.facet(Bg)) {
    let o = i(r);
    if (o === !1) {
      t = !1;
      break;
    }
    Array.isArray(o) && (t = t === !0 ? o : J1(t, o));
  }
  if (t !== !0) {
    let i, o;
    if (t === !1)
      o = r.changes.invertedDesc, i = Re.empty(e.doc.length);
    else {
      let n = r.changes.filter(t);
      i = n.changes, o = n.filtered.mapDesc(n.changes).invertedDesc;
    }
    r = We.create(e, i, r.selection && r.selection.map(o), le.mapEffects(r.effects, o), r.annotations, r.scrollIntoView);
  }
  let l = e.facet(Lg);
  for (let i = l.length - 1; i >= 0; i--) {
    let o = l[i](r);
    o instanceof We ? r = o : Array.isArray(o) && o.length == 1 && o[0] instanceof We ? r = o[0] : r = Kg(e, jl(o), !1);
  }
  return r;
}
function tw(r) {
  let e = r.startState, t = e.facet(Gg), l = r;
  for (let i = t.length - 1; i >= 0; i--) {
    let o = t[i](r);
    o && Object.keys(o).length && (l = Hg(l, oc(e, o, r.changes.newLength), !0));
  }
  return l == r ? r : We.create(e, r.changes, r.selection, l.effects, l.annotations, l.scrollIntoView);
}
const rw = [];
function jl(r) {
  return r == null ? rw : Array.isArray(r) ? r : [r];
}
var Qe = /* @__PURE__ */ function(r) {
  return r[r.Word = 0] = "Word", r[r.Space = 1] = "Space", r[r.Other = 2] = "Other", r;
}(Qe || (Qe = {}));
const lw = /[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/;
let nc;
try {
  nc = /* @__PURE__ */ new RegExp("[\\p{Alphabetic}\\p{Number}_]", "u");
} catch {
}
function iw(r) {
  if (nc)
    return nc.test(r);
  for (let e = 0; e < r.length; e++) {
    let t = r[e];
    if (/\w/.test(t) || t > "" && (t.toUpperCase() != t.toLowerCase() || lw.test(t)))
      return !0;
  }
  return !1;
}
function ow(r) {
  return (e) => {
    if (!/\S/.test(e))
      return Qe.Space;
    if (iw(e))
      return Qe.Word;
    for (let t = 0; t < r.length; t++)
      if (e.indexOf(r[t]) > -1)
        return Qe.Word;
    return Qe.Other;
  };
}
class pe {
  constructor(e, t, l, i, o, n) {
    this.config = e, this.doc = t, this.selection = l, this.values = i, this.status = e.statusTemplate.slice(), this.computeSlot = o, n && (n._state = this);
    for (let s = 0; s < this.config.dynamicSlots.length; s++)
      Ai(this, s << 1);
    this.computeSlot = null;
  }
  field(e, t = !0) {
    let l = this.config.address[e.id];
    if (l == null) {
      if (t)
        throw new RangeError("Field is not present in this state");
      return;
    }
    return Ai(this, l), Cn(this, l);
  }
  /**
  Create a [transaction](https://codemirror.net/6/docs/ref/#state.Transaction) that updates this
  state. Any number of [transaction specs](https://codemirror.net/6/docs/ref/#state.TransactionSpec)
  can be passed. Unless
  [`sequential`](https://codemirror.net/6/docs/ref/#state.TransactionSpec.sequential) is set, the
  [changes](https://codemirror.net/6/docs/ref/#state.TransactionSpec.changes) (if any) of each spec
  are assumed to start in the _current_ document (not the document
  produced by previous specs), and its
  [selection](https://codemirror.net/6/docs/ref/#state.TransactionSpec.selection) and
  [effects](https://codemirror.net/6/docs/ref/#state.TransactionSpec.effects) are assumed to refer
  to the document created by its _own_ changes. The resulting
  transaction contains the combined effect of all the different
  specs. For [selection](https://codemirror.net/6/docs/ref/#state.TransactionSpec.selection), later
  specs take precedence over earlier ones.
  */
  update(...e) {
    return Kg(this, e, !0);
  }
  /**
  @internal
  */
  applyTransaction(e) {
    let t = this.config, { base: l, compartments: i } = t;
    for (let n of e.effects)
      n.is(Ss.reconfigure) ? (t && (i = /* @__PURE__ */ new Map(), t.compartments.forEach((s, a) => i.set(a, s)), t = null), i.set(n.value.compartment, n.value.extension)) : n.is(le.reconfigure) ? (t = null, l = n.value) : n.is(le.appendConfig) && (t = null, l = jl(l).concat(n.value));
    let o;
    t ? o = e.startState.values.slice() : (t = Pn.resolve(l, i, this), o = new pe(t, this.doc, this.selection, t.dynamicSlots.map(() => null), (s, a) => a.reconfigure(s, this), null).values), new pe(t, e.newDoc, e.newSelection, o, (n, s) => s.update(n, e), e);
  }
  /**
  Create a [transaction spec](https://codemirror.net/6/docs/ref/#state.TransactionSpec) that
  replaces every selection range with the given content.
  */
  replaceSelection(e) {
    return typeof e == "string" && (e = this.toText(e)), this.changeByRange((t) => ({
      changes: { from: t.from, to: t.to, insert: e },
      range: w.cursor(t.from + e.length)
    }));
  }
  /**
  Create a set of changes and a new selection by running the given
  function for each range in the active selection. The function
  can return an optional set of changes (in the coordinate space
  of the start document), plus an updated range (in the coordinate
  space of the document produced by the call's own changes). This
  method will merge all the changes and ranges into a single
  changeset and selection, and return it as a [transaction
  spec](https://codemirror.net/6/docs/ref/#state.TransactionSpec), which can be passed to
  [`update`](https://codemirror.net/6/docs/ref/#state.EditorState.update).
  */
  changeByRange(e) {
    let t = this.selection, l = e(t.ranges[0]), i = this.changes(l.changes), o = [l.range], n = jl(l.effects);
    for (let s = 1; s < t.ranges.length; s++) {
      let a = e(t.ranges[s]), c = this.changes(a.changes), d = c.map(i);
      for (let p = 0; p < s; p++)
        o[p] = o[p].map(d);
      let h = i.mapDesc(c, !0);
      o.push(a.range.map(h)), i = i.compose(d), n = le.mapEffects(n, d).concat(le.mapEffects(jl(a.effects), h));
    }
    return {
      changes: i,
      selection: w.create(o, t.mainIndex),
      effects: n
    };
  }
  /**
  Create a [change set](https://codemirror.net/6/docs/ref/#state.ChangeSet) from the given change
  description, taking the state's document length and line
  separator into account.
  */
  changes(e = []) {
    return e instanceof Re ? e : Re.of(e, this.doc.length, this.facet(pe.lineSeparator));
  }
  /**
  Using the state's [line
  separator](https://codemirror.net/6/docs/ref/#state.EditorState^lineSeparator), create a
  [`Text`](https://codemirror.net/6/docs/ref/#state.Text) instance from the given string.
  */
  toText(e) {
    return ue.of(e.split(this.facet(pe.lineSeparator) || ec));
  }
  /**
  Return the given range of the document as a string.
  */
  sliceDoc(e = 0, t = this.doc.length) {
    return this.doc.sliceString(e, t, this.lineBreak);
  }
  /**
  Get the value of a state [facet](https://codemirror.net/6/docs/ref/#state.Facet).
  */
  facet(e) {
    let t = this.config.address[e.id];
    return t == null ? e.default : (Ai(this, t), Cn(this, t));
  }
  /**
  Convert this state to a JSON-serializable object. When custom
  fields should be serialized, you can pass them in as an object
  mapping property names (in the resulting object, which should
  not use `doc` or `selection`) to fields.
  */
  toJSON(e) {
    let t = {
      doc: this.sliceDoc(),
      selection: this.selection.toJSON()
    };
    if (e)
      for (let l in e) {
        let i = e[l];
        i instanceof Ue && this.config.address[i.id] != null && (t[l] = i.spec.toJSON(this.field(e[l]), this));
      }
    return t;
  }
  /**
  Deserialize a state from its JSON representation. When custom
  fields should be deserialized, pass the same object you passed
  to [`toJSON`](https://codemirror.net/6/docs/ref/#state.EditorState.toJSON) when serializing as
  third argument.
  */
  static fromJSON(e, t = {}, l) {
    if (!e || typeof e.doc != "string")
      throw new RangeError("Invalid JSON representation for EditorState");
    let i = [];
    if (l) {
      for (let o in l)
        if (Object.prototype.hasOwnProperty.call(e, o)) {
          let n = l[o], s = e[o];
          i.push(n.init((a) => n.spec.fromJSON(s, a)));
        }
    }
    return pe.create({
      doc: e.doc,
      selection: w.fromJSON(e.selection),
      extensions: t.extensions ? i.concat([t.extensions]) : i
    });
  }
  /**
  Create a new state. You'll usually only need this when
  initializing an editor—updated states are created by applying
  transactions.
  */
  static create(e = {}) {
    let t = Pn.resolve(e.extensions || [], /* @__PURE__ */ new Map()), l = e.doc instanceof ue ? e.doc : ue.of((e.doc || "").split(t.staticFacet(pe.lineSeparator) || ec)), i = e.selection ? e.selection instanceof w ? e.selection : w.single(e.selection.anchor, e.selection.head) : w.single(0);
    return Yg(i, l.length), t.staticFacet(Ug) || (i = i.asSingle()), new pe(t, l, i, t.dynamicSlots.map(() => null), (o, n) => n.create(o), null);
  }
  /**
  The size (in columns) of a tab in the document, determined by
  the [`tabSize`](https://codemirror.net/6/docs/ref/#state.EditorState^tabSize) facet.
  */
  get tabSize() {
    return this.facet(pe.tabSize);
  }
  /**
  Get the proper [line-break](https://codemirror.net/6/docs/ref/#state.EditorState^lineSeparator)
  string for this state.
  */
  get lineBreak() {
    return this.facet(pe.lineSeparator) || `
`;
  }
  /**
  Returns true when the editor is
  [configured](https://codemirror.net/6/docs/ref/#state.EditorState^readOnly) to be read-only.
  */
  get readOnly() {
    return this.facet(Fg);
  }
  /**
  Look up a translation for the given phrase (via the
  [`phrases`](https://codemirror.net/6/docs/ref/#state.EditorState^phrases) facet), or return the
  original string if no translation is found.
  
  If additional arguments are passed, they will be inserted in
  place of markers like `$1` (for the first value) and `$2`, etc.
  A single `$` is equivalent to `$1`, and `$$` will produce a
  literal dollar sign.
  */
  phrase(e, ...t) {
    for (let l of this.facet(pe.phrases))
      if (Object.prototype.hasOwnProperty.call(l, e)) {
        e = l[e];
        break;
      }
    return t.length && (e = e.replace(/\$(\$|\d*)/g, (l, i) => {
      if (i == "$")
        return "$";
      let o = +(i || 1);
      return !o || o > t.length ? l : t[o - 1];
    })), e;
  }
  /**
  Find the values for a given language data field, provided by the
  the [`languageData`](https://codemirror.net/6/docs/ref/#state.EditorState^languageData) facet.
  
  Examples of language data fields are...
  
  - [`"commentTokens"`](https://codemirror.net/6/docs/ref/#commands.CommentTokens) for specifying
    comment syntax.
  - [`"autocomplete"`](https://codemirror.net/6/docs/ref/#autocomplete.autocompletion^config.override)
    for providing language-specific completion sources.
  - [`"wordChars"`](https://codemirror.net/6/docs/ref/#state.EditorState.charCategorizer) for adding
    characters that should be considered part of words in this
    language.
  - [`"closeBrackets"`](https://codemirror.net/6/docs/ref/#autocomplete.CloseBracketConfig) controls
    bracket closing behavior.
  */
  languageDataAt(e, t, l = -1) {
    let i = [];
    for (let o of this.facet(Ig))
      for (let n of o(this, t, l))
        Object.prototype.hasOwnProperty.call(n, e) && i.push(n[e]);
    return i;
  }
  /**
  Return a function that can categorize strings (expected to
  represent a single [grapheme cluster](https://codemirror.net/6/docs/ref/#state.findClusterBreak))
  into one of:
  
   - Word (contains an alphanumeric character or a character
     explicitly listed in the local language's `"wordChars"`
     language data, which should be a string)
   - Space (contains only whitespace)
   - Other (anything else)
  */
  charCategorizer(e) {
    return ow(this.languageDataAt("wordChars", e).join(""));
  }
  /**
  Find the word at the given position, meaning the range
  containing all [word](https://codemirror.net/6/docs/ref/#state.CharCategory.Word) characters
  around it. If no word characters are adjacent to the position,
  this returns null.
  */
  wordAt(e) {
    let { text: t, from: l, length: i } = this.doc.lineAt(e), o = this.charCategorizer(e), n = e - l, s = e - l;
    for (; n > 0; ) {
      let a = nt(t, n, !1);
      if (o(t.slice(a, n)) != Qe.Word)
        break;
      n = a;
    }
    for (; s < i; ) {
      let a = nt(t, s);
      if (o(t.slice(s, a)) != Qe.Word)
        break;
      s = a;
    }
    return n == s ? null : w.range(n + l, s + l);
  }
}
pe.allowMultipleSelections = Ug;
pe.tabSize = /* @__PURE__ */ Y.define({
  combine: (r) => r.length ? r[0] : 4
});
pe.lineSeparator = qg;
pe.readOnly = Fg;
pe.phrases = /* @__PURE__ */ Y.define({
  compare(r, e) {
    let t = Object.keys(r), l = Object.keys(e);
    return t.length == l.length && t.every((i) => r[i] == e[i]);
  }
});
pe.languageData = Ig;
pe.changeFilter = Bg;
pe.transactionFilter = Lg;
pe.transactionExtender = Gg;
Ss.reconfigure = /* @__PURE__ */ le.define();
function ir(r, e, t = {}) {
  let l = {};
  for (let i of r)
    for (let o of Object.keys(i)) {
      let n = i[o], s = l[o];
      if (s === void 0)
        l[o] = n;
      else if (!(s === n || n === void 0))
        if (Object.hasOwnProperty.call(t, o))
          l[o] = t[o](s, n);
        else
          throw new Error("Config merge conflict for field " + o);
    }
  for (let i in e)
    l[i] === void 0 && (l[i] = e[i]);
  return l;
}
class Ol {
  /**
  Compare this value with another value. Used when comparing
  rangesets. The default implementation compares by identity.
  Unless you are only creating a fixed number of unique instances
  of your value type, it is a good idea to implement this
  properly.
  */
  eq(e) {
    return this == e;
  }
  /**
  Create a [range](https://codemirror.net/6/docs/ref/#state.Range) with this value.
  */
  range(e, t = e) {
    return Tn.create(e, t, this);
  }
}
Ol.prototype.startSide = Ol.prototype.endSide = 0;
Ol.prototype.point = !1;
Ol.prototype.mapMode = Ge.TrackDel;
let Tn = class {
  constructor(e, t, l) {
    this.from = e, this.to = t, this.value = l;
  }
  /**
  @internal
  */
  static create(e, t, l) {
    return new Tn(e, t, l);
  }
};
function sc(r, e) {
  return r.from - e.from || r.value.startSide - e.value.startSide;
}
class $d {
  constructor(e, t, l, i) {
    this.from = e, this.to = t, this.value = l, this.maxPoint = i;
  }
  get length() {
    return this.to[this.to.length - 1];
  }
  // Find the index of the given position and side. Use the ranges'
  // `from` pos when `end == false`, `to` when `end == true`.
  findIndex(e, t, l, i = 0) {
    let o = l ? this.to : this.from;
    for (let n = i, s = o.length; ; ) {
      if (n == s)
        return n;
      let a = n + s >> 1, c = o[a] - e || (l ? this.value[a].endSide : this.value[a].startSide) - t;
      if (a == n)
        return c >= 0 ? n : s;
      c >= 0 ? s = a : n = a + 1;
    }
  }
  between(e, t, l, i) {
    for (let o = this.findIndex(t, -1e9, !0), n = this.findIndex(l, 1e9, !1, o); o < n; o++)
      if (i(this.from[o] + e, this.to[o] + e, this.value[o]) === !1)
        return !1;
  }
  map(e, t) {
    let l = [], i = [], o = [], n = -1, s = -1;
    for (let a = 0; a < this.value.length; a++) {
      let c = this.value[a], d = this.from[a] + e, h = this.to[a] + e, p, u;
      if (d == h) {
        let f = t.mapPos(d, c.startSide, c.mapMode);
        if (f == null || (p = u = f, c.startSide != c.endSide && (u = t.mapPos(d, c.endSide), u < p)))
          continue;
      } else if (p = t.mapPos(d, c.startSide), u = t.mapPos(h, c.endSide), p > u || p == u && c.startSide > 0 && c.endSide <= 0)
        continue;
      (u - p || c.endSide - c.startSide) < 0 || (n < 0 && (n = p), c.point && (s = Math.max(s, u - p)), l.push(c), i.push(p - n), o.push(u - n));
    }
    return { mapped: l.length ? new $d(i, o, l, s) : null, pos: n };
  }
}
class ge {
  constructor(e, t, l, i) {
    this.chunkPos = e, this.chunk = t, this.nextLayer = l, this.maxPoint = i;
  }
  /**
  @internal
  */
  static create(e, t, l, i) {
    return new ge(e, t, l, i);
  }
  /**
  @internal
  */
  get length() {
    let e = this.chunk.length - 1;
    return e < 0 ? 0 : Math.max(this.chunkEnd(e), this.nextLayer.length);
  }
  /**
  The number of ranges in the set.
  */
  get size() {
    if (this.isEmpty)
      return 0;
    let e = this.nextLayer.size;
    for (let t of this.chunk)
      e += t.value.length;
    return e;
  }
  /**
  @internal
  */
  chunkEnd(e) {
    return this.chunkPos[e] + this.chunk[e].length;
  }
  /**
  Update the range set, optionally adding new ranges or filtering
  out existing ones.
  
  (Note: The type parameter is just there as a kludge to work
  around TypeScript variance issues that prevented `RangeSet<X>`
  from being a subtype of `RangeSet<Y>` when `X` is a subtype of
  `Y`.)
  */
  update(e) {
    let { add: t = [], sort: l = !1, filterFrom: i = 0, filterTo: o = this.length } = e, n = e.filter;
    if (t.length == 0 && !n)
      return this;
    if (l && (t = t.slice().sort(sc)), this.isEmpty)
      return t.length ? ge.of(t) : this;
    let s = new Jg(this, null, -1).goto(0), a = 0, c = [], d = new Yr();
    for (; s.value || a < t.length; )
      if (a < t.length && (s.from - t[a].from || s.startSide - t[a].value.startSide) >= 0) {
        let h = t[a++];
        d.addInner(h.from, h.to, h.value) || c.push(h);
      } else
        s.rangeIndex == 1 && s.chunkIndex < this.chunk.length && (a == t.length || this.chunkEnd(s.chunkIndex) < t[a].from) && (!n || i > this.chunkEnd(s.chunkIndex) || o < this.chunkPos[s.chunkIndex]) && d.addChunk(this.chunkPos[s.chunkIndex], this.chunk[s.chunkIndex]) ? s.nextChunk() : ((!n || i > s.to || o < s.from || n(s.from, s.to, s.value)) && (d.addInner(s.from, s.to, s.value) || c.push(Tn.create(s.from, s.to, s.value))), s.next());
    return d.finishInner(this.nextLayer.isEmpty && !c.length ? ge.empty : this.nextLayer.update({ add: c, filter: n, filterFrom: i, filterTo: o }));
  }
  /**
  Map this range set through a set of changes, return the new set.
  */
  map(e) {
    if (e.empty || this.isEmpty)
      return this;
    let t = [], l = [], i = -1;
    for (let n = 0; n < this.chunk.length; n++) {
      let s = this.chunkPos[n], a = this.chunk[n], c = e.touchesRange(s, s + a.length);
      if (c === !1)
        i = Math.max(i, a.maxPoint), t.push(a), l.push(e.mapPos(s));
      else if (c === !0) {
        let { mapped: d, pos: h } = a.map(s, e);
        d && (i = Math.max(i, d.maxPoint), t.push(d), l.push(h));
      }
    }
    let o = this.nextLayer.map(e);
    return t.length == 0 ? o : new ge(l, t, o || ge.empty, i);
  }
  /**
  Iterate over the ranges that touch the region `from` to `to`,
  calling `f` for each. There is no guarantee that the ranges will
  be reported in any specific order. When the callback returns
  `false`, iteration stops.
  */
  between(e, t, l) {
    if (!this.isEmpty) {
      for (let i = 0; i < this.chunk.length; i++) {
        let o = this.chunkPos[i], n = this.chunk[i];
        if (t >= o && e <= o + n.length && n.between(o, e - o, t - o, l) === !1)
          return;
      }
      this.nextLayer.between(e, t, l);
    }
  }
  /**
  Iterate over the ranges in this set, in order, including all
  ranges that end at or after `from`.
  */
  iter(e = 0) {
    return Ii.from([this]).goto(e);
  }
  /**
  @internal
  */
  get isEmpty() {
    return this.nextLayer == this;
  }
  /**
  Iterate over the ranges in a collection of sets, in order,
  starting from `from`.
  */
  static iter(e, t = 0) {
    return Ii.from(e).goto(t);
  }
  /**
  Iterate over two groups of sets, calling methods on `comparator`
  to notify it of possible differences.
  */
  static compare(e, t, l, i, o = -1) {
    let n = e.filter((h) => h.maxPoint > 0 || !h.isEmpty && h.maxPoint >= o), s = t.filter((h) => h.maxPoint > 0 || !h.isEmpty && h.maxPoint >= o), a = lp(n, s, l), c = new gi(n, a, o), d = new gi(s, a, o);
    l.iterGaps((h, p, u) => ip(c, h, d, p, u, i)), l.empty && l.length == 0 && ip(c, 0, d, 0, 0, i);
  }
  /**
  Compare the contents of two groups of range sets, returning true
  if they are equivalent in the given range.
  */
  static eq(e, t, l = 0, i) {
    i == null && (i = 1e9 - 1);
    let o = e.filter((d) => !d.isEmpty && t.indexOf(d) < 0), n = t.filter((d) => !d.isEmpty && e.indexOf(d) < 0);
    if (o.length != n.length)
      return !1;
    if (!o.length)
      return !0;
    let s = lp(o, n), a = new gi(o, s, 0).goto(l), c = new gi(n, s, 0).goto(l);
    for (; ; ) {
      if (a.to != c.to || !ac(a.active, c.active) || a.point && (!c.point || !a.point.eq(c.point)))
        return !1;
      if (a.to > i)
        return !0;
      a.next(), c.next();
    }
  }
  /**
  Iterate over a group of range sets at the same time, notifying
  the iterator about the ranges covering every given piece of
  content. Returns the open count (see
  [`SpanIterator.span`](https://codemirror.net/6/docs/ref/#state.SpanIterator.span)) at the end
  of the iteration.
  */
  static spans(e, t, l, i, o = -1) {
    let n = new gi(e, null, o).goto(t), s = t, a = n.openStart;
    for (; ; ) {
      let c = Math.min(n.to, l);
      if (n.point) {
        let d = n.activeForPoint(n.to), h = n.pointFrom < t ? d.length + 1 : Math.min(d.length, a);
        i.point(s, c, n.point, d, h, n.pointRank), a = Math.min(n.openEnd(c), d.length);
      } else
        c > s && (i.span(s, c, n.active, a), a = n.openEnd(c));
      if (n.to > l)
        return a + (n.point && n.to > l ? 1 : 0);
      s = n.to, n.next();
    }
  }
  /**
  Create a range set for the given range or array of ranges. By
  default, this expects the ranges to be _sorted_ (by start
  position and, if two start at the same position,
  `value.startSide`). You can pass `true` as second argument to
  cause the method to sort them.
  */
  static of(e, t = !1) {
    let l = new Yr();
    for (let i of e instanceof Tn ? [e] : t ? nw(e) : e)
      l.add(i.from, i.to, i.value);
    return l.finish();
  }
}
ge.empty = /* @__PURE__ */ new ge([], [], null, -1);
function nw(r) {
  if (r.length > 1)
    for (let e = r[0], t = 1; t < r.length; t++) {
      let l = r[t];
      if (sc(e, l) > 0)
        return r.slice().sort(sc);
      e = l;
    }
  return r;
}
ge.empty.nextLayer = ge.empty;
class Yr {
  /**
  Create an empty builder.
  */
  constructor() {
    this.chunks = [], this.chunkPos = [], this.chunkStart = -1, this.last = null, this.lastFrom = -1e9, this.lastTo = -1e9, this.from = [], this.to = [], this.value = [], this.maxPoint = -1, this.setMaxPoint = -1, this.nextLayer = null;
  }
  finishChunk(e) {
    this.chunks.push(new $d(this.from, this.to, this.value, this.maxPoint)), this.chunkPos.push(this.chunkStart), this.chunkStart = -1, this.setMaxPoint = Math.max(this.setMaxPoint, this.maxPoint), this.maxPoint = -1, e && (this.from = [], this.to = [], this.value = []);
  }
  /**
  Add a range. Ranges should be added in sorted (by `from` and
  `value.startSide`) order.
  */
  add(e, t, l) {
    this.addInner(e, t, l) || (this.nextLayer || (this.nextLayer = new Yr())).add(e, t, l);
  }
  /**
  @internal
  */
  addInner(e, t, l) {
    let i = e - this.lastTo || l.startSide - this.last.endSide;
    if (i <= 0 && (e - this.lastFrom || l.startSide - this.last.startSide) < 0)
      throw new Error("Ranges must be added sorted by `from` position and `startSide`");
    return i < 0 ? !1 : (this.from.length == 250 && this.finishChunk(!0), this.chunkStart < 0 && (this.chunkStart = e), this.from.push(e - this.chunkStart), this.to.push(t - this.chunkStart), this.last = l, this.lastFrom = e, this.lastTo = t, this.value.push(l), l.point && (this.maxPoint = Math.max(this.maxPoint, t - e)), !0);
  }
  /**
  @internal
  */
  addChunk(e, t) {
    if ((e - this.lastTo || t.value[0].startSide - this.last.endSide) < 0)
      return !1;
    this.from.length && this.finishChunk(!0), this.setMaxPoint = Math.max(this.setMaxPoint, t.maxPoint), this.chunks.push(t), this.chunkPos.push(e);
    let l = t.value.length - 1;
    return this.last = t.value[l], this.lastFrom = t.from[l] + e, this.lastTo = t.to[l] + e, !0;
  }
  /**
  Finish the range set. Returns the new set. The builder can't be
  used anymore after this has been called.
  */
  finish() {
    return this.finishInner(ge.empty);
  }
  /**
  @internal
  */
  finishInner(e) {
    if (this.from.length && this.finishChunk(!1), this.chunks.length == 0)
      return e;
    let t = ge.create(this.chunkPos, this.chunks, this.nextLayer ? this.nextLayer.finishInner(e) : e, this.setMaxPoint);
    return this.from = null, t;
  }
}
function lp(r, e, t) {
  let l = /* @__PURE__ */ new Map();
  for (let o of r)
    for (let n = 0; n < o.chunk.length; n++)
      o.chunk[n].maxPoint <= 0 && l.set(o.chunk[n], o.chunkPos[n]);
  let i = /* @__PURE__ */ new Set();
  for (let o of e)
    for (let n = 0; n < o.chunk.length; n++) {
      let s = l.get(o.chunk[n]);
      s != null && (t ? t.mapPos(s) : s) == o.chunkPos[n] && !(t != null && t.touchesRange(s, s + o.chunk[n].length)) && i.add(o.chunk[n]);
    }
  return i;
}
class Jg {
  constructor(e, t, l, i = 0) {
    this.layer = e, this.skip = t, this.minPoint = l, this.rank = i;
  }
  get startSide() {
    return this.value ? this.value.startSide : 0;
  }
  get endSide() {
    return this.value ? this.value.endSide : 0;
  }
  goto(e, t = -1e9) {
    return this.chunkIndex = this.rangeIndex = 0, this.gotoInner(e, t, !1), this;
  }
  gotoInner(e, t, l) {
    for (; this.chunkIndex < this.layer.chunk.length; ) {
      let i = this.layer.chunk[this.chunkIndex];
      if (!(this.skip && this.skip.has(i) || this.layer.chunkEnd(this.chunkIndex) < e || i.maxPoint < this.minPoint))
        break;
      this.chunkIndex++, l = !1;
    }
    if (this.chunkIndex < this.layer.chunk.length) {
      let i = this.layer.chunk[this.chunkIndex].findIndex(e - this.layer.chunkPos[this.chunkIndex], t, !0);
      (!l || this.rangeIndex < i) && this.setRangeIndex(i);
    }
    this.next();
  }
  forward(e, t) {
    (this.to - e || this.endSide - t) < 0 && this.gotoInner(e, t, !0);
  }
  next() {
    for (; ; )
      if (this.chunkIndex == this.layer.chunk.length) {
        this.from = this.to = 1e9, this.value = null;
        break;
      } else {
        let e = this.layer.chunkPos[this.chunkIndex], t = this.layer.chunk[this.chunkIndex], l = e + t.from[this.rangeIndex];
        if (this.from = l, this.to = e + t.to[this.rangeIndex], this.value = t.value[this.rangeIndex], this.setRangeIndex(this.rangeIndex + 1), this.minPoint < 0 || this.value.point && this.to - this.from >= this.minPoint)
          break;
      }
  }
  setRangeIndex(e) {
    if (e == this.layer.chunk[this.chunkIndex].value.length) {
      if (this.chunkIndex++, this.skip)
        for (; this.chunkIndex < this.layer.chunk.length && this.skip.has(this.layer.chunk[this.chunkIndex]); )
          this.chunkIndex++;
      this.rangeIndex = 0;
    } else
      this.rangeIndex = e;
  }
  nextChunk() {
    this.chunkIndex++, this.rangeIndex = 0, this.next();
  }
  compare(e) {
    return this.from - e.from || this.startSide - e.startSide || this.rank - e.rank || this.to - e.to || this.endSide - e.endSide;
  }
}
class Ii {
  constructor(e) {
    this.heap = e;
  }
  static from(e, t = null, l = -1) {
    let i = [];
    for (let o = 0; o < e.length; o++)
      for (let n = e[o]; !n.isEmpty; n = n.nextLayer)
        n.maxPoint >= l && i.push(new Jg(n, t, l, o));
    return i.length == 1 ? i[0] : new Ii(i);
  }
  get startSide() {
    return this.value ? this.value.startSide : 0;
  }
  goto(e, t = -1e9) {
    for (let l of this.heap)
      l.goto(e, t);
    for (let l = this.heap.length >> 1; l >= 0; l--)
      Js(this.heap, l);
    return this.next(), this;
  }
  forward(e, t) {
    for (let l of this.heap)
      l.forward(e, t);
    for (let l = this.heap.length >> 1; l >= 0; l--)
      Js(this.heap, l);
    (this.to - e || this.value.endSide - t) < 0 && this.next();
  }
  next() {
    if (this.heap.length == 0)
      this.from = this.to = 1e9, this.value = null, this.rank = -1;
    else {
      let e = this.heap[0];
      this.from = e.from, this.to = e.to, this.value = e.value, this.rank = e.rank, e.value && e.next(), Js(this.heap, 0);
    }
  }
}
function Js(r, e) {
  for (let t = r[e]; ; ) {
    let l = (e << 1) + 1;
    if (l >= r.length)
      break;
    let i = r[l];
    if (l + 1 < r.length && i.compare(r[l + 1]) >= 0 && (i = r[l + 1], l++), t.compare(i) < 0)
      break;
    r[l] = t, r[e] = i, e = l;
  }
}
class gi {
  constructor(e, t, l) {
    this.minPoint = l, this.active = [], this.activeTo = [], this.activeRank = [], this.minActive = -1, this.point = null, this.pointFrom = 0, this.pointRank = 0, this.to = -1e9, this.endSide = 0, this.openStart = -1, this.cursor = Ii.from(e, t, l);
  }
  goto(e, t = -1e9) {
    return this.cursor.goto(e, t), this.active.length = this.activeTo.length = this.activeRank.length = 0, this.minActive = -1, this.to = e, this.endSide = t, this.openStart = -1, this.next(), this;
  }
  forward(e, t) {
    for (; this.minActive > -1 && (this.activeTo[this.minActive] - e || this.active[this.minActive].endSide - t) < 0; )
      this.removeActive(this.minActive);
    this.cursor.forward(e, t);
  }
  removeActive(e) {
    Co(this.active, e), Co(this.activeTo, e), Co(this.activeRank, e), this.minActive = op(this.active, this.activeTo);
  }
  addActive(e) {
    let t = 0, { value: l, to: i, rank: o } = this.cursor;
    for (; t < this.activeRank.length && this.activeRank[t] <= o; )
      t++;
    To(this.active, t, l), To(this.activeTo, t, i), To(this.activeRank, t, o), e && To(e, t, this.cursor.from), this.minActive = op(this.active, this.activeTo);
  }
  // After calling this, if `this.point` != null, the next range is a
  // point. Otherwise, it's a regular range, covered by `this.active`.
  next() {
    let e = this.to, t = this.point;
    this.point = null;
    let l = this.openStart < 0 ? [] : null;
    for (; ; ) {
      let i = this.minActive;
      if (i > -1 && (this.activeTo[i] - this.cursor.from || this.active[i].endSide - this.cursor.startSide) < 0) {
        if (this.activeTo[i] > e) {
          this.to = this.activeTo[i], this.endSide = this.active[i].endSide;
          break;
        }
        this.removeActive(i), l && Co(l, i);
      } else if (this.cursor.value)
        if (this.cursor.from > e) {
          this.to = this.cursor.from, this.endSide = this.cursor.startSide;
          break;
        } else {
          let o = this.cursor.value;
          if (!o.point)
            this.addActive(l), this.cursor.next();
          else if (t && this.cursor.to == this.to && this.cursor.from < this.cursor.to)
            this.cursor.next();
          else {
            this.point = o, this.pointFrom = this.cursor.from, this.pointRank = this.cursor.rank, this.to = this.cursor.to, this.endSide = o.endSide, this.cursor.next(), this.forward(this.to, this.endSide);
            break;
          }
        }
      else {
        this.to = this.endSide = 1e9;
        break;
      }
    }
    if (l) {
      this.openStart = 0;
      for (let i = l.length - 1; i >= 0 && l[i] < e; i--)
        this.openStart++;
    }
  }
  activeForPoint(e) {
    if (!this.active.length)
      return this.active;
    let t = [];
    for (let l = this.active.length - 1; l >= 0 && !(this.activeRank[l] < this.pointRank); l--)
      (this.activeTo[l] > e || this.activeTo[l] == e && this.active[l].endSide >= this.point.endSide) && t.push(this.active[l]);
    return t.reverse();
  }
  openEnd(e) {
    let t = 0;
    for (let l = this.activeTo.length - 1; l >= 0 && this.activeTo[l] > e; l--)
      t++;
    return t;
  }
}
function ip(r, e, t, l, i, o) {
  r.goto(e), t.goto(l);
  let n = l + i, s = l, a = l - e;
  for (; ; ) {
    let c = r.to + a - t.to || r.endSide - t.endSide, d = c < 0 ? r.to + a : t.to, h = Math.min(d, n);
    if (r.point || t.point ? r.point && t.point && (r.point == t.point || r.point.eq(t.point)) && ac(r.activeForPoint(r.to + a), t.activeForPoint(t.to)) || o.comparePoint(s, h, r.point, t.point) : h > s && !ac(r.active, t.active) && o.compareRange(s, h, r.active, t.active), d > n)
      break;
    s = d, c <= 0 && r.next(), c >= 0 && t.next();
  }
}
function ac(r, e) {
  if (r.length != e.length)
    return !1;
  for (let t = 0; t < r.length; t++)
    if (r[t] != e[t] && !r[t].eq(e[t]))
      return !1;
  return !0;
}
function Co(r, e) {
  for (let t = e, l = r.length - 1; t < l; t++)
    r[t] = r[t + 1];
  r.pop();
}
function To(r, e, t) {
  for (let l = r.length - 1; l >= e; l--)
    r[l + 1] = r[l];
  r[e] = t;
}
function op(r, e) {
  let t = -1, l = 1e9;
  for (let i = 0; i < e.length; i++)
    (e[i] - l || r[i].endSide - r[t].endSide) < 0 && (t = i, l = e[i]);
  return t;
}
function fo(r, e, t = r.length) {
  let l = 0;
  for (let i = 0; i < t; )
    r.charCodeAt(i) == 9 ? (l += e - l % e, i++) : (l++, i = nt(r, i));
  return l;
}
function cc(r, e, t, l) {
  for (let i = 0, o = 0; ; ) {
    if (o >= e)
      return i;
    if (i == r.length)
      break;
    o += r.charCodeAt(i) == 9 ? t - o % t : 1, i = nt(r, i);
  }
  return l === !0 ? -1 : r.length;
}
const dc = "ͼ", np = typeof Symbol > "u" ? "__" + dc : Symbol.for(dc), hc = typeof Symbol > "u" ? "__styleSet" + Math.floor(Math.random() * 1e8) : Symbol("styleSet"), sp = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : {};
class jr {
  // :: (Object<Style>, ?{finish: ?(string) → string})
  // Create a style module from the given spec.
  //
  // When `finish` is given, it is called on regular (non-`@`)
  // selectors (after `&` expansion) to compute the final selector.
  constructor(e, t) {
    this.rules = [];
    let { finish: l } = t || {};
    function i(n) {
      return /^@/.test(n) ? [n] : n.split(/,\s*/);
    }
    function o(n, s, a, c) {
      let d = [], h = /^@(\w+)\b/.exec(n[0]), p = h && h[1] == "keyframes";
      if (h && s == null)
        return a.push(n[0] + ";");
      for (let u in s) {
        let f = s[u];
        if (/&/.test(u))
          o(
            u.split(/,\s*/).map((m) => n.map((O) => m.replace(/&/, O))).reduce((m, O) => m.concat(O)),
            f,
            a
          );
        else if (f && typeof f == "object") {
          if (!h)
            throw new RangeError("The value of a property (" + u + ") should be a primitive value.");
          o(i(u), f, d, p);
        } else
          f != null && d.push(u.replace(/_.*/, "").replace(/[A-Z]/g, (m) => "-" + m.toLowerCase()) + ": " + f + ";");
      }
      (d.length || p) && a.push((l && !h && !c ? n.map(l) : n).join(", ") + " {" + d.join(" ") + "}");
    }
    for (let n in e)
      o(i(n), e[n], this.rules);
  }
  // :: () → string
  // Returns a string containing the module's CSS rules.
  getRules() {
    return this.rules.join(`
`);
  }
  // :: () → string
  // Generate a new unique CSS class name.
  static newName() {
    let e = sp[np] || 1;
    return sp[np] = e + 1, dc + e.toString(36);
  }
  // :: (union<Document, ShadowRoot>, union<[StyleModule], StyleModule>)
  //
  // Mount the given set of modules in the given DOM root, which ensures
  // that the CSS rules defined by the module are available in that
  // context.
  //
  // Rules are only added to the document once per root.
  //
  // Rule order will follow the order of the modules, so that rules from
  // modules later in the array take precedence of those from earlier
  // modules. If you call this function multiple times for the same root
  // in a way that changes the order of already mounted modules, the old
  // order will be changed.
  static mount(e, t) {
    (e[hc] || new sw(e)).mount(Array.isArray(t) ? t : [t]);
  }
}
let zo = null;
class sw {
  constructor(e) {
    if (!e.head && e.adoptedStyleSheets && typeof CSSStyleSheet < "u") {
      if (zo)
        return e.adoptedStyleSheets = [zo.sheet].concat(e.adoptedStyleSheets), e[hc] = zo;
      this.sheet = new CSSStyleSheet(), e.adoptedStyleSheets = [this.sheet].concat(e.adoptedStyleSheets), zo = this;
    } else {
      this.styleTag = (e.ownerDocument || e).createElement("style");
      let t = e.head || e;
      t.insertBefore(this.styleTag, t.firstChild);
    }
    this.modules = [], e[hc] = this;
  }
  mount(e) {
    let t = this.sheet, l = 0, i = 0;
    for (let o = 0; o < e.length; o++) {
      let n = e[o], s = this.modules.indexOf(n);
      if (s < i && s > -1 && (this.modules.splice(s, 1), i--, s = -1), s == -1) {
        if (this.modules.splice(i++, 0, n), t)
          for (let a = 0; a < n.rules.length; a++)
            t.insertRule(n.rules[a], l++);
      } else {
        for (; i < s; )
          l += this.modules[i++].rules.length;
        l += n.rules.length, i++;
      }
    }
    if (!t) {
      let o = "";
      for (let n = 0; n < this.modules.length; n++)
        o += this.modules[n].getRules() + `
`;
      this.styleTag.textContent = o;
    }
  }
}
var Ir = {
  8: "Backspace",
  9: "Tab",
  10: "Enter",
  12: "NumLock",
  13: "Enter",
  16: "Shift",
  17: "Control",
  18: "Alt",
  20: "CapsLock",
  27: "Escape",
  32: " ",
  33: "PageUp",
  34: "PageDown",
  35: "End",
  36: "Home",
  37: "ArrowLeft",
  38: "ArrowUp",
  39: "ArrowRight",
  40: "ArrowDown",
  44: "PrintScreen",
  45: "Insert",
  46: "Delete",
  59: ";",
  61: "=",
  91: "Meta",
  92: "Meta",
  106: "*",
  107: "+",
  108: ",",
  109: "-",
  110: ".",
  111: "/",
  144: "NumLock",
  145: "ScrollLock",
  160: "Shift",
  161: "Shift",
  162: "Control",
  163: "Control",
  164: "Alt",
  165: "Alt",
  173: "-",
  186: ";",
  187: "=",
  188: ",",
  189: "-",
  190: ".",
  191: "/",
  192: "`",
  219: "[",
  220: "\\",
  221: "]",
  222: "'"
}, Ui = {
  48: ")",
  49: "!",
  50: "@",
  51: "#",
  52: "$",
  53: "%",
  54: "^",
  55: "&",
  56: "*",
  57: "(",
  59: ":",
  61: "+",
  173: "_",
  186: ":",
  187: "+",
  188: "<",
  189: "_",
  190: ">",
  191: "?",
  192: "~",
  219: "{",
  220: "|",
  221: "}",
  222: '"'
}, ap = typeof navigator < "u" && /Chrome\/(\d+)/.exec(navigator.userAgent), aw = typeof navigator < "u" && /Mac/.test(navigator.platform), cw = typeof navigator < "u" && /MSIE \d|Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(navigator.userAgent), dw = aw || ap && +ap[1] < 57;
for (var Le = 0; Le < 10; Le++)
  Ir[48 + Le] = Ir[96 + Le] = String(Le);
for (var Le = 1; Le <= 24; Le++)
  Ir[Le + 111] = "F" + Le;
for (var Le = 65; Le <= 90; Le++)
  Ir[Le] = String.fromCharCode(Le + 32), Ui[Le] = String.fromCharCode(Le);
for (var ea in Ir)
  Ui.hasOwnProperty(ea) || (Ui[ea] = Ir[ea]);
function hw(r) {
  var e = dw && (r.ctrlKey || r.altKey || r.metaKey) || cw && r.shiftKey && r.key && r.key.length == 1 || r.key == "Unidentified", t = !e && r.key || (r.shiftKey ? Ui : Ir)[r.keyCode] || r.key || "Unidentified";
  return t == "Esc" && (t = "Escape"), t == "Del" && (t = "Delete"), t == "Left" && (t = "ArrowLeft"), t == "Up" && (t = "ArrowUp"), t == "Right" && (t = "ArrowRight"), t == "Down" && (t = "ArrowDown"), t;
}
function zn(r) {
  let e;
  return r.nodeType == 11 ? e = r.getSelection ? r : r.ownerDocument : e = r, e.getSelection();
}
function Fl(r, e) {
  return e ? r == e || r.contains(e.nodeType != 1 ? e.parentNode : e) : !1;
}
function pw(r) {
  let e = r.activeElement;
  for (; e && e.shadowRoot; )
    e = e.shadowRoot.activeElement;
  return e;
}
function cn(r, e) {
  if (!e.anchorNode)
    return !1;
  try {
    return Fl(r, e.anchorNode);
  } catch {
    return !1;
  }
}
function qi(r) {
  return r.nodeType == 3 ? Hl(r, 0, r.nodeValue.length).getClientRects() : r.nodeType == 1 ? r.getClientRects() : [];
}
function Xn(r, e, t, l) {
  return t ? cp(r, e, t, l, -1) || cp(r, e, t, l, 1) : !1;
}
function An(r) {
  for (var e = 0; ; e++)
    if (r = r.previousSibling, !r)
      return e;
}
function cp(r, e, t, l, i) {
  for (; ; ) {
    if (r == t && e == l)
      return !0;
    if (e == (i < 0 ? 0 : Bi(r))) {
      if (r.nodeName == "DIV")
        return !1;
      let o = r.parentNode;
      if (!o || o.nodeType != 1)
        return !1;
      e = An(r) + (i < 0 ? 0 : 1), r = o;
    } else if (r.nodeType == 1) {
      if (r = r.childNodes[e + (i < 0 ? -1 : 0)], r.nodeType == 1 && r.contentEditable == "false")
        return !1;
      e = i < 0 ? Bi(r) : 0;
    } else
      return !1;
  }
}
function Bi(r) {
  return r.nodeType == 3 ? r.nodeValue.length : r.childNodes.length;
}
const em = { left: 0, right: 0, top: 0, bottom: 0 };
function Pd(r, e) {
  let t = e ? r.left : r.right;
  return { left: t, right: t, top: r.top, bottom: r.bottom };
}
function uw(r) {
  return {
    left: 0,
    right: r.innerWidth,
    top: 0,
    bottom: r.innerHeight
  };
}
function fw(r, e, t, l, i, o, n, s) {
  let a = r.ownerDocument, c = a.defaultView || window;
  for (let d = r; d; )
    if (d.nodeType == 1) {
      let h, p = d == a.body;
      if (p)
        h = uw(c);
      else {
        if (d.scrollHeight <= d.clientHeight && d.scrollWidth <= d.clientWidth) {
          d = d.assignedSlot || d.parentNode;
          continue;
        }
        let m = d.getBoundingClientRect();
        h = {
          left: m.left,
          right: m.left + d.clientWidth,
          top: m.top,
          bottom: m.top + d.clientHeight
        };
      }
      let u = 0, f = 0;
      if (i == "nearest")
        e.top < h.top ? (f = -(h.top - e.top + n), t > 0 && e.bottom > h.bottom + f && (f = e.bottom - h.bottom + f + n)) : e.bottom > h.bottom && (f = e.bottom - h.bottom + n, t < 0 && e.top - f < h.top && (f = -(h.top + f - e.top + n)));
      else {
        let m = e.bottom - e.top, O = h.bottom - h.top;
        f = (i == "center" && m <= O ? e.top + m / 2 - O / 2 : i == "start" || i == "center" && t < 0 ? e.top - n : e.bottom - O + n) - h.top;
      }
      if (l == "nearest" ? e.left < h.left ? (u = -(h.left - e.left + o), t > 0 && e.right > h.right + u && (u = e.right - h.right + u + o)) : e.right > h.right && (u = e.right - h.right + o, t < 0 && e.left < h.left + u && (u = -(h.left + u - e.left + o))) : u = (l == "center" ? e.left + (e.right - e.left) / 2 - (h.right - h.left) / 2 : l == "start" == s ? e.left - o : e.right - (h.right - h.left) + o) - h.left, u || f)
        if (p)
          c.scrollBy(u, f);
        else {
          let m = 0, O = 0;
          if (f) {
            let x = d.scrollTop;
            d.scrollTop += f, O = d.scrollTop - x;
          }
          if (u) {
            let x = d.scrollLeft;
            d.scrollLeft += u, m = d.scrollLeft - x;
          }
          e = {
            left: e.left - m,
            top: e.top - O,
            right: e.right - m,
            bottom: e.bottom - O
          }, m && Math.abs(m - u) < 1 && (l = "nearest"), O && Math.abs(O - f) < 1 && (i = "nearest");
        }
      if (p)
        break;
      d = d.assignedSlot || d.parentNode;
    } else if (d.nodeType == 11)
      d = d.host;
    else
      break;
}
function gw(r) {
  let e = r.ownerDocument;
  for (let t = r.parentNode; t && t != e.body; )
    if (t.nodeType == 1) {
      if (t.scrollHeight > t.clientHeight || t.scrollWidth > t.clientWidth)
        return t;
      t = t.assignedSlot || t.parentNode;
    } else if (t.nodeType == 11)
      t = t.host;
    else
      break;
  return null;
}
class mw {
  constructor() {
    this.anchorNode = null, this.anchorOffset = 0, this.focusNode = null, this.focusOffset = 0;
  }
  eq(e) {
    return this.anchorNode == e.anchorNode && this.anchorOffset == e.anchorOffset && this.focusNode == e.focusNode && this.focusOffset == e.focusOffset;
  }
  setRange(e) {
    this.set(e.anchorNode, e.anchorOffset, e.focusNode, e.focusOffset);
  }
  set(e, t, l, i) {
    this.anchorNode = e, this.anchorOffset = t, this.focusNode = l, this.focusOffset = i;
  }
}
let Cl = null;
function tm(r) {
  if (r.setActive)
    return r.setActive();
  if (Cl)
    return r.focus(Cl);
  let e = [];
  for (let t = r; t && (e.push(t, t.scrollTop, t.scrollLeft), t != t.ownerDocument); t = t.parentNode)
    ;
  if (r.focus(Cl == null ? {
    get preventScroll() {
      return Cl = { preventScroll: !0 }, !0;
    }
  } : void 0), !Cl) {
    Cl = !1;
    for (let t = 0; t < e.length; ) {
      let l = e[t++], i = e[t++], o = e[t++];
      l.scrollTop != i && (l.scrollTop = i), l.scrollLeft != o && (l.scrollLeft = o);
    }
  }
}
let dp;
function Hl(r, e, t = e) {
  let l = dp || (dp = document.createRange());
  return l.setEnd(r, t), l.setStart(r, e), l;
}
function Il(r, e, t) {
  let l = { key: e, code: e, keyCode: t, which: t, cancelable: !0 }, i = new KeyboardEvent("keydown", l);
  i.synthetic = !0, r.dispatchEvent(i);
  let o = new KeyboardEvent("keyup", l);
  return o.synthetic = !0, r.dispatchEvent(o), i.defaultPrevented || o.defaultPrevented;
}
function bw(r) {
  for (; r; ) {
    if (r && (r.nodeType == 9 || r.nodeType == 11 && r.host))
      return r;
    r = r.assignedSlot || r.parentNode;
  }
  return null;
}
function rm(r) {
  for (; r.attributes.length; )
    r.removeAttributeNode(r.attributes[0]);
}
function Ow(r, e) {
  let t = e.focusNode, l = e.focusOffset;
  if (!t || e.anchorNode != t || e.anchorOffset != l)
    return !1;
  for (; ; )
    if (l) {
      if (t.nodeType != 1)
        return !1;
      let i = t.childNodes[l - 1];
      i.contentEditable == "false" ? l-- : (t = i, l = Bi(t));
    } else {
      if (t == r)
        return !0;
      l = An(t), t = t.parentNode;
    }
}
class Ke {
  constructor(e, t, l = !0) {
    this.node = e, this.offset = t, this.precise = l;
  }
  static before(e, t) {
    return new Ke(e.parentNode, An(e), t);
  }
  static after(e, t) {
    return new Ke(e.parentNode, An(e) + 1, t);
  }
}
const Cd = [];
class ye {
  constructor() {
    this.parent = null, this.dom = null, this.dirty = 2;
  }
  get editorView() {
    if (!this.parent)
      throw new Error("Accessing view in orphan content view");
    return this.parent.editorView;
  }
  get overrideDOMText() {
    return null;
  }
  get posAtStart() {
    return this.parent ? this.parent.posBefore(this) : 0;
  }
  get posAtEnd() {
    return this.posAtStart + this.length;
  }
  posBefore(e) {
    let t = this.posAtStart;
    for (let l of this.children) {
      if (l == e)
        return t;
      t += l.length + l.breakAfter;
    }
    throw new RangeError("Invalid child in posBefore");
  }
  posAfter(e) {
    return this.posBefore(e) + e.length;
  }
  // Will return a rectangle directly before (when side < 0), after
  // (side > 0) or directly on (when the browser supports it) the
  // given position.
  coordsAt(e, t) {
    return null;
  }
  sync(e) {
    if (this.dirty & 2) {
      let t = this.dom, l = null, i;
      for (let o of this.children) {
        if (o.dirty) {
          if (!o.dom && (i = l ? l.nextSibling : t.firstChild)) {
            let n = ye.get(i);
            (!n || !n.parent && n.canReuseDOM(o)) && o.reuseDOM(i);
          }
          o.sync(e), o.dirty = 0;
        }
        if (i = l ? l.nextSibling : t.firstChild, e && !e.written && e.node == t && i != o.dom && (e.written = !0), o.dom.parentNode == t)
          for (; i && i != o.dom; )
            i = hp(i);
        else
          t.insertBefore(o.dom, i);
        l = o.dom;
      }
      for (i = l ? l.nextSibling : t.firstChild, i && e && e.node == t && (e.written = !0); i; )
        i = hp(i);
    } else if (this.dirty & 1)
      for (let t of this.children)
        t.dirty && (t.sync(e), t.dirty = 0);
  }
  reuseDOM(e) {
  }
  localPosFromDOM(e, t) {
    let l;
    if (e == this.dom)
      l = this.dom.childNodes[t];
    else {
      let i = Bi(e) == 0 ? 0 : t == 0 ? -1 : 1;
      for (; ; ) {
        let o = e.parentNode;
        if (o == this.dom)
          break;
        i == 0 && o.firstChild != o.lastChild && (e == o.firstChild ? i = -1 : i = 1), e = o;
      }
      i < 0 ? l = e : l = e.nextSibling;
    }
    if (l == this.dom.firstChild)
      return 0;
    for (; l && !ye.get(l); )
      l = l.nextSibling;
    if (!l)
      return this.length;
    for (let i = 0, o = 0; ; i++) {
      let n = this.children[i];
      if (n.dom == l)
        return o;
      o += n.length + n.breakAfter;
    }
  }
  domBoundsAround(e, t, l = 0) {
    let i = -1, o = -1, n = -1, s = -1;
    for (let a = 0, c = l, d = l; a < this.children.length; a++) {
      let h = this.children[a], p = c + h.length;
      if (c < e && p > t)
        return h.domBoundsAround(e, t, c);
      if (p >= e && i == -1 && (i = a, o = c), c > t && h.dom.parentNode == this.dom) {
        n = a, s = d;
        break;
      }
      d = p, c = p + h.breakAfter;
    }
    return {
      from: o,
      to: s < 0 ? l + this.length : s,
      startDOM: (i ? this.children[i - 1].dom.nextSibling : null) || this.dom.firstChild,
      endDOM: n < this.children.length && n >= 0 ? this.children[n].dom : null
    };
  }
  markDirty(e = !1) {
    this.dirty |= 2, this.markParentsDirty(e);
  }
  markParentsDirty(e) {
    for (let t = this.parent; t; t = t.parent) {
      if (e && (t.dirty |= 2), t.dirty & 1)
        return;
      t.dirty |= 1, e = !1;
    }
  }
  setParent(e) {
    this.parent != e && (this.parent = e, this.dirty && this.markParentsDirty(!0));
  }
  setDOM(e) {
    this.dom && (this.dom.cmView = null), this.dom = e, e.cmView = this;
  }
  get rootView() {
    for (let e = this; ; ) {
      let t = e.parent;
      if (!t)
        return e;
      e = t;
    }
  }
  replaceChildren(e, t, l = Cd) {
    this.markDirty();
    for (let i = e; i < t; i++) {
      let o = this.children[i];
      o.parent == this && o.destroy();
    }
    this.children.splice(e, t - e, ...l);
    for (let i = 0; i < l.length; i++)
      l[i].setParent(this);
  }
  ignoreMutation(e) {
    return !1;
  }
  ignoreEvent(e) {
    return !1;
  }
  childCursor(e = this.length) {
    return new lm(this.children, e, this.children.length);
  }
  childPos(e, t = 1) {
    return this.childCursor().findPos(e, t);
  }
  toString() {
    let e = this.constructor.name.replace("View", "");
    return e + (this.children.length ? "(" + this.children.join() + ")" : this.length ? "[" + (e == "Text" ? this.text : this.length) + "]" : "") + (this.breakAfter ? "#" : "");
  }
  static get(e) {
    return e.cmView;
  }
  get isEditable() {
    return !0;
  }
  merge(e, t, l, i, o, n) {
    return !1;
  }
  become(e) {
    return !1;
  }
  canReuseDOM(e) {
    return e.constructor == this.constructor;
  }
  // When this is a zero-length view with a side, this should return a
  // number <= 0 to indicate it is before its position, or a
  // number > 0 when after its position.
  getSide() {
    return 0;
  }
  destroy() {
    this.parent = null;
  }
}
ye.prototype.breakAfter = 0;
function hp(r) {
  let e = r.nextSibling;
  return r.parentNode.removeChild(r), e;
}
class lm {
  constructor(e, t, l) {
    this.children = e, this.pos = t, this.i = l, this.off = 0;
  }
  findPos(e, t = 1) {
    for (; ; ) {
      if (e > this.pos || e == this.pos && (t > 0 || this.i == 0 || this.children[this.i - 1].breakAfter))
        return this.off = e - this.pos, this;
      let l = this.children[--this.i];
      this.pos -= l.length + l.breakAfter;
    }
  }
}
function im(r, e, t, l, i, o, n, s, a) {
  let { children: c } = r, d = c.length ? c[e] : null, h = o.length ? o[o.length - 1] : null, p = h ? h.breakAfter : n;
  if (!(e == l && d && !n && !p && o.length < 2 && d.merge(t, i, o.length ? h : null, t == 0, s, a))) {
    if (l < c.length) {
      let u = c[l];
      u && i < u.length ? (e == l && (u = u.split(i), i = 0), !p && h && u.merge(0, i, h, !0, 0, a) ? o[o.length - 1] = u : (i && u.merge(0, i, null, !1, 0, a), o.push(u))) : u != null && u.breakAfter && (h ? h.breakAfter = 1 : n = 1), l++;
    }
    for (d && (d.breakAfter = n, t > 0 && (!n && o.length && d.merge(t, d.length, o[0], !1, s, 0) ? d.breakAfter = o.shift().breakAfter : (t < d.length || d.children.length && d.children[d.children.length - 1].length == 0) && d.merge(t, d.length, null, !1, s, 0), e++)); e < l && o.length; )
      if (c[l - 1].become(o[o.length - 1]))
        l--, o.pop(), a = o.length ? 0 : s;
      else if (c[e].become(o[0]))
        e++, o.shift(), s = o.length ? 0 : a;
      else
        break;
    !o.length && e && l < c.length && !c[e - 1].breakAfter && c[l].merge(0, 0, c[e - 1], !1, s, a) && e--, (e < l || o.length) && r.replaceChildren(e, l, o);
  }
}
function om(r, e, t, l, i, o) {
  let n = r.childCursor(), { i: s, off: a } = n.findPos(t, 1), { i: c, off: d } = n.findPos(e, -1), h = e - t;
  for (let p of l)
    h += p.length;
  r.length += h, im(r, c, d, s, a, l, 0, i, o);
}
let _t = typeof navigator < "u" ? navigator : { userAgent: "", vendor: "", platform: "" }, pc = typeof document < "u" ? document : { documentElement: { style: {} } };
const uc = /* @__PURE__ */ /Edge\/(\d+)/.exec(_t.userAgent), nm = /* @__PURE__ */ /MSIE \d/.test(_t.userAgent), fc = /* @__PURE__ */ /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(_t.userAgent), Qs = !!(nm || fc || uc), pp = !Qs && /* @__PURE__ */ /gecko\/(\d+)/i.test(_t.userAgent), ta = !Qs && /* @__PURE__ */ /Chrome\/(\d+)/.exec(_t.userAgent), up = "webkitFontSmoothing" in pc.documentElement.style, sm = !Qs && /* @__PURE__ */ /Apple Computer/.test(_t.vendor), fp = sm && (/* @__PURE__ */ /Mobile\/\w+/.test(_t.userAgent) || _t.maxTouchPoints > 2);
var M = {
  mac: fp || /* @__PURE__ */ /Mac/.test(_t.platform),
  windows: /* @__PURE__ */ /Win/.test(_t.platform),
  linux: /* @__PURE__ */ /Linux|X11/.test(_t.platform),
  ie: Qs,
  ie_version: nm ? pc.documentMode || 6 : fc ? +fc[1] : uc ? +uc[1] : 0,
  gecko: pp,
  gecko_version: pp ? +(/* @__PURE__ */ /Firefox\/(\d+)/.exec(_t.userAgent) || [0, 0])[1] : 0,
  chrome: !!ta,
  chrome_version: ta ? +ta[1] : 0,
  ios: fp,
  android: /* @__PURE__ */ /Android\b/.test(_t.userAgent),
  webkit: up,
  safari: sm,
  webkit_version: up ? +(/* @__PURE__ */ /\bAppleWebKit\/(\d+)/.exec(navigator.userAgent) || [0, 0])[1] : 0,
  tabSize: pc.documentElement.style.tabSize != null ? "tab-size" : "-moz-tab-size"
};
const vw = 256;
class Ur extends ye {
  constructor(e) {
    super(), this.text = e;
  }
  get length() {
    return this.text.length;
  }
  createDOM(e) {
    this.setDOM(e || document.createTextNode(this.text));
  }
  sync(e) {
    this.dom || this.createDOM(), this.dom.nodeValue != this.text && (e && e.node == this.dom && (e.written = !0), this.dom.nodeValue = this.text);
  }
  reuseDOM(e) {
    e.nodeType == 3 && this.createDOM(e);
  }
  merge(e, t, l) {
    return l && (!(l instanceof Ur) || this.length - (t - e) + l.length > vw) ? !1 : (this.text = this.text.slice(0, e) + (l ? l.text : "") + this.text.slice(t), this.markDirty(), !0);
  }
  split(e) {
    let t = new Ur(this.text.slice(e));
    return this.text = this.text.slice(0, e), this.markDirty(), t;
  }
  localPosFromDOM(e, t) {
    return e == this.dom ? t : t ? this.text.length : 0;
  }
  domAtPos(e) {
    return new Ke(this.dom, e);
  }
  domBoundsAround(e, t, l) {
    return { from: l, to: l + this.length, startDOM: this.dom, endDOM: this.dom.nextSibling };
  }
  coordsAt(e, t) {
    return gc(this.dom, e, t);
  }
}
class lr extends ye {
  constructor(e, t = [], l = 0) {
    super(), this.mark = e, this.children = t, this.length = l;
    for (let i of t)
      i.setParent(this);
  }
  setAttrs(e) {
    if (rm(e), this.mark.class && (e.className = this.mark.class), this.mark.attrs)
      for (let t in this.mark.attrs)
        e.setAttribute(t, this.mark.attrs[t]);
    return e;
  }
  reuseDOM(e) {
    e.nodeName == this.mark.tagName.toUpperCase() && (this.setDOM(e), this.dirty |= 6);
  }
  sync(e) {
    this.dom ? this.dirty & 4 && this.setAttrs(this.dom) : this.setDOM(this.setAttrs(document.createElement(this.mark.tagName))), super.sync(e);
  }
  merge(e, t, l, i, o, n) {
    return l && (!(l instanceof lr && l.mark.eq(this.mark)) || e && o <= 0 || t < this.length && n <= 0) ? !1 : (om(this, e, t, l ? l.children : [], o - 1, n - 1), this.markDirty(), !0);
  }
  split(e) {
    let t = [], l = 0, i = -1, o = 0;
    for (let s of this.children) {
      let a = l + s.length;
      a > e && t.push(l < e ? s.split(e - l) : s), i < 0 && l >= e && (i = o), l = a, o++;
    }
    let n = this.length - e;
    return this.length = e, i > -1 && (this.children.length = i, this.markDirty()), new lr(this.mark, t, n);
  }
  domAtPos(e) {
    return dm(this, e);
  }
  coordsAt(e, t) {
    return pm(this, e, t);
  }
}
function gc(r, e, t) {
  let l = r.nodeValue.length;
  e > l && (e = l);
  let i = e, o = e, n = 0;
  e == 0 && t < 0 || e == l && t >= 0 ? M.chrome || M.gecko || (e ? (i--, n = 1) : o < l && (o++, n = -1)) : t < 0 ? i-- : o < l && o++;
  let s = Hl(r, i, o).getClientRects();
  if (!s.length)
    return em;
  let a = s[(n ? n < 0 : t >= 0) ? 0 : s.length - 1];
  return M.safari && !n && a.width == 0 && (a = Array.prototype.find.call(s, (c) => c.width) || a), n ? Pd(a, n < 0) : a || null;
}
class Cr extends ye {
  constructor(e, t, l) {
    super(), this.widget = e, this.length = t, this.side = l, this.prevWidget = null;
  }
  static create(e, t, l) {
    return new (e.customView || Cr)(e, t, l);
  }
  split(e) {
    let t = Cr.create(this.widget, this.length - e, this.side);
    return this.length -= e, t;
  }
  sync() {
    (!this.dom || !this.widget.updateDOM(this.dom)) && (this.dom && this.prevWidget && this.prevWidget.destroy(this.dom), this.prevWidget = null, this.setDOM(this.widget.toDOM(this.editorView)), this.dom.contentEditable = "false");
  }
  getSide() {
    return this.side;
  }
  merge(e, t, l, i, o, n) {
    return l && (!(l instanceof Cr) || !this.widget.compare(l.widget) || e > 0 && o <= 0 || t < this.length && n <= 0) ? !1 : (this.length = e + (l ? l.length : 0) + (this.length - t), !0);
  }
  become(e) {
    return e.length == this.length && e instanceof Cr && e.side == this.side && this.widget.constructor == e.widget.constructor ? (this.widget.eq(e.widget) || this.markDirty(!0), this.dom && !this.prevWidget && (this.prevWidget = this.widget), this.widget = e.widget, !0) : !1;
  }
  ignoreMutation() {
    return !0;
  }
  ignoreEvent(e) {
    return this.widget.ignoreEvent(e);
  }
  get overrideDOMText() {
    if (this.length == 0)
      return ue.empty;
    let e = this;
    for (; e.parent; )
      e = e.parent;
    let t = e.editorView, l = t && t.state.doc, i = this.posAtStart;
    return l ? l.slice(i, i + this.length) : ue.empty;
  }
  domAtPos(e) {
    return e == 0 ? Ke.before(this.dom) : Ke.after(this.dom, e == this.length);
  }
  domBoundsAround() {
    return null;
  }
  coordsAt(e, t) {
    let l = this.dom.getClientRects(), i = null;
    if (!l.length)
      return em;
    for (let o = e > 0 ? l.length - 1 : 0; i = l[o], !(e > 0 ? o == 0 : o == l.length - 1 || i.top < i.bottom); o += e > 0 ? -1 : 1)
      ;
    return this.length ? i : Pd(i, this.side > 0);
  }
  get isEditable() {
    return !1;
  }
  destroy() {
    super.destroy(), this.dom && this.widget.destroy(this.dom);
  }
}
class am extends Cr {
  domAtPos(e) {
    let { topView: t, text: l } = this.widget;
    return t ? mc(e, 0, t, l, (i, o) => i.domAtPos(o), (i) => new Ke(l, Math.min(i, l.nodeValue.length))) : new Ke(l, Math.min(e, l.nodeValue.length));
  }
  sync() {
    this.setDOM(this.widget.toDOM());
  }
  localPosFromDOM(e, t) {
    let { topView: l, text: i } = this.widget;
    return l ? cm(e, t, l, i) : Math.min(t, this.length);
  }
  ignoreMutation() {
    return !1;
  }
  get overrideDOMText() {
    return null;
  }
  coordsAt(e, t) {
    let { topView: l, text: i } = this.widget;
    return l ? mc(e, t, l, i, (o, n, s) => o.coordsAt(n, s), (o, n) => gc(i, o, n)) : gc(i, e, t);
  }
  destroy() {
    var e;
    super.destroy(), (e = this.widget.topView) === null || e === void 0 || e.destroy();
  }
  get isEditable() {
    return !0;
  }
  canReuseDOM() {
    return !0;
  }
}
function mc(r, e, t, l, i, o) {
  if (t instanceof lr) {
    for (let n = t.dom.firstChild; n; n = n.nextSibling) {
      let s = ye.get(n);
      if (!s)
        return o(r, e);
      let a = Fl(n, l), c = s.length + (a ? l.nodeValue.length : 0);
      if (r < c || r == c && s.getSide() <= 0)
        return a ? mc(r, e, s, l, i, o) : i(s, r, e);
      r -= c;
    }
    return i(t, t.length, -1);
  } else
    return t.dom == l ? o(r, e) : i(t, r, e);
}
function cm(r, e, t, l) {
  if (t instanceof lr)
    for (let i of t.children) {
      let o = 0, n = Fl(i.dom, l);
      if (Fl(i.dom, r))
        return o + (n ? cm(r, e, i, l) : i.localPosFromDOM(r, e));
      o += n ? l.nodeValue.length : i.length;
    }
  else if (t.dom == l)
    return Math.min(e, l.nodeValue.length);
  return t.localPosFromDOM(r, e);
}
class Kl extends ye {
  constructor(e) {
    super(), this.side = e;
  }
  get length() {
    return 0;
  }
  merge() {
    return !1;
  }
  become(e) {
    return e instanceof Kl && e.side == this.side;
  }
  split() {
    return new Kl(this.side);
  }
  sync() {
    if (!this.dom) {
      let e = document.createElement("img");
      e.className = "cm-widgetBuffer", e.setAttribute("aria-hidden", "true"), this.setDOM(e);
    }
  }
  getSide() {
    return this.side;
  }
  domAtPos(e) {
    return Ke.before(this.dom);
  }
  localPosFromDOM() {
    return 0;
  }
  domBoundsAround() {
    return null;
  }
  coordsAt(e) {
    let t = this.dom.getBoundingClientRect(), l = xw(this, this.side > 0 ? -1 : 1);
    return l && l.top < t.bottom && l.bottom > t.top ? { left: t.left, right: t.right, top: l.top, bottom: l.bottom } : t;
  }
  get overrideDOMText() {
    return ue.empty;
  }
}
Ur.prototype.children = Cr.prototype.children = Kl.prototype.children = Cd;
function xw(r, e) {
  let t = r.parent, l = t ? t.children.indexOf(r) : -1;
  for (; t && l >= 0; )
    if (e < 0 ? l > 0 : l < t.children.length) {
      let i = t.children[l + e];
      if (i instanceof Ur) {
        let o = i.coordsAt(e < 0 ? i.length : 0, e);
        if (o)
          return o;
      }
      l += e;
    } else if (t instanceof lr && t.parent)
      l = t.parent.children.indexOf(t) + (e < 0 ? 0 : 1), t = t.parent;
    else {
      let i = t.dom.lastChild;
      if (i && i.nodeName == "BR")
        return i.getClientRects()[0];
      break;
    }
}
function dm(r, e) {
  let t = r.dom, { children: l } = r, i = 0;
  for (let o = 0; i < l.length; i++) {
    let n = l[i], s = o + n.length;
    if (!(s == o && n.getSide() <= 0)) {
      if (e > o && e < s && n.dom.parentNode == t)
        return n.domAtPos(e - o);
      if (e <= o)
        break;
      o = s;
    }
  }
  for (let o = i; o > 0; o--) {
    let n = l[o - 1];
    if (n.dom.parentNode == t)
      return n.domAtPos(n.length);
  }
  for (let o = i; o < l.length; o++) {
    let n = l[o];
    if (n.dom.parentNode == t)
      return n.domAtPos(0);
  }
  return new Ke(t, 0);
}
function hm(r, e, t) {
  let l, { children: i } = r;
  t > 0 && e instanceof lr && i.length && (l = i[i.length - 1]) instanceof lr && l.mark.eq(e.mark) ? hm(l, e.children[0], t - 1) : (i.push(e), e.setParent(r)), r.length += e.length;
}
function pm(r, e, t) {
  let l = null, i = -1, o = null, n = -1;
  function s(c, d) {
    for (let h = 0, p = 0; h < c.children.length && p <= d; h++) {
      let u = c.children[h], f = p + u.length;
      f >= d && (u.children.length ? s(u, d - p) : !o && (f > d || p == f && u.getSide() > 0) ? (o = u, n = d - p) : (p < d || p == f && u.getSide() < 0) && (l = u, i = d - p)), p = f;
    }
  }
  s(r, e);
  let a = (t < 0 ? l : o) || l || o;
  return a ? a.coordsAt(Math.max(0, a == l ? i : n), t) : _w(r);
}
function _w(r) {
  let e = r.dom.lastChild;
  if (!e)
    return r.dom.getBoundingClientRect();
  let t = qi(e);
  return t[t.length - 1] || null;
}
function bc(r, e) {
  for (let t in r)
    t == "class" && e.class ? e.class += " " + r.class : t == "style" && e.style ? e.style += ";" + r.style : e[t] = r[t];
  return e;
}
function Td(r, e) {
  if (r == e)
    return !0;
  if (!r || !e)
    return !1;
  let t = Object.keys(r), l = Object.keys(e);
  if (t.length != l.length)
    return !1;
  for (let i of t)
    if (l.indexOf(i) == -1 || r[i] !== e[i])
      return !1;
  return !0;
}
function Oc(r, e, t) {
  let l = null;
  if (e)
    for (let i in e)
      t && i in t || r.removeAttribute(l = i);
  if (t)
    for (let i in t)
      e && e[i] == t[i] || r.setAttribute(l = i, t[i]);
  return !!l;
}
class br {
  /**
  Compare this instance to another instance of the same type.
  (TypeScript can't express this, but only instances of the same
  specific class will be passed to this method.) This is used to
  avoid redrawing widgets when they are replaced by a new
  decoration of the same type. The default implementation just
  returns `false`, which will cause new instances of the widget to
  always be redrawn.
  */
  eq(e) {
    return !1;
  }
  /**
  Update a DOM element created by a widget of the same type (but
  different, non-`eq` content) to reflect this widget. May return
  true to indicate that it could update, false to indicate it
  couldn't (in which case the widget will be redrawn). The default
  implementation just returns false.
  */
  updateDOM(e) {
    return !1;
  }
  /**
  @internal
  */
  compare(e) {
    return this == e || this.constructor == e.constructor && this.eq(e);
  }
  /**
  The estimated height this widget will have, to be used when
  estimating the height of content that hasn't been drawn. May
  return -1 to indicate you don't know. The default implementation
  returns -1.
  */
  get estimatedHeight() {
    return -1;
  }
  /**
  Can be used to configure which kinds of events inside the widget
  should be ignored by the editor. The default is to ignore all
  events.
  */
  ignoreEvent(e) {
    return !0;
  }
  /**
  @internal
  */
  get customView() {
    return null;
  }
  /**
  This is called when the an instance of the widget is removed
  from the editor view.
  */
  destroy(e) {
  }
}
var _e = /* @__PURE__ */ function(r) {
  return r[r.Text = 0] = "Text", r[r.WidgetBefore = 1] = "WidgetBefore", r[r.WidgetAfter = 2] = "WidgetAfter", r[r.WidgetRange = 3] = "WidgetRange", r;
}(_e || (_e = {}));
class B extends Ol {
  constructor(e, t, l, i) {
    super(), this.startSide = e, this.endSide = t, this.widget = l, this.spec = i;
  }
  /**
  @internal
  */
  get heightRelevant() {
    return !1;
  }
  /**
  Create a mark decoration, which influences the styling of the
  content in its range. Nested mark decorations will cause nested
  DOM elements to be created. Nesting order is determined by
  precedence of the [facet](https://codemirror.net/6/docs/ref/#view.EditorView^decorations), with
  the higher-precedence decorations creating the inner DOM nodes.
  Such elements are split on line boundaries and on the boundaries
  of lower-precedence decorations.
  */
  static mark(e) {
    return new $s(e);
  }
  /**
  Create a widget decoration, which displays a DOM element at the
  given position.
  */
  static widget(e) {
    let t = e.side || 0, l = !!e.block;
    return t += l ? t > 0 ? 3e8 : -4e8 : t > 0 ? 1e8 : -1e8, new vl(e, t, t, l, e.widget || null, !1);
  }
  /**
  Create a replace decoration which replaces the given range with
  a widget, or simply hides it.
  */
  static replace(e) {
    let t = !!e.block, l, i;
    if (e.isBlockGap)
      l = -5e8, i = 4e8;
    else {
      let { start: o, end: n } = um(e, t);
      l = (o ? t ? -3e8 : -1 : 5e8) - 1, i = (n ? t ? 2e8 : 1 : -6e8) + 1;
    }
    return new vl(e, l, i, t, e.widget || null, !0);
  }
  /**
  Create a line decoration, which can add DOM attributes to the
  line starting at the given position.
  */
  static line(e) {
    return new go(e);
  }
  /**
  Build a [`DecorationSet`](https://codemirror.net/6/docs/ref/#view.DecorationSet) from the given
  decorated range or ranges. If the ranges aren't already sorted,
  pass `true` for `sort` to make the library sort them for you.
  */
  static set(e, t = !1) {
    return ge.of(e, t);
  }
  /**
  @internal
  */
  hasHeight() {
    return this.widget ? this.widget.estimatedHeight > -1 : !1;
  }
}
B.none = ge.empty;
class $s extends B {
  constructor(e) {
    let { start: t, end: l } = um(e);
    super(t ? -1 : 5e8, l ? 1 : -6e8, null, e), this.tagName = e.tagName || "span", this.class = e.class || "", this.attrs = e.attributes || null;
  }
  eq(e) {
    return this == e || e instanceof $s && this.tagName == e.tagName && this.class == e.class && Td(this.attrs, e.attrs);
  }
  range(e, t = e) {
    if (e >= t)
      throw new RangeError("Mark decorations may not be empty");
    return super.range(e, t);
  }
}
$s.prototype.point = !1;
class go extends B {
  constructor(e) {
    super(-2e8, -2e8, null, e);
  }
  eq(e) {
    return e instanceof go && this.spec.class == e.spec.class && Td(this.spec.attributes, e.spec.attributes);
  }
  range(e, t = e) {
    if (t != e)
      throw new RangeError("Line decoration ranges must be zero-length");
    return super.range(e, t);
  }
}
go.prototype.mapMode = Ge.TrackBefore;
go.prototype.point = !0;
class vl extends B {
  constructor(e, t, l, i, o, n) {
    super(t, l, o, e), this.block = i, this.isReplace = n, this.mapMode = i ? t <= 0 ? Ge.TrackBefore : Ge.TrackAfter : Ge.TrackDel;
  }
  // Only relevant when this.block == true
  get type() {
    return this.startSide < this.endSide ? _e.WidgetRange : this.startSide <= 0 ? _e.WidgetBefore : _e.WidgetAfter;
  }
  get heightRelevant() {
    return this.block || !!this.widget && this.widget.estimatedHeight >= 5;
  }
  eq(e) {
    return e instanceof vl && ww(this.widget, e.widget) && this.block == e.block && this.startSide == e.startSide && this.endSide == e.endSide;
  }
  range(e, t = e) {
    if (this.isReplace && (e > t || e == t && this.startSide > 0 && this.endSide <= 0))
      throw new RangeError("Invalid range for replacement decoration");
    if (!this.isReplace && t != e)
      throw new RangeError("Widget decorations can only have zero-length ranges");
    return super.range(e, t);
  }
}
vl.prototype.point = !0;
function um(r, e = !1) {
  let { inclusiveStart: t, inclusiveEnd: l } = r;
  return t == null && (t = r.inclusive), l == null && (l = r.inclusive), { start: t ?? e, end: l ?? e };
}
function ww(r, e) {
  return r == e || !!(r && e && r.compare(e));
}
function vc(r, e, t, l = 0) {
  let i = t.length - 1;
  i >= 0 && t[i] + l >= r ? t[i] = Math.max(t[i], e) : t.push(r, e);
}
class st extends ye {
  constructor() {
    super(...arguments), this.children = [], this.length = 0, this.prevAttrs = void 0, this.attrs = null, this.breakAfter = 0;
  }
  // Consumes source
  merge(e, t, l, i, o, n) {
    if (l) {
      if (!(l instanceof st))
        return !1;
      this.dom || l.transferDOM(this);
    }
    return i && this.setDeco(l ? l.attrs : null), om(this, e, t, l ? l.children : [], o, n), !0;
  }
  split(e) {
    let t = new st();
    if (t.breakAfter = this.breakAfter, this.length == 0)
      return t;
    let { i: l, off: i } = this.childPos(e);
    i && (t.append(this.children[l].split(i), 0), this.children[l].merge(i, this.children[l].length, null, !1, 0, 0), l++);
    for (let o = l; o < this.children.length; o++)
      t.append(this.children[o], 0);
    for (; l > 0 && this.children[l - 1].length == 0; )
      this.children[--l].destroy();
    return this.children.length = l, this.markDirty(), this.length = e, t;
  }
  transferDOM(e) {
    this.dom && (this.markDirty(), e.setDOM(this.dom), e.prevAttrs = this.prevAttrs === void 0 ? this.attrs : this.prevAttrs, this.prevAttrs = void 0, this.dom = null);
  }
  setDeco(e) {
    Td(this.attrs, e) || (this.dom && (this.prevAttrs = this.attrs, this.markDirty()), this.attrs = e);
  }
  append(e, t) {
    hm(this, e, t);
  }
  // Only called when building a line view in ContentBuilder
  addLineDeco(e) {
    let t = e.spec.attributes, l = e.spec.class;
    t && (this.attrs = bc(t, this.attrs || {})), l && (this.attrs = bc({ class: l }, this.attrs || {}));
  }
  domAtPos(e) {
    return dm(this, e);
  }
  reuseDOM(e) {
    e.nodeName == "DIV" && (this.setDOM(e), this.dirty |= 6);
  }
  sync(e) {
    var t;
    this.dom ? this.dirty & 4 && (rm(this.dom), this.dom.className = "cm-line", this.prevAttrs = this.attrs ? null : void 0) : (this.setDOM(document.createElement("div")), this.dom.className = "cm-line", this.prevAttrs = this.attrs ? null : void 0), this.prevAttrs !== void 0 && (Oc(this.dom, this.prevAttrs, this.attrs), this.dom.classList.add("cm-line"), this.prevAttrs = void 0), super.sync(e);
    let l = this.dom.lastChild;
    for (; l && ye.get(l) instanceof lr; )
      l = l.lastChild;
    if (!l || !this.length || l.nodeName != "BR" && ((t = ye.get(l)) === null || t === void 0 ? void 0 : t.isEditable) == !1 && (!M.ios || !this.children.some((i) => i instanceof Ur))) {
      let i = document.createElement("BR");
      i.cmIgnore = !0, this.dom.appendChild(i);
    }
  }
  measureTextSize() {
    if (this.children.length == 0 || this.length > 20)
      return null;
    let e = 0;
    for (let t of this.children) {
      if (!(t instanceof Ur) || /[^ -~]/.test(t.text))
        return null;
      let l = qi(t.dom);
      if (l.length != 1)
        return null;
      e += l[0].width;
    }
    return e ? {
      lineHeight: this.dom.getBoundingClientRect().height,
      charWidth: e / this.length
    } : null;
  }
  coordsAt(e, t) {
    return pm(this, e, t);
  }
  become(e) {
    return !1;
  }
  get type() {
    return _e.Text;
  }
  static find(e, t) {
    for (let l = 0, i = 0; l < e.children.length; l++) {
      let o = e.children[l], n = i + o.length;
      if (n >= t) {
        if (o instanceof st)
          return o;
        if (n > t)
          break;
      }
      i = n + o.breakAfter;
    }
    return null;
  }
}
class gl extends ye {
  constructor(e, t, l) {
    super(), this.widget = e, this.length = t, this.type = l, this.breakAfter = 0, this.prevWidget = null;
  }
  merge(e, t, l, i, o, n) {
    return l && (!(l instanceof gl) || !this.widget.compare(l.widget) || e > 0 && o <= 0 || t < this.length && n <= 0) ? !1 : (this.length = e + (l ? l.length : 0) + (this.length - t), !0);
  }
  domAtPos(e) {
    return e == 0 ? Ke.before(this.dom) : Ke.after(this.dom, e == this.length);
  }
  split(e) {
    let t = this.length - e;
    this.length = e;
    let l = new gl(this.widget, t, this.type);
    return l.breakAfter = this.breakAfter, l;
  }
  get children() {
    return Cd;
  }
  sync() {
    (!this.dom || !this.widget.updateDOM(this.dom)) && (this.dom && this.prevWidget && this.prevWidget.destroy(this.dom), this.prevWidget = null, this.setDOM(this.widget.toDOM(this.editorView)), this.dom.contentEditable = "false");
  }
  get overrideDOMText() {
    return this.parent ? this.parent.view.state.doc.slice(this.posAtStart, this.posAtEnd) : ue.empty;
  }
  domBoundsAround() {
    return null;
  }
  become(e) {
    return e instanceof gl && e.type == this.type && e.widget.constructor == this.widget.constructor ? (e.widget.eq(this.widget) || this.markDirty(!0), this.dom && !this.prevWidget && (this.prevWidget = this.widget), this.widget = e.widget, this.length = e.length, this.breakAfter = e.breakAfter, !0) : !1;
  }
  ignoreMutation() {
    return !0;
  }
  ignoreEvent(e) {
    return this.widget.ignoreEvent(e);
  }
  destroy() {
    super.destroy(), this.dom && this.widget.destroy(this.dom);
  }
}
class zd {
  constructor(e, t, l, i) {
    this.doc = e, this.pos = t, this.end = l, this.disallowBlockEffectsFor = i, this.content = [], this.curLine = null, this.breakAtStart = 0, this.pendingBuffer = 0, this.bufferMarks = [], this.atCursorPos = !0, this.openStart = -1, this.openEnd = -1, this.text = "", this.textOff = 0, this.cursor = e.iter(), this.skip = t;
  }
  posCovered() {
    if (this.content.length == 0)
      return !this.breakAtStart && this.doc.lineAt(this.pos).from != this.pos;
    let e = this.content[this.content.length - 1];
    return !e.breakAfter && !(e instanceof gl && e.type == _e.WidgetBefore);
  }
  getLine() {
    return this.curLine || (this.content.push(this.curLine = new st()), this.atCursorPos = !0), this.curLine;
  }
  flushBuffer(e = this.bufferMarks) {
    this.pendingBuffer && (this.curLine.append(Xo(new Kl(-1), e), e.length), this.pendingBuffer = 0);
  }
  addBlockWidget(e) {
    this.flushBuffer(), this.curLine = null, this.content.push(e);
  }
  finish(e) {
    this.pendingBuffer && e <= this.bufferMarks.length ? this.flushBuffer() : this.pendingBuffer = 0, this.posCovered() || this.getLine();
  }
  buildText(e, t, l) {
    for (; e > 0; ) {
      if (this.textOff == this.text.length) {
        let { value: o, lineBreak: n, done: s } = this.cursor.next(this.skip);
        if (this.skip = 0, s)
          throw new Error("Ran out of text content when drawing inline views");
        if (n) {
          this.posCovered() || this.getLine(), this.content.length ? this.content[this.content.length - 1].breakAfter = 1 : this.breakAtStart = 1, this.flushBuffer(), this.curLine = null, this.atCursorPos = !0, e--;
          continue;
        } else
          this.text = o, this.textOff = 0;
      }
      let i = Math.min(
        this.text.length - this.textOff,
        e,
        512
        /* T.Chunk */
      );
      this.flushBuffer(t.slice(t.length - l)), this.getLine().append(Xo(new Ur(this.text.slice(this.textOff, this.textOff + i)), t), l), this.atCursorPos = !0, this.textOff += i, e -= i, l = 0;
    }
  }
  span(e, t, l, i) {
    this.buildText(t - e, l, i), this.pos = t, this.openStart < 0 && (this.openStart = i);
  }
  point(e, t, l, i, o, n) {
    if (this.disallowBlockEffectsFor[n] && l instanceof vl) {
      if (l.block)
        throw new RangeError("Block decorations may not be specified via plugins");
      if (t > this.doc.lineAt(this.pos).to)
        throw new RangeError("Decorations that replace line breaks may not be specified via plugins");
    }
    let s = t - e;
    if (l instanceof vl)
      if (l.block) {
        let { type: a } = l;
        a == _e.WidgetAfter && !this.posCovered() && this.getLine(), this.addBlockWidget(new gl(l.widget || new gp("div"), s, a));
      } else {
        let a = Cr.create(l.widget || new gp("span"), s, s ? 0 : l.startSide), c = this.atCursorPos && !a.isEditable && o <= i.length && (e < t || l.startSide > 0), d = !a.isEditable && (e < t || o > i.length || l.startSide <= 0), h = this.getLine();
        this.pendingBuffer == 2 && !c && (this.pendingBuffer = 0), this.flushBuffer(i), c && (h.append(Xo(new Kl(1), i), o), o = i.length + Math.max(0, o - i.length)), h.append(Xo(a, i), o), this.atCursorPos = d, this.pendingBuffer = d ? e < t || o > i.length ? 1 : 2 : 0, this.pendingBuffer && (this.bufferMarks = i.slice());
      }
    else
      this.doc.lineAt(this.pos).from == this.pos && this.getLine().addLineDeco(l);
    s && (this.textOff + s <= this.text.length ? this.textOff += s : (this.skip += s - (this.text.length - this.textOff), this.text = "", this.textOff = 0), this.pos = t), this.openStart < 0 && (this.openStart = o);
  }
  static build(e, t, l, i, o) {
    let n = new zd(e, t, l, o);
    return n.openEnd = ge.spans(i, t, l, n), n.openStart < 0 && (n.openStart = n.openEnd), n.finish(n.openEnd), n;
  }
}
function Xo(r, e) {
  for (let t of e)
    r = new lr(t, [r], r.length);
  return r;
}
class gp extends br {
  constructor(e) {
    super(), this.tag = e;
  }
  eq(e) {
    return e.tag == this.tag;
  }
  toDOM() {
    return document.createElement(this.tag);
  }
  updateDOM(e) {
    return e.nodeName.toLowerCase() == this.tag;
  }
}
const fm = /* @__PURE__ */ Y.define(), gm = /* @__PURE__ */ Y.define(), mm = /* @__PURE__ */ Y.define(), bm = /* @__PURE__ */ Y.define(), xc = /* @__PURE__ */ Y.define(), Om = /* @__PURE__ */ Y.define(), vm = /* @__PURE__ */ Y.define({
  combine: (r) => r.some((e) => e)
}), xm = /* @__PURE__ */ Y.define({
  combine: (r) => r.some((e) => e)
});
class En {
  constructor(e, t = "nearest", l = "nearest", i = 5, o = 5) {
    this.range = e, this.y = t, this.x = l, this.yMargin = i, this.xMargin = o;
  }
  map(e) {
    return e.empty ? this : new En(this.range.map(e), this.y, this.x, this.yMargin, this.xMargin);
  }
}
const mp = /* @__PURE__ */ le.define({ map: (r, e) => r.map(e) });
function yt(r, e, t) {
  let l = r.facet(bm);
  l.length ? l[0](e) : window.onerror ? window.onerror(String(e), t, void 0, void 0, e) : t ? console.error(t + ":", e) : console.error(e);
}
const Ps = /* @__PURE__ */ Y.define({ combine: (r) => r.length ? r[0] : !0 });
let yw = 0;
const yi = /* @__PURE__ */ Y.define();
class Ze {
  constructor(e, t, l, i) {
    this.id = e, this.create = t, this.domEventHandlers = l, this.extension = i(this);
  }
  /**
  Define a plugin from a constructor function that creates the
  plugin's value, given an editor view.
  */
  static define(e, t) {
    const { eventHandlers: l, provide: i, decorations: o } = t || {};
    return new Ze(yw++, e, l, (n) => {
      let s = [yi.of(n)];
      return o && s.push(Li.of((a) => {
        let c = a.plugin(n);
        return c ? o(c) : B.none;
      })), i && s.push(i(n)), s;
    });
  }
  /**
  Create a plugin for a class whose constructor takes a single
  editor view as argument.
  */
  static fromClass(e, t) {
    return Ze.define((l) => new e(l), t);
  }
}
class ra {
  constructor(e) {
    this.spec = e, this.mustUpdate = null, this.value = null;
  }
  update(e) {
    if (this.value) {
      if (this.mustUpdate) {
        let t = this.mustUpdate;
        if (this.mustUpdate = null, this.value.update)
          try {
            this.value.update(t);
          } catch (l) {
            if (yt(t.state, l, "CodeMirror plugin crashed"), this.value.destroy)
              try {
                this.value.destroy();
              } catch {
              }
            this.deactivate();
          }
      }
    } else if (this.spec)
      try {
        this.value = this.spec.create(e);
      } catch (t) {
        yt(e.state, t, "CodeMirror plugin crashed"), this.deactivate();
      }
    return this;
  }
  destroy(e) {
    var t;
    if (!((t = this.value) === null || t === void 0) && t.destroy)
      try {
        this.value.destroy();
      } catch (l) {
        yt(e.state, l, "CodeMirror plugin crashed");
      }
  }
  deactivate() {
    this.spec = this.value = null;
  }
}
const _m = /* @__PURE__ */ Y.define(), Xd = /* @__PURE__ */ Y.define(), Li = /* @__PURE__ */ Y.define(), wm = /* @__PURE__ */ Y.define(), ym = /* @__PURE__ */ Y.define(), ki = /* @__PURE__ */ Y.define();
class rr {
  constructor(e, t, l, i) {
    this.fromA = e, this.toA = t, this.fromB = l, this.toB = i;
  }
  join(e) {
    return new rr(Math.min(this.fromA, e.fromA), Math.max(this.toA, e.toA), Math.min(this.fromB, e.fromB), Math.max(this.toB, e.toB));
  }
  addToSet(e) {
    let t = e.length, l = this;
    for (; t > 0; t--) {
      let i = e[t - 1];
      if (!(i.fromA > l.toA)) {
        if (i.toA < l.fromA)
          break;
        l = l.join(i), e.splice(t - 1, 1);
      }
    }
    return e.splice(t, 0, l), e;
  }
  static extendWithRanges(e, t) {
    if (t.length == 0)
      return e;
    let l = [];
    for (let i = 0, o = 0, n = 0, s = 0; ; i++) {
      let a = i == e.length ? null : e[i], c = n - s, d = a ? a.fromB : 1e9;
      for (; o < t.length && t[o] < d; ) {
        let h = t[o], p = t[o + 1], u = Math.max(s, h), f = Math.min(d, p);
        if (u <= f && new rr(u + c, f + c, u, f).addToSet(l), p > d)
          break;
        o += 2;
      }
      if (!a)
        return l;
      new rr(a.fromA, a.toA, a.fromB, a.toB).addToSet(l), n = a.toA, s = a.toB;
    }
  }
}
class Vn {
  constructor(e, t, l) {
    this.view = e, this.state = t, this.transactions = l, this.flags = 0, this.startState = e.state, this.changes = Re.empty(this.startState.doc.length);
    for (let n of l)
      this.changes = this.changes.compose(n.changes);
    let i = [];
    this.changes.iterChangedRanges((n, s, a, c) => i.push(new rr(n, s, a, c))), this.changedRanges = i;
    let o = e.hasFocus;
    o != e.inputState.notifiedFocused && (e.inputState.notifiedFocused = o, this.flags |= 1);
  }
  /**
  @internal
  */
  static create(e, t, l) {
    return new Vn(e, t, l);
  }
  /**
  Tells you whether the [viewport](https://codemirror.net/6/docs/ref/#view.EditorView.viewport) or
  [visible ranges](https://codemirror.net/6/docs/ref/#view.EditorView.visibleRanges) changed in this
  update.
  */
  get viewportChanged() {
    return (this.flags & 4) > 0;
  }
  /**
  Indicates whether the height of a block element in the editor
  changed in this update.
  */
  get heightChanged() {
    return (this.flags & 2) > 0;
  }
  /**
  Returns true when the document was modified or the size of the
  editor, or elements within the editor, changed.
  */
  get geometryChanged() {
    return this.docChanged || (this.flags & 10) > 0;
  }
  /**
  True when this update indicates a focus change.
  */
  get focusChanged() {
    return (this.flags & 1) > 0;
  }
  /**
  Whether the document changed in this update.
  */
  get docChanged() {
    return !this.changes.empty;
  }
  /**
  Whether the selection was explicitly set in this update.
  */
  get selectionSet() {
    return this.transactions.some((e) => e.selection);
  }
  /**
  @internal
  */
  get empty() {
    return this.flags == 0 && this.transactions.length == 0;
  }
}
var Ce = /* @__PURE__ */ function(r) {
  return r[r.LTR = 0] = "LTR", r[r.RTL = 1] = "RTL", r;
}(Ce || (Ce = {}));
const _c = Ce.LTR, kw = Ce.RTL;
function km(r) {
  let e = [];
  for (let t = 0; t < r.length; t++)
    e.push(1 << +r[t]);
  return e;
}
const Sw = /* @__PURE__ */ km("88888888888888888888888888888888888666888888787833333333337888888000000000000000000000000008888880000000000000000000000000088888888888888888888888888888888888887866668888088888663380888308888800000000000000000000000800000000000000000000000000000008"), Qw = /* @__PURE__ */ km("4444448826627288999999999992222222222222222222222222222222222222222222222229999999999999999999994444444444644222822222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222999999949999999229989999223333333333"), wc = /* @__PURE__ */ Object.create(null), jt = [];
for (let r of ["()", "[]", "{}"]) {
  let e = /* @__PURE__ */ r.charCodeAt(0), t = /* @__PURE__ */ r.charCodeAt(1);
  wc[e] = t, wc[t] = -e;
}
function $w(r) {
  return r <= 247 ? Sw[r] : 1424 <= r && r <= 1524 ? 2 : 1536 <= r && r <= 1785 ? Qw[r - 1536] : 1774 <= r && r <= 2220 ? 4 : 8192 <= r && r <= 8203 ? 256 : 64336 <= r && r <= 65023 ? 4 : r == 8204 ? 256 : 1;
}
const Pw = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac\ufb50-\ufdff]/;
class Ul {
  /**
  @internal
  */
  constructor(e, t, l) {
    this.from = e, this.to = t, this.level = l;
  }
  /**
  The direction of this span.
  */
  get dir() {
    return this.level % 2 ? kw : _c;
  }
  /**
  @internal
  */
  side(e, t) {
    return this.dir == t == e ? this.to : this.from;
  }
  /**
  @internal
  */
  static find(e, t, l, i) {
    let o = -1;
    for (let n = 0; n < e.length; n++) {
      let s = e[n];
      if (s.from <= t && s.to >= t) {
        if (s.level == l)
          return n;
        (o < 0 || (i != 0 ? i < 0 ? s.from < t : s.to > t : e[o].level > s.level)) && (o = n);
      }
    }
    if (o < 0)
      throw new RangeError("Index out of range");
    return o;
  }
}
const Pe = [];
function Cw(r, e) {
  let t = r.length, l = e == _c ? 1 : 2, i = e == _c ? 2 : 1;
  if (!r || l == 1 && !Pw.test(r))
    return Sm(t);
  for (let n = 0, s = l, a = l; n < t; n++) {
    let c = $w(r.charCodeAt(n));
    c == 512 ? c = s : c == 8 && a == 4 && (c = 16), Pe[n] = c == 4 ? 2 : c, c & 7 && (a = c), s = c;
  }
  for (let n = 0, s = l, a = l; n < t; n++) {
    let c = Pe[n];
    if (c == 128)
      n < t - 1 && s == Pe[n + 1] && s & 24 ? c = Pe[n] = s : Pe[n] = 256;
    else if (c == 64) {
      let d = n + 1;
      for (; d < t && Pe[d] == 64; )
        d++;
      let h = n && s == 8 || d < t && Pe[d] == 8 ? a == 1 ? 1 : 8 : 256;
      for (let p = n; p < d; p++)
        Pe[p] = h;
      n = d - 1;
    } else
      c == 8 && a == 1 && (Pe[n] = 1);
    s = c, c & 7 && (a = c);
  }
  for (let n = 0, s = 0, a = 0, c, d, h; n < t; n++)
    if (d = wc[c = r.charCodeAt(n)])
      if (d < 0) {
        for (let p = s - 3; p >= 0; p -= 3)
          if (jt[p + 1] == -d) {
            let u = jt[p + 2], f = u & 2 ? l : u & 4 ? u & 1 ? i : l : 0;
            f && (Pe[n] = Pe[jt[p]] = f), s = p;
            break;
          }
      } else {
        if (jt.length == 189)
          break;
        jt[s++] = n, jt[s++] = c, jt[s++] = a;
      }
    else if ((h = Pe[n]) == 2 || h == 1) {
      let p = h == l;
      a = p ? 0 : 1;
      for (let u = s - 3; u >= 0; u -= 3) {
        let f = jt[u + 2];
        if (f & 2)
          break;
        if (p)
          jt[u + 2] |= 2;
        else {
          if (f & 4)
            break;
          jt[u + 2] |= 4;
        }
      }
    }
  for (let n = 0; n < t; n++)
    if (Pe[n] == 256) {
      let s = n + 1;
      for (; s < t && Pe[s] == 256; )
        s++;
      let a = (n ? Pe[n - 1] : l) == 1, c = (s < t ? Pe[s] : l) == 1, d = a == c ? a ? 1 : 2 : l;
      for (let h = n; h < s; h++)
        Pe[h] = d;
      n = s - 1;
    }
  let o = [];
  if (l == 1)
    for (let n = 0; n < t; ) {
      let s = n, a = Pe[n++] != 1;
      for (; n < t && a == (Pe[n] != 1); )
        n++;
      if (a)
        for (let c = n; c > s; ) {
          let d = c, h = Pe[--c] != 2;
          for (; c > s && h == (Pe[c - 1] != 2); )
            c--;
          o.push(new Ul(c, d, h ? 2 : 1));
        }
      else
        o.push(new Ul(s, n, 0));
    }
  else
    for (let n = 0; n < t; ) {
      let s = n, a = Pe[n++] == 2;
      for (; n < t && a == (Pe[n] == 2); )
        n++;
      o.push(new Ul(s, n, a ? 1 : 2));
    }
  return o;
}
function Sm(r) {
  return [new Ul(0, r, 0)];
}
let Qm = "";
function Tw(r, e, t, l, i) {
  var o;
  let n = l.head - r.from, s = -1;
  if (n == 0) {
    if (!i || !r.length)
      return null;
    e[0].level != t && (n = e[0].side(!1, t), s = 0);
  } else if (n == r.length) {
    if (i)
      return null;
    let p = e[e.length - 1];
    p.level != t && (n = p.side(!0, t), s = e.length - 1);
  }
  s < 0 && (s = Ul.find(e, n, (o = l.bidiLevel) !== null && o !== void 0 ? o : -1, l.assoc));
  let a = e[s];
  n == a.side(i, t) && (a = e[s += i ? 1 : -1], n = a.side(!i, t));
  let c = i == (a.dir == t), d = nt(r.text, n, c);
  if (Qm = r.text.slice(Math.min(n, d), Math.max(n, d)), d != a.side(i, t))
    return w.cursor(d + r.from, c ? -1 : 1, a.level);
  let h = s == (i ? e.length - 1 : 0) ? null : e[s + (i ? 1 : -1)];
  return !h && a.level != t ? w.cursor(i ? r.to : r.from, i ? -1 : 1, t) : h && h.level < a.level ? w.cursor(h.side(!i, t) + r.from, i ? 1 : -1, h.level) : w.cursor(d + r.from, i ? -1 : 1, a.level);
}
const Tr = "￿";
class $m {
  constructor(e, t) {
    this.points = e, this.text = "", this.lineSeparator = t.facet(pe.lineSeparator);
  }
  append(e) {
    this.text += e;
  }
  lineBreak() {
    this.text += Tr;
  }
  readRange(e, t) {
    if (!e)
      return this;
    let l = e.parentNode;
    for (let i = e; ; ) {
      this.findPointBefore(l, i), this.readNode(i);
      let o = i.nextSibling;
      if (o == t)
        break;
      let n = ye.get(i), s = ye.get(o);
      (n && s ? n.breakAfter : (n ? n.breakAfter : bp(i)) || bp(o) && (i.nodeName != "BR" || i.cmIgnore)) && this.lineBreak(), i = o;
    }
    return this.findPointBefore(l, t), this;
  }
  readTextNode(e) {
    let t = e.nodeValue;
    for (let l of this.points)
      l.node == e && (l.pos = this.text.length + Math.min(l.offset, t.length));
    for (let l = 0, i = this.lineSeparator ? null : /\r\n?|\n/g; ; ) {
      let o = -1, n = 1, s;
      if (this.lineSeparator ? (o = t.indexOf(this.lineSeparator, l), n = this.lineSeparator.length) : (s = i.exec(t)) && (o = s.index, n = s[0].length), this.append(t.slice(l, o < 0 ? t.length : o)), o < 0)
        break;
      if (this.lineBreak(), n > 1)
        for (let a of this.points)
          a.node == e && a.pos > this.text.length && (a.pos -= n - 1);
      l = o + n;
    }
  }
  readNode(e) {
    if (e.cmIgnore)
      return;
    let t = ye.get(e), l = t && t.overrideDOMText;
    if (l != null) {
      this.findPointInside(e, l.length);
      for (let i = l.iter(); !i.next().done; )
        i.lineBreak ? this.lineBreak() : this.append(i.value);
    } else
      e.nodeType == 3 ? this.readTextNode(e) : e.nodeName == "BR" ? e.nextSibling && this.lineBreak() : e.nodeType == 1 && this.readRange(e.firstChild, null);
  }
  findPointBefore(e, t) {
    for (let l of this.points)
      l.node == e && e.childNodes[l.offset] == t && (l.pos = this.text.length);
  }
  findPointInside(e, t) {
    for (let l of this.points)
      (e.nodeType == 3 ? l.node == e : e.contains(l.node)) && (l.pos = this.text.length + Math.min(t, l.offset));
  }
}
function bp(r) {
  return r.nodeType == 1 && /^(DIV|P|LI|UL|OL|BLOCKQUOTE|DD|DT|H\d|SECTION|PRE)$/.test(r.nodeName);
}
class Op {
  constructor(e, t) {
    this.node = e, this.offset = t, this.pos = -1;
  }
}
class vp extends ye {
  constructor(e) {
    super(), this.view = e, this.compositionDeco = B.none, this.decorations = [], this.dynamicDecorationMap = [], this.minWidth = 0, this.minWidthFrom = 0, this.minWidthTo = 0, this.impreciseAnchor = null, this.impreciseHead = null, this.forceSelection = !1, this.lastUpdate = Date.now(), this.setDOM(e.contentDOM), this.children = [new st()], this.children[0].setParent(this), this.updateDeco(), this.updateInner([new rr(0, 0, 0, e.state.doc.length)], 0);
  }
  get editorView() {
    return this.view;
  }
  get length() {
    return this.view.state.doc.length;
  }
  // Update the document view to a given state. scrollIntoView can be
  // used as a hint to compute a new viewport that includes that
  // position, if we know the editor is going to scroll that position
  // into view.
  update(e) {
    let t = e.changedRanges;
    this.minWidth > 0 && t.length && (t.every(({ fromA: n, toA: s }) => s < this.minWidthFrom || n > this.minWidthTo) ? (this.minWidthFrom = e.changes.mapPos(this.minWidthFrom, 1), this.minWidthTo = e.changes.mapPos(this.minWidthTo, 1)) : this.minWidth = this.minWidthFrom = this.minWidthTo = 0), this.view.inputState.composing < 0 ? this.compositionDeco = B.none : (e.transactions.length || this.dirty) && (this.compositionDeco = Xw(this.view, e.changes)), (M.ie || M.chrome) && !this.compositionDeco.size && e && e.state.doc.lines != e.startState.doc.lines && (this.forceSelection = !0);
    let l = this.decorations, i = this.updateDeco(), o = Zw(l, i, e.changes);
    return t = rr.extendWithRanges(t, o), this.dirty == 0 && t.length == 0 ? !1 : (this.updateInner(t, e.startState.doc.length), e.transactions.length && (this.lastUpdate = Date.now()), !0);
  }
  // Used by update and the constructor do perform the actual DOM
  // update
  updateInner(e, t) {
    this.view.viewState.mustMeasureContent = !0, this.updateChildren(e, t);
    let { observer: l } = this.view;
    l.ignore(() => {
      this.dom.style.height = this.view.viewState.contentHeight + "px", this.dom.style.flexBasis = this.minWidth ? this.minWidth + "px" : "";
      let o = M.chrome || M.ios ? { node: l.selectionRange.focusNode, written: !1 } : void 0;
      this.sync(o), this.dirty = 0, o && (o.written || l.selectionRange.focusNode != o.node) && (this.forceSelection = !0), this.dom.style.height = "";
    });
    let i = [];
    if (this.view.viewport.from || this.view.viewport.to < this.view.state.doc.length)
      for (let o of this.children)
        o instanceof gl && o.widget instanceof xp && i.push(o.dom);
    l.updateGaps(i);
  }
  updateChildren(e, t) {
    let l = this.childCursor(t);
    for (let i = e.length - 1; ; i--) {
      let o = i >= 0 ? e[i] : null;
      if (!o)
        break;
      let { fromA: n, toA: s, fromB: a, toB: c } = o, { content: d, breakAtStart: h, openStart: p, openEnd: u } = zd.build(this.view.state.doc, a, c, this.decorations, this.dynamicDecorationMap), { i: f, off: m } = l.findPos(s, 1), { i: O, off: x } = l.findPos(n, -1);
      im(this, O, x, f, m, d, h, p, u);
    }
  }
  // Sync the DOM selection to this.state.selection
  updateSelection(e = !1, t = !1) {
    if ((e || !this.view.observer.selectionRange.focusNode) && this.view.observer.readSelectionRange(), !(t || this.mayControlSelection()))
      return;
    let l = this.forceSelection;
    this.forceSelection = !1;
    let i = this.view.state.selection.main, o = this.domAtPos(i.anchor), n = i.empty ? o : this.domAtPos(i.head);
    if (M.gecko && i.empty && zw(o)) {
      let a = document.createTextNode("");
      this.view.observer.ignore(() => o.node.insertBefore(a, o.node.childNodes[o.offset] || null)), o = n = new Ke(a, 0), l = !0;
    }
    let s = this.view.observer.selectionRange;
    (l || !s.focusNode || !Xn(o.node, o.offset, s.anchorNode, s.anchorOffset) || !Xn(n.node, n.offset, s.focusNode, s.focusOffset)) && (this.view.observer.ignore(() => {
      M.android && M.chrome && this.dom.contains(s.focusNode) && Rw(s.focusNode, this.dom) && (this.dom.blur(), this.dom.focus({ preventScroll: !0 }));
      let a = zn(this.view.root);
      if (a)
        if (i.empty) {
          if (M.gecko) {
            let c = Ew(o.node, o.offset);
            if (c && c != 3) {
              let d = Cm(o.node, o.offset, c == 1 ? 1 : -1);
              d && (o = new Ke(d, c == 1 ? 0 : d.nodeValue.length));
            }
          }
          a.collapse(o.node, o.offset), i.bidiLevel != null && s.cursorBidiLevel != null && (s.cursorBidiLevel = i.bidiLevel);
        } else if (a.extend) {
          a.collapse(o.node, o.offset);
          try {
            a.extend(n.node, n.offset);
          } catch {
          }
        } else {
          let c = document.createRange();
          i.anchor > i.head && ([o, n] = [n, o]), c.setEnd(n.node, n.offset), c.setStart(o.node, o.offset), a.removeAllRanges(), a.addRange(c);
        }
    }), this.view.observer.setSelectionRange(o, n)), this.impreciseAnchor = o.precise ? null : new Ke(s.anchorNode, s.anchorOffset), this.impreciseHead = n.precise ? null : new Ke(s.focusNode, s.focusOffset);
  }
  enforceCursorAssoc() {
    if (this.compositionDeco.size)
      return;
    let { view: e } = this, t = e.state.selection.main, l = zn(e.root), { anchorNode: i, anchorOffset: o } = e.observer.selectionRange;
    if (!l || !t.empty || !t.assoc || !l.modify)
      return;
    let n = st.find(this, t.head);
    if (!n)
      return;
    let s = n.posAtStart;
    if (t.head == s || t.head == s + n.length)
      return;
    let a = this.coordsAt(t.head, -1), c = this.coordsAt(t.head, 1);
    if (!a || !c || a.bottom > c.top)
      return;
    let d = this.domAtPos(t.head + t.assoc);
    l.collapse(d.node, d.offset), l.modify("move", t.assoc < 0 ? "forward" : "backward", "lineboundary"), e.observer.readSelectionRange();
    let h = e.observer.selectionRange;
    e.docView.posFromDOM(h.anchorNode, h.anchorOffset) != t.from && l.collapse(i, o);
  }
  mayControlSelection() {
    let e = this.view.root.activeElement;
    return e == this.dom || cn(this.dom, this.view.observer.selectionRange) && !(e && this.dom.contains(e));
  }
  nearest(e) {
    for (let t = e; t; ) {
      let l = ye.get(t);
      if (l && l.rootView == this)
        return l;
      t = t.parentNode;
    }
    return null;
  }
  posFromDOM(e, t) {
    let l = this.nearest(e);
    if (!l)
      throw new RangeError("Trying to find position for a DOM position outside of the document");
    return l.localPosFromDOM(e, t) + l.posAtStart;
  }
  domAtPos(e) {
    let { i: t, off: l } = this.childCursor().findPos(e, -1);
    for (; t < this.children.length - 1; ) {
      let i = this.children[t];
      if (l < i.length || i instanceof st)
        break;
      t++, l = 0;
    }
    return this.children[t].domAtPos(l);
  }
  coordsAt(e, t) {
    for (let l = this.length, i = this.children.length - 1; ; i--) {
      let o = this.children[i], n = l - o.breakAfter - o.length;
      if (e > n || e == n && o.type != _e.WidgetBefore && o.type != _e.WidgetAfter && (!i || t == 2 || this.children[i - 1].breakAfter || this.children[i - 1].type == _e.WidgetBefore && t > -2))
        return o.coordsAt(e - n, t);
      l = n;
    }
  }
  measureVisibleLineHeights(e) {
    let t = [], { from: l, to: i } = e, o = this.view.contentDOM.clientWidth, n = o > Math.max(this.view.scrollDOM.clientWidth, this.minWidth) + 1, s = -1, a = this.view.textDirection == Ce.LTR;
    for (let c = 0, d = 0; d < this.children.length; d++) {
      let h = this.children[d], p = c + h.length;
      if (p > i)
        break;
      if (c >= l) {
        let u = h.dom.getBoundingClientRect();
        if (t.push(u.height), n) {
          let f = h.dom.lastChild, m = f ? qi(f) : [];
          if (m.length) {
            let O = m[m.length - 1], x = a ? O.right - u.left : u.right - O.left;
            x > s && (s = x, this.minWidth = o, this.minWidthFrom = c, this.minWidthTo = p);
          }
        }
      }
      c = p + h.breakAfter;
    }
    return t;
  }
  textDirectionAt(e) {
    let { i: t } = this.childPos(e, 1);
    return getComputedStyle(this.children[t].dom).direction == "rtl" ? Ce.RTL : Ce.LTR;
  }
  measureTextSize() {
    for (let i of this.children)
      if (i instanceof st) {
        let o = i.measureTextSize();
        if (o)
          return o;
      }
    let e = document.createElement("div"), t, l;
    return e.className = "cm-line", e.style.width = "99999px", e.textContent = "abc def ghi jkl mno pqr stu", this.view.observer.ignore(() => {
      this.dom.appendChild(e);
      let i = qi(e.firstChild)[0];
      t = e.getBoundingClientRect().height, l = i ? i.width / 27 : 7, e.remove();
    }), { lineHeight: t, charWidth: l };
  }
  childCursor(e = this.length) {
    let t = this.children.length;
    return t && (e -= this.children[--t].length), new lm(this.children, e, t);
  }
  computeBlockGapDeco() {
    let e = [], t = this.view.viewState;
    for (let l = 0, i = 0; ; i++) {
      let o = i == t.viewports.length ? null : t.viewports[i], n = o ? o.from - 1 : this.length;
      if (n > l) {
        let s = t.lineBlockAt(n).bottom - t.lineBlockAt(l).top;
        e.push(B.replace({
          widget: new xp(s),
          block: !0,
          inclusive: !0,
          isBlockGap: !0
        }).range(l, n));
      }
      if (!o)
        break;
      l = o.to + 1;
    }
    return B.set(e);
  }
  updateDeco() {
    let e = this.view.state.facet(Li).map((t, l) => (this.dynamicDecorationMap[l] = typeof t == "function") ? t(this.view) : t);
    for (let t = e.length; t < e.length + 3; t++)
      this.dynamicDecorationMap[t] = !1;
    return this.decorations = [
      ...e,
      this.compositionDeco,
      this.computeBlockGapDeco(),
      this.view.viewState.lineGapDeco
    ];
  }
  scrollIntoView(e) {
    let { range: t } = e, l = this.coordsAt(t.head, t.empty ? t.assoc : t.head > t.anchor ? -1 : 1), i;
    if (!l)
      return;
    !t.empty && (i = this.coordsAt(t.anchor, t.anchor > t.head ? -1 : 1)) && (l = {
      left: Math.min(l.left, i.left),
      top: Math.min(l.top, i.top),
      right: Math.max(l.right, i.right),
      bottom: Math.max(l.bottom, i.bottom)
    });
    let o = 0, n = 0, s = 0, a = 0;
    for (let d of this.view.state.facet(ym).map((h) => h(this.view)))
      if (d) {
        let { left: h, right: p, top: u, bottom: f } = d;
        h != null && (o = Math.max(o, h)), p != null && (n = Math.max(n, p)), u != null && (s = Math.max(s, u)), f != null && (a = Math.max(a, f));
      }
    let c = {
      left: l.left - o,
      top: l.top - s,
      right: l.right + n,
      bottom: l.bottom + a
    };
    fw(this.view.scrollDOM, c, t.head < t.anchor ? -1 : 1, e.x, e.y, e.xMargin, e.yMargin, this.view.textDirection == Ce.LTR);
  }
}
function zw(r) {
  return r.node.nodeType == 1 && r.node.firstChild && (r.offset == 0 || r.node.childNodes[r.offset - 1].contentEditable == "false") && (r.offset == r.node.childNodes.length || r.node.childNodes[r.offset].contentEditable == "false");
}
class xp extends br {
  constructor(e) {
    super(), this.height = e;
  }
  toDOM() {
    let e = document.createElement("div");
    return this.updateDOM(e), e;
  }
  eq(e) {
    return e.height == this.height;
  }
  updateDOM(e) {
    return e.style.height = this.height + "px", !0;
  }
  get estimatedHeight() {
    return this.height;
  }
}
function Pm(r) {
  let e = r.observer.selectionRange, t = e.focusNode && Cm(e.focusNode, e.focusOffset, 0);
  if (!t)
    return null;
  let l = r.docView.nearest(t);
  if (!l)
    return null;
  if (l instanceof st) {
    let i = t;
    for (; i.parentNode != l.dom; )
      i = i.parentNode;
    let o = i.previousSibling;
    for (; o && !ye.get(o); )
      o = o.previousSibling;
    let n = o ? ye.get(o).posAtEnd : l.posAtStart;
    return { from: n, to: n, node: i, text: t };
  } else {
    for (; ; ) {
      let { parent: o } = l;
      if (!o)
        return null;
      if (o instanceof st)
        break;
      l = o;
    }
    let i = l.posAtStart;
    return { from: i, to: i + l.length, node: l.dom, text: t };
  }
}
function Xw(r, e) {
  let t = Pm(r);
  if (!t)
    return B.none;
  let { from: l, to: i, node: o, text: n } = t, s = e.mapPos(l, 1), a = Math.max(s, e.mapPos(i, -1)), { state: c } = r, d = o.nodeType == 3 ? o.nodeValue : new $m([], c).readRange(o.firstChild, null).text;
  if (a - s < d.length)
    if (c.doc.sliceString(s, Math.min(c.doc.length, s + d.length), Tr) == d)
      a = s + d.length;
    else if (c.doc.sliceString(Math.max(0, a - d.length), a, Tr) == d)
      s = a - d.length;
    else
      return B.none;
  else if (c.doc.sliceString(s, a, Tr) != d)
    return B.none;
  let h = ye.get(o);
  return h instanceof am ? h = h.widget.topView : h && (h.parent = null), B.set(B.replace({ widget: new Aw(o, n, h), inclusive: !0 }).range(s, a));
}
class Aw extends br {
  constructor(e, t, l) {
    super(), this.top = e, this.text = t, this.topView = l;
  }
  eq(e) {
    return this.top == e.top && this.text == e.text;
  }
  toDOM() {
    return this.top;
  }
  ignoreEvent() {
    return !1;
  }
  get customView() {
    return am;
  }
}
function Cm(r, e, t) {
  for (; ; ) {
    if (r.nodeType == 3)
      return r;
    if (r.nodeType == 1 && e > 0 && t <= 0)
      r = r.childNodes[e - 1], e = Bi(r);
    else if (r.nodeType == 1 && e < r.childNodes.length && t >= 0)
      r = r.childNodes[e], e = 0;
    else
      return null;
  }
}
function Ew(r, e) {
  return r.nodeType != 1 ? 0 : (e && r.childNodes[e - 1].contentEditable == "false" ? 1 : 0) | (e < r.childNodes.length && r.childNodes[e].contentEditable == "false" ? 2 : 0);
}
class Vw {
  constructor() {
    this.changes = [];
  }
  compareRange(e, t) {
    vc(e, t, this.changes);
  }
  comparePoint(e, t) {
    vc(e, t, this.changes);
  }
}
function Zw(r, e, t) {
  let l = new Vw();
  return ge.compare(r, e, t, l), l.changes;
}
function Rw(r, e) {
  for (let t = r; t && t != e; t = t.assignedSlot || t.parentNode)
    if (t.nodeType == 1 && t.contentEditable == "false")
      return !0;
  return !1;
}
function Dw(r, e, t = 1) {
  let l = r.charCategorizer(e), i = r.doc.lineAt(e), o = e - i.from;
  if (i.length == 0)
    return w.cursor(e);
  o == 0 ? t = 1 : o == i.length && (t = -1);
  let n = o, s = o;
  t < 0 ? n = nt(i.text, o, !1) : s = nt(i.text, o);
  let a = l(i.text.slice(n, s));
  for (; n > 0; ) {
    let c = nt(i.text, n, !1);
    if (l(i.text.slice(c, n)) != a)
      break;
    n = c;
  }
  for (; s < i.length; ) {
    let c = nt(i.text, s);
    if (l(i.text.slice(s, c)) != a)
      break;
    s = c;
  }
  return w.range(n + i.from, s + i.from);
}
function Ww(r, e) {
  return e.left > r ? e.left - r : Math.max(0, r - e.right);
}
function Nw(r, e) {
  return e.top > r ? e.top - r : Math.max(0, r - e.bottom);
}
function la(r, e) {
  return r.top < e.bottom - 1 && r.bottom > e.top + 1;
}
function _p(r, e) {
  return e < r.top ? { top: e, left: r.left, right: r.right, bottom: r.bottom } : r;
}
function wp(r, e) {
  return e > r.bottom ? { top: r.top, left: r.left, right: r.right, bottom: e } : r;
}
function yc(r, e, t) {
  let l, i, o, n, s = !1, a, c, d, h;
  for (let f = r.firstChild; f; f = f.nextSibling) {
    let m = qi(f);
    for (let O = 0; O < m.length; O++) {
      let x = m[O];
      i && la(i, x) && (x = _p(wp(x, i.bottom), i.top));
      let Q = Ww(e, x), P = Nw(t, x);
      if (Q == 0 && P == 0)
        return f.nodeType == 3 ? yp(f, e, t) : yc(f, e, t);
      if (!l || n > P || n == P && o > Q) {
        l = f, i = x, o = Q, n = P;
        let y = P ? t < x.top ? -1 : 1 : Q ? e < x.left ? -1 : 1 : 0;
        s = !y || (y > 0 ? O < m.length - 1 : O > 0);
      }
      Q == 0 ? t > x.bottom && (!d || d.bottom < x.bottom) ? (a = f, d = x) : t < x.top && (!h || h.top > x.top) && (c = f, h = x) : d && la(d, x) ? d = wp(d, x.bottom) : h && la(h, x) && (h = _p(h, x.top));
    }
  }
  if (d && d.bottom >= t ? (l = a, i = d) : h && h.top <= t && (l = c, i = h), !l)
    return { node: r, offset: 0 };
  let p = Math.max(i.left, Math.min(i.right, e));
  if (l.nodeType == 3)
    return yp(l, p, t);
  if (s && l.contentEditable != "false")
    return yc(l, p, t);
  let u = Array.prototype.indexOf.call(r.childNodes, l) + (e >= (i.left + i.right) / 2 ? 1 : 0);
  return { node: r, offset: u };
}
function yp(r, e, t) {
  let l = r.nodeValue.length, i = -1, o = 1e9, n = 0;
  for (let s = 0; s < l; s++) {
    let a = Hl(r, s, s + 1).getClientRects();
    for (let c = 0; c < a.length; c++) {
      let d = a[c];
      if (d.top == d.bottom)
        continue;
      n || (n = e - d.left);
      let h = (d.top > t ? d.top - t : t - d.bottom) - 1;
      if (d.left - 1 <= e && d.right + 1 >= e && h < o) {
        let p = e >= (d.left + d.right) / 2, u = p;
        if ((M.chrome || M.gecko) && Hl(r, s).getBoundingClientRect().left == d.right && (u = !p), h <= 0)
          return { node: r, offset: s + (u ? 1 : 0) };
        i = s + (u ? 1 : 0), o = h;
      }
    }
  }
  return { node: r, offset: i > -1 ? i : n > 0 ? r.nodeValue.length : 0 };
}
function Tm(r, { x: e, y: t }, l, i = -1) {
  var o;
  let n = r.contentDOM.getBoundingClientRect(), s = n.top + r.viewState.paddingTop, a, { docHeight: c } = r.viewState, d = t - s;
  if (d < 0)
    return 0;
  if (d > c)
    return r.state.doc.length;
  for (let x = r.defaultLineHeight / 2, Q = !1; a = r.elementAtHeight(d), a.type != _e.Text; )
    for (; d = i > 0 ? a.bottom + x : a.top - x, !(d >= 0 && d <= c); ) {
      if (Q)
        return l ? null : 0;
      Q = !0, i = -i;
    }
  t = s + d;
  let h = a.from;
  if (h < r.viewport.from)
    return r.viewport.from == 0 ? 0 : l ? null : kp(r, n, a, e, t);
  if (h > r.viewport.to)
    return r.viewport.to == r.state.doc.length ? r.state.doc.length : l ? null : kp(r, n, a, e, t);
  let p = r.dom.ownerDocument, u = r.root.elementFromPoint ? r.root : p, f = u.elementFromPoint(e, t);
  f && !r.contentDOM.contains(f) && (f = null), f || (e = Math.max(n.left + 1, Math.min(n.right - 1, e)), f = u.elementFromPoint(e, t), f && !r.contentDOM.contains(f) && (f = null));
  let m, O = -1;
  if (f && ((o = r.docView.nearest(f)) === null || o === void 0 ? void 0 : o.isEditable) != !1) {
    if (p.caretPositionFromPoint) {
      let x = p.caretPositionFromPoint(e, t);
      x && ({ offsetNode: m, offset: O } = x);
    } else if (p.caretRangeFromPoint) {
      let x = p.caretRangeFromPoint(e, t);
      x && ({ startContainer: m, startOffset: O } = x, (!r.contentDOM.contains(m) || M.safari && Mw(m, O, e) || M.chrome && Yw(m, O, e)) && (m = void 0));
    }
  }
  if (!m || !r.docView.dom.contains(m)) {
    let x = st.find(r.docView, h);
    if (!x)
      return d > a.top + a.height / 2 ? a.to : a.from;
    ({ node: m, offset: O } = yc(x.dom, e, t));
  }
  return r.docView.posFromDOM(m, O);
}
function kp(r, e, t, l, i) {
  let o = Math.round((l - e.left) * r.defaultCharacterWidth);
  if (r.lineWrapping && t.height > r.defaultLineHeight * 1.5) {
    let s = Math.floor((i - t.top) / r.defaultLineHeight);
    o += s * r.viewState.heightOracle.lineLength;
  }
  let n = r.state.sliceDoc(t.from, t.to);
  return t.from + cc(n, o, r.state.tabSize);
}
function Mw(r, e, t) {
  let l;
  if (r.nodeType != 3 || e != (l = r.nodeValue.length))
    return !1;
  for (let i = r.nextSibling; i; i = i.nextSibling)
    if (i.nodeType != 1 || i.nodeName != "BR")
      return !1;
  return Hl(r, l - 1, l).getBoundingClientRect().left > t;
}
function Yw(r, e, t) {
  if (e != 0)
    return !1;
  for (let i = r; ; ) {
    let o = i.parentNode;
    if (!o || o.nodeType != 1 || o.firstChild != i)
      return !1;
    if (o.classList.contains("cm-line"))
      break;
    i = o;
  }
  let l = r.nodeType == 1 ? r.getBoundingClientRect() : Hl(r, 0, Math.max(r.nodeValue.length, 1)).getBoundingClientRect();
  return t - l.left > 5;
}
function jw(r, e, t, l) {
  let i = r.state.doc.lineAt(e.head), o = !l || !r.lineWrapping ? null : r.coordsAtPos(e.assoc < 0 && e.head > i.from ? e.head - 1 : e.head);
  if (o) {
    let a = r.dom.getBoundingClientRect(), c = r.textDirectionAt(i.from), d = r.posAtCoords({
      x: t == (c == Ce.LTR) ? a.right - 1 : a.left + 1,
      y: (o.top + o.bottom) / 2
    });
    if (d != null)
      return w.cursor(d, t ? -1 : 1);
  }
  let n = st.find(r.docView, e.head), s = n ? t ? n.posAtEnd : n.posAtStart : t ? i.to : i.from;
  return w.cursor(s, t ? -1 : 1);
}
function Sp(r, e, t, l) {
  let i = r.state.doc.lineAt(e.head), o = r.bidiSpans(i), n = r.textDirectionAt(i.from);
  for (let s = e, a = null; ; ) {
    let c = Tw(i, o, n, s, t), d = Qm;
    if (!c) {
      if (i.number == (t ? r.state.doc.lines : 1))
        return s;
      d = `
`, i = r.state.doc.line(i.number + (t ? 1 : -1)), o = r.bidiSpans(i), c = w.cursor(t ? i.from : i.to);
    }
    if (a) {
      if (!a(d))
        return s;
    } else {
      if (!l)
        return c;
      a = l(d);
    }
    s = c;
  }
}
function Iw(r, e, t) {
  let l = r.state.charCategorizer(e), i = l(t);
  return (o) => {
    let n = l(o);
    return i == Qe.Space && (i = n), i == n;
  };
}
function Uw(r, e, t, l) {
  let i = e.head, o = t ? 1 : -1;
  if (i == (t ? r.state.doc.length : 0))
    return w.cursor(i, e.assoc);
  let n = e.goalColumn, s, a = r.contentDOM.getBoundingClientRect(), c = r.coordsAtPos(i), d = r.documentTop;
  if (c)
    n == null && (n = c.left - a.left), s = o < 0 ? c.top : c.bottom;
  else {
    let u = r.viewState.lineBlockAt(i);
    n == null && (n = Math.min(a.right - a.left, r.defaultCharacterWidth * (i - u.from))), s = (o < 0 ? u.top : u.bottom) + d;
  }
  let h = a.left + n, p = l ?? r.defaultLineHeight >> 1;
  for (let u = 0; ; u += 10) {
    let f = s + (p + u) * o, m = Tm(r, { x: h, y: f }, !1, o);
    if (f < a.top || f > a.bottom || (o < 0 ? m < i : m > i))
      return w.cursor(m, e.assoc, void 0, n);
  }
}
function ia(r, e, t) {
  let l = r.state.facet(wm).map((i) => i(r));
  for (; ; ) {
    let i = !1;
    for (let o of l)
      o.between(t.from - 1, t.from + 1, (n, s, a) => {
        t.from > n && t.from < s && (t = e.head > t.from ? w.cursor(n, 1) : w.cursor(s, -1), i = !0);
      });
    if (!i)
      return t;
  }
}
class qw {
  constructor(e) {
    this.lastKeyCode = 0, this.lastKeyTime = 0, this.lastTouchTime = 0, this.lastFocusTime = 0, this.lastScrollTop = 0, this.lastScrollLeft = 0, this.chromeScrollHack = -1, this.pendingIOSKey = void 0, this.lastSelectionOrigin = null, this.lastSelectionTime = 0, this.lastEscPress = 0, this.lastContextMenu = 0, this.scrollHandlers = [], this.registeredEvents = [], this.customHandlers = [], this.composing = -1, this.compositionFirstChange = null, this.compositionEndedAt = 0, this.mouseSelection = null;
    let t = (l, i) => {
      this.ignoreDuringComposition(i) || i.type == "keydown" && this.keydown(e, i) || (this.mustFlushObserver(i) && e.observer.forceFlush(), this.runCustomHandlers(i.type, e, i) ? i.preventDefault() : l(e, i));
    };
    for (let l in Ne) {
      let i = Ne[l];
      e.contentDOM.addEventListener(l, (o) => {
        Qp(e, o) && t(i, o);
      }, kc[l]), this.registeredEvents.push(l);
    }
    e.scrollDOM.addEventListener("mousedown", (l) => {
      l.target == e.scrollDOM && t(Ne.mousedown, l);
    }), M.chrome && M.chrome_version == 102 && e.scrollDOM.addEventListener("wheel", () => {
      this.chromeScrollHack < 0 ? e.contentDOM.style.pointerEvents = "none" : window.clearTimeout(this.chromeScrollHack), this.chromeScrollHack = setTimeout(() => {
        this.chromeScrollHack = -1, e.contentDOM.style.pointerEvents = "";
      }, 100);
    }, { passive: !0 }), this.notifiedFocused = e.hasFocus, M.safari && e.contentDOM.addEventListener("input", () => null);
  }
  setSelectionOrigin(e) {
    this.lastSelectionOrigin = e, this.lastSelectionTime = Date.now();
  }
  ensureHandlers(e, t) {
    var l;
    let i;
    this.customHandlers = [];
    for (let o of t)
      if (i = (l = o.update(e).spec) === null || l === void 0 ? void 0 : l.domEventHandlers) {
        this.customHandlers.push({ plugin: o.value, handlers: i });
        for (let n in i)
          this.registeredEvents.indexOf(n) < 0 && n != "scroll" && (this.registeredEvents.push(n), e.contentDOM.addEventListener(n, (s) => {
            Qp(e, s) && this.runCustomHandlers(n, e, s) && s.preventDefault();
          }));
      }
  }
  runCustomHandlers(e, t, l) {
    for (let i of this.customHandlers) {
      let o = i.handlers[e];
      if (o)
        try {
          if (o.call(i.plugin, l, t) || l.defaultPrevented)
            return !0;
        } catch (n) {
          yt(t.state, n);
        }
    }
    return !1;
  }
  runScrollHandlers(e, t) {
    this.lastScrollTop = e.scrollDOM.scrollTop, this.lastScrollLeft = e.scrollDOM.scrollLeft;
    for (let l of this.customHandlers) {
      let i = l.handlers.scroll;
      if (i)
        try {
          i.call(l.plugin, t, e);
        } catch (o) {
          yt(e.state, o);
        }
    }
  }
  keydown(e, t) {
    if (this.lastKeyCode = t.keyCode, this.lastKeyTime = Date.now(), t.keyCode == 9 && Date.now() < this.lastEscPress + 2e3)
      return !0;
    if (M.android && M.chrome && !t.synthetic && (t.keyCode == 13 || t.keyCode == 8))
      return e.observer.delayAndroidKey(t.key, t.keyCode), !0;
    let l;
    return M.ios && !t.synthetic && !t.altKey && !t.metaKey && ((l = zm.find((i) => i.keyCode == t.keyCode)) && !t.ctrlKey || Bw.indexOf(t.key) > -1 && t.ctrlKey && !t.shiftKey) ? (this.pendingIOSKey = l || t, setTimeout(() => this.flushIOSKey(e), 250), !0) : !1;
  }
  flushIOSKey(e) {
    let t = this.pendingIOSKey;
    return t ? (this.pendingIOSKey = void 0, Il(e.contentDOM, t.key, t.keyCode)) : !1;
  }
  ignoreDuringComposition(e) {
    return /^key/.test(e.type) ? this.composing > 0 ? !0 : M.safari && !M.ios && Date.now() - this.compositionEndedAt < 100 ? (this.compositionEndedAt = 0, !0) : !1 : !1;
  }
  mustFlushObserver(e) {
    return e.type == "keydown" && e.keyCode != 229;
  }
  startMouseSelection(e) {
    this.mouseSelection && this.mouseSelection.destroy(), this.mouseSelection = e;
  }
  update(e) {
    this.mouseSelection && this.mouseSelection.update(e), e.transactions.length && (this.lastKeyCode = this.lastSelectionTime = 0);
  }
  destroy() {
    this.mouseSelection && this.mouseSelection.destroy();
  }
}
const zm = [
  { key: "Backspace", keyCode: 8, inputType: "deleteContentBackward" },
  { key: "Enter", keyCode: 13, inputType: "insertParagraph" },
  { key: "Delete", keyCode: 46, inputType: "deleteContentForward" }
], Bw = "dthko", Xm = [16, 17, 18, 20, 91, 92, 224, 225];
function Ao(r) {
  return r * 0.7 + 8;
}
class Lw {
  constructor(e, t, l, i) {
    this.view = e, this.style = l, this.mustSelect = i, this.scrollSpeed = { x: 0, y: 0 }, this.scrolling = -1, this.lastEvent = t, this.scrollParent = gw(e.contentDOM);
    let o = e.contentDOM.ownerDocument;
    o.addEventListener("mousemove", this.move = this.move.bind(this)), o.addEventListener("mouseup", this.up = this.up.bind(this)), this.extend = t.shiftKey, this.multiple = e.state.facet(pe.allowMultipleSelections) && Gw(e, t), this.dragMove = Fw(e, t), this.dragging = Hw(e, t) && Zm(t) == 1 ? null : !1, this.dragging === !1 && (t.preventDefault(), this.select(t));
  }
  move(e) {
    var t;
    if (e.buttons == 0)
      return this.destroy();
    if (this.dragging !== !1)
      return;
    this.select(this.lastEvent = e);
    let l = 0, i = 0, o = ((t = this.scrollParent) === null || t === void 0 ? void 0 : t.getBoundingClientRect()) || { left: 0, top: 0, right: this.view.win.innerWidth, bottom: this.view.win.innerHeight };
    e.clientX <= o.left ? l = -Ao(o.left - e.clientX) : e.clientX >= o.right && (l = Ao(e.clientX - o.right)), e.clientY <= o.top ? i = -Ao(o.top - e.clientY) : e.clientY >= o.bottom && (i = Ao(e.clientY - o.bottom)), this.setScrollSpeed(l, i);
  }
  up(e) {
    this.dragging == null && this.select(this.lastEvent), this.dragging || e.preventDefault(), this.destroy();
  }
  destroy() {
    this.setScrollSpeed(0, 0);
    let e = this.view.contentDOM.ownerDocument;
    e.removeEventListener("mousemove", this.move), e.removeEventListener("mouseup", this.up), this.view.inputState.mouseSelection = null;
  }
  setScrollSpeed(e, t) {
    this.scrollSpeed = { x: e, y: t }, e || t ? this.scrolling < 0 && (this.scrolling = setInterval(() => this.scroll(), 50)) : this.scrolling > -1 && (clearInterval(this.scrolling), this.scrolling = -1);
  }
  scroll() {
    this.scrollParent ? (this.scrollParent.scrollLeft += this.scrollSpeed.x, this.scrollParent.scrollTop += this.scrollSpeed.y) : this.view.win.scrollBy(this.scrollSpeed.x, this.scrollSpeed.y), this.dragging === !1 && this.select(this.lastEvent);
  }
  select(e) {
    let t = this.style.get(e, this.extend, this.multiple);
    (this.mustSelect || !t.eq(this.view.state.selection) || t.main.assoc != this.view.state.selection.main.assoc) && this.view.dispatch({
      selection: t,
      userEvent: "select.pointer"
    }), this.mustSelect = !1;
  }
  update(e) {
    e.docChanged && this.dragging && (this.dragging = this.dragging.map(e.changes)), this.style.update(e) && setTimeout(() => this.select(this.lastEvent), 20);
  }
}
function Gw(r, e) {
  let t = r.state.facet(fm);
  return t.length ? t[0](e) : M.mac ? e.metaKey : e.ctrlKey;
}
function Fw(r, e) {
  let t = r.state.facet(gm);
  return t.length ? t[0](e) : M.mac ? !e.altKey : !e.ctrlKey;
}
function Hw(r, e) {
  let { main: t } = r.state.selection;
  if (t.empty)
    return !1;
  let l = zn(r.root);
  if (!l || l.rangeCount == 0)
    return !0;
  let i = l.getRangeAt(0).getClientRects();
  for (let o = 0; o < i.length; o++) {
    let n = i[o];
    if (n.left <= e.clientX && n.right >= e.clientX && n.top <= e.clientY && n.bottom >= e.clientY)
      return !0;
  }
  return !1;
}
function Qp(r, e) {
  if (!e.bubbles)
    return !0;
  if (e.defaultPrevented)
    return !1;
  for (let t = e.target, l; t != r.contentDOM; t = t.parentNode)
    if (!t || t.nodeType == 11 || (l = ye.get(t)) && l.ignoreEvent(e))
      return !1;
  return !0;
}
const Ne = /* @__PURE__ */ Object.create(null), kc = /* @__PURE__ */ Object.create(null), Am = M.ie && M.ie_version < 15 || M.ios && M.webkit_version < 604;
function Kw(r) {
  let e = r.dom.parentNode;
  if (!e)
    return;
  let t = e.appendChild(document.createElement("textarea"));
  t.style.cssText = "position: fixed; left: -10000px; top: 10px", t.focus(), setTimeout(() => {
    r.focus(), t.remove(), Em(r, t.value);
  }, 50);
}
function Em(r, e) {
  let { state: t } = r, l, i = 1, o = t.toText(e), n = o.lines == t.selection.ranges.length;
  if (Sc != null && t.selection.ranges.every((a) => a.empty) && Sc == o.toString()) {
    let a = -1;
    l = t.changeByRange((c) => {
      let d = t.doc.lineAt(c.from);
      if (d.from == a)
        return { range: c };
      a = d.from;
      let h = t.toText((n ? o.line(i++).text : e) + t.lineBreak);
      return {
        changes: { from: d.from, insert: h },
        range: w.cursor(c.from + h.length)
      };
    });
  } else
    n ? l = t.changeByRange((a) => {
      let c = o.line(i++);
      return {
        changes: { from: a.from, to: a.to, insert: c.text },
        range: w.cursor(a.from + c.length)
      };
    }) : l = t.replaceSelection(o);
  r.dispatch(l, {
    userEvent: "input.paste",
    scrollIntoView: !0
  });
}
Ne.keydown = (r, e) => {
  r.inputState.setSelectionOrigin("select"), e.keyCode == 27 ? r.inputState.lastEscPress = Date.now() : Xm.indexOf(e.keyCode) < 0 && (r.inputState.lastEscPress = 0);
};
Ne.touchstart = (r, e) => {
  r.inputState.lastTouchTime = Date.now(), r.inputState.setSelectionOrigin("select.pointer");
};
Ne.touchmove = (r) => {
  r.inputState.setSelectionOrigin("select.pointer");
};
kc.touchstart = kc.touchmove = { passive: !0 };
Ne.mousedown = (r, e) => {
  if (r.observer.flush(), r.inputState.lastTouchTime > Date.now() - 2e3)
    return;
  let t = null;
  for (let l of r.state.facet(mm))
    if (t = l(r, e), t)
      break;
  if (!t && e.button == 0 && (t = ty(r, e)), t) {
    let l = r.root.activeElement != r.contentDOM;
    l && r.observer.ignore(() => tm(r.contentDOM)), r.inputState.startMouseSelection(new Lw(r, e, t, l));
  }
};
function $p(r, e, t, l) {
  if (l == 1)
    return w.cursor(e, t);
  if (l == 2)
    return Dw(r.state, e, t);
  {
    let i = st.find(r.docView, e), o = r.state.doc.lineAt(i ? i.posAtEnd : e), n = i ? i.posAtStart : o.from, s = i ? i.posAtEnd : o.to;
    return s < r.state.doc.length && s == o.to && s++, w.range(n, s);
  }
}
let Vm = (r, e) => r >= e.top && r <= e.bottom, Pp = (r, e, t) => Vm(e, t) && r >= t.left && r <= t.right;
function Jw(r, e, t, l) {
  let i = st.find(r.docView, e);
  if (!i)
    return 1;
  let o = e - i.posAtStart;
  if (o == 0)
    return 1;
  if (o == i.length)
    return -1;
  let n = i.coordsAt(o, -1);
  if (n && Pp(t, l, n))
    return -1;
  let s = i.coordsAt(o, 1);
  return s && Pp(t, l, s) ? 1 : n && Vm(l, n) ? -1 : 1;
}
function Cp(r, e) {
  let t = r.posAtCoords({ x: e.clientX, y: e.clientY }, !1);
  return { pos: t, bias: Jw(r, t, e.clientX, e.clientY) };
}
const ey = M.ie && M.ie_version <= 11;
let Tp = null, zp = 0, Xp = 0;
function Zm(r) {
  if (!ey)
    return r.detail;
  let e = Tp, t = Xp;
  return Tp = r, Xp = Date.now(), zp = !e || t > Date.now() - 400 && Math.abs(e.clientX - r.clientX) < 2 && Math.abs(e.clientY - r.clientY) < 2 ? (zp + 1) % 3 : 1;
}
function ty(r, e) {
  let t = Cp(r, e), l = Zm(e), i = r.state.selection;
  return {
    update(o) {
      o.docChanged && (t.pos = o.changes.mapPos(t.pos), i = i.map(o.changes));
    },
    get(o, n, s) {
      let a = Cp(r, o), c = $p(r, a.pos, a.bias, l);
      if (t.pos != a.pos && !n) {
        let d = $p(r, t.pos, t.bias, l), h = Math.min(d.from, c.from), p = Math.max(d.to, c.to);
        c = h < c.from ? w.range(h, p) : w.range(p, h);
      }
      return n ? i.replaceRange(i.main.extend(c.from, c.to)) : s && i.ranges.length > 1 && i.ranges.some((d) => d.eq(c)) ? ry(i, c) : s ? i.addRange(c) : w.create([c]);
    }
  };
}
function ry(r, e) {
  for (let t = 0; ; t++)
    if (r.ranges[t].eq(e))
      return w.create(r.ranges.slice(0, t).concat(r.ranges.slice(t + 1)), r.mainIndex == t ? 0 : r.mainIndex - (r.mainIndex > t ? 1 : 0));
}
Ne.dragstart = (r, e) => {
  let { selection: { main: t } } = r.state, { mouseSelection: l } = r.inputState;
  l && (l.dragging = t), e.dataTransfer && (e.dataTransfer.setData("Text", r.state.sliceDoc(t.from, t.to)), e.dataTransfer.effectAllowed = "copyMove");
};
function Ap(r, e, t, l) {
  if (!t)
    return;
  let i = r.posAtCoords({ x: e.clientX, y: e.clientY }, !1);
  e.preventDefault();
  let { mouseSelection: o } = r.inputState, n = l && o && o.dragging && o.dragMove ? { from: o.dragging.from, to: o.dragging.to } : null, s = { from: i, insert: t }, a = r.state.changes(n ? [n, s] : s);
  r.focus(), r.dispatch({
    changes: a,
    selection: { anchor: a.mapPos(i, -1), head: a.mapPos(i, 1) },
    userEvent: n ? "move.drop" : "input.drop"
  });
}
Ne.drop = (r, e) => {
  if (!e.dataTransfer)
    return;
  if (r.state.readOnly)
    return e.preventDefault();
  let t = e.dataTransfer.files;
  if (t && t.length) {
    e.preventDefault();
    let l = Array(t.length), i = 0, o = () => {
      ++i == t.length && Ap(r, e, l.filter((n) => n != null).join(r.state.lineBreak), !1);
    };
    for (let n = 0; n < t.length; n++) {
      let s = new FileReader();
      s.onerror = o, s.onload = () => {
        /[\x00-\x08\x0e-\x1f]{2}/.test(s.result) || (l[n] = s.result), o();
      }, s.readAsText(t[n]);
    }
  } else
    Ap(r, e, e.dataTransfer.getData("Text"), !0);
};
Ne.paste = (r, e) => {
  if (r.state.readOnly)
    return e.preventDefault();
  r.observer.flush();
  let t = Am ? null : e.clipboardData;
  t ? (Em(r, t.getData("text/plain")), e.preventDefault()) : Kw(r);
};
function ly(r, e) {
  let t = r.dom.parentNode;
  if (!t)
    return;
  let l = t.appendChild(document.createElement("textarea"));
  l.style.cssText = "position: fixed; left: -10000px; top: 10px", l.value = e, l.focus(), l.selectionEnd = e.length, l.selectionStart = 0, setTimeout(() => {
    l.remove(), r.focus();
  }, 50);
}
function iy(r) {
  let e = [], t = [], l = !1;
  for (let i of r.selection.ranges)
    i.empty || (e.push(r.sliceDoc(i.from, i.to)), t.push(i));
  if (!e.length) {
    let i = -1;
    for (let { from: o } of r.selection.ranges) {
      let n = r.doc.lineAt(o);
      n.number > i && (e.push(n.text), t.push({ from: n.from, to: Math.min(r.doc.length, n.to + 1) })), i = n.number;
    }
    l = !0;
  }
  return { text: e.join(r.lineBreak), ranges: t, linewise: l };
}
let Sc = null;
Ne.copy = Ne.cut = (r, e) => {
  let { text: t, ranges: l, linewise: i } = iy(r.state);
  if (!t && !i)
    return;
  Sc = i ? t : null;
  let o = Am ? null : e.clipboardData;
  o ? (e.preventDefault(), o.clearData(), o.setData("text/plain", t)) : ly(r, t), e.type == "cut" && !r.state.readOnly && r.dispatch({
    changes: l,
    scrollIntoView: !0,
    userEvent: "delete.cut"
  });
};
function Rm(r) {
  setTimeout(() => {
    r.hasFocus != r.inputState.notifiedFocused && r.update([]);
  }, 10);
}
Ne.focus = (r) => {
  r.inputState.lastFocusTime = Date.now(), !r.scrollDOM.scrollTop && (r.inputState.lastScrollTop || r.inputState.lastScrollLeft) && (r.scrollDOM.scrollTop = r.inputState.lastScrollTop, r.scrollDOM.scrollLeft = r.inputState.lastScrollLeft), Rm(r);
};
Ne.blur = (r) => {
  r.observer.clearSelectionRange(), Rm(r);
};
Ne.compositionstart = Ne.compositionupdate = (r) => {
  r.inputState.compositionFirstChange == null && (r.inputState.compositionFirstChange = !0), r.inputState.composing < 0 && (r.inputState.composing = 0);
};
Ne.compositionend = (r) => {
  r.inputState.composing = -1, r.inputState.compositionEndedAt = Date.now(), r.inputState.compositionFirstChange = null, M.chrome && M.android && r.observer.flushSoon(), setTimeout(() => {
    r.inputState.composing < 0 && r.docView.compositionDeco.size && r.update([]);
  }, 50);
};
Ne.contextmenu = (r) => {
  r.inputState.lastContextMenu = Date.now();
};
Ne.beforeinput = (r, e) => {
  var t;
  let l;
  if (M.chrome && M.android && (l = zm.find((i) => i.inputType == e.inputType)) && (r.observer.delayAndroidKey(l.key, l.keyCode), l.key == "Backspace" || l.key == "Delete")) {
    let i = ((t = window.visualViewport) === null || t === void 0 ? void 0 : t.height) || 0;
    setTimeout(() => {
      var o;
      (((o = window.visualViewport) === null || o === void 0 ? void 0 : o.height) || 0) > i + 10 && r.hasFocus && (r.contentDOM.blur(), r.focus());
    }, 100);
  }
};
const Ep = ["pre-wrap", "normal", "pre-line", "break-spaces"];
class oy {
  constructor(e) {
    this.lineWrapping = e, this.doc = ue.empty, this.heightSamples = {}, this.lineHeight = 14, this.charWidth = 7, this.lineLength = 30, this.heightChanged = !1;
  }
  heightForGap(e, t) {
    let l = this.doc.lineAt(t).number - this.doc.lineAt(e).number + 1;
    return this.lineWrapping && (l += Math.ceil((t - e - l * this.lineLength * 0.5) / this.lineLength)), this.lineHeight * l;
  }
  heightForLine(e) {
    return this.lineWrapping ? (1 + Math.max(0, Math.ceil((e - this.lineLength) / (this.lineLength - 5)))) * this.lineHeight : this.lineHeight;
  }
  setDoc(e) {
    return this.doc = e, this;
  }
  mustRefreshForWrapping(e) {
    return Ep.indexOf(e) > -1 != this.lineWrapping;
  }
  mustRefreshForHeights(e) {
    let t = !1;
    for (let l = 0; l < e.length; l++) {
      let i = e[l];
      i < 0 ? l++ : this.heightSamples[Math.floor(i * 10)] || (t = !0, this.heightSamples[Math.floor(i * 10)] = !0);
    }
    return t;
  }
  refresh(e, t, l, i, o) {
    let n = Ep.indexOf(e) > -1, s = Math.round(t) != Math.round(this.lineHeight) || this.lineWrapping != n;
    if (this.lineWrapping = n, this.lineHeight = t, this.charWidth = l, this.lineLength = i, s) {
      this.heightSamples = {};
      for (let a = 0; a < o.length; a++) {
        let c = o[a];
        c < 0 ? a++ : this.heightSamples[Math.floor(c * 10)] = !0;
      }
    }
    return s;
  }
}
class ny {
  constructor(e, t) {
    this.from = e, this.heights = t, this.index = 0;
  }
  get more() {
    return this.index < this.heights.length;
  }
}
class zr {
  /**
  @internal
  */
  constructor(e, t, l, i, o) {
    this.from = e, this.length = t, this.top = l, this.height = i, this.type = o;
  }
  /**
  The end of the element as a document position.
  */
  get to() {
    return this.from + this.length;
  }
  /**
  The bottom position of the element.
  */
  get bottom() {
    return this.top + this.height;
  }
  /**
  @internal
  */
  join(e) {
    let t = (Array.isArray(this.type) ? this.type : [this]).concat(Array.isArray(e.type) ? e.type : [e]);
    return new zr(this.from, this.length + e.length, this.top, this.height + e.height, t);
  }
}
var we = /* @__PURE__ */ function(r) {
  return r[r.ByPos = 0] = "ByPos", r[r.ByHeight = 1] = "ByHeight", r[r.ByPosNoHeight = 2] = "ByPosNoHeight", r;
}(we || (we = {}));
const dn = 1e-3;
class at {
  constructor(e, t, l = 2) {
    this.length = e, this.height = t, this.flags = l;
  }
  get outdated() {
    return (this.flags & 2) > 0;
  }
  set outdated(e) {
    this.flags = (e ? 2 : 0) | this.flags & -3;
  }
  setHeight(e, t) {
    this.height != t && (Math.abs(this.height - t) > dn && (e.heightChanged = !0), this.height = t);
  }
  // Base case is to replace a leaf node, which simply builds a tree
  // from the new nodes and returns that (HeightMapBranch and
  // HeightMapGap override this to actually use from/to)
  replace(e, t, l) {
    return at.of(l);
  }
  // Again, these are base cases, and are overridden for branch and gap nodes.
  decomposeLeft(e, t) {
    t.push(this);
  }
  decomposeRight(e, t) {
    t.push(this);
  }
  applyChanges(e, t, l, i) {
    let o = this;
    for (let n = i.length - 1; n >= 0; n--) {
      let { fromA: s, toA: a, fromB: c, toB: d } = i[n], h = o.lineAt(s, we.ByPosNoHeight, t, 0, 0), p = h.to >= a ? h : o.lineAt(a, we.ByPosNoHeight, t, 0, 0);
      for (d += p.to - a, a = p.to; n > 0 && h.from <= i[n - 1].toA; )
        s = i[n - 1].fromA, c = i[n - 1].fromB, n--, s < h.from && (h = o.lineAt(s, we.ByPosNoHeight, t, 0, 0));
      c += h.from - s, s = h.from;
      let u = Ad.build(l, e, c, d);
      o = o.replace(s, a, u);
    }
    return o.updateHeight(l, 0);
  }
  static empty() {
    return new vt(0, 0);
  }
  // nodes uses null values to indicate the position of line breaks.
  // There are never line breaks at the start or end of the array, or
  // two line breaks next to each other, and the array isn't allowed
  // to be empty (same restrictions as return value from the builder).
  static of(e) {
    if (e.length == 1)
      return e[0];
    let t = 0, l = e.length, i = 0, o = 0;
    for (; ; )
      if (t == l)
        if (i > o * 2) {
          let s = e[t - 1];
          s.break ? e.splice(--t, 1, s.left, null, s.right) : e.splice(--t, 1, s.left, s.right), l += 1 + s.break, i -= s.size;
        } else if (o > i * 2) {
          let s = e[l];
          s.break ? e.splice(l, 1, s.left, null, s.right) : e.splice(l, 1, s.left, s.right), l += 2 + s.break, o -= s.size;
        } else
          break;
      else if (i < o) {
        let s = e[t++];
        s && (i += s.size);
      } else {
        let s = e[--l];
        s && (o += s.size);
      }
    let n = 0;
    return e[t - 1] == null ? (n = 1, t--) : e[t] == null && (n = 1, l++), new sy(at.of(e.slice(0, t)), n, at.of(e.slice(l)));
  }
}
at.prototype.size = 1;
class Dm extends at {
  constructor(e, t, l) {
    super(e, t), this.type = l;
  }
  blockAt(e, t, l, i) {
    return new zr(i, this.length, l, this.height, this.type);
  }
  lineAt(e, t, l, i, o) {
    return this.blockAt(0, l, i, o);
  }
  forEachLine(e, t, l, i, o, n) {
    e <= o + this.length && t >= o && n(this.blockAt(0, l, i, o));
  }
  updateHeight(e, t = 0, l = !1, i) {
    return i && i.from <= t && i.more && this.setHeight(e, i.heights[i.index++]), this.outdated = !1, this;
  }
  toString() {
    return `block(${this.length})`;
  }
}
class vt extends Dm {
  constructor(e, t) {
    super(e, t, _e.Text), this.collapsed = 0, this.widgetHeight = 0;
  }
  replace(e, t, l) {
    let i = l[0];
    return l.length == 1 && (i instanceof vt || i instanceof qe && i.flags & 4) && Math.abs(this.length - i.length) < 10 ? (i instanceof qe ? i = new vt(i.length, this.height) : i.height = this.height, this.outdated || (i.outdated = !1), i) : at.of(l);
  }
  updateHeight(e, t = 0, l = !1, i) {
    return i && i.from <= t && i.more ? this.setHeight(e, i.heights[i.index++]) : (l || this.outdated) && this.setHeight(e, Math.max(this.widgetHeight, e.heightForLine(this.length - this.collapsed))), this.outdated = !1, this;
  }
  toString() {
    return `line(${this.length}${this.collapsed ? -this.collapsed : ""}${this.widgetHeight ? ":" + this.widgetHeight : ""})`;
  }
}
class qe extends at {
  constructor(e) {
    super(e, 0);
  }
  lines(e, t) {
    let l = e.lineAt(t).number, i = e.lineAt(t + this.length).number;
    return { firstLine: l, lastLine: i, lineHeight: this.height / (i - l + 1) };
  }
  blockAt(e, t, l, i) {
    let { firstLine: o, lastLine: n, lineHeight: s } = this.lines(t, i), a = Math.max(0, Math.min(n - o, Math.floor((e - l) / s))), { from: c, length: d } = t.line(o + a);
    return new zr(c, d, l + s * a, s, _e.Text);
  }
  lineAt(e, t, l, i, o) {
    if (t == we.ByHeight)
      return this.blockAt(e, l, i, o);
    if (t == we.ByPosNoHeight) {
      let { from: h, to: p } = l.lineAt(e);
      return new zr(h, p - h, 0, 0, _e.Text);
    }
    let { firstLine: n, lineHeight: s } = this.lines(l, o), { from: a, length: c, number: d } = l.lineAt(e);
    return new zr(a, c, i + s * (d - n), s, _e.Text);
  }
  forEachLine(e, t, l, i, o, n) {
    let { firstLine: s, lineHeight: a } = this.lines(l, o);
    for (let c = Math.max(e, o), d = Math.min(o + this.length, t); c <= d; ) {
      let h = l.lineAt(c);
      c == e && (i += a * (h.number - s)), n(new zr(h.from, h.length, i, a, _e.Text)), i += a, c = h.to + 1;
    }
  }
  replace(e, t, l) {
    let i = this.length - t;
    if (i > 0) {
      let o = l[l.length - 1];
      o instanceof qe ? l[l.length - 1] = new qe(o.length + i) : l.push(null, new qe(i - 1));
    }
    if (e > 0) {
      let o = l[0];
      o instanceof qe ? l[0] = new qe(e + o.length) : l.unshift(new qe(e - 1), null);
    }
    return at.of(l);
  }
  decomposeLeft(e, t) {
    t.push(new qe(e - 1), null);
  }
  decomposeRight(e, t) {
    t.push(null, new qe(this.length - e - 1));
  }
  updateHeight(e, t = 0, l = !1, i) {
    let o = t + this.length;
    if (i && i.from <= t + this.length && i.more) {
      let n = [], s = Math.max(t, i.from), a = -1, c = e.heightChanged;
      for (i.from > t && n.push(new qe(i.from - t - 1).updateHeight(e, t)); s <= o && i.more; ) {
        let h = e.doc.lineAt(s).length;
        n.length && n.push(null);
        let p = i.heights[i.index++];
        a == -1 ? a = p : Math.abs(p - a) >= dn && (a = -2);
        let u = new vt(h, p);
        u.outdated = !1, n.push(u), s += h + 1;
      }
      s <= o && n.push(null, new qe(o - s).updateHeight(e, s));
      let d = at.of(n);
      return e.heightChanged = c || a < 0 || Math.abs(d.height - this.height) >= dn || Math.abs(a - this.lines(e.doc, t).lineHeight) >= dn, d;
    } else
      (l || this.outdated) && (this.setHeight(e, e.heightForGap(t, t + this.length)), this.outdated = !1);
    return this;
  }
  toString() {
    return `gap(${this.length})`;
  }
}
class sy extends at {
  constructor(e, t, l) {
    super(e.length + t + l.length, e.height + l.height, t | (e.outdated || l.outdated ? 2 : 0)), this.left = e, this.right = l, this.size = e.size + l.size;
  }
  get break() {
    return this.flags & 1;
  }
  blockAt(e, t, l, i) {
    let o = l + this.left.height;
    return e < o ? this.left.blockAt(e, t, l, i) : this.right.blockAt(e, t, o, i + this.left.length + this.break);
  }
  lineAt(e, t, l, i, o) {
    let n = i + this.left.height, s = o + this.left.length + this.break, a = t == we.ByHeight ? e < n : e < s, c = a ? this.left.lineAt(e, t, l, i, o) : this.right.lineAt(e, t, l, n, s);
    if (this.break || (a ? c.to < s : c.from > s))
      return c;
    let d = t == we.ByPosNoHeight ? we.ByPosNoHeight : we.ByPos;
    return a ? c.join(this.right.lineAt(s, d, l, n, s)) : this.left.lineAt(s, d, l, i, o).join(c);
  }
  forEachLine(e, t, l, i, o, n) {
    let s = i + this.left.height, a = o + this.left.length + this.break;
    if (this.break)
      e < a && this.left.forEachLine(e, t, l, i, o, n), t >= a && this.right.forEachLine(e, t, l, s, a, n);
    else {
      let c = this.lineAt(a, we.ByPos, l, i, o);
      e < c.from && this.left.forEachLine(e, c.from - 1, l, i, o, n), c.to >= e && c.from <= t && n(c), t > c.to && this.right.forEachLine(c.to + 1, t, l, s, a, n);
    }
  }
  replace(e, t, l) {
    let i = this.left.length + this.break;
    if (t < i)
      return this.balanced(this.left.replace(e, t, l), this.right);
    if (e > this.left.length)
      return this.balanced(this.left, this.right.replace(e - i, t - i, l));
    let o = [];
    e > 0 && this.decomposeLeft(e, o);
    let n = o.length;
    for (let s of l)
      o.push(s);
    if (e > 0 && Vp(o, n - 1), t < this.length) {
      let s = o.length;
      this.decomposeRight(t, o), Vp(o, s);
    }
    return at.of(o);
  }
  decomposeLeft(e, t) {
    let l = this.left.length;
    if (e <= l)
      return this.left.decomposeLeft(e, t);
    t.push(this.left), this.break && (l++, e >= l && t.push(null)), e > l && this.right.decomposeLeft(e - l, t);
  }
  decomposeRight(e, t) {
    let l = this.left.length, i = l + this.break;
    if (e >= i)
      return this.right.decomposeRight(e - i, t);
    e < l && this.left.decomposeRight(e, t), this.break && e < i && t.push(null), t.push(this.right);
  }
  balanced(e, t) {
    return e.size > 2 * t.size || t.size > 2 * e.size ? at.of(this.break ? [e, null, t] : [e, t]) : (this.left = e, this.right = t, this.height = e.height + t.height, this.outdated = e.outdated || t.outdated, this.size = e.size + t.size, this.length = e.length + this.break + t.length, this);
  }
  updateHeight(e, t = 0, l = !1, i) {
    let { left: o, right: n } = this, s = t + o.length + this.break, a = null;
    return i && i.from <= t + o.length && i.more ? a = o = o.updateHeight(e, t, l, i) : o.updateHeight(e, t, l), i && i.from <= s + n.length && i.more ? a = n = n.updateHeight(e, s, l, i) : n.updateHeight(e, s, l), a ? this.balanced(o, n) : (this.height = this.left.height + this.right.height, this.outdated = !1, this);
  }
  toString() {
    return this.left + (this.break ? " " : "-") + this.right;
  }
}
function Vp(r, e) {
  let t, l;
  r[e] == null && (t = r[e - 1]) instanceof qe && (l = r[e + 1]) instanceof qe && r.splice(e - 1, 3, new qe(t.length + 1 + l.length));
}
const ay = 5;
class Ad {
  constructor(e, t) {
    this.pos = e, this.oracle = t, this.nodes = [], this.lineStart = -1, this.lineEnd = -1, this.covering = null, this.writtenTo = e;
  }
  get isCovered() {
    return this.covering && this.nodes[this.nodes.length - 1] == this.covering;
  }
  span(e, t) {
    if (this.lineStart > -1) {
      let l = Math.min(t, this.lineEnd), i = this.nodes[this.nodes.length - 1];
      i instanceof vt ? i.length += l - this.pos : (l > this.pos || !this.isCovered) && this.nodes.push(new vt(l - this.pos, -1)), this.writtenTo = l, t > l && (this.nodes.push(null), this.writtenTo++, this.lineStart = -1);
    }
    this.pos = t;
  }
  point(e, t, l) {
    if (e < t || l.heightRelevant) {
      let i = l.widget ? l.widget.estimatedHeight : 0;
      i < 0 && (i = this.oracle.lineHeight);
      let o = t - e;
      l.block ? this.addBlock(new Dm(o, i, l.type)) : (o || i >= ay) && this.addLineDeco(i, o);
    } else
      t > e && this.span(e, t);
    this.lineEnd > -1 && this.lineEnd < this.pos && (this.lineEnd = this.oracle.doc.lineAt(this.pos).to);
  }
  enterLine() {
    if (this.lineStart > -1)
      return;
    let { from: e, to: t } = this.oracle.doc.lineAt(this.pos);
    this.lineStart = e, this.lineEnd = t, this.writtenTo < e && ((this.writtenTo < e - 1 || this.nodes[this.nodes.length - 1] == null) && this.nodes.push(this.blankContent(this.writtenTo, e - 1)), this.nodes.push(null)), this.pos > e && this.nodes.push(new vt(this.pos - e, -1)), this.writtenTo = this.pos;
  }
  blankContent(e, t) {
    let l = new qe(t - e);
    return this.oracle.doc.lineAt(e).to == t && (l.flags |= 4), l;
  }
  ensureLine() {
    this.enterLine();
    let e = this.nodes.length ? this.nodes[this.nodes.length - 1] : null;
    if (e instanceof vt)
      return e;
    let t = new vt(0, -1);
    return this.nodes.push(t), t;
  }
  addBlock(e) {
    this.enterLine(), e.type == _e.WidgetAfter && !this.isCovered && this.ensureLine(), this.nodes.push(e), this.writtenTo = this.pos = this.pos + e.length, e.type != _e.WidgetBefore && (this.covering = e);
  }
  addLineDeco(e, t) {
    let l = this.ensureLine();
    l.length += t, l.collapsed += t, l.widgetHeight = Math.max(l.widgetHeight, e), this.writtenTo = this.pos = this.pos + t;
  }
  finish(e) {
    let t = this.nodes.length == 0 ? null : this.nodes[this.nodes.length - 1];
    this.lineStart > -1 && !(t instanceof vt) && !this.isCovered ? this.nodes.push(new vt(0, -1)) : (this.writtenTo < this.pos || t == null) && this.nodes.push(this.blankContent(this.writtenTo, this.pos));
    let l = e;
    for (let i of this.nodes)
      i instanceof vt && i.updateHeight(this.oracle, l), l += i ? i.length : 1;
    return this.nodes;
  }
  // Always called with a region that on both sides either stretches
  // to a line break or the end of the document.
  // The returned array uses null to indicate line breaks, but never
  // starts or ends in a line break, or has multiple line breaks next
  // to each other.
  static build(e, t, l, i) {
    let o = new Ad(l, e);
    return ge.spans(t, l, i, o, 0), o.finish(l);
  }
}
function cy(r, e, t) {
  let l = new dy();
  return ge.compare(r, e, t, l, 0), l.changes;
}
class dy {
  constructor() {
    this.changes = [];
  }
  compareRange() {
  }
  comparePoint(e, t, l, i) {
    (e < t || l && l.heightRelevant || i && i.heightRelevant) && vc(e, t, this.changes, 5);
  }
}
function hy(r, e) {
  let t = r.getBoundingClientRect(), l = r.ownerDocument, i = l.defaultView || window, o = Math.max(0, t.left), n = Math.min(i.innerWidth, t.right), s = Math.max(0, t.top), a = Math.min(i.innerHeight, t.bottom);
  for (let c = r.parentNode; c && c != l.body; )
    if (c.nodeType == 1) {
      let d = c, h = window.getComputedStyle(d);
      if ((d.scrollHeight > d.clientHeight || d.scrollWidth > d.clientWidth) && h.overflow != "visible") {
        let p = d.getBoundingClientRect();
        o = Math.max(o, p.left), n = Math.min(n, p.right), s = Math.max(s, p.top), a = c == r.parentNode ? p.bottom : Math.min(a, p.bottom);
      }
      c = h.position == "absolute" || h.position == "fixed" ? d.offsetParent : d.parentNode;
    } else if (c.nodeType == 11)
      c = c.host;
    else
      break;
  return {
    left: o - t.left,
    right: Math.max(o, n) - t.left,
    top: s - (t.top + e),
    bottom: Math.max(s, a) - (t.top + e)
  };
}
function py(r, e) {
  let t = r.getBoundingClientRect();
  return {
    left: 0,
    right: t.right - t.left,
    top: e,
    bottom: t.bottom - (t.top + e)
  };
}
class oa {
  constructor(e, t, l) {
    this.from = e, this.to = t, this.size = l;
  }
  static same(e, t) {
    if (e.length != t.length)
      return !1;
    for (let l = 0; l < e.length; l++) {
      let i = e[l], o = t[l];
      if (i.from != o.from || i.to != o.to || i.size != o.size)
        return !1;
    }
    return !0;
  }
  draw(e) {
    return B.replace({ widget: new uy(this.size, e) }).range(this.from, this.to);
  }
}
class uy extends br {
  constructor(e, t) {
    super(), this.size = e, this.vertical = t;
  }
  eq(e) {
    return e.size == this.size && e.vertical == this.vertical;
  }
  toDOM() {
    let e = document.createElement("div");
    return this.vertical ? e.style.height = this.size + "px" : (e.style.width = this.size + "px", e.style.height = "2px", e.style.display = "inline-block"), e;
  }
  get estimatedHeight() {
    return this.vertical ? this.size : -1;
  }
}
class Zp {
  constructor(e) {
    this.state = e, this.pixelViewport = { left: 0, right: window.innerWidth, top: 0, bottom: 0 }, this.inView = !0, this.paddingTop = 0, this.paddingBottom = 0, this.contentDOMWidth = 0, this.contentDOMHeight = 0, this.editorHeight = 0, this.editorWidth = 0, this.scaler = Rp, this.scrollTarget = null, this.printing = !1, this.mustMeasureContent = !0, this.defaultTextDirection = Ce.LTR, this.visibleRanges = [], this.mustEnforceCursorAssoc = !1;
    let t = e.facet(Xd).some((l) => typeof l != "function" && l.class == "cm-lineWrapping");
    this.heightOracle = new oy(t), this.stateDeco = e.facet(Li).filter((l) => typeof l != "function"), this.heightMap = at.empty().applyChanges(this.stateDeco, ue.empty, this.heightOracle.setDoc(e.doc), [new rr(0, 0, 0, e.doc.length)]), this.viewport = this.getViewport(0, null), this.updateViewportLines(), this.updateForViewport(), this.lineGaps = this.ensureLineGaps([]), this.lineGapDeco = B.set(this.lineGaps.map((l) => l.draw(!1))), this.computeVisibleRanges();
  }
  updateForViewport() {
    let e = [this.viewport], { main: t } = this.state.selection;
    for (let l = 0; l <= 1; l++) {
      let i = l ? t.head : t.anchor;
      if (!e.some(({ from: o, to: n }) => i >= o && i <= n)) {
        let { from: o, to: n } = this.lineBlockAt(i);
        e.push(new Eo(o, n));
      }
    }
    this.viewports = e.sort((l, i) => l.from - i.from), this.scaler = this.heightMap.height <= 7e6 ? Rp : new my(this.heightOracle.doc, this.heightMap, this.viewports);
  }
  updateViewportLines() {
    this.viewportLines = [], this.heightMap.forEachLine(this.viewport.from, this.viewport.to, this.state.doc, 0, 0, (e) => {
      this.viewportLines.push(this.scaler.scale == 1 ? e : Si(e, this.scaler));
    });
  }
  update(e, t = null) {
    this.state = e.state;
    let l = this.stateDeco;
    this.stateDeco = this.state.facet(Li).filter((c) => typeof c != "function");
    let i = e.changedRanges, o = rr.extendWithRanges(i, cy(l, this.stateDeco, e ? e.changes : Re.empty(this.state.doc.length))), n = this.heightMap.height;
    this.heightMap = this.heightMap.applyChanges(this.stateDeco, e.startState.doc, this.heightOracle.setDoc(this.state.doc), o), this.heightMap.height != n && (e.flags |= 2);
    let s = o.length ? this.mapViewport(this.viewport, e.changes) : this.viewport;
    (t && (t.range.head < s.from || t.range.head > s.to) || !this.viewportIsAppropriate(s)) && (s = this.getViewport(0, t));
    let a = !e.changes.empty || e.flags & 2 || s.from != this.viewport.from || s.to != this.viewport.to;
    this.viewport = s, this.updateForViewport(), a && this.updateViewportLines(), (this.lineGaps.length || this.viewport.to - this.viewport.from > 2e3 << 1) && this.updateLineGaps(this.ensureLineGaps(this.mapLineGaps(this.lineGaps, e.changes))), e.flags |= this.computeVisibleRanges(), t && (this.scrollTarget = t), !this.mustEnforceCursorAssoc && e.selectionSet && e.view.lineWrapping && e.state.selection.main.empty && e.state.selection.main.assoc && !e.state.facet(xm) && (this.mustEnforceCursorAssoc = !0);
  }
  measure(e) {
    let t = e.contentDOM, l = window.getComputedStyle(t), i = this.heightOracle, o = l.whiteSpace;
    this.defaultTextDirection = l.direction == "rtl" ? Ce.RTL : Ce.LTR;
    let n = this.heightOracle.mustRefreshForWrapping(o), s = n || this.mustMeasureContent || this.contentDOMHeight != t.clientHeight;
    this.contentDOMHeight = t.clientHeight, this.mustMeasureContent = !1;
    let a = 0, c = 0, d = parseInt(l.paddingTop) || 0, h = parseInt(l.paddingBottom) || 0;
    (this.paddingTop != d || this.paddingBottom != h) && (this.paddingTop = d, this.paddingBottom = h, a |= 10), this.editorWidth != e.scrollDOM.clientWidth && (i.lineWrapping && (s = !0), this.editorWidth = e.scrollDOM.clientWidth, a |= 8);
    let p = (this.printing ? py : hy)(t, this.paddingTop), u = p.top - this.pixelViewport.top, f = p.bottom - this.pixelViewport.bottom;
    this.pixelViewport = p;
    let m = this.pixelViewport.bottom > this.pixelViewport.top && this.pixelViewport.right > this.pixelViewport.left;
    if (m != this.inView && (this.inView = m, m && (s = !0)), !this.inView && !this.scrollTarget)
      return 0;
    let O = t.clientWidth;
    if ((this.contentDOMWidth != O || this.editorHeight != e.scrollDOM.clientHeight) && (this.contentDOMWidth = O, this.editorHeight = e.scrollDOM.clientHeight, a |= 8), s) {
      let Q = e.docView.measureVisibleLineHeights(this.viewport);
      if (i.mustRefreshForHeights(Q) && (n = !0), n || i.lineWrapping && Math.abs(O - this.contentDOMWidth) > i.charWidth) {
        let { lineHeight: P, charWidth: y } = e.docView.measureTextSize();
        n = P > 0 && i.refresh(o, P, y, O / y, Q), n && (e.docView.minWidth = 0, a |= 8);
      }
      u > 0 && f > 0 ? c = Math.max(u, f) : u < 0 && f < 0 && (c = Math.min(u, f)), i.heightChanged = !1;
      for (let P of this.viewports) {
        let y = P.from == this.viewport.from ? Q : e.docView.measureVisibleLineHeights(P);
        this.heightMap = (n ? at.empty().applyChanges(this.stateDeco, ue.empty, this.heightOracle, [new rr(0, 0, 0, e.state.doc.length)]) : this.heightMap).updateHeight(i, 0, n, new ny(P.from, y));
      }
      i.heightChanged && (a |= 2);
    }
    let x = !this.viewportIsAppropriate(this.viewport, c) || this.scrollTarget && (this.scrollTarget.range.head < this.viewport.from || this.scrollTarget.range.head > this.viewport.to);
    return x && (this.viewport = this.getViewport(c, this.scrollTarget)), this.updateForViewport(), (a & 2 || x) && this.updateViewportLines(), (this.lineGaps.length || this.viewport.to - this.viewport.from > 2e3 << 1) && this.updateLineGaps(this.ensureLineGaps(n ? [] : this.lineGaps, e)), a |= this.computeVisibleRanges(), this.mustEnforceCursorAssoc && (this.mustEnforceCursorAssoc = !1, e.docView.enforceCursorAssoc()), a;
  }
  get visibleTop() {
    return this.scaler.fromDOM(this.pixelViewport.top);
  }
  get visibleBottom() {
    return this.scaler.fromDOM(this.pixelViewport.bottom);
  }
  getViewport(e, t) {
    let l = 0.5 - Math.max(-0.5, Math.min(0.5, e / 1e3 / 2)), i = this.heightMap, o = this.state.doc, { visibleTop: n, visibleBottom: s } = this, a = new Eo(i.lineAt(n - l * 1e3, we.ByHeight, o, 0, 0).from, i.lineAt(s + (1 - l) * 1e3, we.ByHeight, o, 0, 0).to);
    if (t) {
      let { head: c } = t.range;
      if (c < a.from || c > a.to) {
        let d = Math.min(this.editorHeight, this.pixelViewport.bottom - this.pixelViewport.top), h = i.lineAt(c, we.ByPos, o, 0, 0), p;
        t.y == "center" ? p = (h.top + h.bottom) / 2 - d / 2 : t.y == "start" || t.y == "nearest" && c < a.from ? p = h.top : p = h.bottom - d, a = new Eo(i.lineAt(p - 1e3 / 2, we.ByHeight, o, 0, 0).from, i.lineAt(p + d + 1e3 / 2, we.ByHeight, o, 0, 0).to);
      }
    }
    return a;
  }
  mapViewport(e, t) {
    let l = t.mapPos(e.from, -1), i = t.mapPos(e.to, 1);
    return new Eo(this.heightMap.lineAt(l, we.ByPos, this.state.doc, 0, 0).from, this.heightMap.lineAt(i, we.ByPos, this.state.doc, 0, 0).to);
  }
  // Checks if a given viewport covers the visible part of the
  // document and not too much beyond that.
  viewportIsAppropriate({ from: e, to: t }, l = 0) {
    if (!this.inView)
      return !0;
    let { top: i } = this.heightMap.lineAt(e, we.ByPos, this.state.doc, 0, 0), { bottom: o } = this.heightMap.lineAt(t, we.ByPos, this.state.doc, 0, 0), { visibleTop: n, visibleBottom: s } = this;
    return (e == 0 || i <= n - Math.max(10, Math.min(
      -l,
      250
      /* VP.MaxCoverMargin */
    ))) && (t == this.state.doc.length || o >= s + Math.max(10, Math.min(
      l,
      250
      /* VP.MaxCoverMargin */
    ))) && i > n - 2 * 1e3 && o < s + 2 * 1e3;
  }
  mapLineGaps(e, t) {
    if (!e.length || t.empty)
      return e;
    let l = [];
    for (let i of e)
      t.touchesRange(i.from, i.to) || l.push(new oa(t.mapPos(i.from), t.mapPos(i.to), i.size));
    return l;
  }
  // Computes positions in the viewport where the start or end of a
  // line should be hidden, trying to reuse existing line gaps when
  // appropriate to avoid unneccesary redraws.
  // Uses crude character-counting for the positioning and sizing,
  // since actual DOM coordinates aren't always available and
  // predictable. Relies on generous margins (see LG.Margin) to hide
  // the artifacts this might produce from the user.
  ensureLineGaps(e, t) {
    let l = this.heightOracle.lineWrapping, i = l ? 1e4 : 2e3, o = i >> 1, n = i << 1;
    if (this.defaultTextDirection != Ce.LTR && !l)
      return [];
    let s = [], a = (c, d, h, p) => {
      if (d - c < o)
        return;
      let u = this.state.selection.main, f = [u.from];
      u.empty || f.push(u.to);
      for (let O of f)
        if (O > c && O < d) {
          a(c, O - 10, h, p), a(O + 10, d, h, p);
          return;
        }
      let m = gy(e, (O) => O.from >= h.from && O.to <= h.to && Math.abs(O.from - c) < o && Math.abs(O.to - d) < o && !f.some((x) => O.from < x && O.to > x));
      if (!m) {
        if (d < h.to && t && l && t.visibleRanges.some((O) => O.from <= d && O.to >= d)) {
          let O = t.moveToLineBoundary(w.cursor(d), !1, !0).head;
          O > c && (d = O);
        }
        m = new oa(c, d, this.gapSize(h, c, d, p));
      }
      s.push(m);
    };
    for (let c of this.viewportLines) {
      if (c.length < n)
        continue;
      let d = fy(c.from, c.to, this.stateDeco);
      if (d.total < n)
        continue;
      let h = this.scrollTarget ? this.scrollTarget.range.head : null, p, u;
      if (l) {
        let f = i / this.heightOracle.lineLength * this.heightOracle.lineHeight, m, O;
        if (h != null) {
          let x = Zo(d, h), Q = ((this.visibleBottom - this.visibleTop) / 2 + f) / c.height;
          m = x - Q, O = x + Q;
        } else
          m = (this.visibleTop - c.top - f) / c.height, O = (this.visibleBottom - c.top + f) / c.height;
        p = Vo(d, m), u = Vo(d, O);
      } else {
        let f = d.total * this.heightOracle.charWidth, m = i * this.heightOracle.charWidth, O, x;
        if (h != null) {
          let Q = Zo(d, h), P = ((this.pixelViewport.right - this.pixelViewport.left) / 2 + m) / f;
          O = Q - P, x = Q + P;
        } else
          O = (this.pixelViewport.left - m) / f, x = (this.pixelViewport.right + m) / f;
        p = Vo(d, O), u = Vo(d, x);
      }
      p > c.from && a(c.from, p, c, d), u < c.to && a(u, c.to, c, d);
    }
    return s;
  }
  gapSize(e, t, l, i) {
    let o = Zo(i, l) - Zo(i, t);
    return this.heightOracle.lineWrapping ? e.height * o : i.total * this.heightOracle.charWidth * o;
  }
  updateLineGaps(e) {
    oa.same(e, this.lineGaps) || (this.lineGaps = e, this.lineGapDeco = B.set(e.map((t) => t.draw(this.heightOracle.lineWrapping))));
  }
  computeVisibleRanges() {
    let e = this.stateDeco;
    this.lineGaps.length && (e = e.concat(this.lineGapDeco));
    let t = [];
    ge.spans(e, this.viewport.from, this.viewport.to, {
      span(i, o) {
        t.push({ from: i, to: o });
      },
      point() {
      }
    }, 20);
    let l = t.length != this.visibleRanges.length || this.visibleRanges.some((i, o) => i.from != t[o].from || i.to != t[o].to);
    return this.visibleRanges = t, l ? 4 : 0;
  }
  lineBlockAt(e) {
    return e >= this.viewport.from && e <= this.viewport.to && this.viewportLines.find((t) => t.from <= e && t.to >= e) || Si(this.heightMap.lineAt(e, we.ByPos, this.state.doc, 0, 0), this.scaler);
  }
  lineBlockAtHeight(e) {
    return Si(this.heightMap.lineAt(this.scaler.fromDOM(e), we.ByHeight, this.state.doc, 0, 0), this.scaler);
  }
  elementAtHeight(e) {
    return Si(this.heightMap.blockAt(this.scaler.fromDOM(e), this.state.doc, 0, 0), this.scaler);
  }
  get docHeight() {
    return this.scaler.toDOM(this.heightMap.height);
  }
  get contentHeight() {
    return this.docHeight + this.paddingTop + this.paddingBottom;
  }
}
class Eo {
  constructor(e, t) {
    this.from = e, this.to = t;
  }
}
function fy(r, e, t) {
  let l = [], i = r, o = 0;
  return ge.spans(t, r, e, {
    span() {
    },
    point(n, s) {
      n > i && (l.push({ from: i, to: n }), o += n - i), i = s;
    }
  }, 20), i < e && (l.push({ from: i, to: e }), o += e - i), { total: o, ranges: l };
}
function Vo({ total: r, ranges: e }, t) {
  if (t <= 0)
    return e[0].from;
  if (t >= 1)
    return e[e.length - 1].to;
  let l = Math.floor(r * t);
  for (let i = 0; ; i++) {
    let { from: o, to: n } = e[i], s = n - o;
    if (l <= s)
      return o + l;
    l -= s;
  }
}
function Zo(r, e) {
  let t = 0;
  for (let { from: l, to: i } of r.ranges) {
    if (e <= i) {
      t += e - l;
      break;
    }
    t += i - l;
  }
  return t / r.total;
}
function gy(r, e) {
  for (let t of r)
    if (e(t))
      return t;
}
const Rp = {
  toDOM(r) {
    return r;
  },
  fromDOM(r) {
    return r;
  },
  scale: 1
};
class my {
  constructor(e, t, l) {
    let i = 0, o = 0, n = 0;
    this.viewports = l.map(({ from: s, to: a }) => {
      let c = t.lineAt(s, we.ByPos, e, 0, 0).top, d = t.lineAt(a, we.ByPos, e, 0, 0).bottom;
      return i += d - c, { from: s, to: a, top: c, bottom: d, domTop: 0, domBottom: 0 };
    }), this.scale = (7e6 - i) / (t.height - i);
    for (let s of this.viewports)
      s.domTop = n + (s.top - o) * this.scale, n = s.domBottom = s.domTop + (s.bottom - s.top), o = s.bottom;
  }
  toDOM(e) {
    for (let t = 0, l = 0, i = 0; ; t++) {
      let o = t < this.viewports.length ? this.viewports[t] : null;
      if (!o || e < o.top)
        return i + (e - l) * this.scale;
      if (e <= o.bottom)
        return o.domTop + (e - o.top);
      l = o.bottom, i = o.domBottom;
    }
  }
  fromDOM(e) {
    for (let t = 0, l = 0, i = 0; ; t++) {
      let o = t < this.viewports.length ? this.viewports[t] : null;
      if (!o || e < o.domTop)
        return l + (e - i) / this.scale;
      if (e <= o.domBottom)
        return o.top + (e - o.domTop);
      l = o.bottom, i = o.domBottom;
    }
  }
}
function Si(r, e) {
  if (e.scale == 1)
    return r;
  let t = e.toDOM(r.top), l = e.toDOM(r.bottom);
  return new zr(r.from, r.length, t, l - t, Array.isArray(r.type) ? r.type.map((i) => Si(i, e)) : r.type);
}
const Ro = /* @__PURE__ */ Y.define({ combine: (r) => r.join(" ") }), Qc = /* @__PURE__ */ Y.define({ combine: (r) => r.indexOf(!0) > -1 }), $c = /* @__PURE__ */ jr.newName(), Wm = /* @__PURE__ */ jr.newName(), Nm = /* @__PURE__ */ jr.newName(), Mm = { "&light": "." + Wm, "&dark": "." + Nm };
function Pc(r, e, t) {
  return new jr(e, {
    finish(l) {
      return /&/.test(l) ? l.replace(/&\w*/, (i) => {
        if (i == "&")
          return r;
        if (!t || !t[i])
          throw new RangeError(`Unsupported selector: ${i}`);
        return t[i];
      }) : r + " " + l;
    }
  });
}
const by = /* @__PURE__ */ Pc("." + $c, {
  "&": {
    position: "relative !important",
    boxSizing: "border-box",
    "&.cm-focused": {
      // Provide a simple default outline to make sure a focused
      // editor is visually distinct. Can't leave the default behavior
      // because that will apply to the content element, which is
      // inside the scrollable container and doesn't include the
      // gutters. We also can't use an 'auto' outline, since those
      // are, for some reason, drawn behind the element content, which
      // will cause things like the active line background to cover
      // the outline (#297).
      outline: "1px dotted #212121"
    },
    display: "flex !important",
    flexDirection: "column"
  },
  ".cm-scroller": {
    display: "flex !important",
    alignItems: "flex-start !important",
    fontFamily: "monospace",
    lineHeight: 1.4,
    height: "100%",
    overflowX: "auto",
    position: "relative",
    zIndex: 0
  },
  ".cm-content": {
    margin: 0,
    flexGrow: 2,
    flexShrink: 0,
    display: "block",
    whiteSpace: "pre",
    wordWrap: "normal",
    boxSizing: "border-box",
    padding: "4px 0",
    outline: "none",
    "&[contenteditable=true]": {
      WebkitUserModify: "read-write-plaintext-only"
    }
  },
  ".cm-lineWrapping": {
    whiteSpace_fallback: "pre-wrap",
    whiteSpace: "break-spaces",
    wordBreak: "break-word",
    overflowWrap: "anywhere",
    flexShrink: 1
  },
  "&light .cm-content": { caretColor: "black" },
  "&dark .cm-content": { caretColor: "white" },
  ".cm-line": {
    display: "block",
    padding: "0 2px 0 6px"
  },
  ".cm-layer": {
    contain: "size style",
    "& > *": {
      position: "absolute"
    }
  },
  "&light .cm-selectionBackground": {
    background: "#d9d9d9"
  },
  "&dark .cm-selectionBackground": {
    background: "#222"
  },
  "&light.cm-focused .cm-selectionBackground": {
    background: "#d7d4f0"
  },
  "&dark.cm-focused .cm-selectionBackground": {
    background: "#233"
  },
  ".cm-cursorLayer": {
    pointerEvents: "none"
  },
  "&.cm-focused .cm-cursorLayer": {
    animation: "steps(1) cm-blink 1.2s infinite"
  },
  // Two animations defined so that we can switch between them to
  // restart the animation without forcing another style
  // recomputation.
  "@keyframes cm-blink": { "0%": {}, "50%": { opacity: 0 }, "100%": {} },
  "@keyframes cm-blink2": { "0%": {}, "50%": { opacity: 0 }, "100%": {} },
  ".cm-cursor, .cm-dropCursor": {
    borderLeft: "1.2px solid black",
    marginLeft: "-0.6px",
    pointerEvents: "none"
  },
  ".cm-cursor": {
    display: "none"
  },
  "&dark .cm-cursor": {
    borderLeftColor: "#444"
  },
  "&.cm-focused .cm-cursor": {
    display: "block"
  },
  "&light .cm-activeLine": { backgroundColor: "#cceeff44" },
  "&dark .cm-activeLine": { backgroundColor: "#99eeff33" },
  "&light .cm-specialChar": { color: "red" },
  "&dark .cm-specialChar": { color: "#f78" },
  ".cm-gutters": {
    flexShrink: 0,
    display: "flex",
    height: "100%",
    boxSizing: "border-box",
    left: 0,
    zIndex: 200
  },
  "&light .cm-gutters": {
    backgroundColor: "#f5f5f5",
    color: "#6c6c6c",
    borderRight: "1px solid #ddd"
  },
  "&dark .cm-gutters": {
    backgroundColor: "#333338",
    color: "#ccc"
  },
  ".cm-gutter": {
    display: "flex !important",
    flexDirection: "column",
    flexShrink: 0,
    boxSizing: "border-box",
    minHeight: "100%",
    overflow: "hidden"
  },
  ".cm-gutterElement": {
    boxSizing: "border-box"
  },
  ".cm-lineNumbers .cm-gutterElement": {
    padding: "0 3px 0 5px",
    minWidth: "20px",
    textAlign: "right",
    whiteSpace: "nowrap"
  },
  "&light .cm-activeLineGutter": {
    backgroundColor: "#e2f2ff"
  },
  "&dark .cm-activeLineGutter": {
    backgroundColor: "#222227"
  },
  ".cm-panels": {
    boxSizing: "border-box",
    position: "sticky",
    left: 0,
    right: 0
  },
  "&light .cm-panels": {
    backgroundColor: "#f5f5f5",
    color: "black"
  },
  "&light .cm-panels-top": {
    borderBottom: "1px solid #ddd"
  },
  "&light .cm-panels-bottom": {
    borderTop: "1px solid #ddd"
  },
  "&dark .cm-panels": {
    backgroundColor: "#333338",
    color: "white"
  },
  ".cm-tab": {
    display: "inline-block",
    overflow: "hidden",
    verticalAlign: "bottom"
  },
  ".cm-widgetBuffer": {
    verticalAlign: "text-top",
    height: "1em",
    width: 0,
    display: "inline"
  },
  ".cm-placeholder": {
    color: "#888",
    display: "inline-block",
    verticalAlign: "top"
  },
  ".cm-highlightSpace:before": {
    content: "attr(data-display)",
    position: "absolute",
    pointerEvents: "none",
    color: "#888"
  },
  ".cm-highlightTab": {
    backgroundImage: `url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="200" height="20"><path stroke="%23888" stroke-width="1" fill="none" d="M1 10H196L190 5M190 15L196 10M197 4L197 16"/></svg>')`,
    backgroundSize: "auto 100%",
    backgroundPosition: "right 90%",
    backgroundRepeat: "no-repeat"
  },
  ".cm-trailingSpace": {
    backgroundColor: "#ff332255"
  },
  ".cm-button": {
    verticalAlign: "middle",
    color: "inherit",
    fontSize: "70%",
    padding: ".2em 1em",
    borderRadius: "1px"
  },
  "&light .cm-button": {
    backgroundImage: "linear-gradient(#eff1f5, #d9d9df)",
    border: "1px solid #888",
    "&:active": {
      backgroundImage: "linear-gradient(#b4b4b4, #d0d3d6)"
    }
  },
  "&dark .cm-button": {
    backgroundImage: "linear-gradient(#393939, #111)",
    border: "1px solid #888",
    "&:active": {
      backgroundImage: "linear-gradient(#111, #333)"
    }
  },
  ".cm-textfield": {
    verticalAlign: "middle",
    color: "inherit",
    fontSize: "70%",
    border: "1px solid silver",
    padding: ".2em .5em"
  },
  "&light .cm-textfield": {
    backgroundColor: "white"
  },
  "&dark .cm-textfield": {
    border: "1px solid #555",
    backgroundColor: "inherit"
  }
}, Mm);
class Oy {
  constructor(e, t, l, i) {
    this.typeOver = i, this.bounds = null, this.text = "";
    let { impreciseHead: o, impreciseAnchor: n } = e.docView;
    if (e.state.readOnly && t > -1)
      this.newSel = null;
    else if (t > -1 && (this.bounds = e.docView.domBoundsAround(t, l, 0))) {
      let s = o || n ? [] : xy(e), a = new $m(s, e.state);
      a.readRange(this.bounds.startDOM, this.bounds.endDOM), this.text = a.text, this.newSel = _y(s, this.bounds.from);
    } else {
      let s = e.observer.selectionRange, a = o && o.node == s.focusNode && o.offset == s.focusOffset || !Fl(e.contentDOM, s.focusNode) ? e.state.selection.main.head : e.docView.posFromDOM(s.focusNode, s.focusOffset), c = n && n.node == s.anchorNode && n.offset == s.anchorOffset || !Fl(e.contentDOM, s.anchorNode) ? e.state.selection.main.anchor : e.docView.posFromDOM(s.anchorNode, s.anchorOffset);
      this.newSel = w.single(c, a);
    }
  }
}
function Ym(r, e) {
  let t, { newSel: l } = e, i = r.state.selection.main;
  if (e.bounds) {
    let { from: o, to: n } = e.bounds, s = i.from, a = null;
    (r.inputState.lastKeyCode === 8 && r.inputState.lastKeyTime > Date.now() - 100 || M.android && e.text.length < n - o) && (s = i.to, a = "end");
    let c = vy(r.state.doc.sliceString(o, n, Tr), e.text, s - o, a);
    c && (M.chrome && r.inputState.lastKeyCode == 13 && c.toB == c.from + 2 && e.text.slice(c.from, c.toB) == Tr + Tr && c.toB--, t = {
      from: o + c.from,
      to: o + c.toA,
      insert: ue.of(e.text.slice(c.from, c.toB).split(Tr))
    });
  } else
    l && (!r.hasFocus && r.state.facet(Ps) || l.main.eq(i)) && (l = null);
  if (!t && !l)
    return !1;
  if (!t && e.typeOver && !i.empty && l && l.main.empty ? t = { from: i.from, to: i.to, insert: r.state.doc.slice(i.from, i.to) } : t && t.from >= i.from && t.to <= i.to && (t.from != i.from || t.to != i.to) && i.to - i.from - (t.to - t.from) <= 4 ? t = {
    from: i.from,
    to: i.to,
    insert: r.state.doc.slice(i.from, t.from).append(t.insert).append(r.state.doc.slice(t.to, i.to))
  } : (M.mac || M.android) && t && t.from == t.to && t.from == i.head - 1 && /^\. ?$/.test(t.insert.toString()) ? (l && t.insert.length == 2 && (l = w.single(l.main.anchor - 1, l.main.head - 1)), t = { from: i.from, to: i.to, insert: ue.of([" "]) }) : M.chrome && t && t.from == t.to && t.from == i.head && t.insert.toString() == `
 ` && r.lineWrapping && (l && (l = w.single(l.main.anchor - 1, l.main.head - 1)), t = { from: i.from, to: i.to, insert: ue.of([" "]) }), t) {
    let o = r.state;
    if (M.ios && r.inputState.flushIOSKey(r) || M.android && (t.from == i.from && t.to == i.to && t.insert.length == 1 && t.insert.lines == 2 && Il(r.contentDOM, "Enter", 13) || t.from == i.from - 1 && t.to == i.to && t.insert.length == 0 && Il(r.contentDOM, "Backspace", 8) || t.from == i.from && t.to == i.to + 1 && t.insert.length == 0 && Il(r.contentDOM, "Delete", 46)))
      return !0;
    let n = t.insert.toString();
    if (r.state.facet(Om).some((c) => c(r, t.from, t.to, n)))
      return !0;
    r.inputState.composing >= 0 && r.inputState.composing++;
    let s;
    if (t.from >= i.from && t.to <= i.to && t.to - t.from >= (i.to - i.from) / 3 && (!l || l.main.empty && l.main.from == t.from + t.insert.length) && r.inputState.composing < 0) {
      let c = i.from < t.from ? o.sliceDoc(i.from, t.from) : "", d = i.to > t.to ? o.sliceDoc(t.to, i.to) : "";
      s = o.replaceSelection(r.state.toText(c + t.insert.sliceString(0, void 0, r.state.lineBreak) + d));
    } else {
      let c = o.changes(t), d = l && !o.selection.main.eq(l.main) && l.main.to <= c.newLength ? l.main : void 0;
      if (o.selection.ranges.length > 1 && r.inputState.composing >= 0 && t.to <= i.to && t.to >= i.to - 10) {
        let h = r.state.sliceDoc(t.from, t.to), p = Pm(r) || r.state.doc.lineAt(i.head), u = i.to - t.to, f = i.to - i.from;
        s = o.changeByRange((m) => {
          if (m.from == i.from && m.to == i.to)
            return { changes: c, range: d || m.map(c) };
          let O = m.to - u, x = O - h.length;
          if (m.to - m.from != f || r.state.sliceDoc(x, O) != h || // Unfortunately, there's no way to make multiple
          // changes in the same node work without aborting
          // composition, so cursors in the composition range are
          // ignored.
          p && m.to >= p.from && m.from <= p.to)
            return { range: m };
          let Q = o.changes({ from: x, to: O, insert: t.insert }), P = m.to - i.to;
          return {
            changes: Q,
            range: d ? w.range(Math.max(0, d.anchor + P), Math.max(0, d.head + P)) : m.map(Q)
          };
        });
      } else
        s = {
          changes: c,
          selection: d && o.selection.replaceRange(d)
        };
    }
    let a = "input.type";
    return r.composing && (a += ".compose", r.inputState.compositionFirstChange && (a += ".start", r.inputState.compositionFirstChange = !1)), r.dispatch(s, { scrollIntoView: !0, userEvent: a }), !0;
  } else if (l && !l.main.eq(i)) {
    let o = !1, n = "select";
    return r.inputState.lastSelectionTime > Date.now() - 50 && (r.inputState.lastSelectionOrigin == "select" && (o = !0), n = r.inputState.lastSelectionOrigin), r.dispatch({ selection: l, scrollIntoView: o, userEvent: n }), !0;
  } else
    return !1;
}
function vy(r, e, t, l) {
  let i = Math.min(r.length, e.length), o = 0;
  for (; o < i && r.charCodeAt(o) == e.charCodeAt(o); )
    o++;
  if (o == i && r.length == e.length)
    return null;
  let n = r.length, s = e.length;
  for (; n > 0 && s > 0 && r.charCodeAt(n - 1) == e.charCodeAt(s - 1); )
    n--, s--;
  if (l == "end") {
    let a = Math.max(0, o - Math.min(n, s));
    t -= n + a - o;
  }
  if (n < o && r.length < e.length) {
    let a = t <= o && t >= n ? o - t : 0;
    o -= a, s = o + (s - n), n = o;
  } else if (s < o) {
    let a = t <= o && t >= s ? o - t : 0;
    o -= a, n = o + (n - s), s = o;
  }
  return { from: o, toA: n, toB: s };
}
function xy(r) {
  let e = [];
  if (r.root.activeElement != r.contentDOM)
    return e;
  let { anchorNode: t, anchorOffset: l, focusNode: i, focusOffset: o } = r.observer.selectionRange;
  return t && (e.push(new Op(t, l)), (i != t || o != l) && e.push(new Op(i, o))), e;
}
function _y(r, e) {
  if (r.length == 0)
    return null;
  let t = r[0].pos, l = r.length == 2 ? r[1].pos : t;
  return t > -1 && l > -1 ? w.single(t + e, l + e) : null;
}
const wy = {
  childList: !0,
  characterData: !0,
  subtree: !0,
  attributes: !0,
  characterDataOldValue: !0
}, na = M.ie && M.ie_version <= 11;
class yy {
  constructor(e) {
    this.view = e, this.active = !1, this.selectionRange = new mw(), this.selectionChanged = !1, this.delayedFlush = -1, this.resizeTimeout = -1, this.queue = [], this.delayedAndroidKey = null, this.flushingAndroidKey = -1, this.lastChange = 0, this.scrollTargets = [], this.intersection = null, this.resizeScroll = null, this.resizeContent = null, this.intersecting = !1, this.gapIntersection = null, this.gaps = [], this.parentCheck = -1, this.dom = e.contentDOM, this.observer = new MutationObserver((t) => {
      for (let l of t)
        this.queue.push(l);
      (M.ie && M.ie_version <= 11 || M.ios && e.composing) && t.some((l) => l.type == "childList" && l.removedNodes.length || l.type == "characterData" && l.oldValue.length > l.target.nodeValue.length) ? this.flushSoon() : this.flush();
    }), na && (this.onCharData = (t) => {
      this.queue.push({
        target: t.target,
        type: "characterData",
        oldValue: t.prevValue
      }), this.flushSoon();
    }), this.onSelectionChange = this.onSelectionChange.bind(this), this.onResize = this.onResize.bind(this), this.onPrint = this.onPrint.bind(this), this.onScroll = this.onScroll.bind(this), typeof ResizeObserver == "function" && (this.resizeScroll = new ResizeObserver(() => {
      var t;
      ((t = this.view.docView) === null || t === void 0 ? void 0 : t.lastUpdate) < Date.now() - 75 && this.onResize();
    }), this.resizeScroll.observe(e.scrollDOM), this.resizeContent = new ResizeObserver(() => this.view.requestMeasure()), this.resizeContent.observe(e.contentDOM)), this.addWindowListeners(this.win = e.win), this.start(), typeof IntersectionObserver == "function" && (this.intersection = new IntersectionObserver((t) => {
      this.parentCheck < 0 && (this.parentCheck = setTimeout(this.listenForScroll.bind(this), 1e3)), t.length > 0 && t[t.length - 1].intersectionRatio > 0 != this.intersecting && (this.intersecting = !this.intersecting, this.intersecting != this.view.inView && this.onScrollChanged(document.createEvent("Event")));
    }, {}), this.intersection.observe(this.dom), this.gapIntersection = new IntersectionObserver((t) => {
      t.length > 0 && t[t.length - 1].intersectionRatio > 0 && this.onScrollChanged(document.createEvent("Event"));
    }, {})), this.listenForScroll(), this.readSelectionRange();
  }
  onScrollChanged(e) {
    this.view.inputState.runScrollHandlers(this.view, e), this.intersecting && this.view.measure();
  }
  onScroll(e) {
    this.intersecting && this.flush(!1), this.onScrollChanged(e);
  }
  onResize() {
    this.resizeTimeout < 0 && (this.resizeTimeout = setTimeout(() => {
      this.resizeTimeout = -1, this.view.requestMeasure();
    }, 50));
  }
  onPrint() {
    this.view.viewState.printing = !0, this.view.measure(), setTimeout(() => {
      this.view.viewState.printing = !1, this.view.requestMeasure();
    }, 500);
  }
  updateGaps(e) {
    if (this.gapIntersection && (e.length != this.gaps.length || this.gaps.some((t, l) => t != e[l]))) {
      this.gapIntersection.disconnect();
      for (let t of e)
        this.gapIntersection.observe(t);
      this.gaps = e;
    }
  }
  onSelectionChange(e) {
    let t = this.selectionChanged;
    if (!this.readSelectionRange() || this.delayedAndroidKey)
      return;
    let { view: l } = this, i = this.selectionRange;
    if (l.state.facet(Ps) ? l.root.activeElement != this.dom : !cn(l.dom, i))
      return;
    let o = i.anchorNode && l.docView.nearest(i.anchorNode);
    if (o && o.ignoreEvent(e)) {
      t || (this.selectionChanged = !1);
      return;
    }
    (M.ie && M.ie_version <= 11 || M.android && M.chrome) && !l.state.selection.main.empty && // (Selection.isCollapsed isn't reliable on IE)
    i.focusNode && Xn(i.focusNode, i.focusOffset, i.anchorNode, i.anchorOffset) ? this.flushSoon() : this.flush(!1);
  }
  readSelectionRange() {
    let { view: e } = this, t = M.safari && e.root.nodeType == 11 && pw(this.dom.ownerDocument) == this.dom && ky(this.view) || zn(e.root);
    if (!t || this.selectionRange.eq(t))
      return !1;
    let l = cn(this.dom, t);
    return l && !this.selectionChanged && e.inputState.lastFocusTime > Date.now() - 200 && e.inputState.lastTouchTime < Date.now() - 300 && Ow(this.dom, t) ? (this.view.inputState.lastFocusTime = 0, e.docView.updateSelection(), !1) : (this.selectionRange.setRange(t), l && (this.selectionChanged = !0), !0);
  }
  setSelectionRange(e, t) {
    this.selectionRange.set(e.node, e.offset, t.node, t.offset), this.selectionChanged = !1;
  }
  clearSelectionRange() {
    this.selectionRange.set(null, 0, null, 0);
  }
  listenForScroll() {
    this.parentCheck = -1;
    let e = 0, t = null;
    for (let l = this.dom; l; )
      if (l.nodeType == 1)
        !t && e < this.scrollTargets.length && this.scrollTargets[e] == l ? e++ : t || (t = this.scrollTargets.slice(0, e)), t && t.push(l), l = l.assignedSlot || l.parentNode;
      else if (l.nodeType == 11)
        l = l.host;
      else
        break;
    if (e < this.scrollTargets.length && !t && (t = this.scrollTargets.slice(0, e)), t) {
      for (let l of this.scrollTargets)
        l.removeEventListener("scroll", this.onScroll);
      for (let l of this.scrollTargets = t)
        l.addEventListener("scroll", this.onScroll);
    }
  }
  ignore(e) {
    if (!this.active)
      return e();
    try {
      return this.stop(), e();
    } finally {
      this.start(), this.clear();
    }
  }
  start() {
    this.active || (this.observer.observe(this.dom, wy), na && this.dom.addEventListener("DOMCharacterDataModified", this.onCharData), this.active = !0);
  }
  stop() {
    this.active && (this.active = !1, this.observer.disconnect(), na && this.dom.removeEventListener("DOMCharacterDataModified", this.onCharData));
  }
  // Throw away any pending changes
  clear() {
    this.processRecords(), this.queue.length = 0, this.selectionChanged = !1;
  }
  // Chrome Android, especially in combination with GBoard, not only
  // doesn't reliably fire regular key events, but also often
  // surrounds the effect of enter or backspace with a bunch of
  // composition events that, when interrupted, cause text duplication
  // or other kinds of corruption. This hack makes the editor back off
  // from handling DOM changes for a moment when such a key is
  // detected (via beforeinput or keydown), and then tries to flush
  // them or, if that has no effect, dispatches the given key.
  delayAndroidKey(e, t) {
    var l;
    if (!this.delayedAndroidKey) {
      let i = () => {
        let o = this.delayedAndroidKey;
        o && (this.clearDelayedAndroidKey(), !this.flush() && o.force && Il(this.dom, o.key, o.keyCode));
      };
      this.flushingAndroidKey = this.view.win.requestAnimationFrame(i);
    }
    (!this.delayedAndroidKey || e == "Enter") && (this.delayedAndroidKey = {
      key: e,
      keyCode: t,
      // Only run the key handler when no changes are detected if
      // this isn't coming right after another change, in which case
      // it is probably part of a weird chain of updates, and should
      // be ignored if it returns the DOM to its previous state.
      force: this.lastChange < Date.now() - 50 || !!(!((l = this.delayedAndroidKey) === null || l === void 0) && l.force)
    });
  }
  clearDelayedAndroidKey() {
    this.win.cancelAnimationFrame(this.flushingAndroidKey), this.delayedAndroidKey = null, this.flushingAndroidKey = -1;
  }
  flushSoon() {
    this.delayedFlush < 0 && (this.delayedFlush = this.view.win.requestAnimationFrame(() => {
      this.delayedFlush = -1, this.flush();
    }));
  }
  forceFlush() {
    this.delayedFlush >= 0 && (this.view.win.cancelAnimationFrame(this.delayedFlush), this.delayedFlush = -1), this.flush();
  }
  processRecords() {
    let e = this.queue;
    for (let o of this.observer.takeRecords())
      e.push(o);
    e.length && (this.queue = []);
    let t = -1, l = -1, i = !1;
    for (let o of e) {
      let n = this.readMutation(o);
      n && (n.typeOver && (i = !0), t == -1 ? { from: t, to: l } = n : (t = Math.min(n.from, t), l = Math.max(n.to, l)));
    }
    return { from: t, to: l, typeOver: i };
  }
  readChange() {
    let { from: e, to: t, typeOver: l } = this.processRecords(), i = this.selectionChanged && cn(this.dom, this.selectionRange);
    return e < 0 && !i ? null : (e > -1 && (this.lastChange = Date.now()), this.view.inputState.lastFocusTime = 0, this.selectionChanged = !1, new Oy(this.view, e, t, l));
  }
  // Apply pending changes, if any
  flush(e = !0) {
    if (this.delayedFlush >= 0 || this.delayedAndroidKey)
      return !1;
    e && this.readSelectionRange();
    let t = this.readChange();
    if (!t)
      return !1;
    let l = this.view.state, i = Ym(this.view, t);
    return this.view.state == l && this.view.update([]), i;
  }
  readMutation(e) {
    let t = this.view.docView.nearest(e.target);
    if (!t || t.ignoreMutation(e))
      return null;
    if (t.markDirty(e.type == "attributes"), e.type == "attributes" && (t.dirty |= 4), e.type == "childList") {
      let l = Dp(t, e.previousSibling || e.target.previousSibling, -1), i = Dp(t, e.nextSibling || e.target.nextSibling, 1);
      return {
        from: l ? t.posAfter(l) : t.posAtStart,
        to: i ? t.posBefore(i) : t.posAtEnd,
        typeOver: !1
      };
    } else
      return e.type == "characterData" ? { from: t.posAtStart, to: t.posAtEnd, typeOver: e.target.nodeValue == e.oldValue } : null;
  }
  setWindow(e) {
    e != this.win && (this.removeWindowListeners(this.win), this.win = e, this.addWindowListeners(this.win));
  }
  addWindowListeners(e) {
    e.addEventListener("resize", this.onResize), e.addEventListener("beforeprint", this.onPrint), e.addEventListener("scroll", this.onScroll), e.document.addEventListener("selectionchange", this.onSelectionChange);
  }
  removeWindowListeners(e) {
    e.removeEventListener("scroll", this.onScroll), e.removeEventListener("resize", this.onResize), e.removeEventListener("beforeprint", this.onPrint), e.document.removeEventListener("selectionchange", this.onSelectionChange);
  }
  destroy() {
    var e, t, l, i;
    this.stop(), (e = this.intersection) === null || e === void 0 || e.disconnect(), (t = this.gapIntersection) === null || t === void 0 || t.disconnect(), (l = this.resizeScroll) === null || l === void 0 || l.disconnect(), (i = this.resizeContent) === null || i === void 0 || i.disconnect();
    for (let o of this.scrollTargets)
      o.removeEventListener("scroll", this.onScroll);
    this.removeWindowListeners(this.win), clearTimeout(this.parentCheck), clearTimeout(this.resizeTimeout), this.win.cancelAnimationFrame(this.delayedFlush), this.win.cancelAnimationFrame(this.flushingAndroidKey);
  }
}
function Dp(r, e, t) {
  for (; e; ) {
    let l = ye.get(e);
    if (l && l.parent == r)
      return l;
    let i = e.parentNode;
    e = i != r.dom ? i : t > 0 ? e.nextSibling : e.previousSibling;
  }
  return null;
}
function ky(r) {
  let e = null;
  function t(a) {
    a.preventDefault(), a.stopImmediatePropagation(), e = a.getTargetRanges()[0];
  }
  if (r.contentDOM.addEventListener("beforeinput", t, !0), r.dom.ownerDocument.execCommand("indent"), r.contentDOM.removeEventListener("beforeinput", t, !0), !e)
    return null;
  let l = e.startContainer, i = e.startOffset, o = e.endContainer, n = e.endOffset, s = r.docView.domAtPos(r.state.selection.main.anchor);
  return Xn(s.node, s.offset, o, n) && ([l, i, o, n] = [o, n, l, i]), { anchorNode: l, anchorOffset: i, focusNode: o, focusOffset: n };
}
class I {
  /**
  Construct a new view. You'll want to either provide a `parent`
  option, or put `view.dom` into your document after creating a
  view, so that the user can see the editor.
  */
  constructor(e = {}) {
    this.plugins = [], this.pluginMap = /* @__PURE__ */ new Map(), this.editorAttrs = {}, this.contentAttrs = {}, this.bidiCache = [], this.destroyed = !1, this.updateState = 2, this.measureScheduled = -1, this.measureRequests = [], this.contentDOM = document.createElement("div"), this.scrollDOM = document.createElement("div"), this.scrollDOM.tabIndex = -1, this.scrollDOM.className = "cm-scroller", this.scrollDOM.appendChild(this.contentDOM), this.announceDOM = document.createElement("div"), this.announceDOM.style.cssText = "position: fixed; top: -10000px", this.announceDOM.setAttribute("aria-live", "polite"), this.dom = document.createElement("div"), this.dom.appendChild(this.announceDOM), this.dom.appendChild(this.scrollDOM), this._dispatch = e.dispatch || ((t) => this.update([t])), this.dispatch = this.dispatch.bind(this), this._root = e.root || bw(e.parent) || document, this.viewState = new Zp(e.state || pe.create(e)), this.plugins = this.state.facet(yi).map((t) => new ra(t));
    for (let t of this.plugins)
      t.update(this);
    this.observer = new yy(this), this.inputState = new qw(this), this.inputState.ensureHandlers(this, this.plugins), this.docView = new vp(this), this.mountStyles(), this.updateAttrs(), this.updateState = 0, this.requestMeasure(), e.parent && e.parent.appendChild(this.dom);
  }
  /**
  The current editor state.
  */
  get state() {
    return this.viewState.state;
  }
  /**
  To be able to display large documents without consuming too much
  memory or overloading the browser, CodeMirror only draws the
  code that is visible (plus a margin around it) to the DOM. This
  property tells you the extent of the current drawn viewport, in
  document positions.
  */
  get viewport() {
    return this.viewState.viewport;
  }
  /**
  When there are, for example, large collapsed ranges in the
  viewport, its size can be a lot bigger than the actual visible
  content. Thus, if you are doing something like styling the
  content in the viewport, it is preferable to only do so for
  these ranges, which are the subset of the viewport that is
  actually drawn.
  */
  get visibleRanges() {
    return this.viewState.visibleRanges;
  }
  /**
  Returns false when the editor is entirely scrolled out of view
  or otherwise hidden.
  */
  get inView() {
    return this.viewState.inView;
  }
  /**
  Indicates whether the user is currently composing text via
  [IME](https://en.wikipedia.org/wiki/Input_method), and at least
  one change has been made in the current composition.
  */
  get composing() {
    return this.inputState.composing > 0;
  }
  /**
  Indicates whether the user is currently in composing state. Note
  that on some platforms, like Android, this will be the case a
  lot, since just putting the cursor on a word starts a
  composition there.
  */
  get compositionStarted() {
    return this.inputState.composing >= 0;
  }
  /**
  The document or shadow root that the view lives in.
  */
  get root() {
    return this._root;
  }
  /**
  @internal
  */
  get win() {
    return this.dom.ownerDocument.defaultView || window;
  }
  dispatch(...e) {
    this._dispatch(e.length == 1 && e[0] instanceof We ? e[0] : this.state.update(...e));
  }
  /**
  Update the view for the given array of transactions. This will
  update the visible document and selection to match the state
  produced by the transactions, and notify view plugins of the
  change. You should usually call
  [`dispatch`](https://codemirror.net/6/docs/ref/#view.EditorView.dispatch) instead, which uses this
  as a primitive.
  */
  update(e) {
    if (this.updateState != 0)
      throw new Error("Calls to EditorView.update are not allowed while an update is in progress");
    let t = !1, l = !1, i, o = this.state;
    for (let c of e) {
      if (c.startState != o)
        throw new RangeError("Trying to update state with a transaction that doesn't start from the previous state.");
      o = c.state;
    }
    if (this.destroyed) {
      this.viewState.state = o;
      return;
    }
    let n = this.observer.delayedAndroidKey, s = null;
    if (n ? (this.observer.clearDelayedAndroidKey(), s = this.observer.readChange(), (s && !this.state.doc.eq(o.doc) || !this.state.selection.eq(o.selection)) && (s = null)) : this.observer.clear(), o.facet(pe.phrases) != this.state.facet(pe.phrases))
      return this.setState(o);
    i = Vn.create(this, o, e);
    let a = this.viewState.scrollTarget;
    try {
      this.updateState = 2;
      for (let c of e) {
        if (a && (a = a.map(c.changes)), c.scrollIntoView) {
          let { main: d } = c.state.selection;
          a = new En(d.empty ? d : w.cursor(d.head, d.head > d.anchor ? -1 : 1));
        }
        for (let d of c.effects)
          d.is(mp) && (a = d.value);
      }
      this.viewState.update(i, a), this.bidiCache = Zn.update(this.bidiCache, i.changes), i.empty || (this.updatePlugins(i), this.inputState.update(i)), t = this.docView.update(i), this.state.facet(ki) != this.styleModules && this.mountStyles(), l = this.updateAttrs(), this.showAnnouncements(e), this.docView.updateSelection(t, e.some((c) => c.isUserEvent("select.pointer")));
    } finally {
      this.updateState = 0;
    }
    if (i.startState.facet(Ro) != i.state.facet(Ro) && (this.viewState.mustMeasureContent = !0), (t || l || a || this.viewState.mustEnforceCursorAssoc || this.viewState.mustMeasureContent) && this.requestMeasure(), !i.empty)
      for (let c of this.state.facet(xc))
        c(i);
    s && !Ym(this, s) && n.force && Il(this.contentDOM, n.key, n.keyCode);
  }
  /**
  Reset the view to the given state. (This will cause the entire
  document to be redrawn and all view plugins to be reinitialized,
  so you should probably only use it when the new state isn't
  derived from the old state. Otherwise, use
  [`dispatch`](https://codemirror.net/6/docs/ref/#view.EditorView.dispatch) instead.)
  */
  setState(e) {
    if (this.updateState != 0)
      throw new Error("Calls to EditorView.setState are not allowed while an update is in progress");
    if (this.destroyed) {
      this.viewState.state = e;
      return;
    }
    this.updateState = 2;
    let t = this.hasFocus;
    try {
      for (let l of this.plugins)
        l.destroy(this);
      this.viewState = new Zp(e), this.plugins = e.facet(yi).map((l) => new ra(l)), this.pluginMap.clear();
      for (let l of this.plugins)
        l.update(this);
      this.docView = new vp(this), this.inputState.ensureHandlers(this, this.plugins), this.mountStyles(), this.updateAttrs(), this.bidiCache = [];
    } finally {
      this.updateState = 0;
    }
    t && this.focus(), this.requestMeasure();
  }
  updatePlugins(e) {
    let t = e.startState.facet(yi), l = e.state.facet(yi);
    if (t != l) {
      let i = [];
      for (let o of l) {
        let n = t.indexOf(o);
        if (n < 0)
          i.push(new ra(o));
        else {
          let s = this.plugins[n];
          s.mustUpdate = e, i.push(s);
        }
      }
      for (let o of this.plugins)
        o.mustUpdate != e && o.destroy(this);
      this.plugins = i, this.pluginMap.clear(), this.inputState.ensureHandlers(this, this.plugins);
    } else
      for (let i of this.plugins)
        i.mustUpdate = e;
    for (let i = 0; i < this.plugins.length; i++)
      this.plugins[i].update(this);
  }
  /**
  @internal
  */
  measure(e = !0) {
    if (this.destroyed)
      return;
    this.measureScheduled > -1 && cancelAnimationFrame(this.measureScheduled), this.measureScheduled = 0, e && this.observer.forceFlush();
    let t = null, { scrollHeight: l, scrollTop: i, clientHeight: o } = this.scrollDOM, n = i > l - o - 4 ? l : i;
    try {
      for (let s = 0; ; s++) {
        this.updateState = 1;
        let a = this.viewport, c = this.viewState.lineBlockAtHeight(n), d = this.viewState.measure(this);
        if (!d && !this.measureRequests.length && this.viewState.scrollTarget == null)
          break;
        if (s > 5) {
          console.warn(this.measureRequests.length ? "Measure loop restarted more than 5 times" : "Viewport failed to stabilize");
          break;
        }
        let h = [];
        d & 4 || ([this.measureRequests, h] = [h, this.measureRequests]);
        let p = h.map((O) => {
          try {
            return O.read(this);
          } catch (x) {
            return yt(this.state, x), Wp;
          }
        }), u = Vn.create(this, this.state, []), f = !1, m = !1;
        u.flags |= d, t ? t.flags |= d : t = u, this.updateState = 2, u.empty || (this.updatePlugins(u), this.inputState.update(u), this.updateAttrs(), f = this.docView.update(u));
        for (let O = 0; O < h.length; O++)
          if (p[O] != Wp)
            try {
              let x = h[O];
              x.write && x.write(p[O], this);
            } catch (x) {
              yt(this.state, x);
            }
        if (this.viewState.editorHeight)
          if (this.viewState.scrollTarget)
            this.docView.scrollIntoView(this.viewState.scrollTarget), this.viewState.scrollTarget = null, m = !0;
          else {
            let O = this.viewState.lineBlockAt(c.from).top - c.top;
            (O > 1 || O < -1) && (this.scrollDOM.scrollTop += O, m = !0);
          }
        if (f && this.docView.updateSelection(!0), this.viewport.from == a.from && this.viewport.to == a.to && !m && this.measureRequests.length == 0)
          break;
      }
    } finally {
      this.updateState = 0, this.measureScheduled = -1;
    }
    if (t && !t.empty)
      for (let s of this.state.facet(xc))
        s(t);
  }
  /**
  Get the CSS classes for the currently active editor themes.
  */
  get themeClasses() {
    return $c + " " + (this.state.facet(Qc) ? Nm : Wm) + " " + this.state.facet(Ro);
  }
  updateAttrs() {
    let e = Np(this, _m, {
      class: "cm-editor" + (this.hasFocus ? " cm-focused " : " ") + this.themeClasses
    }), t = {
      spellcheck: "false",
      autocorrect: "off",
      autocapitalize: "off",
      translate: "no",
      contenteditable: this.state.facet(Ps) ? "true" : "false",
      class: "cm-content",
      style: `${M.tabSize}: ${this.state.tabSize}`,
      role: "textbox",
      "aria-multiline": "true"
    };
    this.state.readOnly && (t["aria-readonly"] = "true"), Np(this, Xd, t);
    let l = this.observer.ignore(() => {
      let i = Oc(this.contentDOM, this.contentAttrs, t), o = Oc(this.dom, this.editorAttrs, e);
      return i || o;
    });
    return this.editorAttrs = e, this.contentAttrs = t, l;
  }
  showAnnouncements(e) {
    let t = !0;
    for (let l of e)
      for (let i of l.effects)
        if (i.is(I.announce)) {
          t && (this.announceDOM.textContent = ""), t = !1;
          let o = this.announceDOM.appendChild(document.createElement("div"));
          o.textContent = i.value;
        }
  }
  mountStyles() {
    this.styleModules = this.state.facet(ki), jr.mount(this.root, this.styleModules.concat(by).reverse());
  }
  readMeasured() {
    if (this.updateState == 2)
      throw new Error("Reading the editor layout isn't allowed during an update");
    this.updateState == 0 && this.measureScheduled > -1 && this.measure(!1);
  }
  /**
  Schedule a layout measurement, optionally providing callbacks to
  do custom DOM measuring followed by a DOM write phase. Using
  this is preferable reading DOM layout directly from, for
  example, an event handler, because it'll make sure measuring and
  drawing done by other components is synchronized, avoiding
  unnecessary DOM layout computations.
  */
  requestMeasure(e) {
    if (this.measureScheduled < 0 && (this.measureScheduled = this.win.requestAnimationFrame(() => this.measure())), e) {
      if (this.measureRequests.indexOf(e) > -1)
        return;
      if (e.key != null) {
        for (let t = 0; t < this.measureRequests.length; t++)
          if (this.measureRequests[t].key === e.key) {
            this.measureRequests[t] = e;
            return;
          }
      }
      this.measureRequests.push(e);
    }
  }
  /**
  Get the value of a specific plugin, if present. Note that
  plugins that crash can be dropped from a view, so even when you
  know you registered a given plugin, it is recommended to check
  the return value of this method.
  */
  plugin(e) {
    let t = this.pluginMap.get(e);
    return (t === void 0 || t && t.spec != e) && this.pluginMap.set(e, t = this.plugins.find((l) => l.spec == e) || null), t && t.update(this).value;
  }
  /**
  The top position of the document, in screen coordinates. This
  may be negative when the editor is scrolled down. Points
  directly to the top of the first line, not above the padding.
  */
  get documentTop() {
    return this.contentDOM.getBoundingClientRect().top + this.viewState.paddingTop;
  }
  /**
  Reports the padding above and below the document.
  */
  get documentPadding() {
    return { top: this.viewState.paddingTop, bottom: this.viewState.paddingBottom };
  }
  /**
  Find the text line or block widget at the given vertical
  position (which is interpreted as relative to the [top of the
  document](https://codemirror.net/6/docs/ref/#view.EditorView.documentTop)).
  */
  elementAtHeight(e) {
    return this.readMeasured(), this.viewState.elementAtHeight(e);
  }
  /**
  Find the line block (see
  [`lineBlockAt`](https://codemirror.net/6/docs/ref/#view.EditorView.lineBlockAt) at the given
  height, again interpreted relative to the [top of the
  document](https://codemirror.net/6/docs/ref/#view.EditorView.documentTop).
  */
  lineBlockAtHeight(e) {
    return this.readMeasured(), this.viewState.lineBlockAtHeight(e);
  }
  /**
  Get the extent and vertical position of all [line
  blocks](https://codemirror.net/6/docs/ref/#view.EditorView.lineBlockAt) in the viewport. Positions
  are relative to the [top of the
  document](https://codemirror.net/6/docs/ref/#view.EditorView.documentTop);
  */
  get viewportLineBlocks() {
    return this.viewState.viewportLines;
  }
  /**
  Find the line block around the given document position. A line
  block is a range delimited on both sides by either a
  non-[hidden](https://codemirror.net/6/docs/ref/#view.Decoration^replace) line breaks, or the
  start/end of the document. It will usually just hold a line of
  text, but may be broken into multiple textblocks by block
  widgets.
  */
  lineBlockAt(e) {
    return this.viewState.lineBlockAt(e);
  }
  /**
  The editor's total content height.
  */
  get contentHeight() {
    return this.viewState.contentHeight;
  }
  /**
  Move a cursor position by [grapheme
  cluster](https://codemirror.net/6/docs/ref/#state.findClusterBreak). `forward` determines whether
  the motion is away from the line start, or towards it. In
  bidirectional text, the line is traversed in visual order, using
  the editor's [text direction](https://codemirror.net/6/docs/ref/#view.EditorView.textDirection).
  When the start position was the last one on the line, the
  returned position will be across the line break. If there is no
  further line, the original position is returned.
  
  By default, this method moves over a single cluster. The
  optional `by` argument can be used to move across more. It will
  be called with the first cluster as argument, and should return
  a predicate that determines, for each subsequent cluster,
  whether it should also be moved over.
  */
  moveByChar(e, t, l) {
    return ia(this, e, Sp(this, e, t, l));
  }
  /**
  Move a cursor position across the next group of either
  [letters](https://codemirror.net/6/docs/ref/#state.EditorState.charCategorizer) or non-letter
  non-whitespace characters.
  */
  moveByGroup(e, t) {
    return ia(this, e, Sp(this, e, t, (l) => Iw(this, e.head, l)));
  }
  /**
  Move to the next line boundary in the given direction. If
  `includeWrap` is true, line wrapping is on, and there is a
  further wrap point on the current line, the wrap point will be
  returned. Otherwise this function will return the start or end
  of the line.
  */
  moveToLineBoundary(e, t, l = !0) {
    return jw(this, e, t, l);
  }
  /**
  Move a cursor position vertically. When `distance` isn't given,
  it defaults to moving to the next line (including wrapped
  lines). Otherwise, `distance` should provide a positive distance
  in pixels.
  
  When `start` has a
  [`goalColumn`](https://codemirror.net/6/docs/ref/#state.SelectionRange.goalColumn), the vertical
  motion will use that as a target horizontal position. Otherwise,
  the cursor's own horizontal position is used. The returned
  cursor will have its goal column set to whichever column was
  used.
  */
  moveVertically(e, t, l) {
    return ia(this, e, Uw(this, e, t, l));
  }
  /**
  Find the DOM parent node and offset (child offset if `node` is
  an element, character offset when it is a text node) at the
  given document position.
  
  Note that for positions that aren't currently in
  `visibleRanges`, the resulting DOM position isn't necessarily
  meaningful (it may just point before or after a placeholder
  element).
  */
  domAtPos(e) {
    return this.docView.domAtPos(e);
  }
  /**
  Find the document position at the given DOM node. Can be useful
  for associating positions with DOM events. Will raise an error
  when `node` isn't part of the editor content.
  */
  posAtDOM(e, t = 0) {
    return this.docView.posFromDOM(e, t);
  }
  posAtCoords(e, t = !0) {
    return this.readMeasured(), Tm(this, e, t);
  }
  /**
  Get the screen coordinates at the given document position.
  `side` determines whether the coordinates are based on the
  element before (-1) or after (1) the position (if no element is
  available on the given side, the method will transparently use
  another strategy to get reasonable coordinates).
  */
  coordsAtPos(e, t = 1) {
    this.readMeasured();
    let l = this.docView.coordsAt(e, t);
    if (!l || l.left == l.right)
      return l;
    let i = this.state.doc.lineAt(e), o = this.bidiSpans(i), n = o[Ul.find(o, e - i.from, -1, t)];
    return Pd(l, n.dir == Ce.LTR == t > 0);
  }
  /**
  The default width of a character in the editor. May not
  accurately reflect the width of all characters (given variable
  width fonts or styling of invididual ranges).
  */
  get defaultCharacterWidth() {
    return this.viewState.heightOracle.charWidth;
  }
  /**
  The default height of a line in the editor. May not be accurate
  for all lines.
  */
  get defaultLineHeight() {
    return this.viewState.heightOracle.lineHeight;
  }
  /**
  The text direction
  ([`direction`](https://developer.mozilla.org/en-US/docs/Web/CSS/direction)
  CSS property) of the editor's content element.
  */
  get textDirection() {
    return this.viewState.defaultTextDirection;
  }
  /**
  Find the text direction of the block at the given position, as
  assigned by CSS. If
  [`perLineTextDirection`](https://codemirror.net/6/docs/ref/#view.EditorView^perLineTextDirection)
  isn't enabled, or the given position is outside of the viewport,
  this will always return the same as
  [`textDirection`](https://codemirror.net/6/docs/ref/#view.EditorView.textDirection). Note that
  this may trigger a DOM layout.
  */
  textDirectionAt(e) {
    return !this.state.facet(vm) || e < this.viewport.from || e > this.viewport.to ? this.textDirection : (this.readMeasured(), this.docView.textDirectionAt(e));
  }
  /**
  Whether this editor [wraps lines](https://codemirror.net/6/docs/ref/#view.EditorView.lineWrapping)
  (as determined by the
  [`white-space`](https://developer.mozilla.org/en-US/docs/Web/CSS/white-space)
  CSS property of its content element).
  */
  get lineWrapping() {
    return this.viewState.heightOracle.lineWrapping;
  }
  /**
  Returns the bidirectional text structure of the given line
  (which should be in the current document) as an array of span
  objects. The order of these spans matches the [text
  direction](https://codemirror.net/6/docs/ref/#view.EditorView.textDirection)—if that is
  left-to-right, the leftmost spans come first, otherwise the
  rightmost spans come first.
  */
  bidiSpans(e) {
    if (e.length > Sy)
      return Sm(e.length);
    let t = this.textDirectionAt(e.from);
    for (let i of this.bidiCache)
      if (i.from == e.from && i.dir == t)
        return i.order;
    let l = Cw(e.text, t);
    return this.bidiCache.push(new Zn(e.from, e.to, t, l)), l;
  }
  /**
  Check whether the editor has focus.
  */
  get hasFocus() {
    var e;
    return (this.dom.ownerDocument.hasFocus() || M.safari && ((e = this.inputState) === null || e === void 0 ? void 0 : e.lastContextMenu) > Date.now() - 3e4) && this.root.activeElement == this.contentDOM;
  }
  /**
  Put focus on the editor.
  */
  focus() {
    this.observer.ignore(() => {
      tm(this.contentDOM), this.docView.updateSelection();
    });
  }
  /**
  Update the [root](https://codemirror.net/6/docs/ref/##view.EditorViewConfig.root) in which the editor lives. This is only
  necessary when moving the editor's existing DOM to a new window or shadow root.
  */
  setRoot(e) {
    this._root != e && (this._root = e, this.observer.setWindow((e.nodeType == 9 ? e : e.ownerDocument).defaultView || window), this.mountStyles());
  }
  /**
  Clean up this editor view, removing its element from the
  document, unregistering event handlers, and notifying
  plugins. The view instance can no longer be used after
  calling this.
  */
  destroy() {
    for (let e of this.plugins)
      e.destroy(this);
    this.plugins = [], this.inputState.destroy(), this.dom.remove(), this.observer.destroy(), this.measureScheduled > -1 && cancelAnimationFrame(this.measureScheduled), this.destroyed = !0;
  }
  /**
  Returns an effect that can be
  [added](https://codemirror.net/6/docs/ref/#state.TransactionSpec.effects) to a transaction to
  cause it to scroll the given position or range into view.
  */
  static scrollIntoView(e, t = {}) {
    return mp.of(new En(typeof e == "number" ? w.cursor(e) : e, t.y, t.x, t.yMargin, t.xMargin));
  }
  /**
  Returns an extension that can be used to add DOM event handlers.
  The value should be an object mapping event names to handler
  functions. For any given event, such functions are ordered by
  extension precedence, and the first handler to return true will
  be assumed to have handled that event, and no other handlers or
  built-in behavior will be activated for it. These are registered
  on the [content element](https://codemirror.net/6/docs/ref/#view.EditorView.contentDOM), except
  for `scroll` handlers, which will be called any time the
  editor's [scroll element](https://codemirror.net/6/docs/ref/#view.EditorView.scrollDOM) or one of
  its parent nodes is scrolled.
  */
  static domEventHandlers(e) {
    return Ze.define(() => ({}), { eventHandlers: e });
  }
  /**
  Create a theme extension. The first argument can be a
  [`style-mod`](https://github.com/marijnh/style-mod#documentation)
  style spec providing the styles for the theme. These will be
  prefixed with a generated class for the style.
  
  Because the selectors will be prefixed with a scope class, rule
  that directly match the editor's [wrapper
  element](https://codemirror.net/6/docs/ref/#view.EditorView.dom)—to which the scope class will be
  added—need to be explicitly differentiated by adding an `&` to
  the selector for that element—for example
  `&.cm-focused`.
  
  When `dark` is set to true, the theme will be marked as dark,
  which will cause the `&dark` rules from [base
  themes](https://codemirror.net/6/docs/ref/#view.EditorView^baseTheme) to be used (as opposed to
  `&light` when a light theme is active).
  */
  static theme(e, t) {
    let l = jr.newName(), i = [Ro.of(l), ki.of(Pc(`.${l}`, e))];
    return t && t.dark && i.push(Qc.of(!0)), i;
  }
  /**
  Create an extension that adds styles to the base theme. Like
  with [`theme`](https://codemirror.net/6/docs/ref/#view.EditorView^theme), use `&` to indicate the
  place of the editor wrapper element when directly targeting
  that. You can also use `&dark` or `&light` instead to only
  target editors with a dark or light theme.
  */
  static baseTheme(e) {
    return kl.lowest(ki.of(Pc("." + $c, e, Mm)));
  }
  /**
  Retrieve an editor view instance from the view's DOM
  representation.
  */
  static findFromDOM(e) {
    var t;
    let l = e.querySelector(".cm-content"), i = l && ye.get(l) || ye.get(e);
    return ((t = i == null ? void 0 : i.rootView) === null || t === void 0 ? void 0 : t.view) || null;
  }
}
I.styleModule = ki;
I.inputHandler = Om;
I.perLineTextDirection = vm;
I.exceptionSink = bm;
I.updateListener = xc;
I.editable = Ps;
I.mouseSelectionStyle = mm;
I.dragMovesSelection = gm;
I.clickAddsSelectionRange = fm;
I.decorations = Li;
I.atomicRanges = wm;
I.scrollMargins = ym;
I.darkTheme = Qc;
I.contentAttributes = Xd;
I.editorAttributes = _m;
I.lineWrapping = /* @__PURE__ */ I.contentAttributes.of({ class: "cm-lineWrapping" });
I.announce = /* @__PURE__ */ le.define();
const Sy = 4096, Wp = {};
class Zn {
  constructor(e, t, l, i) {
    this.from = e, this.to = t, this.dir = l, this.order = i;
  }
  static update(e, t) {
    if (t.empty)
      return e;
    let l = [], i = e.length ? e[e.length - 1].dir : Ce.LTR;
    for (let o = Math.max(0, e.length - 10); o < e.length; o++) {
      let n = e[o];
      n.dir == i && !t.touchesRange(n.from, n.to) && l.push(new Zn(t.mapPos(n.from, 1), t.mapPos(n.to, -1), n.dir, n.order));
    }
    return l;
  }
}
function Np(r, e, t) {
  for (let l = r.state.facet(e), i = l.length - 1; i >= 0; i--) {
    let o = l[i], n = typeof o == "function" ? o(r) : o;
    n && bc(n, t);
  }
  return t;
}
const Qy = M.mac ? "mac" : M.windows ? "win" : M.linux ? "linux" : "key";
function $y(r, e) {
  const t = r.split(/-(?!$)/);
  let l = t[t.length - 1];
  l == "Space" && (l = " ");
  let i, o, n, s;
  for (let a = 0; a < t.length - 1; ++a) {
    const c = t[a];
    if (/^(cmd|meta|m)$/i.test(c))
      s = !0;
    else if (/^a(lt)?$/i.test(c))
      i = !0;
    else if (/^(c|ctrl|control)$/i.test(c))
      o = !0;
    else if (/^s(hift)?$/i.test(c))
      n = !0;
    else if (/^mod$/i.test(c))
      e == "mac" ? s = !0 : o = !0;
    else
      throw new Error("Unrecognized modifier name: " + c);
  }
  return i && (l = "Alt-" + l), o && (l = "Ctrl-" + l), s && (l = "Meta-" + l), n && (l = "Shift-" + l), l;
}
function Do(r, e, t) {
  return e.altKey && (r = "Alt-" + r), e.ctrlKey && (r = "Ctrl-" + r), e.metaKey && (r = "Meta-" + r), t !== !1 && e.shiftKey && (r = "Shift-" + r), r;
}
const Py = /* @__PURE__ */ kl.default(/* @__PURE__ */ I.domEventHandlers({
  keydown(r, e) {
    return Im(jm(e.state), r, e, "editor");
  }
})), mo = /* @__PURE__ */ Y.define({ enables: Py }), Mp = /* @__PURE__ */ new WeakMap();
function jm(r) {
  let e = r.facet(mo), t = Mp.get(e);
  return t || Mp.set(e, t = zy(e.reduce((l, i) => l.concat(i), []))), t;
}
function Cy(r, e, t) {
  return Im(jm(r.state), e, r, t);
}
let $r = null;
const Ty = 4e3;
function zy(r, e = Qy) {
  let t = /* @__PURE__ */ Object.create(null), l = /* @__PURE__ */ Object.create(null), i = (n, s) => {
    let a = l[n];
    if (a == null)
      l[n] = s;
    else if (a != s)
      throw new Error("Key binding " + n + " is used both as a regular binding and as a multi-stroke prefix");
  }, o = (n, s, a, c) => {
    var d, h;
    let p = t[n] || (t[n] = /* @__PURE__ */ Object.create(null)), u = s.split(/ (?!$)/).map((O) => $y(O, e));
    for (let O = 1; O < u.length; O++) {
      let x = u.slice(0, O).join(" ");
      i(x, !0), p[x] || (p[x] = {
        preventDefault: !0,
        run: [(Q) => {
          let P = $r = { view: Q, prefix: x, scope: n };
          return setTimeout(() => {
            $r == P && ($r = null);
          }, Ty), !0;
        }]
      });
    }
    let f = u.join(" ");
    i(f, !1);
    let m = p[f] || (p[f] = { preventDefault: !1, run: ((h = (d = p._any) === null || d === void 0 ? void 0 : d.run) === null || h === void 0 ? void 0 : h.slice()) || [] });
    a && m.run.push(a), c && (m.preventDefault = !0);
  };
  for (let n of r) {
    let s = n.scope ? n.scope.split(" ") : ["editor"];
    if (n.any)
      for (let c of s) {
        let d = t[c] || (t[c] = /* @__PURE__ */ Object.create(null));
        d._any || (d._any = { preventDefault: !1, run: [] });
        for (let h in d)
          d[h].run.push(n.any);
      }
    let a = n[e] || n.key;
    if (a)
      for (let c of s)
        o(c, a, n.run, n.preventDefault), n.shift && o(c, "Shift-" + a, n.shift, n.preventDefault);
  }
  return t;
}
function Im(r, e, t, l) {
  let i = hw(e), o = Be(i, 0), n = xt(o) == i.length && i != " ", s = "", a = !1;
  $r && $r.view == t && $r.scope == l && (s = $r.prefix + " ", (a = Xm.indexOf(e.keyCode) < 0) && ($r = null));
  let c = /* @__PURE__ */ new Set(), d = (f) => {
    if (f) {
      for (let m of f.run)
        if (!c.has(m) && (c.add(m), m(t, e)))
          return !0;
      f.preventDefault && (a = !0);
    }
    return !1;
  }, h = r[l], p, u;
  if (h) {
    if (d(h[s + Do(i, e, !n)]))
      return !0;
    if (n && (e.altKey || e.metaKey || e.ctrlKey) && // Ctrl-Alt may be used for AltGr on Windows
    !(M.windows && e.ctrlKey && e.altKey) && (p = Ir[e.keyCode]) && p != i) {
      if (d(h[s + Do(p, e, !0)]))
        return !0;
      if (e.shiftKey && (u = Ui[e.keyCode]) != i && u != p && d(h[s + Do(u, e, !1)]))
        return !0;
    } else if (n && e.shiftKey && d(h[s + Do(i, e, !0)]))
      return !0;
    if (d(h._any))
      return !0;
  }
  return a;
}
class bo {
  /**
  Create a marker with the given class and dimensions. If `width`
  is null, the DOM element will get no width style.
  */
  constructor(e, t, l, i, o) {
    this.className = e, this.left = t, this.top = l, this.width = i, this.height = o;
  }
  draw() {
    let e = document.createElement("div");
    return e.className = this.className, this.adjust(e), e;
  }
  update(e, t) {
    return t.className != this.className ? !1 : (this.adjust(e), !0);
  }
  adjust(e) {
    e.style.left = this.left + "px", e.style.top = this.top + "px", this.width != null && (e.style.width = this.width + "px"), e.style.height = this.height + "px";
  }
  eq(e) {
    return this.left == e.left && this.top == e.top && this.width == e.width && this.height == e.height && this.className == e.className;
  }
  /**
  Create a set of rectangles for the given selection range,
  assigning them theclass`className`. Will create a single
  rectangle for empty ranges, and a set of selection-style
  rectangles covering the range's content (in a bidi-aware
  way) for non-empty ones.
  */
  static forRange(e, t, l) {
    if (l.empty) {
      let i = e.coordsAtPos(l.head, l.assoc || 1);
      if (!i)
        return [];
      let o = Um(e);
      return [new bo(t, i.left - o.left, i.top - o.top, null, i.bottom - i.top)];
    } else
      return Xy(e, t, l);
  }
}
function Um(r) {
  let e = r.scrollDOM.getBoundingClientRect();
  return { left: (r.textDirection == Ce.LTR ? e.left : e.right - r.scrollDOM.clientWidth) - r.scrollDOM.scrollLeft, top: e.top - r.scrollDOM.scrollTop };
}
function Yp(r, e, t) {
  let l = w.cursor(e);
  return {
    from: Math.max(t.from, r.moveToLineBoundary(l, !1, !0).from),
    to: Math.min(t.to, r.moveToLineBoundary(l, !0, !0).from),
    type: _e.Text
  };
}
function jp(r, e) {
  let t = r.lineBlockAt(e);
  if (Array.isArray(t.type)) {
    for (let l of t.type)
      if (l.to > e || l.to == e && (l.to == t.to || l.type == _e.Text))
        return l;
  }
  return t;
}
function Xy(r, e, t) {
  if (t.to <= r.viewport.from || t.from >= r.viewport.to)
    return [];
  let l = Math.max(t.from, r.viewport.from), i = Math.min(t.to, r.viewport.to), o = r.textDirection == Ce.LTR, n = r.contentDOM, s = n.getBoundingClientRect(), a = Um(r), c = window.getComputedStyle(n.firstChild), d = s.left + parseInt(c.paddingLeft) + Math.min(0, parseInt(c.textIndent)), h = s.right - parseInt(c.paddingRight), p = jp(r, l), u = jp(r, i), f = p.type == _e.Text ? p : null, m = u.type == _e.Text ? u : null;
  if (r.lineWrapping && (f && (f = Yp(r, l, f)), m && (m = Yp(r, i, m))), f && m && f.from == m.from)
    return x(Q(t.from, t.to, f));
  {
    let y = f ? Q(t.from, null, f) : P(p, !1), C = m ? Q(null, t.to, m) : P(u, !0), Z = [];
    return (f || p).to < (m || u).from - 1 ? Z.push(O(d, y.bottom, h, C.top)) : y.bottom < C.top && r.elementAtHeight((y.bottom + C.top) / 2).type == _e.Text && (y.bottom = C.top = (y.bottom + C.top) / 2), x(y).concat(Z).concat(x(C));
  }
  function O(y, C, Z, G) {
    return new bo(
      e,
      y - a.left,
      C - a.top - 0.01,
      Z - y,
      G - C + 0.01
      /* C.Epsilon */
    );
  }
  function x({ top: y, bottom: C, horizontal: Z }) {
    let G = [];
    for (let W = 0; W < Z.length; W += 2)
      G.push(O(Z[W], y, Z[W + 1], C));
    return G;
  }
  function Q(y, C, Z) {
    let G = 1e9, W = -1e9, D = [];
    function R(ie, fe, ae, H, K) {
      let q = r.coordsAtPos(ie, ie == Z.to ? -2 : 2), he = r.coordsAtPos(ae, ae == Z.from ? 2 : -2);
      G = Math.min(q.top, he.top, G), W = Math.max(q.bottom, he.bottom, W), K == Ce.LTR ? D.push(o && fe ? d : q.left, o && H ? h : he.right) : D.push(!o && H ? d : he.left, !o && fe ? h : q.right);
    }
    let F = y ?? Z.from, J = C ?? Z.to;
    for (let ie of r.visibleRanges)
      if (ie.to > F && ie.from < J)
        for (let fe = Math.max(ie.from, F), ae = Math.min(ie.to, J); ; ) {
          let H = r.state.doc.lineAt(fe);
          for (let K of r.bidiSpans(H)) {
            let q = K.from + H.from, he = K.to + H.from;
            if (q >= ae)
              break;
            he > fe && R(Math.max(q, fe), y == null && q <= F, Math.min(he, ae), C == null && he >= J, K.dir);
          }
          if (fe = H.to + 1, fe >= ae)
            break;
        }
    return D.length == 0 && R(F, y == null, J, C == null, r.textDirection), { top: G, bottom: W, horizontal: D };
  }
  function P(y, C) {
    let Z = s.top + (C ? y.top : y.bottom);
    return { top: Z, bottom: Z, horizontal: [] };
  }
}
function Ay(r, e) {
  return r.constructor == e.constructor && r.eq(e);
}
class Ey {
  constructor(e, t) {
    this.view = e, this.layer = t, this.drawn = [], this.measureReq = { read: this.measure.bind(this), write: this.draw.bind(this) }, this.dom = e.scrollDOM.appendChild(document.createElement("div")), this.dom.classList.add("cm-layer"), t.above && this.dom.classList.add("cm-layer-above"), t.class && this.dom.classList.add(t.class), this.dom.setAttribute("aria-hidden", "true"), this.setOrder(e.state), e.requestMeasure(this.measureReq), t.mount && t.mount(this.dom, e);
  }
  update(e) {
    e.startState.facet(hn) != e.state.facet(hn) && this.setOrder(e.state), (this.layer.update(e, this.dom) || e.geometryChanged) && e.view.requestMeasure(this.measureReq);
  }
  setOrder(e) {
    let t = 0, l = e.facet(hn);
    for (; t < l.length && l[t] != this.layer; )
      t++;
    this.dom.style.zIndex = String((this.layer.above ? 150 : -1) - t);
  }
  measure() {
    return this.layer.markers(this.view);
  }
  draw(e) {
    if (e.length != this.drawn.length || e.some((t, l) => !Ay(t, this.drawn[l]))) {
      let t = this.dom.firstChild, l = 0;
      for (let i of e)
        i.update && t && i.constructor && this.drawn[l].constructor && i.update(t, this.drawn[l]) ? (t = t.nextSibling, l++) : this.dom.insertBefore(i.draw(), t);
      for (; t; ) {
        let i = t.nextSibling;
        t.remove(), t = i;
      }
      this.drawn = e;
    }
  }
  destroy() {
    this.layer.destroy && this.layer.destroy(this.dom, this.view), this.dom.remove();
  }
}
const hn = /* @__PURE__ */ Y.define();
function qm(r) {
  return [
    Ze.define((e) => new Ey(e, r)),
    hn.of(r)
  ];
}
const Bm = !M.ios, Gi = /* @__PURE__ */ Y.define({
  combine(r) {
    return ir(r, {
      cursorBlinkRate: 1200,
      drawRangeCursor: !0
    }, {
      cursorBlinkRate: (e, t) => Math.min(e, t),
      drawRangeCursor: (e, t) => e || t
    });
  }
});
function Vy(r = {}) {
  return [
    Gi.of(r),
    Zy,
    Ry,
    Dy,
    xm.of(!0)
  ];
}
function Lm(r) {
  return r.startState.facet(Gi) != r.state.facet(Gi);
}
const Zy = /* @__PURE__ */ qm({
  above: !0,
  markers(r) {
    let { state: e } = r, t = e.facet(Gi), l = [];
    for (let i of e.selection.ranges) {
      let o = i == e.selection.main;
      if (i.empty ? !o || Bm : t.drawRangeCursor) {
        let n = o ? "cm-cursor cm-cursor-primary" : "cm-cursor cm-cursor-secondary", s = i.empty ? i : w.cursor(i.head, i.head > i.anchor ? -1 : 1);
        for (let a of bo.forRange(r, n, s))
          l.push(a);
      }
    }
    return l;
  },
  update(r, e) {
    r.transactions.some((l) => l.selection) && (e.style.animationName = e.style.animationName == "cm-blink" ? "cm-blink2" : "cm-blink");
    let t = Lm(r);
    return t && Ip(r.state, e), r.docChanged || r.selectionSet || t;
  },
  mount(r, e) {
    Ip(e.state, r);
  },
  class: "cm-cursorLayer"
});
function Ip(r, e) {
  e.style.animationDuration = r.facet(Gi).cursorBlinkRate + "ms";
}
const Ry = /* @__PURE__ */ qm({
  above: !1,
  markers(r) {
    return r.state.selection.ranges.map((e) => e.empty ? [] : bo.forRange(r, "cm-selectionBackground", e)).reduce((e, t) => e.concat(t));
  },
  update(r, e) {
    return r.docChanged || r.selectionSet || r.viewportChanged || Lm(r);
  },
  class: "cm-selectionLayer"
}), Gm = {
  ".cm-line": {
    "& ::selection": { backgroundColor: "transparent !important" },
    "&::selection": { backgroundColor: "transparent !important" }
  }
};
Bm && (Gm[".cm-line"].caretColor = "transparent !important");
const Dy = /* @__PURE__ */ kl.highest(/* @__PURE__ */ I.theme(Gm)), Fm = /* @__PURE__ */ le.define({
  map(r, e) {
    return r == null ? null : e.mapPos(r);
  }
}), Qi = /* @__PURE__ */ Ue.define({
  create() {
    return null;
  },
  update(r, e) {
    return r != null && (r = e.changes.mapPos(r)), e.effects.reduce((t, l) => l.is(Fm) ? l.value : t, r);
  }
}), Wy = /* @__PURE__ */ Ze.fromClass(class {
  constructor(r) {
    this.view = r, this.cursor = null, this.measureReq = { read: this.readPos.bind(this), write: this.drawCursor.bind(this) };
  }
  update(r) {
    var e;
    let t = r.state.field(Qi);
    t == null ? this.cursor != null && ((e = this.cursor) === null || e === void 0 || e.remove(), this.cursor = null) : (this.cursor || (this.cursor = this.view.scrollDOM.appendChild(document.createElement("div")), this.cursor.className = "cm-dropCursor"), (r.startState.field(Qi) != t || r.docChanged || r.geometryChanged) && this.view.requestMeasure(this.measureReq));
  }
  readPos() {
    let r = this.view.state.field(Qi), e = r != null && this.view.coordsAtPos(r);
    if (!e)
      return null;
    let t = this.view.scrollDOM.getBoundingClientRect();
    return {
      left: e.left - t.left + this.view.scrollDOM.scrollLeft,
      top: e.top - t.top + this.view.scrollDOM.scrollTop,
      height: e.bottom - e.top
    };
  }
  drawCursor(r) {
    this.cursor && (r ? (this.cursor.style.left = r.left + "px", this.cursor.style.top = r.top + "px", this.cursor.style.height = r.height + "px") : this.cursor.style.left = "-100000px");
  }
  destroy() {
    this.cursor && this.cursor.remove();
  }
  setDropPos(r) {
    this.view.state.field(Qi) != r && this.view.dispatch({ effects: Fm.of(r) });
  }
}, {
  eventHandlers: {
    dragover(r) {
      this.setDropPos(this.view.posAtCoords({ x: r.clientX, y: r.clientY }));
    },
    dragleave(r) {
      (r.target == this.view.contentDOM || !this.view.contentDOM.contains(r.relatedTarget)) && this.setDropPos(null);
    },
    dragend() {
      this.setDropPos(null);
    },
    drop() {
      this.setDropPos(null);
    }
  }
});
function Ny() {
  return [Qi, Wy];
}
function Up(r, e, t, l, i) {
  e.lastIndex = 0;
  for (let o = r.iterRange(t, l), n = t, s; !o.next().done; n += o.value.length)
    if (!o.lineBreak)
      for (; s = e.exec(o.value); )
        i(n + s.index, s);
}
function My(r, e) {
  let t = r.visibleRanges;
  if (t.length == 1 && t[0].from == r.viewport.from && t[0].to == r.viewport.to)
    return t;
  let l = [];
  for (let { from: i, to: o } of t)
    i = Math.max(r.state.doc.lineAt(i).from, i - e), o = Math.min(r.state.doc.lineAt(o).to, o + e), l.length && l[l.length - 1].to >= i ? l[l.length - 1].to = o : l.push({ from: i, to: o });
  return l;
}
class Yy {
  /**
  Create a decorator.
  */
  constructor(e) {
    const { regexp: t, decoration: l, decorate: i, boundary: o, maxLength: n = 1e3 } = e;
    if (!t.global)
      throw new RangeError("The regular expression given to MatchDecorator should have its 'g' flag set");
    if (this.regexp = t, i)
      this.addMatch = (s, a, c, d) => i(d, c, c + s[0].length, s, a);
    else if (typeof l == "function")
      this.addMatch = (s, a, c, d) => {
        let h = l(s, a, c);
        h && d(c, c + s[0].length, h);
      };
    else if (l)
      this.addMatch = (s, a, c, d) => d(c, c + s[0].length, l);
    else
      throw new RangeError("Either 'decorate' or 'decoration' should be provided to MatchDecorator");
    this.boundary = o, this.maxLength = n;
  }
  /**
  Compute the full set of decorations for matches in the given
  view's viewport. You'll want to call this when initializing your
  plugin.
  */
  createDeco(e) {
    let t = new Yr(), l = t.add.bind(t);
    for (let { from: i, to: o } of My(e, this.maxLength))
      Up(e.state.doc, this.regexp, i, o, (n, s) => this.addMatch(s, e, n, l));
    return t.finish();
  }
  /**
  Update a set of decorations for a view update. `deco` _must_ be
  the set of decorations produced by _this_ `MatchDecorator` for
  the view state before the update.
  */
  updateDeco(e, t) {
    let l = 1e9, i = -1;
    return e.docChanged && e.changes.iterChanges((o, n, s, a) => {
      a > e.view.viewport.from && s < e.view.viewport.to && (l = Math.min(s, l), i = Math.max(a, i));
    }), e.viewportChanged || i - l > 1e3 ? this.createDeco(e.view) : i > -1 ? this.updateRange(e.view, t.map(e.changes), l, i) : t;
  }
  updateRange(e, t, l, i) {
    for (let o of e.visibleRanges) {
      let n = Math.max(o.from, l), s = Math.min(o.to, i);
      if (s > n) {
        let a = e.state.doc.lineAt(n), c = a.to < s ? e.state.doc.lineAt(s) : a, d = Math.max(o.from, a.from), h = Math.min(o.to, c.to);
        if (this.boundary) {
          for (; n > a.from; n--)
            if (this.boundary.test(a.text[n - 1 - a.from])) {
              d = n;
              break;
            }
          for (; s < c.to; s++)
            if (this.boundary.test(c.text[s - c.from])) {
              h = s;
              break;
            }
        }
        let p = [], u, f = (m, O, x) => p.push(x.range(m, O));
        if (a == c)
          for (this.regexp.lastIndex = d - a.from; (u = this.regexp.exec(a.text)) && u.index < h - a.from; )
            this.addMatch(u, e, u.index + a.from, f);
        else
          Up(e.state.doc, this.regexp, d, h, (m, O) => this.addMatch(O, e, m, f));
        t = t.update({ filterFrom: d, filterTo: h, filter: (m, O) => m < d || O > h, add: p });
      }
    }
    return t;
  }
}
const Cc = /x/.unicode != null ? "gu" : "g", jy = /* @__PURE__ */ new RegExp(`[\0-\b
--­؜​‎‏\u2028\u2029‭‮⁦⁧⁩\uFEFF￹-￼]`, Cc), Iy = {
  0: "null",
  7: "bell",
  8: "backspace",
  10: "newline",
  11: "vertical tab",
  13: "carriage return",
  27: "escape",
  8203: "zero width space",
  8204: "zero width non-joiner",
  8205: "zero width joiner",
  8206: "left-to-right mark",
  8207: "right-to-left mark",
  8232: "line separator",
  8237: "left-to-right override",
  8238: "right-to-left override",
  8294: "left-to-right isolate",
  8295: "right-to-left isolate",
  8297: "pop directional isolate",
  8233: "paragraph separator",
  65279: "zero width no-break space",
  65532: "object replacement"
};
let sa = null;
function Uy() {
  var r;
  if (sa == null && typeof document < "u" && document.body) {
    let e = document.body.style;
    sa = ((r = e.tabSize) !== null && r !== void 0 ? r : e.MozTabSize) != null;
  }
  return sa || !1;
}
const pn = /* @__PURE__ */ Y.define({
  combine(r) {
    let e = ir(r, {
      render: null,
      specialChars: jy,
      addSpecialChars: null
    });
    return (e.replaceTabs = !Uy()) && (e.specialChars = new RegExp("	|" + e.specialChars.source, Cc)), e.addSpecialChars && (e.specialChars = new RegExp(e.specialChars.source + "|" + e.addSpecialChars.source, Cc)), e;
  }
});
function qy(r = {}) {
  return [pn.of(r), By()];
}
let qp = null;
function By() {
  return qp || (qp = Ze.fromClass(class {
    constructor(r) {
      this.view = r, this.decorations = B.none, this.decorationCache = /* @__PURE__ */ Object.create(null), this.decorator = this.makeDecorator(r.state.facet(pn)), this.decorations = this.decorator.createDeco(r);
    }
    makeDecorator(r) {
      return new Yy({
        regexp: r.specialChars,
        decoration: (e, t, l) => {
          let { doc: i } = t.state, o = Be(e[0], 0);
          if (o == 9) {
            let n = i.lineAt(l), s = t.state.tabSize, a = fo(n.text, s, l - n.from);
            return B.replace({ widget: new Hy((s - a % s) * this.view.defaultCharacterWidth) });
          }
          return this.decorationCache[o] || (this.decorationCache[o] = B.replace({ widget: new Fy(r, o) }));
        },
        boundary: r.replaceTabs ? void 0 : /[^]/
      });
    }
    update(r) {
      let e = r.state.facet(pn);
      r.startState.facet(pn) != e ? (this.decorator = this.makeDecorator(e), this.decorations = this.decorator.createDeco(r.view)) : this.decorations = this.decorator.updateDeco(r, this.decorations);
    }
  }, {
    decorations: (r) => r.decorations
  }));
}
const Ly = "•";
function Gy(r) {
  return r >= 32 ? Ly : r == 10 ? "␤" : String.fromCharCode(9216 + r);
}
class Fy extends br {
  constructor(e, t) {
    super(), this.options = e, this.code = t;
  }
  eq(e) {
    return e.code == this.code;
  }
  toDOM(e) {
    let t = Gy(this.code), l = e.state.phrase("Control character") + " " + (Iy[this.code] || "0x" + this.code.toString(16)), i = this.options.render && this.options.render(this.code, l, t);
    if (i)
      return i;
    let o = document.createElement("span");
    return o.textContent = t, o.title = l, o.setAttribute("aria-label", l), o.className = "cm-specialChar", o;
  }
  ignoreEvent() {
    return !1;
  }
}
class Hy extends br {
  constructor(e) {
    super(), this.width = e;
  }
  eq(e) {
    return e.width == this.width;
  }
  toDOM() {
    let e = document.createElement("span");
    return e.textContent = "	", e.className = "cm-tab", e.style.width = this.width + "px", e;
  }
  ignoreEvent() {
    return !1;
  }
}
function Ky() {
  return ek;
}
const Jy = /* @__PURE__ */ B.line({ class: "cm-activeLine" }), ek = /* @__PURE__ */ Ze.fromClass(class {
  constructor(r) {
    this.decorations = this.getDeco(r);
  }
  update(r) {
    (r.docChanged || r.selectionSet) && (this.decorations = this.getDeco(r.view));
  }
  getDeco(r) {
    let e = -1, t = [];
    for (let l of r.state.selection.ranges) {
      let i = r.lineBlockAt(l.head);
      i.from > e && (t.push(Jy.range(i.from)), e = i.from);
    }
    return B.set(t);
  }
}, {
  decorations: (r) => r.decorations
}), Tc = 2e3;
function tk(r, e, t) {
  let l = Math.min(e.line, t.line), i = Math.max(e.line, t.line), o = [];
  if (e.off > Tc || t.off > Tc || e.col < 0 || t.col < 0) {
    let n = Math.min(e.off, t.off), s = Math.max(e.off, t.off);
    for (let a = l; a <= i; a++) {
      let c = r.doc.line(a);
      c.length <= s && o.push(w.range(c.from + n, c.to + s));
    }
  } else {
    let n = Math.min(e.col, t.col), s = Math.max(e.col, t.col);
    for (let a = l; a <= i; a++) {
      let c = r.doc.line(a), d = cc(c.text, n, r.tabSize, !0);
      if (d < 0)
        o.push(w.cursor(c.to));
      else {
        let h = cc(c.text, s, r.tabSize);
        o.push(w.range(c.from + d, c.from + h));
      }
    }
  }
  return o;
}
function rk(r, e) {
  let t = r.coordsAtPos(r.viewport.from);
  return t ? Math.round(Math.abs((t.left - e) / r.defaultCharacterWidth)) : -1;
}
function Bp(r, e) {
  let t = r.posAtCoords({ x: e.clientX, y: e.clientY }, !1), l = r.state.doc.lineAt(t), i = t - l.from, o = i > Tc ? -1 : i == l.length ? rk(r, e.clientX) : fo(l.text, r.state.tabSize, t - l.from);
  return { line: l.number, col: o, off: i };
}
function lk(r, e) {
  let t = Bp(r, e), l = r.state.selection;
  return t ? {
    update(i) {
      if (i.docChanged) {
        let o = i.changes.mapPos(i.startState.doc.line(t.line).from), n = i.state.doc.lineAt(o);
        t = { line: n.number, col: t.col, off: Math.min(t.off, n.length) }, l = l.map(i.changes);
      }
    },
    get(i, o, n) {
      let s = Bp(r, i);
      if (!s)
        return l;
      let a = tk(r.state, t, s);
      return a.length ? n ? w.create(a.concat(l.ranges)) : w.create(a) : l;
    }
  } : null;
}
function ik(r) {
  let e = (r == null ? void 0 : r.eventFilter) || ((t) => t.altKey && t.button == 0);
  return I.mouseSelectionStyle.of((t, l) => e(l) ? lk(t, l) : null);
}
const ok = {
  Alt: [18, (r) => r.altKey],
  Control: [17, (r) => r.ctrlKey],
  Shift: [16, (r) => r.shiftKey],
  Meta: [91, (r) => r.metaKey]
}, nk = { style: "cursor: crosshair" };
function sk(r = {}) {
  let [e, t] = ok[r.key || "Alt"], l = Ze.fromClass(class {
    constructor(i) {
      this.view = i, this.isDown = !1;
    }
    set(i) {
      this.isDown != i && (this.isDown = i, this.view.update([]));
    }
  }, {
    eventHandlers: {
      keydown(i) {
        this.set(i.keyCode == e || t(i));
      },
      keyup(i) {
        (i.keyCode == e || !t(i)) && this.set(!1);
      },
      mousemove(i) {
        this.set(t(i));
      }
    }
  });
  return [
    l,
    I.contentAttributes.of((i) => {
      var o;
      return !((o = i.plugin(l)) === null || o === void 0) && o.isDown ? nk : null;
    })
  ];
}
const Wo = "-10000px";
class Hm {
  constructor(e, t, l) {
    this.facet = t, this.createTooltipView = l, this.input = e.state.facet(t), this.tooltips = this.input.filter((i) => i), this.tooltipViews = this.tooltips.map(l);
  }
  update(e) {
    var t;
    let l = e.state.facet(this.facet), i = l.filter((n) => n);
    if (l === this.input) {
      for (let n of this.tooltipViews)
        n.update && n.update(e);
      return !1;
    }
    let o = [];
    for (let n = 0; n < i.length; n++) {
      let s = i[n], a = -1;
      if (s) {
        for (let c = 0; c < this.tooltips.length; c++) {
          let d = this.tooltips[c];
          d && d.create == s.create && (a = c);
        }
        if (a < 0)
          o[n] = this.createTooltipView(s);
        else {
          let c = o[n] = this.tooltipViews[a];
          c.update && c.update(e);
        }
      }
    }
    for (let n of this.tooltipViews)
      o.indexOf(n) < 0 && (n.dom.remove(), (t = n.destroy) === null || t === void 0 || t.call(n));
    return this.input = l, this.tooltips = i, this.tooltipViews = o, !0;
  }
}
function ak(r) {
  let { win: e } = r;
  return { top: 0, left: 0, bottom: e.innerHeight, right: e.innerWidth };
}
const aa = /* @__PURE__ */ Y.define({
  combine: (r) => {
    var e, t, l;
    return {
      position: M.ios ? "absolute" : ((e = r.find((i) => i.position)) === null || e === void 0 ? void 0 : e.position) || "fixed",
      parent: ((t = r.find((i) => i.parent)) === null || t === void 0 ? void 0 : t.parent) || null,
      tooltipSpace: ((l = r.find((i) => i.tooltipSpace)) === null || l === void 0 ? void 0 : l.tooltipSpace) || ak
    };
  }
}), Km = /* @__PURE__ */ Ze.fromClass(class {
  constructor(r) {
    this.view = r, this.inView = !0, this.lastTransaction = 0, this.measureTimeout = -1;
    let e = r.state.facet(aa);
    this.position = e.position, this.parent = e.parent, this.classes = r.themeClasses, this.createContainer(), this.measureReq = { read: this.readMeasure.bind(this), write: this.writeMeasure.bind(this), key: this }, this.manager = new Hm(r, Ed, (t) => this.createTooltip(t)), this.intersectionObserver = typeof IntersectionObserver == "function" ? new IntersectionObserver((t) => {
      Date.now() > this.lastTransaction - 50 && t.length > 0 && t[t.length - 1].intersectionRatio < 1 && this.measureSoon();
    }, { threshold: [1] }) : null, this.observeIntersection(), r.win.addEventListener("resize", this.measureSoon = this.measureSoon.bind(this)), this.maybeMeasure();
  }
  createContainer() {
    this.parent ? (this.container = document.createElement("div"), this.container.style.position = "relative", this.container.className = this.view.themeClasses, this.parent.appendChild(this.container)) : this.container = this.view.dom;
  }
  observeIntersection() {
    if (this.intersectionObserver) {
      this.intersectionObserver.disconnect();
      for (let r of this.manager.tooltipViews)
        this.intersectionObserver.observe(r.dom);
    }
  }
  measureSoon() {
    this.measureTimeout < 0 && (this.measureTimeout = setTimeout(() => {
      this.measureTimeout = -1, this.maybeMeasure();
    }, 50));
  }
  update(r) {
    r.transactions.length && (this.lastTransaction = Date.now());
    let e = this.manager.update(r);
    e && this.observeIntersection();
    let t = e || r.geometryChanged, l = r.state.facet(aa);
    if (l.position != this.position) {
      this.position = l.position;
      for (let i of this.manager.tooltipViews)
        i.dom.style.position = this.position;
      t = !0;
    }
    if (l.parent != this.parent) {
      this.parent && this.container.remove(), this.parent = l.parent, this.createContainer();
      for (let i of this.manager.tooltipViews)
        this.container.appendChild(i.dom);
      t = !0;
    } else
      this.parent && this.view.themeClasses != this.classes && (this.classes = this.container.className = this.view.themeClasses);
    t && this.maybeMeasure();
  }
  createTooltip(r) {
    let e = r.create(this.view);
    if (e.dom.classList.add("cm-tooltip"), r.arrow && !e.dom.querySelector(".cm-tooltip > .cm-tooltip-arrow")) {
      let t = document.createElement("div");
      t.className = "cm-tooltip-arrow", e.dom.appendChild(t);
    }
    return e.dom.style.position = this.position, e.dom.style.top = Wo, this.container.appendChild(e.dom), e.mount && e.mount(this.view), e;
  }
  destroy() {
    var r, e;
    this.view.win.removeEventListener("resize", this.measureSoon);
    for (let t of this.manager.tooltipViews)
      t.dom.remove(), (r = t.destroy) === null || r === void 0 || r.call(t);
    (e = this.intersectionObserver) === null || e === void 0 || e.disconnect(), clearTimeout(this.measureTimeout);
  }
  readMeasure() {
    let r = this.view.dom.getBoundingClientRect();
    return {
      editor: r,
      parent: this.parent ? this.container.getBoundingClientRect() : r,
      pos: this.manager.tooltips.map((e, t) => {
        let l = this.manager.tooltipViews[t];
        return l.getCoords ? l.getCoords(e.pos) : this.view.coordsAtPos(e.pos);
      }),
      size: this.manager.tooltipViews.map(({ dom: e }) => e.getBoundingClientRect()),
      space: this.view.state.facet(aa).tooltipSpace(this.view)
    };
  }
  writeMeasure(r) {
    let { editor: e, space: t } = r, l = [];
    for (let i = 0; i < this.manager.tooltips.length; i++) {
      let o = this.manager.tooltips[i], n = this.manager.tooltipViews[i], { dom: s } = n, a = r.pos[i], c = r.size[i];
      if (!a || a.bottom <= Math.max(e.top, t.top) || a.top >= Math.min(e.bottom, t.bottom) || a.right < Math.max(e.left, t.left) - 0.1 || a.left > Math.min(e.right, t.right) + 0.1) {
        s.style.top = Wo;
        continue;
      }
      let d = o.arrow ? n.dom.querySelector(".cm-tooltip-arrow") : null, h = d ? 7 : 0, p = c.right - c.left, u = c.bottom - c.top, f = n.offset || dk, m = this.view.textDirection == Ce.LTR, O = c.width > t.right - t.left ? m ? t.left : t.right - c.width : m ? Math.min(a.left - (d ? 14 : 0) + f.x, t.right - p) : Math.max(t.left, a.left - p + (d ? 14 : 0) - f.x), x = !!o.above;
      !o.strictSide && (x ? a.top - (c.bottom - c.top) - f.y < t.top : a.bottom + (c.bottom - c.top) + f.y > t.bottom) && x == t.bottom - a.bottom > a.top - t.top && (x = !x);
      let Q = (x ? a.top - t.top : t.bottom - a.bottom) - h;
      if (Q < u && n.resize !== !1) {
        if (Q < this.view.defaultLineHeight) {
          s.style.top = Wo;
          continue;
        }
        s.style.height = (u = Q) + "px";
      } else
        s.style.height && (s.style.height = "");
      let P = x ? a.top - u - h - f.y : a.bottom + h + f.y, y = O + p;
      if (n.overlap !== !0)
        for (let C of l)
          C.left < y && C.right > O && C.top < P + u && C.bottom > P && (P = x ? C.top - u - 2 - h : C.bottom + h + 2);
      this.position == "absolute" ? (s.style.top = P - r.parent.top + "px", s.style.left = O - r.parent.left + "px") : (s.style.top = P + "px", s.style.left = O + "px"), d && (d.style.left = `${a.left + (m ? f.x : -f.x) - (O + 14 - 7)}px`), n.overlap !== !0 && l.push({ left: O, top: P, right: y, bottom: P + u }), s.classList.toggle("cm-tooltip-above", x), s.classList.toggle("cm-tooltip-below", !x), n.positioned && n.positioned(r.space);
    }
  }
  maybeMeasure() {
    if (this.manager.tooltips.length && (this.view.inView && this.view.requestMeasure(this.measureReq), this.inView != this.view.inView && (this.inView = this.view.inView, !this.inView)))
      for (let r of this.manager.tooltipViews)
        r.dom.style.top = Wo;
  }
}, {
  eventHandlers: {
    scroll() {
      this.maybeMeasure();
    }
  }
}), ck = /* @__PURE__ */ I.baseTheme({
  ".cm-tooltip": {
    zIndex: 100,
    boxSizing: "border-box"
  },
  "&light .cm-tooltip": {
    border: "1px solid #bbb",
    backgroundColor: "#f5f5f5"
  },
  "&light .cm-tooltip-section:not(:first-child)": {
    borderTop: "1px solid #bbb"
  },
  "&dark .cm-tooltip": {
    backgroundColor: "#333338",
    color: "white"
  },
  ".cm-tooltip-arrow": {
    height: `${7}px`,
    width: `${7 * 2}px`,
    position: "absolute",
    zIndex: -1,
    overflow: "hidden",
    "&:before, &:after": {
      content: "''",
      position: "absolute",
      width: 0,
      height: 0,
      borderLeft: `${7}px solid transparent`,
      borderRight: `${7}px solid transparent`
    },
    ".cm-tooltip-above &": {
      bottom: `-${7}px`,
      "&:before": {
        borderTop: `${7}px solid #bbb`
      },
      "&:after": {
        borderTop: `${7}px solid #f5f5f5`,
        bottom: "1px"
      }
    },
    ".cm-tooltip-below &": {
      top: `-${7}px`,
      "&:before": {
        borderBottom: `${7}px solid #bbb`
      },
      "&:after": {
        borderBottom: `${7}px solid #f5f5f5`,
        top: "1px"
      }
    }
  },
  "&dark .cm-tooltip .cm-tooltip-arrow": {
    "&:before": {
      borderTopColor: "#333338",
      borderBottomColor: "#333338"
    },
    "&:after": {
      borderTopColor: "transparent",
      borderBottomColor: "transparent"
    }
  }
}), dk = { x: 0, y: 0 }, Ed = /* @__PURE__ */ Y.define({
  enables: [Km, ck]
}), Rn = /* @__PURE__ */ Y.define();
class Vd {
  constructor(e) {
    this.view = e, this.mounted = !1, this.dom = document.createElement("div"), this.dom.classList.add("cm-tooltip-hover"), this.manager = new Hm(e, Rn, (t) => this.createHostedView(t));
  }
  // Needs to be static so that host tooltip instances always match
  static create(e) {
    return new Vd(e);
  }
  createHostedView(e) {
    let t = e.create(this.view);
    return t.dom.classList.add("cm-tooltip-section"), this.dom.appendChild(t.dom), this.mounted && t.mount && t.mount(this.view), t;
  }
  mount(e) {
    for (let t of this.manager.tooltipViews)
      t.mount && t.mount(e);
    this.mounted = !0;
  }
  positioned(e) {
    for (let t of this.manager.tooltipViews)
      t.positioned && t.positioned(e);
  }
  update(e) {
    this.manager.update(e);
  }
}
const hk = /* @__PURE__ */ Ed.compute([Rn], (r) => {
  let e = r.facet(Rn).filter((t) => t);
  return e.length === 0 ? null : {
    pos: Math.min(...e.map((t) => t.pos)),
    end: Math.max(...e.filter((t) => t.end != null).map((t) => t.end)),
    create: Vd.create,
    above: e[0].above,
    arrow: e.some((t) => t.arrow)
  };
});
class pk {
  constructor(e, t, l, i, o) {
    this.view = e, this.source = t, this.field = l, this.setHover = i, this.hoverTime = o, this.hoverTimeout = -1, this.restartTimeout = -1, this.pending = null, this.lastMove = { x: 0, y: 0, target: e.dom, time: 0 }, this.checkHover = this.checkHover.bind(this), e.dom.addEventListener("mouseleave", this.mouseleave = this.mouseleave.bind(this)), e.dom.addEventListener("mousemove", this.mousemove = this.mousemove.bind(this));
  }
  update() {
    this.pending && (this.pending = null, clearTimeout(this.restartTimeout), this.restartTimeout = setTimeout(() => this.startHover(), 20));
  }
  get active() {
    return this.view.state.field(this.field);
  }
  checkHover() {
    if (this.hoverTimeout = -1, this.active)
      return;
    let e = Date.now() - this.lastMove.time;
    e < this.hoverTime ? this.hoverTimeout = setTimeout(this.checkHover, this.hoverTime - e) : this.startHover();
  }
  startHover() {
    clearTimeout(this.restartTimeout);
    let { lastMove: e } = this, t = this.view.contentDOM.contains(e.target) ? this.view.posAtCoords(e) : null;
    if (t == null)
      return;
    let l = this.view.coordsAtPos(t);
    if (l == null || e.y < l.top || e.y > l.bottom || e.x < l.left - this.view.defaultCharacterWidth || e.x > l.right + this.view.defaultCharacterWidth)
      return;
    let i = this.view.bidiSpans(this.view.state.doc.lineAt(t)).find((s) => s.from <= t && s.to >= t), o = i && i.dir == Ce.RTL ? -1 : 1, n = this.source(this.view, t, e.x < l.left ? -o : o);
    if (n != null && n.then) {
      let s = this.pending = { pos: t };
      n.then((a) => {
        this.pending == s && (this.pending = null, a && this.view.dispatch({ effects: this.setHover.of(a) }));
      }, (a) => yt(this.view.state, a, "hover tooltip"));
    } else
      n && this.view.dispatch({ effects: this.setHover.of(n) });
  }
  mousemove(e) {
    var t;
    this.lastMove = { x: e.clientX, y: e.clientY, target: e.target, time: Date.now() }, this.hoverTimeout < 0 && (this.hoverTimeout = setTimeout(this.checkHover, this.hoverTime));
    let l = this.active;
    if (l && !Lp(this.lastMove.target) || this.pending) {
      let { pos: i } = l || this.pending, o = (t = l == null ? void 0 : l.end) !== null && t !== void 0 ? t : i;
      (i == o ? this.view.posAtCoords(this.lastMove) != i : !uk(
        this.view,
        i,
        o,
        e.clientX,
        e.clientY,
        6
        /* Hover.MaxDist */
      )) && (this.view.dispatch({ effects: this.setHover.of(null) }), this.pending = null);
    }
  }
  mouseleave(e) {
    clearTimeout(this.hoverTimeout), this.hoverTimeout = -1, this.active && !Lp(e.relatedTarget) && this.view.dispatch({ effects: this.setHover.of(null) });
  }
  destroy() {
    clearTimeout(this.hoverTimeout), this.view.dom.removeEventListener("mouseleave", this.mouseleave), this.view.dom.removeEventListener("mousemove", this.mousemove);
  }
}
function Lp(r) {
  for (let e = r; e; e = e.parentNode)
    if (e.nodeType == 1 && e.classList.contains("cm-tooltip"))
      return !0;
  return !1;
}
function uk(r, e, t, l, i, o) {
  let n = document.createRange(), s = r.domAtPos(e), a = r.domAtPos(t);
  n.setEnd(a.node, a.offset), n.setStart(s.node, s.offset);
  let c = n.getClientRects();
  n.detach();
  for (let d = 0; d < c.length; d++) {
    let h = c[d];
    if (Math.max(h.top - i, i - h.bottom, h.left - l, l - h.right) <= o)
      return !0;
  }
  return !1;
}
function fk(r, e = {}) {
  let t = le.define(), l = Ue.define({
    create() {
      return null;
    },
    update(i, o) {
      if (i && (e.hideOnChange && (o.docChanged || o.selection) || e.hideOn && e.hideOn(o, i)))
        return null;
      if (i && o.docChanged) {
        let n = o.changes.mapPos(i.pos, -1, Ge.TrackDel);
        if (n == null)
          return null;
        let s = Object.assign(/* @__PURE__ */ Object.create(null), i);
        s.pos = n, i.end != null && (s.end = o.changes.mapPos(i.end)), i = s;
      }
      for (let n of o.effects)
        n.is(t) && (i = n.value), n.is(mk) && (i = null);
      return i;
    },
    provide: (i) => Rn.from(i)
  });
  return [
    l,
    Ze.define((i) => new pk(
      i,
      r,
      l,
      t,
      e.hoverTime || 300
      /* Hover.Time */
    )),
    hk
  ];
}
function gk(r, e) {
  let t = r.plugin(Km);
  if (!t)
    return null;
  let l = t.manager.tooltips.indexOf(e);
  return l < 0 ? null : t.manager.tooltipViews[l];
}
const mk = /* @__PURE__ */ le.define(), Gp = /* @__PURE__ */ Y.define({
  combine(r) {
    let e, t;
    for (let l of r)
      e = e || l.topContainer, t = t || l.bottomContainer;
    return { topContainer: e, bottomContainer: t };
  }
});
function Fi(r, e) {
  let t = r.plugin(Jm), l = t ? t.specs.indexOf(e) : -1;
  return l > -1 ? t.panels[l] : null;
}
const Jm = /* @__PURE__ */ Ze.fromClass(class {
  constructor(r) {
    this.input = r.state.facet(Hi), this.specs = this.input.filter((t) => t), this.panels = this.specs.map((t) => t(r));
    let e = r.state.facet(Gp);
    this.top = new No(r, !0, e.topContainer), this.bottom = new No(r, !1, e.bottomContainer), this.top.sync(this.panels.filter((t) => t.top)), this.bottom.sync(this.panels.filter((t) => !t.top));
    for (let t of this.panels)
      t.dom.classList.add("cm-panel"), t.mount && t.mount();
  }
  update(r) {
    let e = r.state.facet(Gp);
    this.top.container != e.topContainer && (this.top.sync([]), this.top = new No(r.view, !0, e.topContainer)), this.bottom.container != e.bottomContainer && (this.bottom.sync([]), this.bottom = new No(r.view, !1, e.bottomContainer)), this.top.syncClasses(), this.bottom.syncClasses();
    let t = r.state.facet(Hi);
    if (t != this.input) {
      let l = t.filter((a) => a), i = [], o = [], n = [], s = [];
      for (let a of l) {
        let c = this.specs.indexOf(a), d;
        c < 0 ? (d = a(r.view), s.push(d)) : (d = this.panels[c], d.update && d.update(r)), i.push(d), (d.top ? o : n).push(d);
      }
      this.specs = l, this.panels = i, this.top.sync(o), this.bottom.sync(n);
      for (let a of s)
        a.dom.classList.add("cm-panel"), a.mount && a.mount();
    } else
      for (let l of this.panels)
        l.update && l.update(r);
  }
  destroy() {
    this.top.sync([]), this.bottom.sync([]);
  }
}, {
  provide: (r) => I.scrollMargins.of((e) => {
    let t = e.plugin(r);
    return t && { top: t.top.scrollMargin(), bottom: t.bottom.scrollMargin() };
  })
});
class No {
  constructor(e, t, l) {
    this.view = e, this.top = t, this.container = l, this.dom = void 0, this.classes = "", this.panels = [], this.syncClasses();
  }
  sync(e) {
    for (let t of this.panels)
      t.destroy && e.indexOf(t) < 0 && t.destroy();
    this.panels = e, this.syncDOM();
  }
  syncDOM() {
    if (this.panels.length == 0) {
      this.dom && (this.dom.remove(), this.dom = void 0);
      return;
    }
    if (!this.dom) {
      this.dom = document.createElement("div"), this.dom.className = this.top ? "cm-panels cm-panels-top" : "cm-panels cm-panels-bottom", this.dom.style[this.top ? "top" : "bottom"] = "0";
      let t = this.container || this.view.dom;
      t.insertBefore(this.dom, this.top ? t.firstChild : null);
    }
    let e = this.dom.firstChild;
    for (let t of this.panels)
      if (t.dom.parentNode == this.dom) {
        for (; e != t.dom; )
          e = Fp(e);
        e = e.nextSibling;
      } else
        this.dom.insertBefore(t.dom, e);
    for (; e; )
      e = Fp(e);
  }
  scrollMargin() {
    return !this.dom || this.container ? 0 : Math.max(0, this.top ? this.dom.getBoundingClientRect().bottom - Math.max(0, this.view.scrollDOM.getBoundingClientRect().top) : Math.min(innerHeight, this.view.scrollDOM.getBoundingClientRect().bottom) - this.dom.getBoundingClientRect().top);
  }
  syncClasses() {
    if (!(!this.container || this.classes == this.view.themeClasses)) {
      for (let e of this.classes.split(" "))
        e && this.container.classList.remove(e);
      for (let e of (this.classes = this.view.themeClasses).split(" "))
        e && this.container.classList.add(e);
    }
  }
}
function Fp(r) {
  let e = r.nextSibling;
  return r.remove(), e;
}
const Hi = /* @__PURE__ */ Y.define({
  enables: Jm
});
class fr extends Ol {
  /**
  @internal
  */
  compare(e) {
    return this == e || this.constructor == e.constructor && this.eq(e);
  }
  /**
  Compare this marker to another marker of the same type.
  */
  eq(e) {
    return !1;
  }
  /**
  Called if the marker has a `toDOM` method and its representation
  was removed from a gutter.
  */
  destroy(e) {
  }
}
fr.prototype.elementClass = "";
fr.prototype.toDOM = void 0;
fr.prototype.mapMode = Ge.TrackBefore;
fr.prototype.startSide = fr.prototype.endSide = -1;
fr.prototype.point = !0;
const un = /* @__PURE__ */ Y.define(), bk = {
  class: "",
  renderEmptyElements: !1,
  elementStyle: "",
  markers: () => ge.empty,
  lineMarker: () => null,
  lineMarkerChange: null,
  initialSpacer: null,
  updateSpacer: null,
  domEventHandlers: {}
}, Ei = /* @__PURE__ */ Y.define();
function Ok(r) {
  return [eb(), Ei.of(Object.assign(Object.assign({}, bk), r))];
}
const zc = /* @__PURE__ */ Y.define({
  combine: (r) => r.some((e) => e)
});
function eb(r) {
  let e = [
    vk
  ];
  return r && r.fixed === !1 && e.push(zc.of(!0)), e;
}
const vk = /* @__PURE__ */ Ze.fromClass(class {
  constructor(r) {
    this.view = r, this.prevViewport = r.viewport, this.dom = document.createElement("div"), this.dom.className = "cm-gutters", this.dom.setAttribute("aria-hidden", "true"), this.dom.style.minHeight = this.view.contentHeight + "px", this.gutters = r.state.facet(Ei).map((e) => new Kp(r, e));
    for (let e of this.gutters)
      this.dom.appendChild(e.dom);
    this.fixed = !r.state.facet(zc), this.fixed && (this.dom.style.position = "sticky"), this.syncGutters(!1), r.scrollDOM.insertBefore(this.dom, r.contentDOM);
  }
  update(r) {
    if (this.updateGutters(r)) {
      let e = this.prevViewport, t = r.view.viewport, l = Math.min(e.to, t.to) - Math.max(e.from, t.from);
      this.syncGutters(l < (t.to - t.from) * 0.8);
    }
    r.geometryChanged && (this.dom.style.minHeight = this.view.contentHeight + "px"), this.view.state.facet(zc) != !this.fixed && (this.fixed = !this.fixed, this.dom.style.position = this.fixed ? "sticky" : ""), this.prevViewport = r.view.viewport;
  }
  syncGutters(r) {
    let e = this.dom.nextSibling;
    r && this.dom.remove();
    let t = ge.iter(this.view.state.facet(un), this.view.viewport.from), l = [], i = this.gutters.map((o) => new xk(o, this.view.viewport, -this.view.documentPadding.top));
    for (let o of this.view.viewportLineBlocks) {
      let n;
      if (Array.isArray(o.type)) {
        for (let s of o.type)
          if (s.type == _e.Text) {
            n = s;
            break;
          }
      } else
        n = o.type == _e.Text ? o : void 0;
      if (n) {
        l.length && (l = []), tb(t, l, o.from);
        for (let s of i)
          s.line(this.view, n, l);
      }
    }
    for (let o of i)
      o.finish();
    r && this.view.scrollDOM.insertBefore(this.dom, e);
  }
  updateGutters(r) {
    let e = r.startState.facet(Ei), t = r.state.facet(Ei), l = r.docChanged || r.heightChanged || r.viewportChanged || !ge.eq(r.startState.facet(un), r.state.facet(un), r.view.viewport.from, r.view.viewport.to);
    if (e == t)
      for (let i of this.gutters)
        i.update(r) && (l = !0);
    else {
      l = !0;
      let i = [];
      for (let o of t) {
        let n = e.indexOf(o);
        n < 0 ? i.push(new Kp(this.view, o)) : (this.gutters[n].update(r), i.push(this.gutters[n]));
      }
      for (let o of this.gutters)
        o.dom.remove(), i.indexOf(o) < 0 && o.destroy();
      for (let o of i)
        this.dom.appendChild(o.dom);
      this.gutters = i;
    }
    return l;
  }
  destroy() {
    for (let r of this.gutters)
      r.destroy();
    this.dom.remove();
  }
}, {
  provide: (r) => I.scrollMargins.of((e) => {
    let t = e.plugin(r);
    return !t || t.gutters.length == 0 || !t.fixed ? null : e.textDirection == Ce.LTR ? { left: t.dom.offsetWidth } : { right: t.dom.offsetWidth };
  })
});
function Hp(r) {
  return Array.isArray(r) ? r : [r];
}
function tb(r, e, t) {
  for (; r.value && r.from <= t; )
    r.from == t && e.push(r.value), r.next();
}
class xk {
  constructor(e, t, l) {
    this.gutter = e, this.height = l, this.i = 0, this.cursor = ge.iter(e.markers, t.from);
  }
  line(e, t, l) {
    let i = [];
    tb(this.cursor, i, t.from), l.length && (i = i.concat(l));
    let o = this.gutter.config.lineMarker(e, t, i);
    o && i.unshift(o);
    let n = this.gutter;
    if (i.length == 0 && !n.config.renderEmptyElements)
      return;
    let s = t.top - this.height;
    if (this.i == n.elements.length) {
      let a = new rb(e, t.height, s, i);
      n.elements.push(a), n.dom.appendChild(a.dom);
    } else
      n.elements[this.i].update(e, t.height, s, i);
    this.height = t.bottom, this.i++;
  }
  finish() {
    let e = this.gutter;
    for (; e.elements.length > this.i; ) {
      let t = e.elements.pop();
      e.dom.removeChild(t.dom), t.destroy();
    }
  }
}
class Kp {
  constructor(e, t) {
    this.view = e, this.config = t, this.elements = [], this.spacer = null, this.dom = document.createElement("div"), this.dom.className = "cm-gutter" + (this.config.class ? " " + this.config.class : "");
    for (let l in t.domEventHandlers)
      this.dom.addEventListener(l, (i) => {
        let o = i.target, n;
        if (o != this.dom && this.dom.contains(o)) {
          for (; o.parentNode != this.dom; )
            o = o.parentNode;
          let a = o.getBoundingClientRect();
          n = (a.top + a.bottom) / 2;
        } else
          n = i.clientY;
        let s = e.lineBlockAtHeight(n - e.documentTop);
        t.domEventHandlers[l](e, s, i) && i.preventDefault();
      });
    this.markers = Hp(t.markers(e)), t.initialSpacer && (this.spacer = new rb(e, 0, 0, [t.initialSpacer(e)]), this.dom.appendChild(this.spacer.dom), this.spacer.dom.style.cssText += "visibility: hidden; pointer-events: none");
  }
  update(e) {
    let t = this.markers;
    if (this.markers = Hp(this.config.markers(e.view)), this.spacer && this.config.updateSpacer) {
      let i = this.config.updateSpacer(this.spacer.markers[0], e);
      i != this.spacer.markers[0] && this.spacer.update(e.view, 0, 0, [i]);
    }
    let l = e.view.viewport;
    return !ge.eq(this.markers, t, l.from, l.to) || (this.config.lineMarkerChange ? this.config.lineMarkerChange(e) : !1);
  }
  destroy() {
    for (let e of this.elements)
      e.destroy();
  }
}
class rb {
  constructor(e, t, l, i) {
    this.height = -1, this.above = 0, this.markers = [], this.dom = document.createElement("div"), this.dom.className = "cm-gutterElement", this.update(e, t, l, i);
  }
  update(e, t, l, i) {
    this.height != t && (this.dom.style.height = (this.height = t) + "px"), this.above != l && (this.dom.style.marginTop = (this.above = l) ? l + "px" : ""), _k(this.markers, i) || this.setMarkers(e, i);
  }
  setMarkers(e, t) {
    let l = "cm-gutterElement", i = this.dom.firstChild;
    for (let o = 0, n = 0; ; ) {
      let s = n, a = o < t.length ? t[o++] : null, c = !1;
      if (a) {
        let d = a.elementClass;
        d && (l += " " + d);
        for (let h = n; h < this.markers.length; h++)
          if (this.markers[h].compare(a)) {
            s = h, c = !0;
            break;
          }
      } else
        s = this.markers.length;
      for (; n < s; ) {
        let d = this.markers[n++];
        if (d.toDOM) {
          d.destroy(i);
          let h = i.nextSibling;
          i.remove(), i = h;
        }
      }
      if (!a)
        break;
      a.toDOM && (c ? i = i.nextSibling : this.dom.insertBefore(a.toDOM(e), i)), c && n++;
    }
    this.dom.className = l, this.markers = t;
  }
  destroy() {
    this.setMarkers(null, []);
  }
}
function _k(r, e) {
  if (r.length != e.length)
    return !1;
  for (let t = 0; t < r.length; t++)
    if (!r[t].compare(e[t]))
      return !1;
  return !0;
}
const wk = /* @__PURE__ */ Y.define(), Zl = /* @__PURE__ */ Y.define({
  combine(r) {
    return ir(r, { formatNumber: String, domEventHandlers: {} }, {
      domEventHandlers(e, t) {
        let l = Object.assign({}, e);
        for (let i in t) {
          let o = l[i], n = t[i];
          l[i] = o ? (s, a, c) => o(s, a, c) || n(s, a, c) : n;
        }
        return l;
      }
    });
  }
});
class ca extends fr {
  constructor(e) {
    super(), this.number = e;
  }
  eq(e) {
    return this.number == e.number;
  }
  toDOM() {
    return document.createTextNode(this.number);
  }
}
function da(r, e) {
  return r.state.facet(Zl).formatNumber(e, r.state);
}
const yk = /* @__PURE__ */ Ei.compute([Zl], (r) => ({
  class: "cm-lineNumbers",
  renderEmptyElements: !1,
  markers(e) {
    return e.state.facet(wk);
  },
  lineMarker(e, t, l) {
    return l.some((i) => i.toDOM) ? null : new ca(da(e, e.state.doc.lineAt(t.from).number));
  },
  lineMarkerChange: (e) => e.startState.facet(Zl) != e.state.facet(Zl),
  initialSpacer(e) {
    return new ca(da(e, Jp(e.state.doc.lines)));
  },
  updateSpacer(e, t) {
    let l = da(t.view, Jp(t.view.state.doc.lines));
    return l == e.number ? e : new ca(l);
  },
  domEventHandlers: r.facet(Zl).domEventHandlers
}));
function kk(r = {}) {
  return [
    Zl.of(r),
    eb(),
    yk
  ];
}
function Jp(r) {
  let e = 9;
  for (; e < r; )
    e = e * 10 + 9;
  return e;
}
const Sk = /* @__PURE__ */ new class extends fr {
  constructor() {
    super(...arguments), this.elementClass = "cm-activeLineGutter";
  }
}(), Qk = /* @__PURE__ */ un.compute(["selection"], (r) => {
  let e = [], t = -1;
  for (let l of r.selection.ranges) {
    let i = r.doc.lineAt(l.head).from;
    i > t && (t = i, e.push(Sk.range(i)));
  }
  return ge.of(e);
});
function $k() {
  return Qk;
}
const lb = 1024;
let Pk = 0;
class Qt {
  constructor(e, t) {
    this.from = e, this.to = t;
  }
}
class se {
  /// Create a new node prop type.
  constructor(e = {}) {
    this.id = Pk++, this.perNode = !!e.perNode, this.deserialize = e.deserialize || (() => {
      throw new Error("This node type doesn't define a deserialize function");
    });
  }
  /// This is meant to be used with
  /// [`NodeSet.extend`](#common.NodeSet.extend) or
  /// [`LRParser.configure`](#lr.ParserConfig.props) to compute
  /// prop values for each node type in the set. Takes a [match
  /// object](#common.NodeType^match) or function that returns undefined
  /// if the node type doesn't get this prop, and the prop's value if
  /// it does.
  add(e) {
    if (this.perNode)
      throw new RangeError("Can't add per-node props to node types");
    return typeof e != "function" && (e = ct.match(e)), (t) => {
      let l = e(t);
      return l === void 0 ? null : [this, l];
    };
  }
}
se.closedBy = new se({ deserialize: (r) => r.split(" ") });
se.openedBy = new se({ deserialize: (r) => r.split(" ") });
se.group = new se({ deserialize: (r) => r.split(" ") });
se.contextHash = new se({ perNode: !0 });
se.lookAhead = new se({ perNode: !0 });
se.mounted = new se({ perNode: !0 });
class Ck {
  constructor(e, t, l) {
    this.tree = e, this.overlay = t, this.parser = l;
  }
}
const Tk = /* @__PURE__ */ Object.create(null);
class ct {
  /// @internal
  constructor(e, t, l, i = 0) {
    this.name = e, this.props = t, this.id = l, this.flags = i;
  }
  /// Define a node type.
  static define(e) {
    let t = e.props && e.props.length ? /* @__PURE__ */ Object.create(null) : Tk, l = (e.top ? 1 : 0) | (e.skipped ? 2 : 0) | (e.error ? 4 : 0) | (e.name == null ? 8 : 0), i = new ct(e.name || "", t, e.id, l);
    if (e.props) {
      for (let o of e.props)
        if (Array.isArray(o) || (o = o(i)), o) {
          if (o[0].perNode)
            throw new RangeError("Can't store a per-node prop on a node type");
          t[o[0].id] = o[1];
        }
    }
    return i;
  }
  /// Retrieves a node prop for this type. Will return `undefined` if
  /// the prop isn't present on this node.
  prop(e) {
    return this.props[e.id];
  }
  /// True when this is the top node of a grammar.
  get isTop() {
    return (this.flags & 1) > 0;
  }
  /// True when this node is produced by a skip rule.
  get isSkipped() {
    return (this.flags & 2) > 0;
  }
  /// Indicates whether this is an error node.
  get isError() {
    return (this.flags & 4) > 0;
  }
  /// When true, this node type doesn't correspond to a user-declared
  /// named node, for example because it is used to cache repetition.
  get isAnonymous() {
    return (this.flags & 8) > 0;
  }
  /// Returns true when this node's name or one of its
  /// [groups](#common.NodeProp^group) matches the given string.
  is(e) {
    if (typeof e == "string") {
      if (this.name == e)
        return !0;
      let t = this.prop(se.group);
      return t ? t.indexOf(e) > -1 : !1;
    }
    return this.id == e;
  }
  /// Create a function from node types to arbitrary values by
  /// specifying an object whose property names are node or
  /// [group](#common.NodeProp^group) names. Often useful with
  /// [`NodeProp.add`](#common.NodeProp.add). You can put multiple
  /// names, separated by spaces, in a single property name to map
  /// multiple node names to a single value.
  static match(e) {
    let t = /* @__PURE__ */ Object.create(null);
    for (let l in e)
      for (let i of l.split(" "))
        t[i] = e[l];
    return (l) => {
      for (let i = l.prop(se.group), o = -1; o < (i ? i.length : 0); o++) {
        let n = t[o < 0 ? l.name : i[o]];
        if (n)
          return n;
      }
    };
  }
}
ct.none = new ct(
  "",
  /* @__PURE__ */ Object.create(null),
  0,
  8
  /* NodeFlag.Anonymous */
);
class Zd {
  /// Create a set with the given types. The `id` property of each
  /// type should correspond to its position within the array.
  constructor(e) {
    this.types = e;
    for (let t = 0; t < e.length; t++)
      if (e[t].id != t)
        throw new RangeError("Node type ids should correspond to array positions when creating a node set");
  }
  /// Create a copy of this set with some node properties added. The
  /// arguments to this method can be created with
  /// [`NodeProp.add`](#common.NodeProp.add).
  extend(...e) {
    let t = [];
    for (let l of this.types) {
      let i = null;
      for (let o of e) {
        let n = o(l);
        n && (i || (i = Object.assign({}, l.props)), i[n[0].id] = n[1]);
      }
      t.push(i ? new ct(l.name, i, l.id, l.flags) : l);
    }
    return new Zd(t);
  }
}
const Mo = /* @__PURE__ */ new WeakMap(), eu = /* @__PURE__ */ new WeakMap();
var Se;
(function(r) {
  r[r.ExcludeBuffers = 1] = "ExcludeBuffers", r[r.IncludeAnonymous = 2] = "IncludeAnonymous", r[r.IgnoreMounts = 4] = "IgnoreMounts", r[r.IgnoreOverlays = 8] = "IgnoreOverlays";
})(Se || (Se = {}));
class Te {
  /// Construct a new tree. See also [`Tree.build`](#common.Tree^build).
  constructor(e, t, l, i, o) {
    if (this.type = e, this.children = t, this.positions = l, this.length = i, this.props = null, o && o.length) {
      this.props = /* @__PURE__ */ Object.create(null);
      for (let [n, s] of o)
        this.props[typeof n == "number" ? n : n.id] = s;
    }
  }
  /// @internal
  toString() {
    let e = this.prop(se.mounted);
    if (e && !e.overlay)
      return e.tree.toString();
    let t = "";
    for (let l of this.children) {
      let i = l.toString();
      i && (t && (t += ","), t += i);
    }
    return this.type.name ? (/\W/.test(this.type.name) && !this.type.isError ? JSON.stringify(this.type.name) : this.type.name) + (t.length ? "(" + t + ")" : "") : t;
  }
  /// Get a [tree cursor](#common.TreeCursor) positioned at the top of
  /// the tree. Mode can be used to [control](#common.IterMode) which
  /// nodes the cursor visits.
  cursor(e = 0) {
    return new Ki(this.topNode, e);
  }
  /// Get a [tree cursor](#common.TreeCursor) pointing into this tree
  /// at the given position and side (see
  /// [`moveTo`](#common.TreeCursor.moveTo).
  cursorAt(e, t = 0, l = 0) {
    let i = Mo.get(this) || this.topNode, o = new Ki(i);
    return o.moveTo(e, t), Mo.set(this, o._tree), o;
  }
  /// Get a [syntax node](#common.SyntaxNode) object for the top of the
  /// tree.
  get topNode() {
    return new Pt(this, 0, 0, null);
  }
  /// Get the [syntax node](#common.SyntaxNode) at the given position.
  /// If `side` is -1, this will move into nodes that end at the
  /// position. If 1, it'll move into nodes that start at the
  /// position. With 0, it'll only enter nodes that cover the position
  /// from both sides.
  ///
  /// Note that this will not enter
  /// [overlays](#common.MountedTree.overlay), and you often want
  /// [`resolveInner`](#common.Tree.resolveInner) instead.
  resolve(e, t = 0) {
    let l = Jl(Mo.get(this) || this.topNode, e, t, !1);
    return Mo.set(this, l), l;
  }
  /// Like [`resolve`](#common.Tree.resolve), but will enter
  /// [overlaid](#common.MountedTree.overlay) nodes, producing a syntax node
  /// pointing into the innermost overlaid tree at the given position
  /// (with parent links going through all parent structure, including
  /// the host trees).
  resolveInner(e, t = 0) {
    let l = Jl(eu.get(this) || this.topNode, e, t, !0);
    return eu.set(this, l), l;
  }
  /// Iterate over the tree and its children, calling `enter` for any
  /// node that touches the `from`/`to` region (if given) before
  /// running over such a node's children, and `leave` (if given) when
  /// leaving the node. When `enter` returns `false`, that node will
  /// not have its children iterated over (or `leave` called).
  iterate(e) {
    let { enter: t, leave: l, from: i = 0, to: o = this.length } = e;
    for (let n = this.cursor((e.mode || 0) | Se.IncludeAnonymous); ; ) {
      let s = !1;
      if (n.from <= o && n.to >= i && (n.type.isAnonymous || t(n) !== !1)) {
        if (n.firstChild())
          continue;
        s = !0;
      }
      for (; s && l && !n.type.isAnonymous && l(n), !n.nextSibling(); ) {
        if (!n.parent())
          return;
        s = !0;
      }
    }
  }
  /// Get the value of the given [node prop](#common.NodeProp) for this
  /// node. Works with both per-node and per-type props.
  prop(e) {
    return e.perNode ? this.props ? this.props[e.id] : void 0 : this.type.prop(e);
  }
  /// Returns the node's [per-node props](#common.NodeProp.perNode) in a
  /// format that can be passed to the [`Tree`](#common.Tree)
  /// constructor.
  get propValues() {
    let e = [];
    if (this.props)
      for (let t in this.props)
        e.push([+t, this.props[t]]);
    return e;
  }
  /// Balance the direct children of this tree, producing a copy of
  /// which may have children grouped into subtrees with type
  /// [`NodeType.none`](#common.NodeType^none).
  balance(e = {}) {
    return this.children.length <= 8 ? this : Wd(ct.none, this.children, this.positions, 0, this.children.length, 0, this.length, (t, l, i) => new Te(this.type, t, l, i, this.propValues), e.makeTree || ((t, l, i) => new Te(ct.none, t, l, i)));
  }
  /// Build a tree from a postfix-ordered buffer of node information,
  /// or a cursor over such a buffer.
  static build(e) {
    return Xk(e);
  }
}
Te.empty = new Te(ct.none, [], [], 0);
class Rd {
  constructor(e, t) {
    this.buffer = e, this.index = t;
  }
  get id() {
    return this.buffer[this.index - 4];
  }
  get start() {
    return this.buffer[this.index - 3];
  }
  get end() {
    return this.buffer[this.index - 2];
  }
  get size() {
    return this.buffer[this.index - 1];
  }
  get pos() {
    return this.index;
  }
  next() {
    this.index -= 4;
  }
  fork() {
    return new Rd(this.buffer, this.index);
  }
}
class Sl {
  /// Create a tree buffer.
  constructor(e, t, l) {
    this.buffer = e, this.length = t, this.set = l;
  }
  /// @internal
  get type() {
    return ct.none;
  }
  /// @internal
  toString() {
    let e = [];
    for (let t = 0; t < this.buffer.length; )
      e.push(this.childString(t)), t = this.buffer[t + 3];
    return e.join(",");
  }
  /// @internal
  childString(e) {
    let t = this.buffer[e], l = this.buffer[e + 3], i = this.set.types[t], o = i.name;
    if (/\W/.test(o) && !i.isError && (o = JSON.stringify(o)), e += 4, l == e)
      return o;
    let n = [];
    for (; e < l; )
      n.push(this.childString(e)), e = this.buffer[e + 3];
    return o + "(" + n.join(",") + ")";
  }
  /// @internal
  findChild(e, t, l, i, o) {
    let { buffer: n } = this, s = -1;
    for (let a = e; a != t && !(ib(o, i, n[a + 1], n[a + 2]) && (s = a, l > 0)); a = n[a + 3])
      ;
    return s;
  }
  /// @internal
  slice(e, t, l) {
    let i = this.buffer, o = new Uint16Array(t - e), n = 0;
    for (let s = e, a = 0; s < t; ) {
      o[a++] = i[s++], o[a++] = i[s++] - l;
      let c = o[a++] = i[s++] - l;
      o[a++] = i[s++] - e, n = Math.max(n, c);
    }
    return new Sl(o, n, this.set);
  }
}
function ib(r, e, t, l) {
  switch (r) {
    case -2:
      return t < e;
    case -1:
      return l >= e && t < e;
    case 0:
      return t < e && l > e;
    case 1:
      return t <= e && l > e;
    case 2:
      return l > e;
    case 4:
      return !0;
  }
}
function ob(r, e) {
  let t = r.childBefore(e);
  for (; t; ) {
    let l = t.lastChild;
    if (!l || l.to != t.to)
      break;
    l.type.isError && l.from == l.to ? (r = t, t = l.prevSibling) : t = l;
  }
  return r;
}
function Jl(r, e, t, l) {
  for (var i; r.from == r.to || (t < 1 ? r.from >= e : r.from > e) || (t > -1 ? r.to <= e : r.to < e); ) {
    let n = !l && r instanceof Pt && r.index < 0 ? null : r.parent;
    if (!n)
      return r;
    r = n;
  }
  let o = l ? 0 : Se.IgnoreOverlays;
  if (l)
    for (let n = r, s = n.parent; s; n = s, s = n.parent)
      n instanceof Pt && n.index < 0 && ((i = s.enter(e, t, o)) === null || i === void 0 ? void 0 : i.from) != n.from && (r = s);
  for (; ; ) {
    let n = r.enter(e, t, o);
    if (!n)
      return r;
    r = n;
  }
}
class Pt {
  constructor(e, t, l, i) {
    this._tree = e, this.from = t, this.index = l, this._parent = i;
  }
  get type() {
    return this._tree.type;
  }
  get name() {
    return this._tree.type.name;
  }
  get to() {
    return this.from + this._tree.length;
  }
  nextChild(e, t, l, i, o = 0) {
    for (let n = this; ; ) {
      for (let { children: s, positions: a } = n._tree, c = t > 0 ? s.length : -1; e != c; e += t) {
        let d = s[e], h = a[e] + n.from;
        if (ib(i, l, h, h + d.length)) {
          if (d instanceof Sl) {
            if (o & Se.ExcludeBuffers)
              continue;
            let p = d.findChild(0, d.buffer.length, t, l - h, i);
            if (p > -1)
              return new Kt(new zk(n, d, e, h), null, p);
          } else if (o & Se.IncludeAnonymous || !d.type.isAnonymous || Dd(d)) {
            let p;
            if (!(o & Se.IgnoreMounts) && d.props && (p = d.prop(se.mounted)) && !p.overlay)
              return new Pt(p.tree, h, e, n);
            let u = new Pt(d, h, e, n);
            return o & Se.IncludeAnonymous || !u.type.isAnonymous ? u : u.nextChild(t < 0 ? d.children.length - 1 : 0, t, l, i);
          }
        }
      }
      if (o & Se.IncludeAnonymous || !n.type.isAnonymous || (n.index >= 0 ? e = n.index + t : e = t < 0 ? -1 : n._parent._tree.children.length, n = n._parent, !n))
        return null;
    }
  }
  get firstChild() {
    return this.nextChild(
      0,
      1,
      0,
      4
      /* Side.DontCare */
    );
  }
  get lastChild() {
    return this.nextChild(
      this._tree.children.length - 1,
      -1,
      0,
      4
      /* Side.DontCare */
    );
  }
  childAfter(e) {
    return this.nextChild(
      0,
      1,
      e,
      2
      /* Side.After */
    );
  }
  childBefore(e) {
    return this.nextChild(
      this._tree.children.length - 1,
      -1,
      e,
      -2
      /* Side.Before */
    );
  }
  enter(e, t, l = 0) {
    let i;
    if (!(l & Se.IgnoreOverlays) && (i = this._tree.prop(se.mounted)) && i.overlay) {
      let o = e - this.from;
      for (let { from: n, to: s } of i.overlay)
        if ((t > 0 ? n <= o : n < o) && (t < 0 ? s >= o : s > o))
          return new Pt(i.tree, i.overlay[0].from + this.from, -1, this);
    }
    return this.nextChild(0, 1, e, t, l);
  }
  nextSignificantParent() {
    let e = this;
    for (; e.type.isAnonymous && e._parent; )
      e = e._parent;
    return e;
  }
  get parent() {
    return this._parent ? this._parent.nextSignificantParent() : null;
  }
  get nextSibling() {
    return this._parent && this.index >= 0 ? this._parent.nextChild(
      this.index + 1,
      1,
      0,
      4
      /* Side.DontCare */
    ) : null;
  }
  get prevSibling() {
    return this._parent && this.index >= 0 ? this._parent.nextChild(
      this.index - 1,
      -1,
      0,
      4
      /* Side.DontCare */
    ) : null;
  }
  cursor(e = 0) {
    return new Ki(this, e);
  }
  get tree() {
    return this._tree;
  }
  toTree() {
    return this._tree;
  }
  resolve(e, t = 0) {
    return Jl(this, e, t, !1);
  }
  resolveInner(e, t = 0) {
    return Jl(this, e, t, !0);
  }
  enterUnfinishedNodesBefore(e) {
    return ob(this, e);
  }
  getChild(e, t = null, l = null) {
    let i = Dn(this, e, t, l);
    return i.length ? i[0] : null;
  }
  getChildren(e, t = null, l = null) {
    return Dn(this, e, t, l);
  }
  /// @internal
  toString() {
    return this._tree.toString();
  }
  get node() {
    return this;
  }
  matchContext(e) {
    return Wn(this, e);
  }
}
function Dn(r, e, t, l) {
  let i = r.cursor(), o = [];
  if (!i.firstChild())
    return o;
  if (t != null) {
    for (; !i.type.is(t); )
      if (!i.nextSibling())
        return o;
  }
  for (; ; ) {
    if (l != null && i.type.is(l))
      return o;
    if (i.type.is(e) && o.push(i.node), !i.nextSibling())
      return l == null ? o : [];
  }
}
function Wn(r, e, t = e.length - 1) {
  for (let l = r.parent; t >= 0; l = l.parent) {
    if (!l)
      return !1;
    if (!l.type.isAnonymous) {
      if (e[t] && e[t] != l.name)
        return !1;
      t--;
    }
  }
  return !0;
}
class zk {
  constructor(e, t, l, i) {
    this.parent = e, this.buffer = t, this.index = l, this.start = i;
  }
}
class Kt {
  get name() {
    return this.type.name;
  }
  get from() {
    return this.context.start + this.context.buffer.buffer[this.index + 1];
  }
  get to() {
    return this.context.start + this.context.buffer.buffer[this.index + 2];
  }
  constructor(e, t, l) {
    this.context = e, this._parent = t, this.index = l, this.type = e.buffer.set.types[e.buffer.buffer[l]];
  }
  child(e, t, l) {
    let { buffer: i } = this.context, o = i.findChild(this.index + 4, i.buffer[this.index + 3], e, t - this.context.start, l);
    return o < 0 ? null : new Kt(this.context, this, o);
  }
  get firstChild() {
    return this.child(
      1,
      0,
      4
      /* Side.DontCare */
    );
  }
  get lastChild() {
    return this.child(
      -1,
      0,
      4
      /* Side.DontCare */
    );
  }
  childAfter(e) {
    return this.child(
      1,
      e,
      2
      /* Side.After */
    );
  }
  childBefore(e) {
    return this.child(
      -1,
      e,
      -2
      /* Side.Before */
    );
  }
  enter(e, t, l = 0) {
    if (l & Se.ExcludeBuffers)
      return null;
    let { buffer: i } = this.context, o = i.findChild(this.index + 4, i.buffer[this.index + 3], t > 0 ? 1 : -1, e - this.context.start, t);
    return o < 0 ? null : new Kt(this.context, this, o);
  }
  get parent() {
    return this._parent || this.context.parent.nextSignificantParent();
  }
  externalSibling(e) {
    return this._parent ? null : this.context.parent.nextChild(
      this.context.index + e,
      e,
      0,
      4
      /* Side.DontCare */
    );
  }
  get nextSibling() {
    let { buffer: e } = this.context, t = e.buffer[this.index + 3];
    return t < (this._parent ? e.buffer[this._parent.index + 3] : e.buffer.length) ? new Kt(this.context, this._parent, t) : this.externalSibling(1);
  }
  get prevSibling() {
    let { buffer: e } = this.context, t = this._parent ? this._parent.index + 4 : 0;
    return this.index == t ? this.externalSibling(-1) : new Kt(this.context, this._parent, e.findChild(
      t,
      this.index,
      -1,
      0,
      4
      /* Side.DontCare */
    ));
  }
  cursor(e = 0) {
    return new Ki(this, e);
  }
  get tree() {
    return null;
  }
  toTree() {
    let e = [], t = [], { buffer: l } = this.context, i = this.index + 4, o = l.buffer[this.index + 3];
    if (o > i) {
      let n = l.buffer[this.index + 1];
      e.push(l.slice(i, o, n)), t.push(0);
    }
    return new Te(this.type, e, t, this.to - this.from);
  }
  resolve(e, t = 0) {
    return Jl(this, e, t, !1);
  }
  resolveInner(e, t = 0) {
    return Jl(this, e, t, !0);
  }
  enterUnfinishedNodesBefore(e) {
    return ob(this, e);
  }
  /// @internal
  toString() {
    return this.context.buffer.childString(this.index);
  }
  getChild(e, t = null, l = null) {
    let i = Dn(this, e, t, l);
    return i.length ? i[0] : null;
  }
  getChildren(e, t = null, l = null) {
    return Dn(this, e, t, l);
  }
  get node() {
    return this;
  }
  matchContext(e) {
    return Wn(this, e);
  }
}
class Ki {
  /// Shorthand for `.type.name`.
  get name() {
    return this.type.name;
  }
  /// @internal
  constructor(e, t = 0) {
    if (this.mode = t, this.buffer = null, this.stack = [], this.index = 0, this.bufferNode = null, e instanceof Pt)
      this.yieldNode(e);
    else {
      this._tree = e.context.parent, this.buffer = e.context;
      for (let l = e._parent; l; l = l._parent)
        this.stack.unshift(l.index);
      this.bufferNode = e, this.yieldBuf(e.index);
    }
  }
  yieldNode(e) {
    return e ? (this._tree = e, this.type = e.type, this.from = e.from, this.to = e.to, !0) : !1;
  }
  yieldBuf(e, t) {
    this.index = e;
    let { start: l, buffer: i } = this.buffer;
    return this.type = t || i.set.types[i.buffer[e]], this.from = l + i.buffer[e + 1], this.to = l + i.buffer[e + 2], !0;
  }
  yield(e) {
    return e ? e instanceof Pt ? (this.buffer = null, this.yieldNode(e)) : (this.buffer = e.context, this.yieldBuf(e.index, e.type)) : !1;
  }
  /// @internal
  toString() {
    return this.buffer ? this.buffer.buffer.childString(this.index) : this._tree.toString();
  }
  /// @internal
  enterChild(e, t, l) {
    if (!this.buffer)
      return this.yield(this._tree.nextChild(e < 0 ? this._tree._tree.children.length - 1 : 0, e, t, l, this.mode));
    let { buffer: i } = this.buffer, o = i.findChild(this.index + 4, i.buffer[this.index + 3], e, t - this.buffer.start, l);
    return o < 0 ? !1 : (this.stack.push(this.index), this.yieldBuf(o));
  }
  /// Move the cursor to this node's first child. When this returns
  /// false, the node has no child, and the cursor has not been moved.
  firstChild() {
    return this.enterChild(
      1,
      0,
      4
      /* Side.DontCare */
    );
  }
  /// Move the cursor to this node's last child.
  lastChild() {
    return this.enterChild(
      -1,
      0,
      4
      /* Side.DontCare */
    );
  }
  /// Move the cursor to the first child that ends after `pos`.
  childAfter(e) {
    return this.enterChild(
      1,
      e,
      2
      /* Side.After */
    );
  }
  /// Move to the last child that starts before `pos`.
  childBefore(e) {
    return this.enterChild(
      -1,
      e,
      -2
      /* Side.Before */
    );
  }
  /// Move the cursor to the child around `pos`. If side is -1 the
  /// child may end at that position, when 1 it may start there. This
  /// will also enter [overlaid](#common.MountedTree.overlay)
  /// [mounted](#common.NodeProp^mounted) trees unless `overlays` is
  /// set to false.
  enter(e, t, l = this.mode) {
    return this.buffer ? l & Se.ExcludeBuffers ? !1 : this.enterChild(1, e, t) : this.yield(this._tree.enter(e, t, l));
  }
  /// Move to the node's parent node, if this isn't the top node.
  parent() {
    if (!this.buffer)
      return this.yieldNode(this.mode & Se.IncludeAnonymous ? this._tree._parent : this._tree.parent);
    if (this.stack.length)
      return this.yieldBuf(this.stack.pop());
    let e = this.mode & Se.IncludeAnonymous ? this.buffer.parent : this.buffer.parent.nextSignificantParent();
    return this.buffer = null, this.yieldNode(e);
  }
  /// @internal
  sibling(e) {
    if (!this.buffer)
      return this._tree._parent ? this.yield(this._tree.index < 0 ? null : this._tree._parent.nextChild(this._tree.index + e, e, 0, 4, this.mode)) : !1;
    let { buffer: t } = this.buffer, l = this.stack.length - 1;
    if (e < 0) {
      let i = l < 0 ? 0 : this.stack[l] + 4;
      if (this.index != i)
        return this.yieldBuf(t.findChild(
          i,
          this.index,
          -1,
          0,
          4
          /* Side.DontCare */
        ));
    } else {
      let i = t.buffer[this.index + 3];
      if (i < (l < 0 ? t.buffer.length : t.buffer[this.stack[l] + 3]))
        return this.yieldBuf(i);
    }
    return l < 0 ? this.yield(this.buffer.parent.nextChild(this.buffer.index + e, e, 0, 4, this.mode)) : !1;
  }
  /// Move to this node's next sibling, if any.
  nextSibling() {
    return this.sibling(1);
  }
  /// Move to this node's previous sibling, if any.
  prevSibling() {
    return this.sibling(-1);
  }
  atLastNode(e) {
    let t, l, { buffer: i } = this;
    if (i) {
      if (e > 0) {
        if (this.index < i.buffer.buffer.length)
          return !1;
      } else
        for (let o = 0; o < this.index; o++)
          if (i.buffer.buffer[o + 3] < this.index)
            return !1;
      ({ index: t, parent: l } = i);
    } else
      ({ index: t, _parent: l } = this._tree);
    for (; l; { index: t, _parent: l } = l)
      if (t > -1)
        for (let o = t + e, n = e < 0 ? -1 : l._tree.children.length; o != n; o += e) {
          let s = l._tree.children[o];
          if (this.mode & Se.IncludeAnonymous || s instanceof Sl || !s.type.isAnonymous || Dd(s))
            return !1;
        }
    return !0;
  }
  move(e, t) {
    if (t && this.enterChild(
      e,
      0,
      4
      /* Side.DontCare */
    ))
      return !0;
    for (; ; ) {
      if (this.sibling(e))
        return !0;
      if (this.atLastNode(e) || !this.parent())
        return !1;
    }
  }
  /// Move to the next node in a
  /// [pre-order](https://en.wikipedia.org/wiki/Tree_traversal#Pre-order,_NLR)
  /// traversal, going from a node to its first child or, if the
  /// current node is empty or `enter` is false, its next sibling or
  /// the next sibling of the first parent node that has one.
  next(e = !0) {
    return this.move(1, e);
  }
  /// Move to the next node in a last-to-first pre-order traveral. A
  /// node is followed by its last child or, if it has none, its
  /// previous sibling or the previous sibling of the first parent
  /// node that has one.
  prev(e = !0) {
    return this.move(-1, e);
  }
  /// Move the cursor to the innermost node that covers `pos`. If
  /// `side` is -1, it will enter nodes that end at `pos`. If it is 1,
  /// it will enter nodes that start at `pos`.
  moveTo(e, t = 0) {
    for (; (this.from == this.to || (t < 1 ? this.from >= e : this.from > e) || (t > -1 ? this.to <= e : this.to < e)) && this.parent(); )
      ;
    for (; this.enterChild(1, e, t); )
      ;
    return this;
  }
  /// Get a [syntax node](#common.SyntaxNode) at the cursor's current
  /// position.
  get node() {
    if (!this.buffer)
      return this._tree;
    let e = this.bufferNode, t = null, l = 0;
    if (e && e.context == this.buffer) {
      e:
        for (let i = this.index, o = this.stack.length; o >= 0; ) {
          for (let n = e; n; n = n._parent)
            if (n.index == i) {
              if (i == this.index)
                return n;
              t = n, l = o + 1;
              break e;
            }
          i = this.stack[--o];
        }
    }
    for (let i = l; i < this.stack.length; i++)
      t = new Kt(this.buffer, t, this.stack[i]);
    return this.bufferNode = new Kt(this.buffer, t, this.index);
  }
  /// Get the [tree](#common.Tree) that represents the current node, if
  /// any. Will return null when the node is in a [tree
  /// buffer](#common.TreeBuffer).
  get tree() {
    return this.buffer ? null : this._tree._tree;
  }
  /// Iterate over the current node and all its descendants, calling
  /// `enter` when entering a node and `leave`, if given, when leaving
  /// one. When `enter` returns `false`, any children of that node are
  /// skipped, and `leave` isn't called for it.
  iterate(e, t) {
    for (let l = 0; ; ) {
      let i = !1;
      if (this.type.isAnonymous || e(this) !== !1) {
        if (this.firstChild()) {
          l++;
          continue;
        }
        this.type.isAnonymous || (i = !0);
      }
      for (; i && t && t(this), i = this.type.isAnonymous, !this.nextSibling(); ) {
        if (!l)
          return;
        this.parent(), l--, i = !0;
      }
    }
  }
  /// Test whether the current node matches a given context—a sequence
  /// of direct parent node names. Empty strings in the context array
  /// are treated as wildcards.
  matchContext(e) {
    if (!this.buffer)
      return Wn(this.node, e);
    let { buffer: t } = this.buffer, { types: l } = t.set;
    for (let i = e.length - 1, o = this.stack.length - 1; i >= 0; o--) {
      if (o < 0)
        return Wn(this.node, e, i);
      let n = l[t.buffer[this.stack[o]]];
      if (!n.isAnonymous) {
        if (e[i] && e[i] != n.name)
          return !1;
        i--;
      }
    }
    return !0;
  }
}
function Dd(r) {
  return r.children.some((e) => e instanceof Sl || !e.type.isAnonymous || Dd(e));
}
function Xk(r) {
  var e;
  let { buffer: t, nodeSet: l, maxBufferLength: i = lb, reused: o = [], minRepeatType: n = l.types.length } = r, s = Array.isArray(t) ? new Rd(t, t.length) : t, a = l.types, c = 0, d = 0;
  function h(y, C, Z, G, W) {
    let { id: D, start: R, end: F, size: J } = s, ie = d;
    for (; J < 0; )
      if (s.next(), J == -1) {
        let q = o[D];
        Z.push(q), G.push(R - y);
        return;
      } else if (J == -3) {
        c = D;
        return;
      } else if (J == -4) {
        d = D;
        return;
      } else
        throw new RangeError(`Unrecognized record size: ${J}`);
    let fe = a[D], ae, H, K = R - y;
    if (F - R <= i && (H = m(s.pos - C, W))) {
      let q = new Uint16Array(H.size - H.skip), he = s.pos - H.size, et = q.length;
      for (; s.pos > he; )
        et = O(H.start, q, et);
      ae = new Sl(q, F - H.start, l), K = H.start - y;
    } else {
      let q = s.pos - J;
      s.next();
      let he = [], et = [], tt = D >= n ? D : -1, rt = 0, Xe = F;
      for (; s.pos > q; )
        tt >= 0 && s.id == tt && s.size >= 0 ? (s.end <= Xe - i && (u(he, et, R, rt, s.end, Xe, tt, ie), rt = he.length, Xe = s.end), s.next()) : h(R, q, he, et, tt);
      if (tt >= 0 && rt > 0 && rt < he.length && u(he, et, R, rt, R, Xe, tt, ie), he.reverse(), et.reverse(), tt > -1 && rt > 0) {
        let Ql = p(fe);
        ae = Wd(fe, he, et, 0, he.length, 0, F - R, Ql, Ql);
      } else
        ae = f(fe, he, et, F - R, ie - F);
    }
    Z.push(ae), G.push(K);
  }
  function p(y) {
    return (C, Z, G) => {
      let W = 0, D = C.length - 1, R, F;
      if (D >= 0 && (R = C[D]) instanceof Te) {
        if (!D && R.type == y && R.length == G)
          return R;
        (F = R.prop(se.lookAhead)) && (W = Z[D] + R.length + F);
      }
      return f(y, C, Z, G, W);
    };
  }
  function u(y, C, Z, G, W, D, R, F) {
    let J = [], ie = [];
    for (; y.length > G; )
      J.push(y.pop()), ie.push(C.pop() + Z - W);
    y.push(f(l.types[R], J, ie, D - W, F - D)), C.push(W - Z);
  }
  function f(y, C, Z, G, W = 0, D) {
    if (c) {
      let R = [se.contextHash, c];
      D = D ? [R].concat(D) : [R];
    }
    if (W > 25) {
      let R = [se.lookAhead, W];
      D = D ? [R].concat(D) : [R];
    }
    return new Te(y, C, Z, G, D);
  }
  function m(y, C) {
    let Z = s.fork(), G = 0, W = 0, D = 0, R = Z.end - i, F = { size: 0, start: 0, skip: 0 };
    e:
      for (let J = Z.pos - y; Z.pos > J; ) {
        let ie = Z.size;
        if (Z.id == C && ie >= 0) {
          F.size = G, F.start = W, F.skip = D, D += 4, G += 4, Z.next();
          continue;
        }
        let fe = Z.pos - ie;
        if (ie < 0 || fe < J || Z.start < R)
          break;
        let ae = Z.id >= n ? 4 : 0, H = Z.start;
        for (Z.next(); Z.pos > fe; ) {
          if (Z.size < 0)
            if (Z.size == -3)
              ae += 4;
            else
              break e;
          else
            Z.id >= n && (ae += 4);
          Z.next();
        }
        W = H, G += ie, D += ae;
      }
    return (C < 0 || G == y) && (F.size = G, F.start = W, F.skip = D), F.size > 4 ? F : void 0;
  }
  function O(y, C, Z) {
    let { id: G, start: W, end: D, size: R } = s;
    if (s.next(), R >= 0 && G < n) {
      let F = Z;
      if (R > 4) {
        let J = s.pos - (R - 4);
        for (; s.pos > J; )
          Z = O(y, C, Z);
      }
      C[--Z] = F, C[--Z] = D - y, C[--Z] = W - y, C[--Z] = G;
    } else
      R == -3 ? c = G : R == -4 && (d = G);
    return Z;
  }
  let x = [], Q = [];
  for (; s.pos > 0; )
    h(r.start || 0, r.bufferStart || 0, x, Q, -1);
  let P = (e = r.length) !== null && e !== void 0 ? e : x.length ? Q[0] + x[0].length : 0;
  return new Te(a[r.topID], x.reverse(), Q.reverse(), P);
}
const tu = /* @__PURE__ */ new WeakMap();
function fn(r, e) {
  if (!r.isAnonymous || e instanceof Sl || e.type != r)
    return 1;
  let t = tu.get(e);
  if (t == null) {
    t = 1;
    for (let l of e.children) {
      if (l.type != r || !(l instanceof Te)) {
        t = 1;
        break;
      }
      t += fn(r, l);
    }
    tu.set(e, t);
  }
  return t;
}
function Wd(r, e, t, l, i, o, n, s, a) {
  let c = 0;
  for (let f = l; f < i; f++)
    c += fn(r, e[f]);
  let d = Math.ceil(
    c * 1.5 / 8
    /* Balance.BranchFactor */
  ), h = [], p = [];
  function u(f, m, O, x, Q) {
    for (let P = O; P < x; ) {
      let y = P, C = m[P], Z = fn(r, f[P]);
      for (P++; P < x; P++) {
        let G = fn(r, f[P]);
        if (Z + G >= d)
          break;
        Z += G;
      }
      if (P == y + 1) {
        if (Z > d) {
          let G = f[y];
          u(G.children, G.positions, 0, G.children.length, m[y] + Q);
          continue;
        }
        h.push(f[y]);
      } else {
        let G = m[P - 1] + f[P - 1].length - C;
        h.push(Wd(r, f, m, y, P, C, G, null, a));
      }
      p.push(C + Q - o);
    }
  }
  return u(e, t, l, i, 0), (s || a)(h, p, n);
}
class Ak {
  constructor() {
    this.map = /* @__PURE__ */ new WeakMap();
  }
  setBuffer(e, t, l) {
    let i = this.map.get(e);
    i || this.map.set(e, i = /* @__PURE__ */ new Map()), i.set(t, l);
  }
  getBuffer(e, t) {
    let l = this.map.get(e);
    return l && l.get(t);
  }
  /// Set the value for this syntax node.
  set(e, t) {
    e instanceof Kt ? this.setBuffer(e.context.buffer, e.index, t) : e instanceof Pt && this.map.set(e.tree, t);
  }
  /// Retrieve value for this syntax node, if it exists in the map.
  get(e) {
    return e instanceof Kt ? this.getBuffer(e.context.buffer, e.index) : e instanceof Pt ? this.map.get(e.tree) : void 0;
  }
  /// Set the value for the node that a cursor currently points to.
  cursorSet(e, t) {
    e.buffer ? this.setBuffer(e.buffer.buffer, e.index, t) : this.map.set(e.tree, t);
  }
  /// Retrieve the value for the node that a cursor currently points
  /// to.
  cursorGet(e) {
    return e.buffer ? this.getBuffer(e.buffer.buffer, e.index) : this.map.get(e.tree);
  }
}
class hr {
  /// Construct a tree fragment. You'll usually want to use
  /// [`addTree`](#common.TreeFragment^addTree) and
  /// [`applyChanges`](#common.TreeFragment^applyChanges) instead of
  /// calling this directly.
  constructor(e, t, l, i, o = !1, n = !1) {
    this.from = e, this.to = t, this.tree = l, this.offset = i, this.open = (o ? 1 : 0) | (n ? 2 : 0);
  }
  /// Whether the start of the fragment represents the start of a
  /// parse, or the end of a change. (In the second case, it may not
  /// be safe to reuse some nodes at the start, depending on the
  /// parsing algorithm.)
  get openStart() {
    return (this.open & 1) > 0;
  }
  /// Whether the end of the fragment represents the end of a
  /// full-document parse, or the start of a change.
  get openEnd() {
    return (this.open & 2) > 0;
  }
  /// Create a set of fragments from a freshly parsed tree, or update
  /// an existing set of fragments by replacing the ones that overlap
  /// with a tree with content from the new tree. When `partial` is
  /// true, the parse is treated as incomplete, and the resulting
  /// fragment has [`openEnd`](#common.TreeFragment.openEnd) set to
  /// true.
  static addTree(e, t = [], l = !1) {
    let i = [new hr(0, e.length, e, 0, !1, l)];
    for (let o of t)
      o.to > e.length && i.push(o);
    return i;
  }
  /// Apply a set of edits to an array of fragments, removing or
  /// splitting fragments as necessary to remove edited ranges, and
  /// adjusting offsets for fragments that moved.
  static applyChanges(e, t, l = 128) {
    if (!t.length)
      return e;
    let i = [], o = 1, n = e.length ? e[0] : null;
    for (let s = 0, a = 0, c = 0; ; s++) {
      let d = s < t.length ? t[s] : null, h = d ? d.fromA : 1e9;
      if (h - a >= l)
        for (; n && n.from < h; ) {
          let p = n;
          if (a >= p.from || h <= p.to || c) {
            let u = Math.max(p.from, a) - c, f = Math.min(p.to, h) - c;
            p = u >= f ? null : new hr(u, f, p.tree, p.offset + c, s > 0, !!d);
          }
          if (p && i.push(p), n.to > h)
            break;
          n = o < e.length ? e[o++] : null;
        }
      if (!d)
        break;
      a = d.toA, c = d.toA - d.toB;
    }
    return i;
  }
}
class nb {
  /// Start a parse, returning a [partial parse](#common.PartialParse)
  /// object. [`fragments`](#common.TreeFragment) can be passed in to
  /// make the parse incremental.
  ///
  /// By default, the entire input is parsed. You can pass `ranges`,
  /// which should be a sorted array of non-empty, non-overlapping
  /// ranges, to parse only those ranges. The tree returned in that
  /// case will start at `ranges[0].from`.
  startParse(e, t, l) {
    return typeof e == "string" && (e = new Ek(e)), l = l ? l.length ? l.map((i) => new Qt(i.from, i.to)) : [new Qt(0, 0)] : [new Qt(0, e.length)], this.createParse(e, t || [], l);
  }
  /// Run a full parse, returning the resulting tree.
  parse(e, t, l) {
    let i = this.startParse(e, t, l);
    for (; ; ) {
      let o = i.advance();
      if (o)
        return o;
    }
  }
}
class Ek {
  constructor(e) {
    this.string = e;
  }
  get length() {
    return this.string.length;
  }
  chunk(e) {
    return this.string.slice(e);
  }
  get lineChunks() {
    return !1;
  }
  read(e, t) {
    return this.string.slice(e, t);
  }
}
function Vk(r) {
  return (e, t, l, i) => new Rk(e, r, t, l, i);
}
class ru {
  constructor(e, t, l, i, o) {
    this.parser = e, this.parse = t, this.overlay = l, this.target = i, this.ranges = o;
  }
}
class Zk {
  constructor(e, t, l, i, o, n, s) {
    this.parser = e, this.predicate = t, this.mounts = l, this.index = i, this.start = o, this.target = n, this.prev = s, this.depth = 0, this.ranges = [];
  }
}
const Xc = new se({ perNode: !0 });
class Rk {
  constructor(e, t, l, i, o) {
    this.nest = t, this.input = l, this.fragments = i, this.ranges = o, this.inner = [], this.innerDone = 0, this.baseTree = null, this.stoppedAt = null, this.baseParse = e;
  }
  advance() {
    if (this.baseParse) {
      let l = this.baseParse.advance();
      if (!l)
        return null;
      if (this.baseParse = null, this.baseTree = l, this.startInner(), this.stoppedAt != null)
        for (let i of this.inner)
          i.parse.stopAt(this.stoppedAt);
    }
    if (this.innerDone == this.inner.length) {
      let l = this.baseTree;
      return this.stoppedAt != null && (l = new Te(l.type, l.children, l.positions, l.length, l.propValues.concat([[Xc, this.stoppedAt]]))), l;
    }
    let e = this.inner[this.innerDone], t = e.parse.advance();
    if (t) {
      this.innerDone++;
      let l = Object.assign(/* @__PURE__ */ Object.create(null), e.target.props);
      l[se.mounted.id] = new Ck(t, e.overlay, e.parser), e.target.props = l;
    }
    return null;
  }
  get parsedPos() {
    if (this.baseParse)
      return 0;
    let e = this.input.length;
    for (let t = this.innerDone; t < this.inner.length; t++)
      this.inner[t].ranges[0].from < e && (e = Math.min(e, this.inner[t].parse.parsedPos));
    return e;
  }
  stopAt(e) {
    if (this.stoppedAt = e, this.baseParse)
      this.baseParse.stopAt(e);
    else
      for (let t = this.innerDone; t < this.inner.length; t++)
        this.inner[t].parse.stopAt(e);
  }
  startInner() {
    let e = new Nk(this.fragments), t = null, l = null, i = new Ki(new Pt(this.baseTree, this.ranges[0].from, 0, null), Se.IncludeAnonymous | Se.IgnoreMounts);
    e:
      for (let o, n; this.stoppedAt == null || i.from < this.stoppedAt; ) {
        let s = !0, a;
        if (e.hasNode(i)) {
          if (t) {
            let c = t.mounts.find((d) => d.frag.from <= i.from && d.frag.to >= i.to && d.mount.overlay);
            if (c)
              for (let d of c.mount.overlay) {
                let h = d.from + c.pos, p = d.to + c.pos;
                h >= i.from && p <= i.to && !t.ranges.some((u) => u.from < p && u.to > h) && t.ranges.push({ from: h, to: p });
              }
          }
          s = !1;
        } else if (l && (n = Dk(l.ranges, i.from, i.to)))
          s = n != 2;
        else if (!i.type.isAnonymous && i.from < i.to && (o = this.nest(i, this.input))) {
          i.tree || Wk(i);
          let c = e.findMounts(i.from, o.parser);
          if (typeof o.overlay == "function")
            t = new Zk(o.parser, o.overlay, c, this.inner.length, i.from, i.tree, t);
          else {
            let d = ou(this.ranges, o.overlay || [new Qt(i.from, i.to)]);
            d.length && this.inner.push(new ru(o.parser, o.parser.startParse(this.input, nu(c, d), d), o.overlay ? o.overlay.map((h) => new Qt(h.from - i.from, h.to - i.from)) : null, i.tree, d)), o.overlay ? d.length && (l = { ranges: d, depth: 0, prev: l }) : s = !1;
          }
        } else
          t && (a = t.predicate(i)) && (a === !0 && (a = new Qt(i.from, i.to)), a.from < a.to && t.ranges.push(a));
        if (s && i.firstChild())
          t && t.depth++, l && l.depth++;
        else
          for (; !i.nextSibling(); ) {
            if (!i.parent())
              break e;
            if (t && !--t.depth) {
              let c = ou(this.ranges, t.ranges);
              c.length && this.inner.splice(t.index, 0, new ru(t.parser, t.parser.startParse(this.input, nu(t.mounts, c), c), t.ranges.map((d) => new Qt(d.from - t.start, d.to - t.start)), t.target, c)), t = t.prev;
            }
            l && !--l.depth && (l = l.prev);
          }
      }
  }
}
function Dk(r, e, t) {
  for (let l of r) {
    if (l.from >= t)
      break;
    if (l.to > e)
      return l.from <= e && l.to >= t ? 2 : 1;
  }
  return 0;
}
function lu(r, e, t, l, i, o) {
  if (e < t) {
    let n = r.buffer[e + 1];
    l.push(r.slice(e, t, n)), i.push(n - o);
  }
}
function Wk(r) {
  let { node: e } = r, t = 0;
  do
    r.parent(), t++;
  while (!r.tree);
  let l = 0, i = r.tree, o = 0;
  for (; o = i.positions[l] + r.from, !(o <= e.from && o + i.children[l].length >= e.to); l++)
    ;
  let n = i.children[l], s = n.buffer;
  function a(c, d, h, p, u) {
    let f = c;
    for (; s[f + 2] + o <= e.from; )
      f = s[f + 3];
    let m = [], O = [];
    lu(n, c, f, m, O, p);
    let x = s[f + 1], Q = s[f + 2], P = x + o == e.from && Q + o == e.to && s[f] == e.type.id;
    return m.push(P ? e.toTree() : a(f + 4, s[f + 3], n.set.types[s[f]], x, Q - x)), O.push(x - p), lu(n, s[f + 3], d, m, O, p), new Te(h, m, O, u);
  }
  i.children[l] = a(0, s.length, ct.none, 0, n.length);
  for (let c = 0; c <= t; c++)
    r.childAfter(e.from);
}
class iu {
  constructor(e, t) {
    this.offset = t, this.done = !1, this.cursor = e.cursor(Se.IncludeAnonymous | Se.IgnoreMounts);
  }
  // Move to the first node (in pre-order) that starts at or after `pos`.
  moveTo(e) {
    let { cursor: t } = this, l = e - this.offset;
    for (; !this.done && t.from < l; )
      t.to >= e && t.enter(l, 1, Se.IgnoreOverlays | Se.ExcludeBuffers) || t.next(!1) || (this.done = !0);
  }
  hasNode(e) {
    if (this.moveTo(e.from), !this.done && this.cursor.from + this.offset == e.from && this.cursor.tree)
      for (let t = this.cursor.tree; ; ) {
        if (t == e.tree)
          return !0;
        if (t.children.length && t.positions[0] == 0 && t.children[0] instanceof Te)
          t = t.children[0];
        else
          break;
      }
    return !1;
  }
}
let Nk = class {
  constructor(e) {
    var t;
    if (this.fragments = e, this.curTo = 0, this.fragI = 0, e.length) {
      let l = this.curFrag = e[0];
      this.curTo = (t = l.tree.prop(Xc)) !== null && t !== void 0 ? t : l.to, this.inner = new iu(l.tree, -l.offset);
    } else
      this.curFrag = this.inner = null;
  }
  hasNode(e) {
    for (; this.curFrag && e.from >= this.curTo; )
      this.nextFrag();
    return this.curFrag && this.curFrag.from <= e.from && this.curTo >= e.to && this.inner.hasNode(e);
  }
  nextFrag() {
    var e;
    if (this.fragI++, this.fragI == this.fragments.length)
      this.curFrag = this.inner = null;
    else {
      let t = this.curFrag = this.fragments[this.fragI];
      this.curTo = (e = t.tree.prop(Xc)) !== null && e !== void 0 ? e : t.to, this.inner = new iu(t.tree, -t.offset);
    }
  }
  findMounts(e, t) {
    var l;
    let i = [];
    if (this.inner) {
      this.inner.cursor.moveTo(e, 1);
      for (let o = this.inner.cursor.node; o; o = o.parent) {
        let n = (l = o.tree) === null || l === void 0 ? void 0 : l.prop(se.mounted);
        if (n && n.parser == t)
          for (let s = this.fragI; s < this.fragments.length; s++) {
            let a = this.fragments[s];
            if (a.from >= o.to)
              break;
            a.tree == this.curFrag.tree && i.push({
              frag: a,
              pos: o.from - a.offset,
              mount: n
            });
          }
      }
    }
    return i;
  }
};
function ou(r, e) {
  let t = null, l = e;
  for (let i = 1, o = 0; i < r.length; i++) {
    let n = r[i - 1].to, s = r[i].from;
    for (; o < l.length; o++) {
      let a = l[o];
      if (a.from >= s)
        break;
      a.to <= n || (t || (l = t = e.slice()), a.from < n ? (t[o] = new Qt(a.from, n), a.to > s && t.splice(o + 1, 0, new Qt(s, a.to))) : a.to > s ? t[o--] = new Qt(s, a.to) : t.splice(o--, 1));
    }
  }
  return l;
}
function Mk(r, e, t, l) {
  let i = 0, o = 0, n = !1, s = !1, a = -1e9, c = [];
  for (; ; ) {
    let d = i == r.length ? 1e9 : n ? r[i].to : r[i].from, h = o == e.length ? 1e9 : s ? e[o].to : e[o].from;
    if (n != s) {
      let p = Math.max(a, t), u = Math.min(d, h, l);
      p < u && c.push(new Qt(p, u));
    }
    if (a = Math.min(d, h), a == 1e9)
      break;
    d == a && (n ? (n = !1, i++) : n = !0), h == a && (s ? (s = !1, o++) : s = !0);
  }
  return c;
}
function nu(r, e) {
  let t = [];
  for (let { pos: l, mount: i, frag: o } of r) {
    let n = l + (i.overlay ? i.overlay[0].from : 0), s = n + i.tree.length, a = Math.max(o.from, n), c = Math.min(o.to, s);
    if (i.overlay) {
      let d = i.overlay.map((p) => new Qt(p.from + l, p.to + l)), h = Mk(e, d, a, c);
      for (let p = 0, u = a; ; p++) {
        let f = p == h.length, m = f ? c : h[p].from;
        if (m > u && t.push(new hr(u, m, i.tree, -n, o.from >= u || o.openStart, o.to <= m || o.openEnd)), f)
          break;
        u = h[p].to;
      }
    } else
      t.push(new hr(a, c, i.tree, -n, o.from >= n || o.openStart, o.to <= s || o.openEnd));
  }
  return t;
}
let Yk = 0;
class Lt {
  /// @internal
  constructor(e, t, l) {
    this.set = e, this.base = t, this.modified = l, this.id = Yk++;
  }
  /// Define a new tag. If `parent` is given, the tag is treated as a
  /// sub-tag of that parent, and
  /// [highlighters](#highlight.tagHighlighter) that don't mention
  /// this tag will try to fall back to the parent tag (or grandparent
  /// tag, etc).
  static define(e) {
    if (e != null && e.base)
      throw new Error("Can not derive from a modified tag");
    let t = new Lt([], null, []);
    if (t.set.push(t), e)
      for (let l of e.set)
        t.set.push(l);
    return t;
  }
  /// Define a tag _modifier_, which is a function that, given a tag,
  /// will return a tag that is a subtag of the original. Applying the
  /// same modifier to a twice tag will return the same value (`m1(t1)
  /// == m1(t1)`) and applying multiple modifiers will, regardless or
  /// order, produce the same tag (`m1(m2(t1)) == m2(m1(t1))`).
  ///
  /// When multiple modifiers are applied to a given base tag, each
  /// smaller set of modifiers is registered as a parent, so that for
  /// example `m1(m2(m3(t1)))` is a subtype of `m1(m2(t1))`,
  /// `m1(m3(t1)`, and so on.
  static defineModifier() {
    let e = new Nn();
    return (t) => t.modified.indexOf(e) > -1 ? t : Nn.get(t.base || t, t.modified.concat(e).sort((l, i) => l.id - i.id));
  }
}
let jk = 0;
class Nn {
  constructor() {
    this.instances = [], this.id = jk++;
  }
  static get(e, t) {
    if (!t.length)
      return e;
    let l = t[0].instances.find((s) => s.base == e && Ik(t, s.modified));
    if (l)
      return l;
    let i = [], o = new Lt(i, e, t);
    for (let s of t)
      s.instances.push(o);
    let n = Uk(t);
    for (let s of e.set)
      if (!s.modified.length)
        for (let a of n)
          i.push(Nn.get(s, a));
    return o;
  }
}
function Ik(r, e) {
  return r.length == e.length && r.every((t, l) => t == e[l]);
}
function Uk(r) {
  let e = [[]];
  for (let t = 0; t < r.length; t++)
    for (let l = 0, i = e.length; l < i; l++)
      e.push(e[l].concat(r[t]));
  return e.sort((t, l) => l.length - t.length);
}
function Cs(r) {
  let e = /* @__PURE__ */ Object.create(null);
  for (let t in r) {
    let l = r[t];
    Array.isArray(l) || (l = [l]);
    for (let i of t.split(" "))
      if (i) {
        let o = [], n = 2, s = i;
        for (let h = 0; ; ) {
          if (s == "..." && h > 0 && h + 3 == i.length) {
            n = 1;
            break;
          }
          let p = /^"(?:[^"\\]|\\.)*?"|[^\/!]+/.exec(s);
          if (!p)
            throw new RangeError("Invalid path: " + i);
          if (o.push(p[0] == "*" ? "" : p[0][0] == '"' ? JSON.parse(p[0]) : p[0]), h += p[0].length, h == i.length)
            break;
          let u = i[h++];
          if (h == i.length && u == "!") {
            n = 0;
            break;
          }
          if (u != "/")
            throw new RangeError("Invalid path: " + i);
          s = i.slice(h);
        }
        let a = o.length - 1, c = o[a];
        if (!c)
          throw new RangeError("Invalid path: " + i);
        let d = new Mn(l, n, a > 0 ? o.slice(0, a) : null);
        e[c] = d.sort(e[c]);
      }
  }
  return sb.add(e);
}
const sb = new se();
class Mn {
  constructor(e, t, l, i) {
    this.tags = e, this.mode = t, this.context = l, this.next = i;
  }
  get opaque() {
    return this.mode == 0;
  }
  get inherit() {
    return this.mode == 1;
  }
  sort(e) {
    return !e || e.depth < this.depth ? (this.next = e, this) : (e.next = this.sort(e.next), e);
  }
  get depth() {
    return this.context ? this.context.length : 0;
  }
}
Mn.empty = new Mn([], 2, null);
function ab(r, e) {
  let t = /* @__PURE__ */ Object.create(null);
  for (let o of r)
    if (!Array.isArray(o.tag))
      t[o.tag.id] = o.class;
    else
      for (let n of o.tag)
        t[n.id] = o.class;
  let { scope: l, all: i = null } = e || {};
  return {
    style: (o) => {
      let n = i;
      for (let s of o)
        for (let a of s.set) {
          let c = t[a.id];
          if (c) {
            n = n ? n + " " + c : c;
            break;
          }
        }
      return n;
    },
    scope: l
  };
}
function qk(r, e) {
  let t = null;
  for (let l of r) {
    let i = l.style(e);
    i && (t = t ? t + " " + i : i);
  }
  return t;
}
function Bk(r, e, t, l = 0, i = r.length) {
  let o = new Lk(l, Array.isArray(e) ? e : [e], t);
  o.highlightRange(r.cursor(), l, i, "", o.highlighters), o.flush(i);
}
class Lk {
  constructor(e, t, l) {
    this.at = e, this.highlighters = t, this.span = l, this.class = "";
  }
  startSpan(e, t) {
    t != this.class && (this.flush(e), e > this.at && (this.at = e), this.class = t);
  }
  flush(e) {
    e > this.at && this.class && this.span(this.at, e, this.class);
  }
  highlightRange(e, t, l, i, o) {
    let { type: n, from: s, to: a } = e;
    if (s >= l || a <= t)
      return;
    n.isTop && (o = this.highlighters.filter((u) => !u.scope || u.scope(n)));
    let c = i, d = Gk(e) || Mn.empty, h = qk(o, d.tags);
    if (h && (c && (c += " "), c += h, d.mode == 1 && (i += (i ? " " : "") + h)), this.startSpan(e.from, c), d.opaque)
      return;
    let p = e.tree && e.tree.prop(se.mounted);
    if (p && p.overlay) {
      let u = e.node.enter(p.overlay[0].from + s, 1), f = this.highlighters.filter((O) => !O.scope || O.scope(p.tree.type)), m = e.firstChild();
      for (let O = 0, x = s; ; O++) {
        let Q = O < p.overlay.length ? p.overlay[O] : null, P = Q ? Q.from + s : a, y = Math.max(t, x), C = Math.min(l, P);
        if (y < C && m)
          for (; e.from < C && (this.highlightRange(e, y, C, i, o), this.startSpan(Math.min(C, e.to), c), !(e.to >= P || !e.nextSibling())); )
            ;
        if (!Q || P > l)
          break;
        x = Q.to + s, x > t && (this.highlightRange(u.cursor(), Math.max(t, Q.from + s), Math.min(l, x), i, f), this.startSpan(x, c));
      }
      m && e.parent();
    } else if (e.firstChild()) {
      do
        if (!(e.to <= t)) {
          if (e.from >= l)
            break;
          this.highlightRange(e, t, l, i, o), this.startSpan(Math.min(l, e.to), c);
        }
      while (e.nextSibling());
      e.parent();
    }
  }
}
function Gk(r) {
  let e = r.type.prop(sb);
  for (; e && e.context && !r.matchContext(e.context); )
    e = e.next;
  return e || null;
}
const E = Lt.define, Yo = E(), yr = E(), su = E(yr), au = E(yr), kr = E(), jo = E(kr), ha = E(kr), qt = E(), Jr = E(qt), It = E(), Ut = E(), Ac = E(), mi = E(Ac), Io = E(), v = {
  /// A comment.
  comment: Yo,
  /// A line [comment](#highlight.tags.comment).
  lineComment: E(Yo),
  /// A block [comment](#highlight.tags.comment).
  blockComment: E(Yo),
  /// A documentation [comment](#highlight.tags.comment).
  docComment: E(Yo),
  /// Any kind of identifier.
  name: yr,
  /// The [name](#highlight.tags.name) of a variable.
  variableName: E(yr),
  /// A type [name](#highlight.tags.name).
  typeName: su,
  /// A tag name (subtag of [`typeName`](#highlight.tags.typeName)).
  tagName: E(su),
  /// A property or field [name](#highlight.tags.name).
  propertyName: au,
  /// An attribute name (subtag of [`propertyName`](#highlight.tags.propertyName)).
  attributeName: E(au),
  /// The [name](#highlight.tags.name) of a class.
  className: E(yr),
  /// A label [name](#highlight.tags.name).
  labelName: E(yr),
  /// A namespace [name](#highlight.tags.name).
  namespace: E(yr),
  /// The [name](#highlight.tags.name) of a macro.
  macroName: E(yr),
  /// A literal value.
  literal: kr,
  /// A string [literal](#highlight.tags.literal).
  string: jo,
  /// A documentation [string](#highlight.tags.string).
  docString: E(jo),
  /// A character literal (subtag of [string](#highlight.tags.string)).
  character: E(jo),
  /// An attribute value (subtag of [string](#highlight.tags.string)).
  attributeValue: E(jo),
  /// A number [literal](#highlight.tags.literal).
  number: ha,
  /// An integer [number](#highlight.tags.number) literal.
  integer: E(ha),
  /// A floating-point [number](#highlight.tags.number) literal.
  float: E(ha),
  /// A boolean [literal](#highlight.tags.literal).
  bool: E(kr),
  /// Regular expression [literal](#highlight.tags.literal).
  regexp: E(kr),
  /// An escape [literal](#highlight.tags.literal), for example a
  /// backslash escape in a string.
  escape: E(kr),
  /// A color [literal](#highlight.tags.literal).
  color: E(kr),
  /// A URL [literal](#highlight.tags.literal).
  url: E(kr),
  /// A language keyword.
  keyword: It,
  /// The [keyword](#highlight.tags.keyword) for the self or this
  /// object.
  self: E(It),
  /// The [keyword](#highlight.tags.keyword) for null.
  null: E(It),
  /// A [keyword](#highlight.tags.keyword) denoting some atomic value.
  atom: E(It),
  /// A [keyword](#highlight.tags.keyword) that represents a unit.
  unit: E(It),
  /// A modifier [keyword](#highlight.tags.keyword).
  modifier: E(It),
  /// A [keyword](#highlight.tags.keyword) that acts as an operator.
  operatorKeyword: E(It),
  /// A control-flow related [keyword](#highlight.tags.keyword).
  controlKeyword: E(It),
  /// A [keyword](#highlight.tags.keyword) that defines something.
  definitionKeyword: E(It),
  /// A [keyword](#highlight.tags.keyword) related to defining or
  /// interfacing with modules.
  moduleKeyword: E(It),
  /// An operator.
  operator: Ut,
  /// An [operator](#highlight.tags.operator) that dereferences something.
  derefOperator: E(Ut),
  /// Arithmetic-related [operator](#highlight.tags.operator).
  arithmeticOperator: E(Ut),
  /// Logical [operator](#highlight.tags.operator).
  logicOperator: E(Ut),
  /// Bit [operator](#highlight.tags.operator).
  bitwiseOperator: E(Ut),
  /// Comparison [operator](#highlight.tags.operator).
  compareOperator: E(Ut),
  /// [Operator](#highlight.tags.operator) that updates its operand.
  updateOperator: E(Ut),
  /// [Operator](#highlight.tags.operator) that defines something.
  definitionOperator: E(Ut),
  /// Type-related [operator](#highlight.tags.operator).
  typeOperator: E(Ut),
  /// Control-flow [operator](#highlight.tags.operator).
  controlOperator: E(Ut),
  /// Program or markup punctuation.
  punctuation: Ac,
  /// [Punctuation](#highlight.tags.punctuation) that separates
  /// things.
  separator: E(Ac),
  /// Bracket-style [punctuation](#highlight.tags.punctuation).
  bracket: mi,
  /// Angle [brackets](#highlight.tags.bracket) (usually `<` and `>`
  /// tokens).
  angleBracket: E(mi),
  /// Square [brackets](#highlight.tags.bracket) (usually `[` and `]`
  /// tokens).
  squareBracket: E(mi),
  /// Parentheses (usually `(` and `)` tokens). Subtag of
  /// [bracket](#highlight.tags.bracket).
  paren: E(mi),
  /// Braces (usually `{` and `}` tokens). Subtag of
  /// [bracket](#highlight.tags.bracket).
  brace: E(mi),
  /// Content, for example plain text in XML or markup documents.
  content: qt,
  /// [Content](#highlight.tags.content) that represents a heading.
  heading: Jr,
  /// A level 1 [heading](#highlight.tags.heading).
  heading1: E(Jr),
  /// A level 2 [heading](#highlight.tags.heading).
  heading2: E(Jr),
  /// A level 3 [heading](#highlight.tags.heading).
  heading3: E(Jr),
  /// A level 4 [heading](#highlight.tags.heading).
  heading4: E(Jr),
  /// A level 5 [heading](#highlight.tags.heading).
  heading5: E(Jr),
  /// A level 6 [heading](#highlight.tags.heading).
  heading6: E(Jr),
  /// A prose separator (such as a horizontal rule).
  contentSeparator: E(qt),
  /// [Content](#highlight.tags.content) that represents a list.
  list: E(qt),
  /// [Content](#highlight.tags.content) that represents a quote.
  quote: E(qt),
  /// [Content](#highlight.tags.content) that is emphasized.
  emphasis: E(qt),
  /// [Content](#highlight.tags.content) that is styled strong.
  strong: E(qt),
  /// [Content](#highlight.tags.content) that is part of a link.
  link: E(qt),
  /// [Content](#highlight.tags.content) that is styled as code or
  /// monospace.
  monospace: E(qt),
  /// [Content](#highlight.tags.content) that has a strike-through
  /// style.
  strikethrough: E(qt),
  /// Inserted text in a change-tracking format.
  inserted: E(),
  /// Deleted text.
  deleted: E(),
  /// Changed text.
  changed: E(),
  /// An invalid or unsyntactic element.
  invalid: E(),
  /// Metadata or meta-instruction.
  meta: Io,
  /// [Metadata](#highlight.tags.meta) that applies to the entire
  /// document.
  documentMeta: E(Io),
  /// [Metadata](#highlight.tags.meta) that annotates or adds
  /// attributes to a given syntactic element.
  annotation: E(Io),
  /// Processing instruction or preprocessor directive. Subtag of
  /// [meta](#highlight.tags.meta).
  processingInstruction: E(Io),
  /// [Modifier](#highlight.Tag^defineModifier) that indicates that a
  /// given element is being defined. Expected to be used with the
  /// various [name](#highlight.tags.name) tags.
  definition: Lt.defineModifier(),
  /// [Modifier](#highlight.Tag^defineModifier) that indicates that
  /// something is constant. Mostly expected to be used with
  /// [variable names](#highlight.tags.variableName).
  constant: Lt.defineModifier(),
  /// [Modifier](#highlight.Tag^defineModifier) used to indicate that
  /// a [variable](#highlight.tags.variableName) or [property
  /// name](#highlight.tags.propertyName) is being called or defined
  /// as a function.
  function: Lt.defineModifier(),
  /// [Modifier](#highlight.Tag^defineModifier) that can be applied to
  /// [names](#highlight.tags.name) to indicate that they belong to
  /// the language's standard environment.
  standard: Lt.defineModifier(),
  /// [Modifier](#highlight.Tag^defineModifier) that indicates a given
  /// [names](#highlight.tags.name) is local to some scope.
  local: Lt.defineModifier(),
  /// A generic variant [modifier](#highlight.Tag^defineModifier) that
  /// can be used to tag language-specific alternative variants of
  /// some common tag. It is recommended for themes to define special
  /// forms of at least the [string](#highlight.tags.string) and
  /// [variable name](#highlight.tags.variableName) tags, since those
  /// come up a lot.
  special: Lt.defineModifier()
};
ab([
  { tag: v.link, class: "tok-link" },
  { tag: v.heading, class: "tok-heading" },
  { tag: v.emphasis, class: "tok-emphasis" },
  { tag: v.strong, class: "tok-strong" },
  { tag: v.keyword, class: "tok-keyword" },
  { tag: v.atom, class: "tok-atom" },
  { tag: v.bool, class: "tok-bool" },
  { tag: v.url, class: "tok-url" },
  { tag: v.labelName, class: "tok-labelName" },
  { tag: v.inserted, class: "tok-inserted" },
  { tag: v.deleted, class: "tok-deleted" },
  { tag: v.literal, class: "tok-literal" },
  { tag: v.string, class: "tok-string" },
  { tag: v.number, class: "tok-number" },
  { tag: [v.regexp, v.escape, v.special(v.string)], class: "tok-string2" },
  { tag: v.variableName, class: "tok-variableName" },
  { tag: v.local(v.variableName), class: "tok-variableName tok-local" },
  { tag: v.definition(v.variableName), class: "tok-variableName tok-definition" },
  { tag: v.special(v.variableName), class: "tok-variableName2" },
  { tag: v.definition(v.propertyName), class: "tok-propertyName tok-definition" },
  { tag: v.typeName, class: "tok-typeName" },
  { tag: v.namespace, class: "tok-namespace" },
  { tag: v.className, class: "tok-className" },
  { tag: v.macroName, class: "tok-macroName" },
  { tag: v.propertyName, class: "tok-propertyName" },
  { tag: v.operator, class: "tok-operator" },
  { tag: v.comment, class: "tok-comment" },
  { tag: v.meta, class: "tok-meta" },
  { tag: v.invalid, class: "tok-invalid" },
  { tag: v.punctuation, class: "tok-punctuation" }
]);
var pa;
const Ji = /* @__PURE__ */ new se();
function Fk(r) {
  return Y.define({
    combine: r ? (e) => e.concat(r) : void 0
  });
}
class Rt {
  /**
  Construct a language object. If you need to invoke this
  directly, first define a data facet with
  [`defineLanguageFacet`](https://codemirror.net/6/docs/ref/#language.defineLanguageFacet), and then
  configure your parser to [attach](https://codemirror.net/6/docs/ref/#language.languageDataProp) it
  to the language's outer syntax node.
  */
  constructor(e, t, l = [], i = "") {
    this.data = e, this.name = i, pe.prototype.hasOwnProperty("tree") || Object.defineProperty(pe.prototype, "tree", { get() {
      return ze(this);
    } }), this.parser = t, this.extension = [
      qr.of(this),
      pe.languageData.of((o, n, s) => o.facet(cu(o, n, s)))
    ].concat(l);
  }
  /**
  Query whether this language is active at the given position.
  */
  isActiveAt(e, t, l = -1) {
    return cu(e, t, l) == this.data;
  }
  /**
  Find the document regions that were parsed using this language.
  The returned regions will _include_ any nested languages rooted
  in this language, when those exist.
  */
  findRegions(e) {
    let t = e.facet(qr);
    if ((t == null ? void 0 : t.data) == this.data)
      return [{ from: 0, to: e.doc.length }];
    if (!t || !t.allowsNesting)
      return [];
    let l = [], i = (o, n) => {
      if (o.prop(Ji) == this.data) {
        l.push({ from: n, to: n + o.length });
        return;
      }
      let s = o.prop(se.mounted);
      if (s) {
        if (s.tree.prop(Ji) == this.data) {
          if (s.overlay)
            for (let a of s.overlay)
              l.push({ from: a.from + n, to: a.to + n });
          else
            l.push({ from: n, to: n + o.length });
          return;
        } else if (s.overlay) {
          let a = l.length;
          if (i(s.tree, s.overlay[0].from + n), l.length > a)
            return;
        }
      }
      for (let a = 0; a < o.children.length; a++) {
        let c = o.children[a];
        c instanceof Te && i(c, o.positions[a] + n);
      }
    };
    return i(ze(e), 0), l;
  }
  /**
  Indicates whether this language allows nested languages. The
  default implementation returns true.
  */
  get allowsNesting() {
    return !0;
  }
}
Rt.setState = /* @__PURE__ */ le.define();
function cu(r, e, t) {
  let l = r.facet(qr);
  if (!l)
    return null;
  let i = l.data;
  if (l.allowsNesting)
    for (let o = ze(r).topNode; o; o = o.enter(e, t, Se.ExcludeBuffers))
      i = o.type.prop(Ji) || i;
  return i;
}
class ei extends Rt {
  constructor(e, t, l) {
    super(e, t, [], l), this.parser = t;
  }
  /**
  Define a language from a parser.
  */
  static define(e) {
    let t = Fk(e.languageData);
    return new ei(t, e.parser.configure({
      props: [Ji.add((l) => l.isTop ? t : void 0)]
    }), e.name);
  }
  /**
  Create a new instance of this language with a reconfigured
  version of its parser and optionally a new name.
  */
  configure(e, t) {
    return new ei(this.data, this.parser.configure(e), t || this.name);
  }
  get allowsNesting() {
    return this.parser.hasWrappers();
  }
}
function ze(r) {
  let e = r.field(Rt.state, !1);
  return e ? e.tree : Te.empty;
}
class Hk {
  constructor(e, t = e.length) {
    this.doc = e, this.length = t, this.cursorPos = 0, this.string = "", this.cursor = e.iter();
  }
  syncTo(e) {
    return this.string = this.cursor.next(e - this.cursorPos).value, this.cursorPos = e + this.string.length, this.cursorPos - this.string.length;
  }
  chunk(e) {
    return this.syncTo(e), this.string;
  }
  get lineChunks() {
    return !0;
  }
  read(e, t) {
    let l = this.cursorPos - this.string.length;
    return e < l || t >= this.cursorPos ? this.doc.sliceString(e, t) : this.string.slice(e - l, t - l);
  }
}
let bi = null;
class Yn {
  constructor(e, t, l = [], i, o, n, s, a) {
    this.parser = e, this.state = t, this.fragments = l, this.tree = i, this.treeLen = o, this.viewport = n, this.skipped = s, this.scheduleOn = a, this.parse = null, this.tempSkipped = [];
  }
  /**
  @internal
  */
  static create(e, t, l) {
    return new Yn(e, t, [], Te.empty, 0, l, [], null);
  }
  startParse() {
    return this.parser.startParse(new Hk(this.state.doc), this.fragments);
  }
  /**
  @internal
  */
  work(e, t) {
    return t != null && t >= this.state.doc.length && (t = void 0), this.tree != Te.empty && this.isDone(t ?? this.state.doc.length) ? (this.takeTree(), !0) : this.withContext(() => {
      var l;
      if (typeof e == "number") {
        let i = Date.now() + e;
        e = () => Date.now() > i;
      }
      for (this.parse || (this.parse = this.startParse()), t != null && (this.parse.stoppedAt == null || this.parse.stoppedAt > t) && t < this.state.doc.length && this.parse.stopAt(t); ; ) {
        let i = this.parse.advance();
        if (i)
          if (this.fragments = this.withoutTempSkipped(hr.addTree(i, this.fragments, this.parse.stoppedAt != null)), this.treeLen = (l = this.parse.stoppedAt) !== null && l !== void 0 ? l : this.state.doc.length, this.tree = i, this.parse = null, this.treeLen < (t ?? this.state.doc.length))
            this.parse = this.startParse();
          else
            return !0;
        if (e())
          return !1;
      }
    });
  }
  /**
  @internal
  */
  takeTree() {
    let e, t;
    this.parse && (e = this.parse.parsedPos) >= this.treeLen && ((this.parse.stoppedAt == null || this.parse.stoppedAt > e) && this.parse.stopAt(e), this.withContext(() => {
      for (; !(t = this.parse.advance()); )
        ;
    }), this.treeLen = e, this.tree = t, this.fragments = this.withoutTempSkipped(hr.addTree(this.tree, this.fragments, !0)), this.parse = null);
  }
  withContext(e) {
    let t = bi;
    bi = this;
    try {
      return e();
    } finally {
      bi = t;
    }
  }
  withoutTempSkipped(e) {
    for (let t; t = this.tempSkipped.pop(); )
      e = du(e, t.from, t.to);
    return e;
  }
  /**
  @internal
  */
  changes(e, t) {
    let { fragments: l, tree: i, treeLen: o, viewport: n, skipped: s } = this;
    if (this.takeTree(), !e.empty) {
      let a = [];
      if (e.iterChangedRanges((c, d, h, p) => a.push({ fromA: c, toA: d, fromB: h, toB: p })), l = hr.applyChanges(l, a), i = Te.empty, o = 0, n = { from: e.mapPos(n.from, -1), to: e.mapPos(n.to, 1) }, this.skipped.length) {
        s = [];
        for (let c of this.skipped) {
          let d = e.mapPos(c.from, 1), h = e.mapPos(c.to, -1);
          d < h && s.push({ from: d, to: h });
        }
      }
    }
    return new Yn(this.parser, t, l, i, o, n, s, this.scheduleOn);
  }
  /**
  @internal
  */
  updateViewport(e) {
    if (this.viewport.from == e.from && this.viewport.to == e.to)
      return !1;
    this.viewport = e;
    let t = this.skipped.length;
    for (let l = 0; l < this.skipped.length; l++) {
      let { from: i, to: o } = this.skipped[l];
      i < e.to && o > e.from && (this.fragments = du(this.fragments, i, o), this.skipped.splice(l--, 1));
    }
    return this.skipped.length >= t ? !1 : (this.reset(), !0);
  }
  /**
  @internal
  */
  reset() {
    this.parse && (this.takeTree(), this.parse = null);
  }
  /**
  Notify the parse scheduler that the given region was skipped
  because it wasn't in view, and the parse should be restarted
  when it comes into view.
  */
  skipUntilInView(e, t) {
    this.skipped.push({ from: e, to: t });
  }
  /**
  Returns a parser intended to be used as placeholder when
  asynchronously loading a nested parser. It'll skip its input and
  mark it as not-really-parsed, so that the next update will parse
  it again.
  
  When `until` is given, a reparse will be scheduled when that
  promise resolves.
  */
  static getSkippingParser(e) {
    return new class extends nb {
      createParse(t, l, i) {
        let o = i[0].from, n = i[i.length - 1].to;
        return {
          parsedPos: o,
          advance() {
            let a = bi;
            if (a) {
              for (let c of i)
                a.tempSkipped.push(c);
              e && (a.scheduleOn = a.scheduleOn ? Promise.all([a.scheduleOn, e]) : e);
            }
            return this.parsedPos = n, new Te(ct.none, [], [], n - o);
          },
          stoppedAt: null,
          stopAt() {
          }
        };
      }
    }();
  }
  /**
  @internal
  */
  isDone(e) {
    e = Math.min(e, this.state.doc.length);
    let t = this.fragments;
    return this.treeLen >= e && t.length && t[0].from == 0 && t[0].to >= e;
  }
  /**
  Get the context for the current parse, or `null` if no editor
  parse is in progress.
  */
  static get() {
    return bi;
  }
}
function du(r, e, t) {
  return hr.applyChanges(r, [{ fromA: e, toA: t, fromB: e, toB: t }]);
}
class ti {
  constructor(e) {
    this.context = e, this.tree = e.tree;
  }
  apply(e) {
    if (!e.docChanged && this.tree == this.context.tree)
      return this;
    let t = this.context.changes(e.changes, e.state), l = this.context.treeLen == e.startState.doc.length ? void 0 : Math.max(e.changes.mapPos(this.context.treeLen), t.viewport.to);
    return t.work(20, l) || t.takeTree(), new ti(t);
  }
  static init(e) {
    let t = Math.min(3e3, e.doc.length), l = Yn.create(e.facet(qr).parser, e, { from: 0, to: t });
    return l.work(20, t) || l.takeTree(), new ti(l);
  }
}
Rt.state = /* @__PURE__ */ Ue.define({
  create: ti.init,
  update(r, e) {
    for (let t of e.effects)
      if (t.is(Rt.setState))
        return t.value;
    return e.startState.facet(qr) != e.state.facet(qr) ? ti.init(e.state) : r.apply(e);
  }
});
let cb = (r) => {
  let e = setTimeout(
    () => r(),
    500
    /* Work.MaxPause */
  );
  return () => clearTimeout(e);
};
typeof requestIdleCallback < "u" && (cb = (r) => {
  let e = -1, t = setTimeout(
    () => {
      e = requestIdleCallback(r, {
        timeout: 500 - 100
        /* Work.MinPause */
      });
    },
    100
    /* Work.MinPause */
  );
  return () => e < 0 ? clearTimeout(t) : cancelIdleCallback(e);
});
const ua = typeof navigator < "u" && (!((pa = navigator.scheduling) === null || pa === void 0) && pa.isInputPending) ? () => navigator.scheduling.isInputPending() : null, Kk = /* @__PURE__ */ Ze.fromClass(class {
  constructor(e) {
    this.view = e, this.working = null, this.workScheduled = 0, this.chunkEnd = -1, this.chunkBudget = -1, this.work = this.work.bind(this), this.scheduleWork();
  }
  update(e) {
    let t = this.view.state.field(Rt.state).context;
    (t.updateViewport(e.view.viewport) || this.view.viewport.to > t.treeLen) && this.scheduleWork(), e.docChanged && (this.view.hasFocus && (this.chunkBudget += 50), this.scheduleWork()), this.checkAsyncSchedule(t);
  }
  scheduleWork() {
    if (this.working)
      return;
    let { state: e } = this.view, t = e.field(Rt.state);
    (t.tree != t.context.tree || !t.context.isDone(e.doc.length)) && (this.working = cb(this.work));
  }
  work(e) {
    this.working = null;
    let t = Date.now();
    if (this.chunkEnd < t && (this.chunkEnd < 0 || this.view.hasFocus) && (this.chunkEnd = t + 3e4, this.chunkBudget = 3e3), this.chunkBudget <= 0)
      return;
    let { state: l, viewport: { to: i } } = this.view, o = l.field(Rt.state);
    if (o.tree == o.context.tree && o.context.isDone(
      i + 1e5
      /* Work.MaxParseAhead */
    ))
      return;
    let n = Date.now() + Math.min(this.chunkBudget, 100, e && !ua ? Math.max(25, e.timeRemaining() - 5) : 1e9), s = o.context.treeLen < i && l.doc.length > i + 1e3, a = o.context.work(() => ua && ua() || Date.now() > n, i + (s ? 0 : 1e5));
    this.chunkBudget -= Date.now() - t, (a || this.chunkBudget <= 0) && (o.context.takeTree(), this.view.dispatch({ effects: Rt.setState.of(new ti(o.context)) })), this.chunkBudget > 0 && !(a && !s) && this.scheduleWork(), this.checkAsyncSchedule(o.context);
  }
  checkAsyncSchedule(e) {
    e.scheduleOn && (this.workScheduled++, e.scheduleOn.then(() => this.scheduleWork()).catch((t) => yt(this.view.state, t)).then(() => this.workScheduled--), e.scheduleOn = null);
  }
  destroy() {
    this.working && this.working();
  }
  isWorking() {
    return !!(this.working || this.workScheduled > 0);
  }
}, {
  eventHandlers: { focus() {
    this.scheduleWork();
  } }
}), qr = /* @__PURE__ */ Y.define({
  combine(r) {
    return r.length ? r[0] : null;
  },
  enables: (r) => [
    Rt.state,
    Kk,
    I.contentAttributes.compute([r], (e) => {
      let t = e.facet(r);
      return t && t.name ? { "data-language": t.name } : {};
    })
  ]
});
class Nd {
  /**
  Create a language support object.
  */
  constructor(e, t = []) {
    this.language = e, this.support = t, this.extension = [e, t];
  }
}
const Jk = /* @__PURE__ */ Y.define(), Ts = /* @__PURE__ */ Y.define({
  combine: (r) => {
    if (!r.length)
      return "  ";
    if (!/^(?: +|\t+)$/.test(r[0]))
      throw new Error("Invalid indent unit: " + JSON.stringify(r[0]));
    return r[0];
  }
});
function jn(r) {
  let e = r.facet(Ts);
  return e.charCodeAt(0) == 9 ? r.tabSize * e.length : e.length;
}
function eo(r, e) {
  let t = "", l = r.tabSize;
  if (r.facet(Ts).charCodeAt(0) == 9)
    for (; e >= l; )
      t += "	", e -= l;
  for (let i = 0; i < e; i++)
    t += " ";
  return t;
}
function Md(r, e) {
  r instanceof pe && (r = new zs(r));
  for (let l of r.state.facet(Jk)) {
    let i = l(r, e);
    if (i !== void 0)
      return i;
  }
  let t = ze(r.state);
  return t ? e3(r, t, e) : null;
}
class zs {
  /**
  Create an indent context.
  */
  constructor(e, t = {}) {
    this.state = e, this.options = t, this.unit = jn(e);
  }
  /**
  Get a description of the line at the given position, taking
  [simulated line
  breaks](https://codemirror.net/6/docs/ref/#language.IndentContext.constructor^options.simulateBreak)
  into account. If there is such a break at `pos`, the `bias`
  argument determines whether the part of the line line before or
  after the break is used.
  */
  lineAt(e, t = 1) {
    let l = this.state.doc.lineAt(e), { simulateBreak: i, simulateDoubleBreak: o } = this.options;
    return i != null && i >= l.from && i <= l.to ? o && i == e ? { text: "", from: e } : (t < 0 ? i < e : i <= e) ? { text: l.text.slice(i - l.from), from: i } : { text: l.text.slice(0, i - l.from), from: l.from } : l;
  }
  /**
  Get the text directly after `pos`, either the entire line
  or the next 100 characters, whichever is shorter.
  */
  textAfterPos(e, t = 1) {
    if (this.options.simulateDoubleBreak && e == this.options.simulateBreak)
      return "";
    let { text: l, from: i } = this.lineAt(e, t);
    return l.slice(e - i, Math.min(l.length, e + 100 - i));
  }
  /**
  Find the column for the given position.
  */
  column(e, t = 1) {
    let { text: l, from: i } = this.lineAt(e, t), o = this.countColumn(l, e - i), n = this.options.overrideIndentation ? this.options.overrideIndentation(i) : -1;
    return n > -1 && (o += n - this.countColumn(l, l.search(/\S|$/))), o;
  }
  /**
  Find the column position (taking tabs into account) of the given
  position in the given string.
  */
  countColumn(e, t = e.length) {
    return fo(e, this.state.tabSize, t);
  }
  /**
  Find the indentation column of the line at the given point.
  */
  lineIndent(e, t = 1) {
    let { text: l, from: i } = this.lineAt(e, t), o = this.options.overrideIndentation;
    if (o) {
      let n = o(i);
      if (n > -1)
        return n;
    }
    return this.countColumn(l, l.search(/\S|$/));
  }
  /**
  Returns the [simulated line
  break](https://codemirror.net/6/docs/ref/#language.IndentContext.constructor^options.simulateBreak)
  for this context, if any.
  */
  get simulatedBreak() {
    return this.options.simulateBreak || null;
  }
}
const Xs = /* @__PURE__ */ new se();
function e3(r, e, t) {
  return db(e.resolveInner(t).enterUnfinishedNodesBefore(t), t, r);
}
function t3(r) {
  return r.pos == r.options.simulateBreak && r.options.simulateDoubleBreak;
}
function r3(r) {
  let e = r.type.prop(Xs);
  if (e)
    return e;
  let t = r.firstChild, l;
  if (t && (l = t.type.prop(se.closedBy))) {
    let i = r.lastChild, o = i && l.indexOf(i.name) > -1;
    return (n) => hb(n, !0, 1, void 0, o && !t3(n) ? i.from : void 0);
  }
  return r.parent == null ? l3 : null;
}
function db(r, e, t) {
  for (; r; r = r.parent) {
    let l = r3(r);
    if (l)
      return l(Yd.create(t, e, r));
  }
  return null;
}
function l3() {
  return 0;
}
class Yd extends zs {
  constructor(e, t, l) {
    super(e.state, e.options), this.base = e, this.pos = t, this.node = l;
  }
  /**
  @internal
  */
  static create(e, t, l) {
    return new Yd(e, t, l);
  }
  /**
  Get the text directly after `this.pos`, either the entire line
  or the next 100 characters, whichever is shorter.
  */
  get textAfter() {
    return this.textAfterPos(this.pos);
  }
  /**
  Get the indentation at the reference line for `this.node`, which
  is the line on which it starts, unless there is a node that is
  _not_ a parent of this node covering the start of that line. If
  so, the line at the start of that node is tried, again skipping
  on if it is covered by another such node.
  */
  get baseIndent() {
    let e = this.state.doc.lineAt(this.node.from);
    for (; ; ) {
      let t = this.node.resolve(e.from);
      for (; t.parent && t.parent.from == t.from; )
        t = t.parent;
      if (i3(t, this.node))
        break;
      e = this.state.doc.lineAt(t.from);
    }
    return this.lineIndent(e.from);
  }
  /**
  Continue looking for indentations in the node's parent nodes,
  and return the result of that.
  */
  continue() {
    let e = this.node.parent;
    return e ? db(e, this.pos, this.base) : 0;
  }
}
function i3(r, e) {
  for (let t = e; t; t = t.parent)
    if (r == t)
      return !0;
  return !1;
}
function o3(r) {
  let e = r.node, t = e.childAfter(e.from), l = e.lastChild;
  if (!t)
    return null;
  let i = r.options.simulateBreak, o = r.state.doc.lineAt(t.from), n = i == null || i <= o.from ? o.to : Math.min(o.to, i);
  for (let s = t.to; ; ) {
    let a = e.childAfter(s);
    if (!a || a == l)
      return null;
    if (!a.type.isSkipped)
      return a.from < n ? t : null;
    s = a.to;
  }
}
function n3({ closing: r, align: e = !0, units: t = 1 }) {
  return (l) => hb(l, e, t, r);
}
function hb(r, e, t, l, i) {
  let o = r.textAfter, n = o.match(/^\s*/)[0].length, s = l && o.slice(n, n + l.length) == l || i == r.pos + n, a = e ? o3(r) : null;
  return a ? s ? r.column(a.from) : r.column(a.to) : r.baseIndent + (s ? 0 : r.unit * t);
}
const s3 = (r) => r.baseIndent;
function gn({ except: r, units: e = 1 } = {}) {
  return (t) => {
    let l = r && r.test(t.textAfter);
    return t.baseIndent + (l ? 0 : e * t.unit);
  };
}
const a3 = 200;
function c3() {
  return pe.transactionFilter.of((r) => {
    if (!r.docChanged || !r.isUserEvent("input.type") && !r.isUserEvent("input.complete"))
      return r;
    let e = r.startState.languageDataAt("indentOnInput", r.startState.selection.main.head);
    if (!e.length)
      return r;
    let t = r.newDoc, { head: l } = r.newSelection.main, i = t.lineAt(l);
    if (l > i.from + a3)
      return r;
    let o = t.sliceString(i.from, l);
    if (!e.some((c) => c.test(o)))
      return r;
    let { state: n } = r, s = -1, a = [];
    for (let { head: c } of n.selection.ranges) {
      let d = n.doc.lineAt(c);
      if (d.from == s)
        continue;
      s = d.from;
      let h = Md(n, d.from);
      if (h == null)
        continue;
      let p = /^\s*/.exec(d.text)[0], u = eo(n, h);
      p != u && a.push({ from: d.from, to: d.from + p.length, insert: u });
    }
    return a.length ? [r, { changes: a, sequential: !0 }] : r;
  });
}
const d3 = /* @__PURE__ */ Y.define(), As = /* @__PURE__ */ new se();
function pb(r) {
  let e = r.firstChild, t = r.lastChild;
  return e && e.to < t.from ? { from: e.to, to: t.type.isError ? r.to : t.from } : null;
}
function h3(r, e, t) {
  let l = ze(r);
  if (l.length < t)
    return null;
  let i = l.resolveInner(t, 1), o = null;
  for (let n = i; n; n = n.parent) {
    if (n.to <= t || n.from > t)
      continue;
    if (o && n.from < e)
      break;
    let s = n.type.prop(As);
    if (s && (n.to < l.length - 50 || l.length == r.doc.length || !p3(n))) {
      let a = s(n, r);
      a && a.from <= t && a.from >= e && a.to > t && (o = a);
    }
  }
  return o;
}
function p3(r) {
  let e = r.lastChild;
  return e && e.to == r.to && e.type.isError;
}
function In(r, e, t) {
  for (let l of r.facet(d3)) {
    let i = l(r, e, t);
    if (i)
      return i;
  }
  return h3(r, e, t);
}
function ub(r, e) {
  let t = e.mapPos(r.from, 1), l = e.mapPos(r.to, -1);
  return t >= l ? void 0 : { from: t, to: l };
}
const Es = /* @__PURE__ */ le.define({ map: ub }), Oo = /* @__PURE__ */ le.define({ map: ub });
function fb(r) {
  let e = [];
  for (let { head: t } of r.state.selection.ranges)
    e.some((l) => l.from <= t && l.to >= t) || e.push(r.lineBlockAt(t));
  return e;
}
const xl = /* @__PURE__ */ Ue.define({
  create() {
    return B.none;
  },
  update(r, e) {
    r = r.map(e.changes);
    for (let t of e.effects)
      t.is(Es) && !u3(r, t.value.from, t.value.to) ? r = r.update({ add: [hu.range(t.value.from, t.value.to)] }) : t.is(Oo) && (r = r.update({
        filter: (l, i) => t.value.from != l || t.value.to != i,
        filterFrom: t.value.from,
        filterTo: t.value.to
      }));
    if (e.selection) {
      let t = !1, { head: l } = e.selection.main;
      r.between(l, l, (i, o) => {
        i < l && o > l && (t = !0);
      }), t && (r = r.update({
        filterFrom: l,
        filterTo: l,
        filter: (i, o) => o <= l || i >= l
      }));
    }
    return r;
  },
  provide: (r) => I.decorations.from(r),
  toJSON(r, e) {
    let t = [];
    return r.between(0, e.doc.length, (l, i) => {
      t.push(l, i);
    }), t;
  },
  fromJSON(r) {
    if (!Array.isArray(r) || r.length % 2)
      throw new RangeError("Invalid JSON for fold state");
    let e = [];
    for (let t = 0; t < r.length; ) {
      let l = r[t++], i = r[t++];
      if (typeof l != "number" || typeof i != "number")
        throw new RangeError("Invalid JSON for fold state");
      e.push(hu.range(l, i));
    }
    return B.set(e, !0);
  }
});
function Un(r, e, t) {
  var l;
  let i = null;
  return (l = r.field(xl, !1)) === null || l === void 0 || l.between(e, t, (o, n) => {
    (!i || i.from > o) && (i = { from: o, to: n });
  }), i;
}
function u3(r, e, t) {
  let l = !1;
  return r.between(e, e, (i, o) => {
    i == e && o == t && (l = !0);
  }), l;
}
function gb(r, e) {
  return r.field(xl, !1) ? e : e.concat(le.appendConfig.of(Ob()));
}
const f3 = (r) => {
  for (let e of fb(r)) {
    let t = In(r.state, e.from, e.to);
    if (t)
      return r.dispatch({ effects: gb(r.state, [Es.of(t), mb(r, t)]) }), !0;
  }
  return !1;
}, g3 = (r) => {
  if (!r.state.field(xl, !1))
    return !1;
  let e = [];
  for (let t of fb(r)) {
    let l = Un(r.state, t.from, t.to);
    l && e.push(Oo.of(l), mb(r, l, !1));
  }
  return e.length && r.dispatch({ effects: e }), e.length > 0;
};
function mb(r, e, t = !0) {
  let l = r.state.doc.lineAt(e.from).number, i = r.state.doc.lineAt(e.to).number;
  return I.announce.of(`${r.state.phrase(t ? "Folded lines" : "Unfolded lines")} ${l} ${r.state.phrase("to")} ${i}.`);
}
const m3 = (r) => {
  let { state: e } = r, t = [];
  for (let l = 0; l < e.doc.length; ) {
    let i = r.lineBlockAt(l), o = In(e, i.from, i.to);
    o && t.push(Es.of(o)), l = (o ? r.lineBlockAt(o.to) : i).to + 1;
  }
  return t.length && r.dispatch({ effects: gb(r.state, t) }), !!t.length;
}, b3 = (r) => {
  let e = r.state.field(xl, !1);
  if (!e || !e.size)
    return !1;
  let t = [];
  return e.between(0, r.state.doc.length, (l, i) => {
    t.push(Oo.of({ from: l, to: i }));
  }), r.dispatch({ effects: t }), !0;
}, O3 = [
  { key: "Ctrl-Shift-[", mac: "Cmd-Alt-[", run: f3 },
  { key: "Ctrl-Shift-]", mac: "Cmd-Alt-]", run: g3 },
  { key: "Ctrl-Alt-[", run: m3 },
  { key: "Ctrl-Alt-]", run: b3 }
], v3 = {
  placeholderDOM: null,
  placeholderText: "…"
}, bb = /* @__PURE__ */ Y.define({
  combine(r) {
    return ir(r, v3);
  }
});
function Ob(r) {
  let e = [xl, w3];
  return r && e.push(bb.of(r)), e;
}
const hu = /* @__PURE__ */ B.replace({ widget: /* @__PURE__ */ new class extends br {
  toDOM(r) {
    let { state: e } = r, t = e.facet(bb), l = (o) => {
      let n = r.lineBlockAt(r.posAtDOM(o.target)), s = Un(r.state, n.from, n.to);
      s && r.dispatch({ effects: Oo.of(s) }), o.preventDefault();
    };
    if (t.placeholderDOM)
      return t.placeholderDOM(r, l);
    let i = document.createElement("span");
    return i.textContent = t.placeholderText, i.setAttribute("aria-label", e.phrase("folded code")), i.title = e.phrase("unfold"), i.className = "cm-foldPlaceholder", i.onclick = l, i;
  }
}() }), x3 = {
  openText: "⌄",
  closedText: "›",
  markerDOM: null,
  domEventHandlers: {},
  foldingChanged: () => !1
};
class fa extends fr {
  constructor(e, t) {
    super(), this.config = e, this.open = t;
  }
  eq(e) {
    return this.config == e.config && this.open == e.open;
  }
  toDOM(e) {
    if (this.config.markerDOM)
      return this.config.markerDOM(this.open);
    let t = document.createElement("span");
    return t.textContent = this.open ? this.config.openText : this.config.closedText, t.title = e.state.phrase(this.open ? "Fold line" : "Unfold line"), t;
  }
}
function _3(r = {}) {
  let e = Object.assign(Object.assign({}, x3), r), t = new fa(e, !0), l = new fa(e, !1), i = Ze.fromClass(class {
    constructor(n) {
      this.from = n.viewport.from, this.markers = this.buildMarkers(n);
    }
    update(n) {
      (n.docChanged || n.viewportChanged || n.startState.facet(qr) != n.state.facet(qr) || n.startState.field(xl, !1) != n.state.field(xl, !1) || ze(n.startState) != ze(n.state) || e.foldingChanged(n)) && (this.markers = this.buildMarkers(n.view));
    }
    buildMarkers(n) {
      let s = new Yr();
      for (let a of n.viewportLineBlocks) {
        let c = Un(n.state, a.from, a.to) ? l : In(n.state, a.from, a.to) ? t : null;
        c && s.add(a.from, a.from, c);
      }
      return s.finish();
    }
  }), { domEventHandlers: o } = e;
  return [
    i,
    Ok({
      class: "cm-foldGutter",
      markers(n) {
        var s;
        return ((s = n.plugin(i)) === null || s === void 0 ? void 0 : s.markers) || ge.empty;
      },
      initialSpacer() {
        return new fa(e, !1);
      },
      domEventHandlers: Object.assign(Object.assign({}, o), { click: (n, s, a) => {
        if (o.click && o.click(n, s, a))
          return !0;
        let c = Un(n.state, s.from, s.to);
        if (c)
          return n.dispatch({ effects: Oo.of(c) }), !0;
        let d = In(n.state, s.from, s.to);
        return d ? (n.dispatch({ effects: Es.of(d) }), !0) : !1;
      } })
    }),
    Ob()
  ];
}
const w3 = /* @__PURE__ */ I.baseTheme({
  ".cm-foldPlaceholder": {
    backgroundColor: "#eee",
    border: "1px solid #ddd",
    color: "#888",
    borderRadius: ".2em",
    margin: "0 1px",
    padding: "0 1px",
    cursor: "pointer"
  },
  ".cm-foldGutter span": {
    padding: "0 1px",
    cursor: "pointer"
  }
});
class Vs {
  constructor(e, t) {
    this.specs = e;
    let l;
    function i(s) {
      let a = jr.newName();
      return (l || (l = /* @__PURE__ */ Object.create(null)))["." + a] = s, a;
    }
    const o = typeof t.all == "string" ? t.all : t.all ? i(t.all) : void 0, n = t.scope;
    this.scope = n instanceof Rt ? (s) => s.prop(Ji) == n.data : n ? (s) => s == n : void 0, this.style = ab(e.map((s) => ({
      tag: s.tag,
      class: s.class || i(Object.assign({}, s, { tag: null }))
    })), {
      all: o
    }).style, this.module = l ? new jr(l) : null, this.themeType = t.themeType;
  }
  /**
  Create a highlighter style that associates the given styles to
  the given tags. The specs must be objects that hold a style tag
  or array of tags in their `tag` property, and either a single
  `class` property providing a static CSS class (for highlighter
  that rely on external styling), or a
  [`style-mod`](https://github.com/marijnh/style-mod#documentation)-style
  set of CSS properties (which define the styling for those tags).
  
  The CSS rules created for a highlighter will be emitted in the
  order of the spec's properties. That means that for elements that
  have multiple tags associated with them, styles defined further
  down in the list will have a higher CSS precedence than styles
  defined earlier.
  */
  static define(e, t) {
    return new Vs(e, t || {});
  }
}
const Ec = /* @__PURE__ */ Y.define(), vb = /* @__PURE__ */ Y.define({
  combine(r) {
    return r.length ? [r[0]] : null;
  }
});
function ga(r) {
  let e = r.facet(Ec);
  return e.length ? e : r.facet(vb);
}
function y3(r, e) {
  let t = [S3], l;
  return r instanceof Vs && (r.module && t.push(I.styleModule.of(r.module)), l = r.themeType), e != null && e.fallback ? t.push(vb.of(r)) : l ? t.push(Ec.computeN([I.darkTheme], (i) => i.facet(I.darkTheme) == (l == "dark") ? [r] : [])) : t.push(Ec.of(r)), t;
}
class k3 {
  constructor(e) {
    this.markCache = /* @__PURE__ */ Object.create(null), this.tree = ze(e.state), this.decorations = this.buildDeco(e, ga(e.state));
  }
  update(e) {
    let t = ze(e.state), l = ga(e.state), i = l != ga(e.startState);
    t.length < e.view.viewport.to && !i && t.type == this.tree.type ? this.decorations = this.decorations.map(e.changes) : (t != this.tree || e.viewportChanged || i) && (this.tree = t, this.decorations = this.buildDeco(e.view, l));
  }
  buildDeco(e, t) {
    if (!t || !this.tree.length)
      return B.none;
    let l = new Yr();
    for (let { from: i, to: o } of e.visibleRanges)
      Bk(this.tree, t, (n, s, a) => {
        l.add(n, s, this.markCache[a] || (this.markCache[a] = B.mark({ class: a })));
      }, i, o);
    return l.finish();
  }
}
const S3 = /* @__PURE__ */ kl.high(/* @__PURE__ */ Ze.fromClass(k3, {
  decorations: (r) => r.decorations
})), Q3 = /* @__PURE__ */ Vs.define([
  {
    tag: v.meta,
    color: "#404740"
  },
  {
    tag: v.link,
    textDecoration: "underline"
  },
  {
    tag: v.heading,
    textDecoration: "underline",
    fontWeight: "bold"
  },
  {
    tag: v.emphasis,
    fontStyle: "italic"
  },
  {
    tag: v.strong,
    fontWeight: "bold"
  },
  {
    tag: v.strikethrough,
    textDecoration: "line-through"
  },
  {
    tag: v.keyword,
    color: "#708"
  },
  {
    tag: [v.atom, v.bool, v.url, v.contentSeparator, v.labelName],
    color: "#219"
  },
  {
    tag: [v.literal, v.inserted],
    color: "#164"
  },
  {
    tag: [v.string, v.deleted],
    color: "#a11"
  },
  {
    tag: [v.regexp, v.escape, /* @__PURE__ */ v.special(v.string)],
    color: "#e40"
  },
  {
    tag: /* @__PURE__ */ v.definition(v.variableName),
    color: "#00f"
  },
  {
    tag: /* @__PURE__ */ v.local(v.variableName),
    color: "#30a"
  },
  {
    tag: [v.typeName, v.namespace],
    color: "#085"
  },
  {
    tag: v.className,
    color: "#167"
  },
  {
    tag: [/* @__PURE__ */ v.special(v.variableName), v.macroName],
    color: "#256"
  },
  {
    tag: /* @__PURE__ */ v.definition(v.propertyName),
    color: "#00c"
  },
  {
    tag: v.comment,
    color: "#940"
  },
  {
    tag: v.invalid,
    color: "#f00"
  }
]), $3 = /* @__PURE__ */ I.baseTheme({
  "&.cm-focused .cm-matchingBracket": { backgroundColor: "#328c8252" },
  "&.cm-focused .cm-nonmatchingBracket": { backgroundColor: "#bb555544" }
}), xb = 1e4, _b = "()[]{}", wb = /* @__PURE__ */ Y.define({
  combine(r) {
    return ir(r, {
      afterCursor: !0,
      brackets: _b,
      maxScanDistance: xb,
      renderMatch: T3
    });
  }
}), P3 = /* @__PURE__ */ B.mark({ class: "cm-matchingBracket" }), C3 = /* @__PURE__ */ B.mark({ class: "cm-nonmatchingBracket" });
function T3(r) {
  let e = [], t = r.matched ? P3 : C3;
  return e.push(t.range(r.start.from, r.start.to)), r.end && e.push(t.range(r.end.from, r.end.to)), e;
}
const z3 = /* @__PURE__ */ Ue.define({
  create() {
    return B.none;
  },
  update(r, e) {
    if (!e.docChanged && !e.selection)
      return r;
    let t = [], l = e.state.facet(wb);
    for (let i of e.state.selection.ranges) {
      if (!i.empty)
        continue;
      let o = Jt(e.state, i.head, -1, l) || i.head > 0 && Jt(e.state, i.head - 1, 1, l) || l.afterCursor && (Jt(e.state, i.head, 1, l) || i.head < e.state.doc.length && Jt(e.state, i.head + 1, -1, l));
      o && (t = t.concat(l.renderMatch(o, e.state)));
    }
    return B.set(t, !0);
  },
  provide: (r) => I.decorations.from(r)
}), X3 = [
  z3,
  $3
];
function A3(r = {}) {
  return [wb.of(r), X3];
}
const yb = /* @__PURE__ */ new se();
function Vc(r, e, t) {
  let l = r.prop(e < 0 ? se.openedBy : se.closedBy);
  if (l)
    return l;
  if (r.name.length == 1) {
    let i = t.indexOf(r.name);
    if (i > -1 && i % 2 == (e < 0 ? 1 : 0))
      return [t[i + e]];
  }
  return null;
}
function Zc(r) {
  let e = r.type.prop(yb);
  return e ? e(r.node) : r;
}
function Jt(r, e, t, l = {}) {
  let i = l.maxScanDistance || xb, o = l.brackets || _b, n = ze(r), s = n.resolveInner(e, t);
  for (let a = s; a; a = a.parent) {
    let c = Vc(a.type, t, o);
    if (c && a.from < a.to) {
      let d = Zc(a);
      if (d && (t > 0 ? e >= d.from && e < d.to : e > d.from && e <= d.to))
        return E3(r, e, t, a, d, c, o);
    }
  }
  return V3(r, e, t, n, s.type, i, o);
}
function E3(r, e, t, l, i, o, n) {
  let s = l.parent, a = { from: i.from, to: i.to }, c = 0, d = s == null ? void 0 : s.cursor();
  if (d && (t < 0 ? d.childBefore(l.from) : d.childAfter(l.to)))
    do
      if (t < 0 ? d.to <= l.from : d.from >= l.to) {
        if (c == 0 && o.indexOf(d.type.name) > -1 && d.from < d.to) {
          let h = Zc(d);
          return { start: a, end: h ? { from: h.from, to: h.to } : void 0, matched: !0 };
        } else if (Vc(d.type, t, n))
          c++;
        else if (Vc(d.type, -t, n)) {
          if (c == 0) {
            let h = Zc(d);
            return {
              start: a,
              end: h && h.from < h.to ? { from: h.from, to: h.to } : void 0,
              matched: !1
            };
          }
          c--;
        }
      }
    while (t < 0 ? d.prevSibling() : d.nextSibling());
  return { start: a, matched: !1 };
}
function V3(r, e, t, l, i, o, n) {
  let s = t < 0 ? r.sliceDoc(e - 1, e) : r.sliceDoc(e, e + 1), a = n.indexOf(s);
  if (a < 0 || a % 2 == 0 != t > 0)
    return null;
  let c = { from: t < 0 ? e - 1 : e, to: t > 0 ? e + 1 : e }, d = r.doc.iterRange(e, t > 0 ? r.doc.length : 0), h = 0;
  for (let p = 0; !d.next().done && p <= o; ) {
    let u = d.value;
    t < 0 && (p += u.length);
    let f = e + p * t;
    for (let m = t > 0 ? 0 : u.length - 1, O = t > 0 ? u.length : -1; m != O; m += t) {
      let x = n.indexOf(u[m]);
      if (!(x < 0 || l.resolveInner(f + m, 1).type != i))
        if (x % 2 == 0 == t > 0)
          h++;
        else {
          if (h == 1)
            return { start: c, end: { from: f + m, to: f + m + 1 }, matched: x >> 1 == a >> 1 };
          h--;
        }
    }
    t > 0 && (p += u.length);
  }
  return d.done ? { start: c, matched: !1 } : null;
}
const Z3 = /* @__PURE__ */ Object.create(null), pu = [ct.none], uu = [], R3 = /* @__PURE__ */ Object.create(null);
for (let [r, e] of [
  ["variable", "variableName"],
  ["variable-2", "variableName.special"],
  ["string-2", "string.special"],
  ["def", "variableName.definition"],
  ["tag", "tagName"],
  ["attribute", "attributeName"],
  ["type", "typeName"],
  ["builtin", "variableName.standard"],
  ["qualifier", "modifier"],
  ["error", "invalid"],
  ["header", "heading"],
  ["property", "propertyName"]
])
  R3[r] = /* @__PURE__ */ D3(Z3, e);
function ma(r, e) {
  uu.indexOf(r) > -1 || (uu.push(r), console.warn(e));
}
function D3(r, e) {
  let t = null;
  for (let o of e.split(".")) {
    let n = r[o] || v[o];
    n ? typeof n == "function" ? t ? t = n(t) : ma(o, `Modifier ${o} used at start of tag`) : t ? ma(o, `Tag ${o} used as modifier`) : t = n : ma(o, `Unknown highlighting tag ${o}`);
  }
  if (!t)
    return 0;
  let l = e.replace(/ /g, "_"), i = ct.define({
    id: pu.length,
    name: l,
    props: [Cs({ [l]: t })]
  });
  return pu.push(i), i.id;
}
const W3 = (r) => {
  let e = Id(r.state);
  return e.line ? N3(r) : e.block ? Y3(r) : !1;
};
function jd(r, e) {
  return ({ state: t, dispatch: l }) => {
    if (t.readOnly)
      return !1;
    let i = r(e, t);
    return i ? (l(t.update(i)), !0) : !1;
  };
}
const N3 = /* @__PURE__ */ jd(
  U3,
  0
  /* CommentOption.Toggle */
), M3 = /* @__PURE__ */ jd(
  kb,
  0
  /* CommentOption.Toggle */
), Y3 = /* @__PURE__ */ jd(
  (r, e) => kb(r, e, I3(e)),
  0
  /* CommentOption.Toggle */
);
function Id(r, e = r.selection.main.head) {
  let t = r.languageDataAt("commentTokens", e);
  return t.length ? t[0] : {};
}
const Oi = 50;
function j3(r, { open: e, close: t }, l, i) {
  let o = r.sliceDoc(l - Oi, l), n = r.sliceDoc(i, i + Oi), s = /\s*$/.exec(o)[0].length, a = /^\s*/.exec(n)[0].length, c = o.length - s;
  if (o.slice(c - e.length, c) == e && n.slice(a, a + t.length) == t)
    return {
      open: { pos: l - s, margin: s && 1 },
      close: { pos: i + a, margin: a && 1 }
    };
  let d, h;
  i - l <= 2 * Oi ? d = h = r.sliceDoc(l, i) : (d = r.sliceDoc(l, l + Oi), h = r.sliceDoc(i - Oi, i));
  let p = /^\s*/.exec(d)[0].length, u = /\s*$/.exec(h)[0].length, f = h.length - u - t.length;
  return d.slice(p, p + e.length) == e && h.slice(f, f + t.length) == t ? {
    open: {
      pos: l + p + e.length,
      margin: /\s/.test(d.charAt(p + e.length)) ? 1 : 0
    },
    close: {
      pos: i - u - t.length,
      margin: /\s/.test(h.charAt(f - 1)) ? 1 : 0
    }
  } : null;
}
function I3(r) {
  let e = [];
  for (let t of r.selection.ranges) {
    let l = r.doc.lineAt(t.from), i = t.to <= l.to ? l : r.doc.lineAt(t.to), o = e.length - 1;
    o >= 0 && e[o].to > l.from ? e[o].to = i.to : e.push({ from: l.from, to: i.to });
  }
  return e;
}
function kb(r, e, t = e.selection.ranges) {
  let l = t.map((o) => Id(e, o.from).block);
  if (!l.every((o) => o))
    return null;
  let i = t.map((o, n) => j3(e, l[n], o.from, o.to));
  if (r != 2 && !i.every((o) => o))
    return { changes: e.changes(t.map((o, n) => i[n] ? [] : [{ from: o.from, insert: l[n].open + " " }, { from: o.to, insert: " " + l[n].close }])) };
  if (r != 1 && i.some((o) => o)) {
    let o = [];
    for (let n = 0, s; n < i.length; n++)
      if (s = i[n]) {
        let a = l[n], { open: c, close: d } = s;
        o.push({ from: c.pos - a.open.length, to: c.pos + c.margin }, { from: d.pos - d.margin, to: d.pos + a.close.length });
      }
    return { changes: o };
  }
  return null;
}
function U3(r, e, t = e.selection.ranges) {
  let l = [], i = -1;
  for (let { from: o, to: n } of t) {
    let s = l.length, a = 1e9;
    for (let c = o; c <= n; ) {
      let d = e.doc.lineAt(c);
      if (d.from > i && (o == n || n > d.from)) {
        i = d.from;
        let h = Id(e, c).line;
        if (!h)
          continue;
        let p = /^\s*/.exec(d.text)[0].length, u = p == d.length, f = d.text.slice(p, p + h.length) == h ? p : -1;
        p < d.text.length && p < a && (a = p), l.push({ line: d, comment: f, token: h, indent: p, empty: u, single: !1 });
      }
      c = d.to + 1;
    }
    if (a < 1e9)
      for (let c = s; c < l.length; c++)
        l[c].indent < l[c].line.text.length && (l[c].indent = a);
    l.length == s + 1 && (l[s].single = !0);
  }
  if (r != 2 && l.some((o) => o.comment < 0 && (!o.empty || o.single))) {
    let o = [];
    for (let { line: s, token: a, indent: c, empty: d, single: h } of l)
      (h || !d) && o.push({ from: s.from + c, insert: a + " " });
    let n = e.changes(o);
    return { changes: n, selection: e.selection.map(n, 1) };
  } else if (r != 1 && l.some((o) => o.comment >= 0)) {
    let o = [];
    for (let { line: n, comment: s, token: a } of l)
      if (s >= 0) {
        let c = n.from + s, d = c + a.length;
        n.text[d - n.from] == " " && d++, o.push({ from: c, to: d });
      }
    return { changes: o };
  }
  return null;
}
const Rc = /* @__PURE__ */ Lr.define(), q3 = /* @__PURE__ */ Lr.define(), B3 = /* @__PURE__ */ Y.define(), Sb = /* @__PURE__ */ Y.define({
  combine(r) {
    return ir(r, {
      minDepth: 100,
      newGroupDelay: 500,
      joinToEvent: (e, t) => t
    }, {
      minDepth: Math.max,
      newGroupDelay: Math.min,
      joinToEvent: (e, t) => (l, i) => e(l, i) || t(l, i)
    });
  }
});
function L3(r) {
  let e = 0;
  return r.iterChangedRanges((t, l) => e = l), e;
}
const Qb = /* @__PURE__ */ Ue.define({
  create() {
    return er.empty;
  },
  update(r, e) {
    let t = e.state.facet(Sb), l = e.annotation(Rc);
    if (l) {
      let a = e.docChanged ? w.single(L3(e.changes)) : void 0, c = pt.fromTransaction(e, a), d = l.side, h = d == 0 ? r.undone : r.done;
      return c ? h = qn(h, h.length, t.minDepth, c) : h = Cb(h, e.startState.selection), new er(d == 0 ? l.rest : h, d == 0 ? h : l.rest);
    }
    let i = e.annotation(q3);
    if ((i == "full" || i == "before") && (r = r.isolate()), e.annotation(We.addToHistory) === !1)
      return e.changes.empty ? r : r.addMapping(e.changes.desc);
    let o = pt.fromTransaction(e), n = e.annotation(We.time), s = e.annotation(We.userEvent);
    return o ? r = r.addChanges(o, n, s, t, e) : e.selection && (r = r.addSelection(e.startState.selection, n, s, t.newGroupDelay)), (i == "full" || i == "after") && (r = r.isolate()), r;
  },
  toJSON(r) {
    return { done: r.done.map((e) => e.toJSON()), undone: r.undone.map((e) => e.toJSON()) };
  },
  fromJSON(r) {
    return new er(r.done.map(pt.fromJSON), r.undone.map(pt.fromJSON));
  }
});
function G3(r = {}) {
  return [
    Qb,
    Sb.of(r),
    I.domEventHandlers({
      beforeinput(e, t) {
        let l = e.inputType == "historyUndo" ? $b : e.inputType == "historyRedo" ? Dc : null;
        return l ? (e.preventDefault(), l(t)) : !1;
      }
    })
  ];
}
function Zs(r, e) {
  return function({ state: t, dispatch: l }) {
    if (!e && t.readOnly)
      return !1;
    let i = t.field(Qb, !1);
    if (!i)
      return !1;
    let o = i.pop(r, t, e);
    return o ? (l(o), !0) : !1;
  };
}
const $b = /* @__PURE__ */ Zs(0, !1), Dc = /* @__PURE__ */ Zs(1, !1), F3 = /* @__PURE__ */ Zs(0, !0), H3 = /* @__PURE__ */ Zs(1, !0);
class pt {
  constructor(e, t, l, i, o) {
    this.changes = e, this.effects = t, this.mapped = l, this.startSelection = i, this.selectionsAfter = o;
  }
  setSelAfter(e) {
    return new pt(this.changes, this.effects, this.mapped, this.startSelection, e);
  }
  toJSON() {
    var e, t, l;
    return {
      changes: (e = this.changes) === null || e === void 0 ? void 0 : e.toJSON(),
      mapped: (t = this.mapped) === null || t === void 0 ? void 0 : t.toJSON(),
      startSelection: (l = this.startSelection) === null || l === void 0 ? void 0 : l.toJSON(),
      selectionsAfter: this.selectionsAfter.map((i) => i.toJSON())
    };
  }
  static fromJSON(e) {
    return new pt(e.changes && Re.fromJSON(e.changes), [], e.mapped && tr.fromJSON(e.mapped), e.startSelection && w.fromJSON(e.startSelection), e.selectionsAfter.map(w.fromJSON));
  }
  // This does not check `addToHistory` and such, it assumes the
  // transaction needs to be converted to an item. Returns null when
  // there are no changes or effects in the transaction.
  static fromTransaction(e, t) {
    let l = $t;
    for (let i of e.startState.facet(B3)) {
      let o = i(e);
      o.length && (l = l.concat(o));
    }
    return !l.length && e.changes.empty ? null : new pt(e.changes.invert(e.startState.doc), l, void 0, t || e.startState.selection, $t);
  }
  static selection(e) {
    return new pt(void 0, $t, void 0, void 0, e);
  }
}
function qn(r, e, t, l) {
  let i = e + 1 > t + 20 ? e - t - 1 : 0, o = r.slice(i, e);
  return o.push(l), o;
}
function K3(r, e) {
  let t = [], l = !1;
  return r.iterChangedRanges((i, o) => t.push(i, o)), e.iterChangedRanges((i, o, n, s) => {
    for (let a = 0; a < t.length; ) {
      let c = t[a++], d = t[a++];
      s >= c && n <= d && (l = !0);
    }
  }), l;
}
function J3(r, e) {
  return r.ranges.length == e.ranges.length && r.ranges.filter((t, l) => t.empty != e.ranges[l].empty).length === 0;
}
function Pb(r, e) {
  return r.length ? e.length ? r.concat(e) : r : e;
}
const $t = [], eS = 200;
function Cb(r, e) {
  if (r.length) {
    let t = r[r.length - 1], l = t.selectionsAfter.slice(Math.max(0, t.selectionsAfter.length - eS));
    return l.length && l[l.length - 1].eq(e) ? r : (l.push(e), qn(r, r.length - 1, 1e9, t.setSelAfter(l)));
  } else
    return [pt.selection([e])];
}
function tS(r) {
  let e = r[r.length - 1], t = r.slice();
  return t[r.length - 1] = e.setSelAfter(e.selectionsAfter.slice(0, e.selectionsAfter.length - 1)), t;
}
function ba(r, e) {
  if (!r.length)
    return r;
  let t = r.length, l = $t;
  for (; t; ) {
    let i = rS(r[t - 1], e, l);
    if (i.changes && !i.changes.empty || i.effects.length) {
      let o = r.slice(0, t);
      return o[t - 1] = i, o;
    } else
      e = i.mapped, t--, l = i.selectionsAfter;
  }
  return l.length ? [pt.selection(l)] : $t;
}
function rS(r, e, t) {
  let l = Pb(r.selectionsAfter.length ? r.selectionsAfter.map((s) => s.map(e)) : $t, t);
  if (!r.changes)
    return pt.selection(l);
  let i = r.changes.map(e), o = e.mapDesc(r.changes, !0), n = r.mapped ? r.mapped.composeDesc(o) : o;
  return new pt(i, le.mapEffects(r.effects, e), n, r.startSelection.map(o), l);
}
const lS = /^(input\.type|delete)($|\.)/;
class er {
  constructor(e, t, l = 0, i = void 0) {
    this.done = e, this.undone = t, this.prevTime = l, this.prevUserEvent = i;
  }
  isolate() {
    return this.prevTime ? new er(this.done, this.undone) : this;
  }
  addChanges(e, t, l, i, o) {
    let n = this.done, s = n[n.length - 1];
    return s && s.changes && !s.changes.empty && e.changes && (!l || lS.test(l)) && (!s.selectionsAfter.length && t - this.prevTime < i.newGroupDelay && i.joinToEvent(o, K3(s.changes, e.changes)) || // For compose (but not compose.start) events, always join with previous event
    l == "input.type.compose") ? n = qn(n, n.length - 1, i.minDepth, new pt(e.changes.compose(s.changes), Pb(e.effects, s.effects), s.mapped, s.startSelection, $t)) : n = qn(n, n.length, i.minDepth, e), new er(n, $t, t, l);
  }
  addSelection(e, t, l, i) {
    let o = this.done.length ? this.done[this.done.length - 1].selectionsAfter : $t;
    return o.length > 0 && t - this.prevTime < i && l == this.prevUserEvent && l && /^select($|\.)/.test(l) && J3(o[o.length - 1], e) ? this : new er(Cb(this.done, e), this.undone, t, l);
  }
  addMapping(e) {
    return new er(ba(this.done, e), ba(this.undone, e), this.prevTime, this.prevUserEvent);
  }
  pop(e, t, l) {
    let i = e == 0 ? this.done : this.undone;
    if (i.length == 0)
      return null;
    let o = i[i.length - 1];
    if (l && o.selectionsAfter.length)
      return t.update({
        selection: o.selectionsAfter[o.selectionsAfter.length - 1],
        annotations: Rc.of({ side: e, rest: tS(i) }),
        userEvent: e == 0 ? "select.undo" : "select.redo",
        scrollIntoView: !0
      });
    if (o.changes) {
      let n = i.length == 1 ? $t : i.slice(0, i.length - 1);
      return o.mapped && (n = ba(n, o.mapped)), t.update({
        changes: o.changes,
        selection: o.startSelection,
        effects: o.effects,
        annotations: Rc.of({ side: e, rest: n }),
        filter: !1,
        userEvent: e == 0 ? "undo" : "redo",
        scrollIntoView: !0
      });
    } else
      return null;
  }
}
er.empty = /* @__PURE__ */ new er($t, $t);
const iS = [
  { key: "Mod-z", run: $b, preventDefault: !0 },
  { key: "Mod-y", mac: "Mod-Shift-z", run: Dc, preventDefault: !0 },
  { linux: "Ctrl-Shift-z", run: Dc, preventDefault: !0 },
  { key: "Mod-u", run: F3, preventDefault: !0 },
  { key: "Alt-u", mac: "Mod-Shift-u", run: H3, preventDefault: !0 }
];
function si(r, e) {
  return w.create(r.ranges.map(e), r.mainIndex);
}
function or(r, e) {
  return r.update({ selection: e, scrollIntoView: !0, userEvent: "select" });
}
function Nt({ state: r, dispatch: e }, t) {
  let l = si(r.selection, t);
  return l.eq(r.selection) ? !1 : (e(or(r, l)), !0);
}
function Rs(r, e) {
  return w.cursor(e ? r.to : r.from);
}
function Tb(r, e) {
  return Nt(r, (t) => t.empty ? r.moveByChar(t, e) : Rs(t, e));
}
function Je(r) {
  return r.textDirectionAt(r.state.selection.main.head) == Ce.LTR;
}
const zb = (r) => Tb(r, !Je(r)), Xb = (r) => Tb(r, Je(r));
function Ab(r, e) {
  return Nt(r, (t) => t.empty ? r.moveByGroup(t, e) : Rs(t, e));
}
const oS = (r) => Ab(r, !Je(r)), nS = (r) => Ab(r, Je(r));
function sS(r, e, t) {
  if (e.type.prop(t))
    return !0;
  let l = e.to - e.from;
  return l && (l > 2 || /[^\s,.;:]/.test(r.sliceDoc(e.from, e.to))) || e.firstChild;
}
function Ds(r, e, t) {
  let l = ze(r).resolveInner(e.head), i = t ? se.closedBy : se.openedBy;
  for (let a = e.head; ; ) {
    let c = t ? l.childAfter(a) : l.childBefore(a);
    if (!c)
      break;
    sS(r, c, i) ? l = c : a = t ? c.to : c.from;
  }
  let o = l.type.prop(i), n, s;
  return o && (n = t ? Jt(r, l.from, 1) : Jt(r, l.to, -1)) && n.matched ? s = t ? n.end.to : n.end.from : s = t ? l.to : l.from, w.cursor(s, t ? -1 : 1);
}
const aS = (r) => Nt(r, (e) => Ds(r.state, e, !Je(r))), cS = (r) => Nt(r, (e) => Ds(r.state, e, Je(r)));
function Eb(r, e) {
  return Nt(r, (t) => {
    if (!t.empty)
      return Rs(t, e);
    let l = r.moveVertically(t, e);
    return l.head != t.head ? l : r.moveToLineBoundary(t, e);
  });
}
const Vb = (r) => Eb(r, !1), Zb = (r) => Eb(r, !0);
function Rb(r) {
  return Math.max(r.defaultLineHeight, Math.min(r.dom.clientHeight, innerHeight) - 5);
}
function Db(r, e) {
  let { state: t } = r, l = si(t.selection, (s) => s.empty ? r.moveVertically(s, e, Rb(r)) : Rs(s, e));
  if (l.eq(t.selection))
    return !1;
  let i = r.coordsAtPos(t.selection.main.head), o = r.scrollDOM.getBoundingClientRect(), n;
  return i && i.top > o.top && i.bottom < o.bottom && i.top - o.top <= r.scrollDOM.scrollHeight - r.scrollDOM.scrollTop - r.scrollDOM.clientHeight && (n = I.scrollIntoView(l.main.head, { y: "start", yMargin: i.top - o.top })), r.dispatch(or(t, l), { effects: n }), !0;
}
const fu = (r) => Db(r, !1), Wc = (r) => Db(r, !0);
function Gr(r, e, t) {
  let l = r.lineBlockAt(e.head), i = r.moveToLineBoundary(e, t);
  if (i.head == e.head && i.head != (t ? l.to : l.from) && (i = r.moveToLineBoundary(e, t, !1)), !t && i.head == l.from && l.length) {
    let o = /^\s*/.exec(r.state.sliceDoc(l.from, Math.min(l.from + 100, l.to)))[0].length;
    o && e.head != l.from + o && (i = w.cursor(l.from + o));
  }
  return i;
}
const dS = (r) => Nt(r, (e) => Gr(r, e, !0)), hS = (r) => Nt(r, (e) => Gr(r, e, !1)), pS = (r) => Nt(r, (e) => Gr(r, e, !Je(r))), uS = (r) => Nt(r, (e) => Gr(r, e, Je(r))), fS = (r) => Nt(r, (e) => w.cursor(r.lineBlockAt(e.head).from, 1)), gS = (r) => Nt(r, (e) => w.cursor(r.lineBlockAt(e.head).to, -1));
function mS(r, e, t) {
  let l = !1, i = si(r.selection, (o) => {
    let n = Jt(r, o.head, -1) || Jt(r, o.head, 1) || o.head > 0 && Jt(r, o.head - 1, 1) || o.head < r.doc.length && Jt(r, o.head + 1, -1);
    if (!n || !n.end)
      return o;
    l = !0;
    let s = n.start.from == o.head ? n.end.to : n.end.from;
    return t ? w.range(o.anchor, s) : w.cursor(s);
  });
  return l ? (e(or(r, i)), !0) : !1;
}
const bS = ({ state: r, dispatch: e }) => mS(r, e, !1);
function zt(r, e) {
  let t = si(r.state.selection, (l) => {
    let i = e(l);
    return w.range(l.anchor, i.head, i.goalColumn, i.bidiLevel || void 0);
  });
  return t.eq(r.state.selection) ? !1 : (r.dispatch(or(r.state, t)), !0);
}
function Wb(r, e) {
  return zt(r, (t) => r.moveByChar(t, e));
}
const Nb = (r) => Wb(r, !Je(r)), Mb = (r) => Wb(r, Je(r));
function Yb(r, e) {
  return zt(r, (t) => r.moveByGroup(t, e));
}
const OS = (r) => Yb(r, !Je(r)), vS = (r) => Yb(r, Je(r)), xS = (r) => zt(r, (e) => Ds(r.state, e, !Je(r))), _S = (r) => zt(r, (e) => Ds(r.state, e, Je(r)));
function jb(r, e) {
  return zt(r, (t) => r.moveVertically(t, e));
}
const Ib = (r) => jb(r, !1), Ub = (r) => jb(r, !0);
function qb(r, e) {
  return zt(r, (t) => r.moveVertically(t, e, Rb(r)));
}
const gu = (r) => qb(r, !1), mu = (r) => qb(r, !0), wS = (r) => zt(r, (e) => Gr(r, e, !0)), yS = (r) => zt(r, (e) => Gr(r, e, !1)), kS = (r) => zt(r, (e) => Gr(r, e, !Je(r))), SS = (r) => zt(r, (e) => Gr(r, e, Je(r))), QS = (r) => zt(r, (e) => w.cursor(r.lineBlockAt(e.head).from)), $S = (r) => zt(r, (e) => w.cursor(r.lineBlockAt(e.head).to)), bu = ({ state: r, dispatch: e }) => (e(or(r, { anchor: 0 })), !0), Ou = ({ state: r, dispatch: e }) => (e(or(r, { anchor: r.doc.length })), !0), vu = ({ state: r, dispatch: e }) => (e(or(r, { anchor: r.selection.main.anchor, head: 0 })), !0), xu = ({ state: r, dispatch: e }) => (e(or(r, { anchor: r.selection.main.anchor, head: r.doc.length })), !0), PS = ({ state: r, dispatch: e }) => (e(r.update({ selection: { anchor: 0, head: r.doc.length }, userEvent: "select" })), !0), CS = ({ state: r, dispatch: e }) => {
  let t = Ns(r).map(({ from: l, to: i }) => w.range(l, Math.min(i + 1, r.doc.length)));
  return e(r.update({ selection: w.create(t), userEvent: "select" })), !0;
}, TS = ({ state: r, dispatch: e }) => {
  let t = si(r.selection, (l) => {
    var i;
    let o = ze(r).resolveInner(l.head, 1);
    for (; !(o.from < l.from && o.to >= l.to || o.to > l.to && o.from <= l.from || !(!((i = o.parent) === null || i === void 0) && i.parent)); )
      o = o.parent;
    return w.range(o.to, o.from);
  });
  return e(or(r, t)), !0;
}, zS = ({ state: r, dispatch: e }) => {
  let t = r.selection, l = null;
  return t.ranges.length > 1 ? l = w.create([t.main]) : t.main.empty || (l = w.create([w.cursor(t.main.head)])), l ? (e(or(r, l)), !0) : !1;
};
function Ws(r, e) {
  if (r.state.readOnly)
    return !1;
  let t = "delete.selection", { state: l } = r, i = l.changeByRange((o) => {
    let { from: n, to: s } = o;
    if (n == s) {
      let a = e(n);
      a < n ? (t = "delete.backward", a = Uo(r, a, !1)) : a > n && (t = "delete.forward", a = Uo(r, a, !0)), n = Math.min(n, a), s = Math.max(s, a);
    } else
      n = Uo(r, n, !1), s = Uo(r, s, !0);
    return n == s ? { range: o } : { changes: { from: n, to: s }, range: w.cursor(n) };
  });
  return i.changes.empty ? !1 : (r.dispatch(l.update(i, {
    scrollIntoView: !0,
    userEvent: t,
    effects: t == "delete.selection" ? I.announce.of(l.phrase("Selection deleted")) : void 0
  })), !0);
}
function Uo(r, e, t) {
  if (r instanceof I)
    for (let l of r.state.facet(I.atomicRanges).map((i) => i(r)))
      l.between(e, e, (i, o) => {
        i < e && o > e && (e = t ? o : i);
      });
  return e;
}
const Bb = (r, e) => Ws(r, (t) => {
  let { state: l } = r, i = l.doc.lineAt(t), o, n;
  if (!e && t > i.from && t < i.from + 200 && !/[^ \t]/.test(o = i.text.slice(0, t - i.from))) {
    if (o[o.length - 1] == "	")
      return t - 1;
    let s = fo(o, l.tabSize), a = s % jn(l) || jn(l);
    for (let c = 0; c < a && o[o.length - 1 - c] == " "; c++)
      t--;
    n = t;
  } else
    n = nt(i.text, t - i.from, e, e) + i.from, n == t && i.number != (e ? l.doc.lines : 1) && (n += e ? 1 : -1);
  return n;
}), Nc = (r) => Bb(r, !1), Lb = (r) => Bb(r, !0), Gb = (r, e) => Ws(r, (t) => {
  let l = t, { state: i } = r, o = i.doc.lineAt(l), n = i.charCategorizer(l);
  for (let s = null; ; ) {
    if (l == (e ? o.to : o.from)) {
      l == t && o.number != (e ? i.doc.lines : 1) && (l += e ? 1 : -1);
      break;
    }
    let a = nt(o.text, l - o.from, e) + o.from, c = o.text.slice(Math.min(l, a) - o.from, Math.max(l, a) - o.from), d = n(c);
    if (s != null && d != s)
      break;
    (c != " " || l != t) && (s = d), l = a;
  }
  return l;
}), Fb = (r) => Gb(r, !1), XS = (r) => Gb(r, !0), Hb = (r) => Ws(r, (e) => {
  let t = r.lineBlockAt(e).to;
  return e < t ? t : Math.min(r.state.doc.length, e + 1);
}), AS = (r) => Ws(r, (e) => {
  let t = r.lineBlockAt(e).from;
  return e > t ? t : Math.max(0, e - 1);
}), ES = ({ state: r, dispatch: e }) => {
  if (r.readOnly)
    return !1;
  let t = r.changeByRange((l) => ({
    changes: { from: l.from, to: l.to, insert: ue.of(["", ""]) },
    range: w.cursor(l.from)
  }));
  return e(r.update(t, { scrollIntoView: !0, userEvent: "input" })), !0;
}, VS = ({ state: r, dispatch: e }) => {
  if (r.readOnly)
    return !1;
  let t = r.changeByRange((l) => {
    if (!l.empty || l.from == 0 || l.from == r.doc.length)
      return { range: l };
    let i = l.from, o = r.doc.lineAt(i), n = i == o.from ? i - 1 : nt(o.text, i - o.from, !1) + o.from, s = i == o.to ? i + 1 : nt(o.text, i - o.from, !0) + o.from;
    return {
      changes: { from: n, to: s, insert: r.doc.slice(i, s).append(r.doc.slice(n, i)) },
      range: w.cursor(s)
    };
  });
  return t.changes.empty ? !1 : (e(r.update(t, { scrollIntoView: !0, userEvent: "move.character" })), !0);
};
function Ns(r) {
  let e = [], t = -1;
  for (let l of r.selection.ranges) {
    let i = r.doc.lineAt(l.from), o = r.doc.lineAt(l.to);
    if (!l.empty && l.to == o.from && (o = r.doc.lineAt(l.to - 1)), t >= i.number) {
      let n = e[e.length - 1];
      n.to = o.to, n.ranges.push(l);
    } else
      e.push({ from: i.from, to: o.to, ranges: [l] });
    t = o.number + 1;
  }
  return e;
}
function Kb(r, e, t) {
  if (r.readOnly)
    return !1;
  let l = [], i = [];
  for (let o of Ns(r)) {
    if (t ? o.to == r.doc.length : o.from == 0)
      continue;
    let n = r.doc.lineAt(t ? o.to + 1 : o.from - 1), s = n.length + 1;
    if (t) {
      l.push({ from: o.to, to: n.to }, { from: o.from, insert: n.text + r.lineBreak });
      for (let a of o.ranges)
        i.push(w.range(Math.min(r.doc.length, a.anchor + s), Math.min(r.doc.length, a.head + s)));
    } else {
      l.push({ from: n.from, to: o.from }, { from: o.to, insert: r.lineBreak + n.text });
      for (let a of o.ranges)
        i.push(w.range(a.anchor - s, a.head - s));
    }
  }
  return l.length ? (e(r.update({
    changes: l,
    scrollIntoView: !0,
    selection: w.create(i, r.selection.mainIndex),
    userEvent: "move.line"
  })), !0) : !1;
}
const ZS = ({ state: r, dispatch: e }) => Kb(r, e, !1), RS = ({ state: r, dispatch: e }) => Kb(r, e, !0);
function Jb(r, e, t) {
  if (r.readOnly)
    return !1;
  let l = [];
  for (let i of Ns(r))
    t ? l.push({ from: i.from, insert: r.doc.slice(i.from, i.to) + r.lineBreak }) : l.push({ from: i.to, insert: r.lineBreak + r.doc.slice(i.from, i.to) });
  return e(r.update({ changes: l, scrollIntoView: !0, userEvent: "input.copyline" })), !0;
}
const DS = ({ state: r, dispatch: e }) => Jb(r, e, !1), WS = ({ state: r, dispatch: e }) => Jb(r, e, !0), NS = (r) => {
  if (r.state.readOnly)
    return !1;
  let { state: e } = r, t = e.changes(Ns(e).map(({ from: i, to: o }) => (i > 0 ? i-- : o < e.doc.length && o++, { from: i, to: o }))), l = si(e.selection, (i) => r.moveVertically(i, !0)).map(t);
  return r.dispatch({ changes: t, selection: l, scrollIntoView: !0, userEvent: "delete.line" }), !0;
};
function MS(r, e) {
  if (/\(\)|\[\]|\{\}/.test(r.sliceDoc(e - 1, e + 1)))
    return { from: e, to: e };
  let t = ze(r).resolveInner(e), l = t.childBefore(e), i = t.childAfter(e), o;
  return l && i && l.to <= e && i.from >= e && (o = l.type.prop(se.closedBy)) && o.indexOf(i.name) > -1 && r.doc.lineAt(l.to).from == r.doc.lineAt(i.from).from ? { from: l.to, to: i.from } : null;
}
const YS = /* @__PURE__ */ eO(!1), jS = /* @__PURE__ */ eO(!0);
function eO(r) {
  return ({ state: e, dispatch: t }) => {
    if (e.readOnly)
      return !1;
    let l = e.changeByRange((i) => {
      let { from: o, to: n } = i, s = e.doc.lineAt(o), a = !r && o == n && MS(e, o);
      r && (o = n = (n <= s.to ? s : e.doc.lineAt(n)).to);
      let c = new zs(e, { simulateBreak: o, simulateDoubleBreak: !!a }), d = Md(c, o);
      for (d == null && (d = /^\s*/.exec(e.doc.lineAt(o).text)[0].length); n < s.to && /\s/.test(s.text[n - s.from]); )
        n++;
      a ? { from: o, to: n } = a : o > s.from && o < s.from + 100 && !/\S/.test(s.text.slice(0, o)) && (o = s.from);
      let h = ["", eo(e, d)];
      return a && h.push(eo(e, c.lineIndent(s.from, -1))), {
        changes: { from: o, to: n, insert: ue.of(h) },
        range: w.cursor(o + 1 + h[1].length)
      };
    });
    return t(e.update(l, { scrollIntoView: !0, userEvent: "input" })), !0;
  };
}
function Ud(r, e) {
  let t = -1;
  return r.changeByRange((l) => {
    let i = [];
    for (let n = l.from; n <= l.to; ) {
      let s = r.doc.lineAt(n);
      s.number > t && (l.empty || l.to > s.from) && (e(s, i, l), t = s.number), n = s.to + 1;
    }
    let o = r.changes(i);
    return {
      changes: i,
      range: w.range(o.mapPos(l.anchor, 1), o.mapPos(l.head, 1))
    };
  });
}
const IS = ({ state: r, dispatch: e }) => {
  if (r.readOnly)
    return !1;
  let t = /* @__PURE__ */ Object.create(null), l = new zs(r, { overrideIndentation: (o) => {
    let n = t[o];
    return n ?? -1;
  } }), i = Ud(r, (o, n, s) => {
    let a = Md(l, o.from);
    if (a == null)
      return;
    /\S/.test(o.text) || (a = 0);
    let c = /^\s*/.exec(o.text)[0], d = eo(r, a);
    (c != d || s.from < o.from + c.length) && (t[o.from] = a, n.push({ from: o.from, to: o.from + c.length, insert: d }));
  });
  return i.changes.empty || e(r.update(i, { userEvent: "indent" })), !0;
}, US = ({ state: r, dispatch: e }) => r.readOnly ? !1 : (e(r.update(Ud(r, (t, l) => {
  l.push({ from: t.from, insert: r.facet(Ts) });
}), { userEvent: "input.indent" })), !0), qS = ({ state: r, dispatch: e }) => r.readOnly ? !1 : (e(r.update(Ud(r, (t, l) => {
  let i = /^\s*/.exec(t.text)[0];
  if (!i)
    return;
  let o = fo(i, r.tabSize), n = 0, s = eo(r, Math.max(0, o - jn(r)));
  for (; n < i.length && n < s.length && i.charCodeAt(n) == s.charCodeAt(n); )
    n++;
  l.push({ from: t.from + n, to: t.from + i.length, insert: s.slice(n) });
}), { userEvent: "delete.dedent" })), !0), BS = [
  { key: "Ctrl-b", run: zb, shift: Nb, preventDefault: !0 },
  { key: "Ctrl-f", run: Xb, shift: Mb },
  { key: "Ctrl-p", run: Vb, shift: Ib },
  { key: "Ctrl-n", run: Zb, shift: Ub },
  { key: "Ctrl-a", run: fS, shift: QS },
  { key: "Ctrl-e", run: gS, shift: $S },
  { key: "Ctrl-d", run: Lb },
  { key: "Ctrl-h", run: Nc },
  { key: "Ctrl-k", run: Hb },
  { key: "Ctrl-Alt-h", run: Fb },
  { key: "Ctrl-o", run: ES },
  { key: "Ctrl-t", run: VS },
  { key: "Ctrl-v", run: Wc }
], LS = /* @__PURE__ */ [
  { key: "ArrowLeft", run: zb, shift: Nb, preventDefault: !0 },
  { key: "Mod-ArrowLeft", mac: "Alt-ArrowLeft", run: oS, shift: OS, preventDefault: !0 },
  { mac: "Cmd-ArrowLeft", run: pS, shift: kS, preventDefault: !0 },
  { key: "ArrowRight", run: Xb, shift: Mb, preventDefault: !0 },
  { key: "Mod-ArrowRight", mac: "Alt-ArrowRight", run: nS, shift: vS, preventDefault: !0 },
  { mac: "Cmd-ArrowRight", run: uS, shift: SS, preventDefault: !0 },
  { key: "ArrowUp", run: Vb, shift: Ib, preventDefault: !0 },
  { mac: "Cmd-ArrowUp", run: bu, shift: vu },
  { mac: "Ctrl-ArrowUp", run: fu, shift: gu },
  { key: "ArrowDown", run: Zb, shift: Ub, preventDefault: !0 },
  { mac: "Cmd-ArrowDown", run: Ou, shift: xu },
  { mac: "Ctrl-ArrowDown", run: Wc, shift: mu },
  { key: "PageUp", run: fu, shift: gu },
  { key: "PageDown", run: Wc, shift: mu },
  { key: "Home", run: hS, shift: yS, preventDefault: !0 },
  { key: "Mod-Home", run: bu, shift: vu },
  { key: "End", run: dS, shift: wS, preventDefault: !0 },
  { key: "Mod-End", run: Ou, shift: xu },
  { key: "Enter", run: YS },
  { key: "Mod-a", run: PS },
  { key: "Backspace", run: Nc, shift: Nc },
  { key: "Delete", run: Lb },
  { key: "Mod-Backspace", mac: "Alt-Backspace", run: Fb },
  { key: "Mod-Delete", mac: "Alt-Delete", run: XS },
  { mac: "Mod-Backspace", run: AS },
  { mac: "Mod-Delete", run: Hb }
].concat(/* @__PURE__ */ BS.map((r) => ({ mac: r.key, run: r.run, shift: r.shift }))), tO = /* @__PURE__ */ [
  { key: "Alt-ArrowLeft", mac: "Ctrl-ArrowLeft", run: aS, shift: xS },
  { key: "Alt-ArrowRight", mac: "Ctrl-ArrowRight", run: cS, shift: _S },
  { key: "Alt-ArrowUp", run: ZS },
  { key: "Shift-Alt-ArrowUp", run: DS },
  { key: "Alt-ArrowDown", run: RS },
  { key: "Shift-Alt-ArrowDown", run: WS },
  { key: "Escape", run: zS },
  { key: "Mod-Enter", run: jS },
  { key: "Alt-l", mac: "Ctrl-l", run: CS },
  { key: "Mod-i", run: TS, preventDefault: !0 },
  { key: "Mod-[", run: qS },
  { key: "Mod-]", run: US },
  { key: "Mod-Alt-\\", run: IS },
  { key: "Shift-Mod-k", run: NS },
  { key: "Shift-Mod-\\", run: bS },
  { key: "Mod-/", run: W3 },
  { key: "Alt-A", run: M3 }
].concat(LS);
class Bn {
  /// @internal
  constructor(e, t, l, i, o, n, s, a, c, d = 0, h) {
    this.p = e, this.stack = t, this.state = l, this.reducePos = i, this.pos = o, this.score = n, this.buffer = s, this.bufferBase = a, this.curContext = c, this.lookAhead = d, this.parent = h;
  }
  /// @internal
  toString() {
    return `[${this.stack.filter((e, t) => t % 3 == 0).concat(this.state)}]@${this.pos}${this.score ? "!" + this.score : ""}`;
  }
  // Start an empty stack
  /// @internal
  static start(e, t, l = 0) {
    let i = e.parser.context;
    return new Bn(e, [], t, l, l, 0, [], 0, i ? new _u(i, i.start) : null, 0, null);
  }
  /// The stack's current [context](#lr.ContextTracker) value, if
  /// any. Its type will depend on the context tracker's type
  /// parameter, or it will be `null` if there is no context
  /// tracker.
  get context() {
    return this.curContext ? this.curContext.context : null;
  }
  // Push a state onto the stack, tracking its start position as well
  // as the buffer base at that point.
  /// @internal
  pushState(e, t) {
    this.stack.push(this.state, t, this.bufferBase + this.buffer.length), this.state = e;
  }
  // Apply a reduce action
  /// @internal
  reduce(e) {
    let t = e >> 19, l = e & 65535, { parser: i } = this.p, o = i.dynamicPrecedence(l);
    if (o && (this.score += o), t == 0) {
      this.pushState(i.getGoto(this.state, l, !0), this.reducePos), l < i.minRepeatTerm && this.storeNode(l, this.reducePos, this.reducePos, 4, !0), this.reduceContext(l, this.reducePos);
      return;
    }
    let n = this.stack.length - (t - 1) * 3 - (e & 262144 ? 6 : 0), s = n ? this.stack[n - 2] : 0, a = this.reducePos - s;
    a >= 2e3 && (s == this.p.lastBigReductionStart ? (this.p.bigReductionCount++, this.p.lastBigReductionSize = a) : this.p.lastBigReductionSize < a && (this.p.bigReductionCount = 1, this.p.lastBigReductionStart = s, this.p.lastBigReductionSize = a));
    let c = n ? this.stack[n - 1] : 0, d = this.bufferBase + this.buffer.length - c;
    if (l < i.minRepeatTerm || e & 131072) {
      let h = i.stateFlag(
        this.state,
        1
        /* StateFlag.Skipped */
      ) ? this.pos : this.reducePos;
      this.storeNode(l, s, h, d + 4, !0);
    }
    if (e & 262144)
      this.state = this.stack[n];
    else {
      let h = this.stack[n - 3];
      this.state = i.getGoto(h, l, !0);
    }
    for (; this.stack.length > n; )
      this.stack.pop();
    this.reduceContext(l, s);
  }
  // Shift a value into the buffer
  /// @internal
  storeNode(e, t, l, i = 4, o = !1) {
    if (e == 0 && (!this.stack.length || this.stack[this.stack.length - 1] < this.buffer.length + this.bufferBase)) {
      let n = this, s = this.buffer.length;
      if (s == 0 && n.parent && (s = n.bufferBase - n.parent.bufferBase, n = n.parent), s > 0 && n.buffer[s - 4] == 0 && n.buffer[s - 1] > -1) {
        if (t == l)
          return;
        if (n.buffer[s - 2] >= t) {
          n.buffer[s - 2] = l;
          return;
        }
      }
    }
    if (!o || this.pos == l)
      this.buffer.push(e, t, l, i);
    else {
      let n = this.buffer.length;
      if (n > 0 && this.buffer[n - 4] != 0)
        for (; n > 0 && this.buffer[n - 2] > l; )
          this.buffer[n] = this.buffer[n - 4], this.buffer[n + 1] = this.buffer[n - 3], this.buffer[n + 2] = this.buffer[n - 2], this.buffer[n + 3] = this.buffer[n - 1], n -= 4, i > 4 && (i -= 4);
      this.buffer[n] = e, this.buffer[n + 1] = t, this.buffer[n + 2] = l, this.buffer[n + 3] = i;
    }
  }
  // Apply a shift action
  /// @internal
  shift(e, t, l) {
    let i = this.pos;
    if (e & 131072)
      this.pushState(e & 65535, this.pos);
    else if (e & 262144)
      this.pos = l, this.shiftContext(t, i), t <= this.p.parser.maxNode && this.buffer.push(t, i, l, 4);
    else {
      let o = e, { parser: n } = this.p;
      (l > this.pos || t <= n.maxNode) && (this.pos = l, n.stateFlag(
        o,
        1
        /* StateFlag.Skipped */
      ) || (this.reducePos = l)), this.pushState(o, i), this.shiftContext(t, i), t <= n.maxNode && this.buffer.push(t, i, l, 4);
    }
  }
  // Apply an action
  /// @internal
  apply(e, t, l) {
    e & 65536 ? this.reduce(e) : this.shift(e, t, l);
  }
  // Add a prebuilt (reused) node into the buffer.
  /// @internal
  useNode(e, t) {
    let l = this.p.reused.length - 1;
    (l < 0 || this.p.reused[l] != e) && (this.p.reused.push(e), l++);
    let i = this.pos;
    this.reducePos = this.pos = i + e.length, this.pushState(t, i), this.buffer.push(
      l,
      i,
      this.reducePos,
      -1
      /* size == -1 means this is a reused value */
    ), this.curContext && this.updateContext(this.curContext.tracker.reuse(this.curContext.context, e, this, this.p.stream.reset(this.pos - e.length)));
  }
  // Split the stack. Due to the buffer sharing and the fact
  // that `this.stack` tends to stay quite shallow, this isn't very
  // expensive.
  /// @internal
  split() {
    let e = this, t = e.buffer.length;
    for (; t > 0 && e.buffer[t - 2] > e.reducePos; )
      t -= 4;
    let l = e.buffer.slice(t), i = e.bufferBase + t;
    for (; e && i == e.bufferBase; )
      e = e.parent;
    return new Bn(this.p, this.stack.slice(), this.state, this.reducePos, this.pos, this.score, l, i, this.curContext, this.lookAhead, e);
  }
  // Try to recover from an error by 'deleting' (ignoring) one token.
  /// @internal
  recoverByDelete(e, t) {
    let l = e <= this.p.parser.maxNode;
    l && this.storeNode(e, this.pos, t, 4), this.storeNode(0, this.pos, t, l ? 8 : 4), this.pos = this.reducePos = t, this.score -= 190;
  }
  /// Check if the given term would be able to be shifted (optionally
  /// after some reductions) on this stack. This can be useful for
  /// external tokenizers that want to make sure they only provide a
  /// given token when it applies.
  canShift(e) {
    for (let t = new GS(this); ; ) {
      let l = this.p.parser.stateSlot(
        t.state,
        4
        /* ParseState.DefaultReduce */
      ) || this.p.parser.hasAction(t.state, e);
      if (l == 0)
        return !1;
      if (!(l & 65536))
        return !0;
      t.reduce(l);
    }
  }
  // Apply up to Recover.MaxNext recovery actions that conceptually
  // inserts some missing token or rule.
  /// @internal
  recoverByInsert(e) {
    if (this.stack.length >= 300)
      return [];
    let t = this.p.parser.nextStates(this.state);
    if (t.length > 4 << 1 || this.stack.length >= 120) {
      let i = [];
      for (let o = 0, n; o < t.length; o += 2)
        (n = t[o + 1]) != this.state && this.p.parser.hasAction(n, e) && i.push(t[o], n);
      if (this.stack.length < 120)
        for (let o = 0; i.length < 4 << 1 && o < t.length; o += 2) {
          let n = t[o + 1];
          i.some((s, a) => a & 1 && s == n) || i.push(t[o], n);
        }
      t = i;
    }
    let l = [];
    for (let i = 0; i < t.length && l.length < 4; i += 2) {
      let o = t[i + 1];
      if (o == this.state)
        continue;
      let n = this.split();
      n.pushState(o, this.pos), n.storeNode(0, n.pos, n.pos, 4, !0), n.shiftContext(t[i], this.pos), n.score -= 200, l.push(n);
    }
    return l;
  }
  // Force a reduce, if possible. Return false if that can't
  // be done.
  /// @internal
  forceReduce() {
    let e = this.p.parser.stateSlot(
      this.state,
      5
      /* ParseState.ForcedReduce */
    );
    if (!(e & 65536))
      return !1;
    let { parser: t } = this.p;
    if (!t.validAction(this.state, e)) {
      let l = e >> 19, i = e & 65535, o = this.stack.length - l * 3;
      if (o < 0 || t.getGoto(this.stack[o], i, !1) < 0)
        return !1;
      this.storeNode(0, this.reducePos, this.reducePos, 4, !0), this.score -= 100;
    }
    return this.reducePos = this.pos, this.reduce(e), !0;
  }
  /// @internal
  forceAll() {
    for (; !this.p.parser.stateFlag(
      this.state,
      2
      /* StateFlag.Accepting */
    ); )
      if (!this.forceReduce()) {
        this.storeNode(0, this.pos, this.pos, 4, !0);
        break;
      }
    return this;
  }
  /// Check whether this state has no further actions (assumed to be a direct descendant of the
  /// top state, since any other states must be able to continue
  /// somehow). @internal
  get deadEnd() {
    if (this.stack.length != 3)
      return !1;
    let { parser: e } = this.p;
    return e.data[e.stateSlot(
      this.state,
      1
      /* ParseState.Actions */
    )] == 65535 && !e.stateSlot(
      this.state,
      4
      /* ParseState.DefaultReduce */
    );
  }
  /// Restart the stack (put it back in its start state). Only safe
  /// when this.stack.length == 3 (state is directly below the top
  /// state). @internal
  restart() {
    this.state = this.stack[0], this.stack.length = 0;
  }
  /// @internal
  sameState(e) {
    if (this.state != e.state || this.stack.length != e.stack.length)
      return !1;
    for (let t = 0; t < this.stack.length; t += 3)
      if (this.stack[t] != e.stack[t])
        return !1;
    return !0;
  }
  /// Get the parser used by this stack.
  get parser() {
    return this.p.parser;
  }
  /// Test whether a given dialect (by numeric ID, as exported from
  /// the terms file) is enabled.
  dialectEnabled(e) {
    return this.p.parser.dialect.flags[e];
  }
  shiftContext(e, t) {
    this.curContext && this.updateContext(this.curContext.tracker.shift(this.curContext.context, e, this, this.p.stream.reset(t)));
  }
  reduceContext(e, t) {
    this.curContext && this.updateContext(this.curContext.tracker.reduce(this.curContext.context, e, this, this.p.stream.reset(t)));
  }
  /// @internal
  emitContext() {
    let e = this.buffer.length - 1;
    (e < 0 || this.buffer[e] != -3) && this.buffer.push(this.curContext.hash, this.reducePos, this.reducePos, -3);
  }
  /// @internal
  emitLookAhead() {
    let e = this.buffer.length - 1;
    (e < 0 || this.buffer[e] != -4) && this.buffer.push(this.lookAhead, this.reducePos, this.reducePos, -4);
  }
  updateContext(e) {
    if (e != this.curContext.context) {
      let t = new _u(this.curContext.tracker, e);
      t.hash != this.curContext.hash && this.emitContext(), this.curContext = t;
    }
  }
  /// @internal
  setLookAhead(e) {
    e > this.lookAhead && (this.emitLookAhead(), this.lookAhead = e);
  }
  /// @internal
  close() {
    this.curContext && this.curContext.tracker.strict && this.emitContext(), this.lookAhead > 0 && this.emitLookAhead();
  }
}
class _u {
  constructor(e, t) {
    this.tracker = e, this.context = t, this.hash = e.strict ? e.hash(t) : 0;
  }
}
var wu;
(function(r) {
  r[r.Insert = 200] = "Insert", r[r.Delete = 190] = "Delete", r[r.Reduce = 100] = "Reduce", r[r.MaxNext = 4] = "MaxNext", r[r.MaxInsertStackDepth = 300] = "MaxInsertStackDepth", r[r.DampenInsertStackDepth = 120] = "DampenInsertStackDepth", r[r.MinBigReduction = 2e3] = "MinBigReduction";
})(wu || (wu = {}));
class GS {
  constructor(e) {
    this.start = e, this.state = e.state, this.stack = e.stack, this.base = this.stack.length;
  }
  reduce(e) {
    let t = e & 65535, l = e >> 19;
    l == 0 ? (this.stack == this.start.stack && (this.stack = this.stack.slice()), this.stack.push(this.state, 0, 0), this.base += 3) : this.base -= (l - 1) * 3;
    let i = this.start.p.parser.getGoto(this.stack[this.base - 3], t, !0);
    this.state = i;
  }
}
class Ln {
  constructor(e, t, l) {
    this.stack = e, this.pos = t, this.index = l, this.buffer = e.buffer, this.index == 0 && this.maybeNext();
  }
  static create(e, t = e.bufferBase + e.buffer.length) {
    return new Ln(e, t, t - e.bufferBase);
  }
  maybeNext() {
    let e = this.stack.parent;
    e != null && (this.index = this.stack.bufferBase - e.bufferBase, this.stack = e, this.buffer = e.buffer);
  }
  get id() {
    return this.buffer[this.index - 4];
  }
  get start() {
    return this.buffer[this.index - 3];
  }
  get end() {
    return this.buffer[this.index - 2];
  }
  get size() {
    return this.buffer[this.index - 1];
  }
  next() {
    this.index -= 4, this.pos -= 4, this.index == 0 && this.maybeNext();
  }
  fork() {
    return new Ln(this.stack, this.pos, this.index);
  }
}
function $i(r, e = Uint16Array) {
  if (typeof r != "string")
    return r;
  let t = null;
  for (let l = 0, i = 0; l < r.length; ) {
    let o = 0;
    for (; ; ) {
      let n = r.charCodeAt(l++), s = !1;
      if (n == 126) {
        o = 65535;
        break;
      }
      n >= 92 && n--, n >= 34 && n--;
      let a = n - 32;
      if (a >= 46 && (a -= 46, s = !0), o += a, s)
        break;
      o *= 46;
    }
    t ? t[i++] = o : t = new e(o);
  }
  return t;
}
class mn {
  constructor() {
    this.start = -1, this.value = -1, this.end = -1, this.extended = -1, this.lookAhead = 0, this.mask = 0, this.context = 0;
  }
}
const yu = new mn();
class FS {
  /// @internal
  constructor(e, t) {
    this.input = e, this.ranges = t, this.chunk = "", this.chunkOff = 0, this.chunk2 = "", this.chunk2Pos = 0, this.next = -1, this.token = yu, this.rangeIndex = 0, this.pos = this.chunkPos = t[0].from, this.range = t[0], this.end = t[t.length - 1].to, this.readNext();
  }
  /// @internal
  resolveOffset(e, t) {
    let l = this.range, i = this.rangeIndex, o = this.pos + e;
    for (; o < l.from; ) {
      if (!i)
        return null;
      let n = this.ranges[--i];
      o -= l.from - n.to, l = n;
    }
    for (; t < 0 ? o > l.to : o >= l.to; ) {
      if (i == this.ranges.length - 1)
        return null;
      let n = this.ranges[++i];
      o += n.from - l.to, l = n;
    }
    return o;
  }
  /// @internal
  clipPos(e) {
    if (e >= this.range.from && e < this.range.to)
      return e;
    for (let t of this.ranges)
      if (t.to > e)
        return Math.max(e, t.from);
    return this.end;
  }
  /// Look at a code unit near the stream position. `.peek(0)` equals
  /// `.next`, `.peek(-1)` gives you the previous character, and so
  /// on.
  ///
  /// Note that looking around during tokenizing creates dependencies
  /// on potentially far-away content, which may reduce the
  /// effectiveness incremental parsing—when looking forward—or even
  /// cause invalid reparses when looking backward more than 25 code
  /// units, since the library does not track lookbehind.
  peek(e) {
    let t = this.chunkOff + e, l, i;
    if (t >= 0 && t < this.chunk.length)
      l = this.pos + e, i = this.chunk.charCodeAt(t);
    else {
      let o = this.resolveOffset(e, 1);
      if (o == null)
        return -1;
      if (l = o, l >= this.chunk2Pos && l < this.chunk2Pos + this.chunk2.length)
        i = this.chunk2.charCodeAt(l - this.chunk2Pos);
      else {
        let n = this.rangeIndex, s = this.range;
        for (; s.to <= l; )
          s = this.ranges[++n];
        this.chunk2 = this.input.chunk(this.chunk2Pos = l), l + this.chunk2.length > s.to && (this.chunk2 = this.chunk2.slice(0, s.to - l)), i = this.chunk2.charCodeAt(0);
      }
    }
    return l >= this.token.lookAhead && (this.token.lookAhead = l + 1), i;
  }
  /// Accept a token. By default, the end of the token is set to the
  /// current stream position, but you can pass an offset (relative to
  /// the stream position) to change that.
  acceptToken(e, t = 0) {
    let l = t ? this.resolveOffset(t, -1) : this.pos;
    if (l == null || l < this.token.start)
      throw new RangeError("Token end out of bounds");
    this.token.value = e, this.token.end = l;
  }
  getChunk() {
    if (this.pos >= this.chunk2Pos && this.pos < this.chunk2Pos + this.chunk2.length) {
      let { chunk: e, chunkPos: t } = this;
      this.chunk = this.chunk2, this.chunkPos = this.chunk2Pos, this.chunk2 = e, this.chunk2Pos = t, this.chunkOff = this.pos - this.chunkPos;
    } else {
      this.chunk2 = this.chunk, this.chunk2Pos = this.chunkPos;
      let e = this.input.chunk(this.pos), t = this.pos + e.length;
      this.chunk = t > this.range.to ? e.slice(0, this.range.to - this.pos) : e, this.chunkPos = this.pos, this.chunkOff = 0;
    }
  }
  readNext() {
    return this.chunkOff >= this.chunk.length && (this.getChunk(), this.chunkOff == this.chunk.length) ? this.next = -1 : this.next = this.chunk.charCodeAt(this.chunkOff);
  }
  /// Move the stream forward N (defaults to 1) code units. Returns
  /// the new value of [`next`](#lr.InputStream.next).
  advance(e = 1) {
    for (this.chunkOff += e; this.pos + e >= this.range.to; ) {
      if (this.rangeIndex == this.ranges.length - 1)
        return this.setDone();
      e -= this.range.to - this.pos, this.range = this.ranges[++this.rangeIndex], this.pos = this.range.from;
    }
    return this.pos += e, this.pos >= this.token.lookAhead && (this.token.lookAhead = this.pos + 1), this.readNext();
  }
  setDone() {
    return this.pos = this.chunkPos = this.end, this.range = this.ranges[this.rangeIndex = this.ranges.length - 1], this.chunk = "", this.next = -1;
  }
  /// @internal
  reset(e, t) {
    if (t ? (this.token = t, t.start = e, t.lookAhead = e + 1, t.value = t.extended = -1) : this.token = yu, this.pos != e) {
      if (this.pos = e, e == this.end)
        return this.setDone(), this;
      for (; e < this.range.from; )
        this.range = this.ranges[--this.rangeIndex];
      for (; e >= this.range.to; )
        this.range = this.ranges[++this.rangeIndex];
      e >= this.chunkPos && e < this.chunkPos + this.chunk.length ? this.chunkOff = e - this.chunkPos : (this.chunk = "", this.chunkOff = 0), this.readNext();
    }
    return this;
  }
  /// @internal
  read(e, t) {
    if (e >= this.chunkPos && t <= this.chunkPos + this.chunk.length)
      return this.chunk.slice(e - this.chunkPos, t - this.chunkPos);
    if (e >= this.chunk2Pos && t <= this.chunk2Pos + this.chunk2.length)
      return this.chunk2.slice(e - this.chunk2Pos, t - this.chunk2Pos);
    if (e >= this.range.from && t <= this.range.to)
      return this.input.read(e, t);
    let l = "";
    for (let i of this.ranges) {
      if (i.from >= t)
        break;
      i.to > e && (l += this.input.read(Math.max(i.from, e), Math.min(i.to, t)));
    }
    return l;
  }
}
class ql {
  constructor(e, t) {
    this.data = e, this.id = t;
  }
  token(e, t) {
    let { parser: l } = t.p;
    rO(this.data, e, t, this.id, l.data, l.tokenPrecTable);
  }
}
ql.prototype.contextual = ql.prototype.fallback = ql.prototype.extend = !1;
class Mc {
  constructor(e, t, l) {
    this.precTable = t, this.elseToken = l, this.data = typeof e == "string" ? $i(e) : e;
  }
  token(e, t) {
    let l = e.pos, i;
    for (; i = e.pos, rO(this.data, e, t, 0, this.data, this.precTable), !(e.token.value > -1); ) {
      if (this.elseToken == null)
        return;
      if (e.next < 0)
        break;
      e.advance(), e.reset(i + 1, e.token);
    }
    i > l && (e.reset(l, e.token), e.acceptToken(this.elseToken, i - l));
  }
}
Mc.prototype.contextual = ql.prototype.fallback = ql.prototype.extend = !1;
class Or {
  /// Create a tokenizer. The first argument is the function that,
  /// given an input stream, scans for the types of tokens it
  /// recognizes at the stream's position, and calls
  /// [`acceptToken`](#lr.InputStream.acceptToken) when it finds
  /// one.
  constructor(e, t = {}) {
    this.token = e, this.contextual = !!t.contextual, this.fallback = !!t.fallback, this.extend = !!t.extend;
  }
}
function rO(r, e, t, l, i, o) {
  let n = 0, s = 1 << l, { dialect: a } = t.p.parser;
  e:
    for (; s & r[n]; ) {
      let c = r[n + 1];
      for (let u = n + 3; u < c; u += 2)
        if ((r[u + 1] & s) > 0) {
          let f = r[u];
          if (a.allows(f) && (e.token.value == -1 || e.token.value == f || HS(f, e.token.value, i, o))) {
            e.acceptToken(f);
            break;
          }
        }
      let d = e.next, h = 0, p = r[n + 2];
      if (e.next < 0 && p > h && r[c + p * 3 - 3] == 65535 && r[c + p * 3 - 3] == 65535) {
        n = r[c + p * 3 - 1];
        continue e;
      }
      for (; h < p; ) {
        let u = h + p >> 1, f = c + u + (u << 1), m = r[f], O = r[f + 1] || 65536;
        if (d < m)
          p = u;
        else if (d >= O)
          h = u + 1;
        else {
          n = r[f + 2], e.advance();
          continue e;
        }
      }
      break;
    }
}
function ku(r, e, t) {
  for (let l = e, i; (i = r[l]) != 65535; l++)
    if (i == t)
      return l - e;
  return -1;
}
function HS(r, e, t, l) {
  let i = ku(t, l, e);
  return i < 0 || ku(t, l, r) < i;
}
const At = typeof process < "u" && {} && /\bparse\b/.test({}.LOG);
let Oa = null;
var Su;
(function(r) {
  r[r.Margin = 25] = "Margin";
})(Su || (Su = {}));
function Qu(r, e, t) {
  let l = r.cursor(Se.IncludeAnonymous);
  for (l.moveTo(e); ; )
    if (!(t < 0 ? l.childBefore(e) : l.childAfter(e)))
      for (; ; ) {
        if ((t < 0 ? l.to < e : l.from > e) && !l.type.isError)
          return t < 0 ? Math.max(0, Math.min(
            l.to - 1,
            e - 25
            /* Safety.Margin */
          )) : Math.min(r.length, Math.max(
            l.from + 1,
            e + 25
            /* Safety.Margin */
          ));
        if (t < 0 ? l.prevSibling() : l.nextSibling())
          break;
        if (!l.parent())
          return t < 0 ? 0 : r.length;
      }
}
class KS {
  constructor(e, t) {
    this.fragments = e, this.nodeSet = t, this.i = 0, this.fragment = null, this.safeFrom = -1, this.safeTo = -1, this.trees = [], this.start = [], this.index = [], this.nextFragment();
  }
  nextFragment() {
    let e = this.fragment = this.i == this.fragments.length ? null : this.fragments[this.i++];
    if (e) {
      for (this.safeFrom = e.openStart ? Qu(e.tree, e.from + e.offset, 1) - e.offset : e.from, this.safeTo = e.openEnd ? Qu(e.tree, e.to + e.offset, -1) - e.offset : e.to; this.trees.length; )
        this.trees.pop(), this.start.pop(), this.index.pop();
      this.trees.push(e.tree), this.start.push(-e.offset), this.index.push(0), this.nextStart = this.safeFrom;
    } else
      this.nextStart = 1e9;
  }
  // `pos` must be >= any previously given `pos` for this cursor
  nodeAt(e) {
    if (e < this.nextStart)
      return null;
    for (; this.fragment && this.safeTo <= e; )
      this.nextFragment();
    if (!this.fragment)
      return null;
    for (; ; ) {
      let t = this.trees.length - 1;
      if (t < 0)
        return this.nextFragment(), null;
      let l = this.trees[t], i = this.index[t];
      if (i == l.children.length) {
        this.trees.pop(), this.start.pop(), this.index.pop();
        continue;
      }
      let o = l.children[i], n = this.start[t] + l.positions[i];
      if (n > e)
        return this.nextStart = n, null;
      if (o instanceof Te) {
        if (n == e) {
          if (n < this.safeFrom)
            return null;
          let s = n + o.length;
          if (s <= this.safeTo) {
            let a = o.prop(se.lookAhead);
            if (!a || s + a < this.fragment.to)
              return o;
          }
        }
        this.index[t]++, n + o.length >= Math.max(this.safeFrom, e) && (this.trees.push(o), this.start.push(n), this.index.push(0));
      } else
        this.index[t]++, this.nextStart = n + o.length;
    }
  }
}
class JS {
  constructor(e, t) {
    this.stream = t, this.tokens = [], this.mainToken = null, this.actions = [], this.tokens = e.tokenizers.map((l) => new mn());
  }
  getActions(e) {
    let t = 0, l = null, { parser: i } = e.p, { tokenizers: o } = i, n = i.stateSlot(
      e.state,
      3
      /* ParseState.TokenizerMask */
    ), s = e.curContext ? e.curContext.hash : 0, a = 0;
    for (let c = 0; c < o.length; c++) {
      if (!(1 << c & n))
        continue;
      let d = o[c], h = this.tokens[c];
      if (!(l && !d.fallback) && ((d.contextual || h.start != e.pos || h.mask != n || h.context != s) && (this.updateCachedToken(h, d, e), h.mask = n, h.context = s), h.lookAhead > h.end + 25 && (a = Math.max(h.lookAhead, a)), h.value != 0)) {
        let p = t;
        if (h.extended > -1 && (t = this.addActions(e, h.extended, h.end, t)), t = this.addActions(e, h.value, h.end, t), !d.extend && (l = h, t > p))
          break;
      }
    }
    for (; this.actions.length > t; )
      this.actions.pop();
    return a && e.setLookAhead(a), !l && e.pos == this.stream.end && (l = new mn(), l.value = e.p.parser.eofTerm, l.start = l.end = e.pos, t = this.addActions(e, l.value, l.end, t)), this.mainToken = l, this.actions;
  }
  getMainToken(e) {
    if (this.mainToken)
      return this.mainToken;
    let t = new mn(), { pos: l, p: i } = e;
    return t.start = l, t.end = Math.min(l + 1, i.stream.end), t.value = l == i.stream.end ? i.parser.eofTerm : 0, t;
  }
  updateCachedToken(e, t, l) {
    let i = this.stream.clipPos(l.pos);
    if (t.token(this.stream.reset(i, e), l), e.value > -1) {
      let { parser: o } = l.p;
      for (let n = 0; n < o.specialized.length; n++)
        if (o.specialized[n] == e.value) {
          let s = o.specializers[n](this.stream.read(e.start, e.end), l);
          if (s >= 0 && l.p.parser.dialect.allows(s >> 1)) {
            s & 1 ? e.extended = s >> 1 : e.value = s >> 1;
            break;
          }
        }
    } else
      e.value = 0, e.end = this.stream.clipPos(i + 1);
  }
  putAction(e, t, l, i) {
    for (let o = 0; o < i; o += 3)
      if (this.actions[o] == e)
        return i;
    return this.actions[i++] = e, this.actions[i++] = t, this.actions[i++] = l, i;
  }
  addActions(e, t, l, i) {
    let { state: o } = e, { parser: n } = e.p, { data: s } = n;
    for (let a = 0; a < 2; a++)
      for (let c = n.stateSlot(
        o,
        a ? 2 : 1
        /* ParseState.Actions */
      ); ; c += 3) {
        if (s[c] == 65535)
          if (s[c + 1] == 1)
            c = cr(s, c + 2);
          else {
            i == 0 && s[c + 1] == 2 && (i = this.putAction(cr(s, c + 2), t, l, i));
            break;
          }
        s[c] == t && (i = this.putAction(cr(s, c + 1), t, l, i));
      }
    return i;
  }
}
var $u;
(function(r) {
  r[r.Distance = 5] = "Distance", r[r.MaxRemainingPerStep = 3] = "MaxRemainingPerStep", r[r.MinBufferLengthPrune = 500] = "MinBufferLengthPrune", r[r.ForceReduceLimit = 10] = "ForceReduceLimit", r[r.CutDepth = 15e3] = "CutDepth", r[r.CutTo = 9e3] = "CutTo", r[r.MaxLeftAssociativeReductionCount = 1e3] = "MaxLeftAssociativeReductionCount";
})($u || ($u = {}));
class e6 {
  constructor(e, t, l, i) {
    this.parser = e, this.input = t, this.ranges = i, this.recovering = 0, this.nextStackID = 9812, this.minStackPos = 0, this.reused = [], this.stoppedAt = null, this.lastBigReductionStart = -1, this.lastBigReductionSize = 0, this.bigReductionCount = 0, this.stream = new FS(t, i), this.tokens = new JS(e, this.stream), this.topTerm = e.top[1];
    let { from: o } = i[0];
    this.stacks = [Bn.start(this, e.top[0], o)], this.fragments = l.length && this.stream.end - o > e.bufferLength * 4 ? new KS(l, e.nodeSet) : null;
  }
  get parsedPos() {
    return this.minStackPos;
  }
  // Move the parser forward. This will process all parse stacks at
  // `this.pos` and try to advance them to a further position. If no
  // stack for such a position is found, it'll start error-recovery.
  //
  // When the parse is finished, this will return a syntax tree. When
  // not, it returns `null`.
  advance() {
    let e = this.stacks, t = this.minStackPos, l = this.stacks = [], i, o;
    if (this.bigReductionCount > 1e3 && e.length == 1) {
      let [n] = e;
      for (; n.forceReduce() && n.stack.length && n.stack[n.stack.length - 2] >= this.lastBigReductionStart; )
        ;
      this.bigReductionCount = this.lastBigReductionSize = 0;
    }
    for (let n = 0; n < e.length; n++) {
      let s = e[n];
      for (; ; ) {
        if (this.tokens.mainToken = null, s.pos > t)
          l.push(s);
        else {
          if (this.advanceStack(s, l, e))
            continue;
          {
            i || (i = [], o = []), i.push(s);
            let a = this.tokens.getMainToken(s);
            o.push(a.value, a.end);
          }
        }
        break;
      }
    }
    if (!l.length) {
      let n = i && r6(i);
      if (n)
        return this.stackToTree(n);
      if (this.parser.strict)
        throw At && i && console.log("Stuck with token " + (this.tokens.mainToken ? this.parser.getName(this.tokens.mainToken.value) : "none")), new SyntaxError("No parse at " + t);
      this.recovering || (this.recovering = 5);
    }
    if (this.recovering && i) {
      let n = this.stoppedAt != null && i[0].pos > this.stoppedAt ? i[0] : this.runRecovery(i, o, l);
      if (n)
        return this.stackToTree(n.forceAll());
    }
    if (this.recovering) {
      let n = this.recovering == 1 ? 1 : this.recovering * 3;
      if (l.length > n)
        for (l.sort((s, a) => a.score - s.score); l.length > n; )
          l.pop();
      l.some((s) => s.reducePos > t) && this.recovering--;
    } else if (l.length > 1) {
      e:
        for (let n = 0; n < l.length - 1; n++) {
          let s = l[n];
          for (let a = n + 1; a < l.length; a++) {
            let c = l[a];
            if (s.sameState(c) || s.buffer.length > 500 && c.buffer.length > 500)
              if ((s.score - c.score || s.buffer.length - c.buffer.length) > 0)
                l.splice(a--, 1);
              else {
                l.splice(n--, 1);
                continue e;
              }
          }
        }
    }
    this.minStackPos = l[0].pos;
    for (let n = 1; n < l.length; n++)
      l[n].pos < this.minStackPos && (this.minStackPos = l[n].pos);
    return null;
  }
  stopAt(e) {
    if (this.stoppedAt != null && this.stoppedAt < e)
      throw new RangeError("Can't move stoppedAt forward");
    this.stoppedAt = e;
  }
  // Returns an updated version of the given stack, or null if the
  // stack can't advance normally. When `split` and `stacks` are
  // given, stacks split off by ambiguous operations will be pushed to
  // `split`, or added to `stacks` if they move `pos` forward.
  advanceStack(e, t, l) {
    let i = e.pos, { parser: o } = this, n = At ? this.stackID(e) + " -> " : "";
    if (this.stoppedAt != null && i > this.stoppedAt)
      return e.forceReduce() ? e : null;
    if (this.fragments) {
      let c = e.curContext && e.curContext.tracker.strict, d = c ? e.curContext.hash : 0;
      for (let h = this.fragments.nodeAt(i); h; ) {
        let p = this.parser.nodeSet.types[h.type.id] == h.type ? o.getGoto(e.state, h.type.id) : -1;
        if (p > -1 && h.length && (!c || (h.prop(se.contextHash) || 0) == d))
          return e.useNode(h, p), At && console.log(n + this.stackID(e) + ` (via reuse of ${o.getName(h.type.id)})`), !0;
        if (!(h instanceof Te) || h.children.length == 0 || h.positions[0] > 0)
          break;
        let u = h.children[0];
        if (u instanceof Te && h.positions[0] == 0)
          h = u;
        else
          break;
      }
    }
    let s = o.stateSlot(
      e.state,
      4
      /* ParseState.DefaultReduce */
    );
    if (s > 0)
      return e.reduce(s), At && console.log(n + this.stackID(e) + ` (via always-reduce ${o.getName(
        s & 65535
        /* Action.ValueMask */
      )})`), !0;
    if (e.stack.length >= 15e3)
      for (; e.stack.length > 9e3 && e.forceReduce(); )
        ;
    let a = this.tokens.getActions(e);
    for (let c = 0; c < a.length; ) {
      let d = a[c++], h = a[c++], p = a[c++], u = c == a.length || !l, f = u ? e : e.split();
      if (f.apply(d, h, p), At && console.log(n + this.stackID(f) + ` (via ${d & 65536 ? `reduce of ${o.getName(
        d & 65535
        /* Action.ValueMask */
      )}` : "shift"} for ${o.getName(h)} @ ${i}${f == e ? "" : ", split"})`), u)
        return !0;
      f.pos > i ? t.push(f) : l.push(f);
    }
    return !1;
  }
  // Advance a given stack forward as far as it will go. Returns the
  // (possibly updated) stack if it got stuck, or null if it moved
  // forward and was given to `pushStackDedup`.
  advanceFully(e, t) {
    let l = e.pos;
    for (; ; ) {
      if (!this.advanceStack(e, null, null))
        return !1;
      if (e.pos > l)
        return Pu(e, t), !0;
    }
  }
  runRecovery(e, t, l) {
    let i = null, o = !1;
    for (let n = 0; n < e.length; n++) {
      let s = e[n], a = t[n << 1], c = t[(n << 1) + 1], d = At ? this.stackID(s) + " -> " : "";
      if (s.deadEnd && (o || (o = !0, s.restart(), At && console.log(d + this.stackID(s) + " (restarted)"), this.advanceFully(s, l))))
        continue;
      let h = s.split(), p = d;
      for (let u = 0; h.forceReduce() && u < 10 && (At && console.log(p + this.stackID(h) + " (via force-reduce)"), !this.advanceFully(h, l)); u++)
        At && (p = this.stackID(h) + " -> ");
      for (let u of s.recoverByInsert(a))
        At && console.log(d + this.stackID(u) + " (via recover-insert)"), this.advanceFully(u, l);
      this.stream.end > s.pos ? (c == s.pos && (c++, a = 0), s.recoverByDelete(a, c), At && console.log(d + this.stackID(s) + ` (via recover-delete ${this.parser.getName(a)})`), Pu(s, l)) : (!i || i.score < s.score) && (i = s);
    }
    return i;
  }
  // Convert the stack's buffer to a syntax tree.
  stackToTree(e) {
    return e.close(), Te.build({
      buffer: Ln.create(e),
      nodeSet: this.parser.nodeSet,
      topID: this.topTerm,
      maxBufferLength: this.parser.bufferLength,
      reused: this.reused,
      start: this.ranges[0].from,
      length: e.pos - this.ranges[0].from,
      minRepeatType: this.parser.minRepeatTerm
    });
  }
  stackID(e) {
    let t = (Oa || (Oa = /* @__PURE__ */ new WeakMap())).get(e);
    return t || Oa.set(e, t = String.fromCodePoint(this.nextStackID++)), t + e;
  }
}
function Pu(r, e) {
  for (let t = 0; t < e.length; t++) {
    let l = e[t];
    if (l.pos == r.pos && l.sameState(r)) {
      e[t].score < r.score && (e[t] = r);
      return;
    }
  }
  e.push(r);
}
class t6 {
  constructor(e, t, l) {
    this.source = e, this.flags = t, this.disabled = l;
  }
  allows(e) {
    return !this.disabled || this.disabled[e] == 0;
  }
}
const va = (r) => r;
class lO {
  /// Define a context tracker.
  constructor(e) {
    this.start = e.start, this.shift = e.shift || va, this.reduce = e.reduce || va, this.reuse = e.reuse || va, this.hash = e.hash || (() => 0), this.strict = e.strict !== !1;
  }
}
class ri extends nb {
  /// @internal
  constructor(e) {
    if (super(), this.wrappers = [], e.version != 14)
      throw new RangeError(`Parser version (${e.version}) doesn't match runtime version (${14})`);
    let t = e.nodeNames.split(" ");
    this.minRepeatTerm = t.length;
    for (let s = 0; s < e.repeatNodeCount; s++)
      t.push("");
    let l = Object.keys(e.topRules).map((s) => e.topRules[s][1]), i = [];
    for (let s = 0; s < t.length; s++)
      i.push([]);
    function o(s, a, c) {
      i[s].push([a, a.deserialize(String(c))]);
    }
    if (e.nodeProps)
      for (let s of e.nodeProps) {
        let a = s[0];
        typeof a == "string" && (a = se[a]);
        for (let c = 1; c < s.length; ) {
          let d = s[c++];
          if (d >= 0)
            o(d, a, s[c++]);
          else {
            let h = s[c + -d];
            for (let p = -d; p > 0; p--)
              o(s[c++], a, h);
            c++;
          }
        }
      }
    this.nodeSet = new Zd(t.map((s, a) => ct.define({
      name: a >= this.minRepeatTerm ? void 0 : s,
      id: a,
      props: i[a],
      top: l.indexOf(a) > -1,
      error: a == 0,
      skipped: e.skippedNodes && e.skippedNodes.indexOf(a) > -1
    }))), e.propSources && (this.nodeSet = this.nodeSet.extend(...e.propSources)), this.strict = !1, this.bufferLength = lb;
    let n = $i(e.tokenData);
    this.context = e.context, this.specializerSpecs = e.specialized || [], this.specialized = new Uint16Array(this.specializerSpecs.length);
    for (let s = 0; s < this.specializerSpecs.length; s++)
      this.specialized[s] = this.specializerSpecs[s].term;
    this.specializers = this.specializerSpecs.map(Cu), this.states = $i(e.states, Uint32Array), this.data = $i(e.stateData), this.goto = $i(e.goto), this.maxTerm = e.maxTerm, this.tokenizers = e.tokenizers.map((s) => typeof s == "number" ? new ql(n, s) : s), this.topRules = e.topRules, this.dialects = e.dialects || {}, this.dynamicPrecedences = e.dynamicPrecedences || null, this.tokenPrecTable = e.tokenPrec, this.termNames = e.termNames || null, this.maxNode = this.nodeSet.types.length - 1, this.dialect = this.parseDialect(), this.top = this.topRules[Object.keys(this.topRules)[0]];
  }
  createParse(e, t, l) {
    let i = new e6(this, e, t, l);
    for (let o of this.wrappers)
      i = o(i, e, t, l);
    return i;
  }
  /// Get a goto table entry @internal
  getGoto(e, t, l = !1) {
    let i = this.goto;
    if (t >= i[0])
      return -1;
    for (let o = i[t + 1]; ; ) {
      let n = i[o++], s = n & 1, a = i[o++];
      if (s && l)
        return a;
      for (let c = o + (n >> 1); o < c; o++)
        if (i[o] == e)
          return a;
      if (s)
        return -1;
    }
  }
  /// Check if this state has an action for a given terminal @internal
  hasAction(e, t) {
    let l = this.data;
    for (let i = 0; i < 2; i++)
      for (let o = this.stateSlot(
        e,
        i ? 2 : 1
        /* ParseState.Actions */
      ), n; ; o += 3) {
        if ((n = l[o]) == 65535)
          if (l[o + 1] == 1)
            n = l[o = cr(l, o + 2)];
          else {
            if (l[o + 1] == 2)
              return cr(l, o + 2);
            break;
          }
        if (n == t || n == 0)
          return cr(l, o + 1);
      }
    return 0;
  }
  /// @internal
  stateSlot(e, t) {
    return this.states[e * 6 + t];
  }
  /// @internal
  stateFlag(e, t) {
    return (this.stateSlot(
      e,
      0
      /* ParseState.Flags */
    ) & t) > 0;
  }
  /// @internal
  validAction(e, t) {
    if (t == this.stateSlot(
      e,
      4
      /* ParseState.DefaultReduce */
    ))
      return !0;
    for (let l = this.stateSlot(
      e,
      1
      /* ParseState.Actions */
    ); ; l += 3) {
      if (this.data[l] == 65535)
        if (this.data[l + 1] == 1)
          l = cr(this.data, l + 2);
        else
          return !1;
      if (t == cr(this.data, l + 1))
        return !0;
    }
  }
  /// Get the states that can follow this one through shift actions or
  /// goto jumps. @internal
  nextStates(e) {
    let t = [];
    for (let l = this.stateSlot(
      e,
      1
      /* ParseState.Actions */
    ); ; l += 3) {
      if (this.data[l] == 65535)
        if (this.data[l + 1] == 1)
          l = cr(this.data, l + 2);
        else
          break;
      if (!(this.data[l + 2] & 1)) {
        let i = this.data[l + 1];
        t.some((o, n) => n & 1 && o == i) || t.push(this.data[l], i);
      }
    }
    return t;
  }
  /// Configure the parser. Returns a new parser instance that has the
  /// given settings modified. Settings not provided in `config` are
  /// kept from the original parser.
  configure(e) {
    let t = Object.assign(Object.create(ri.prototype), this);
    if (e.props && (t.nodeSet = this.nodeSet.extend(...e.props)), e.top) {
      let l = this.topRules[e.top];
      if (!l)
        throw new RangeError(`Invalid top rule name ${e.top}`);
      t.top = l;
    }
    return e.tokenizers && (t.tokenizers = this.tokenizers.map((l) => {
      let i = e.tokenizers.find((o) => o.from == l);
      return i ? i.to : l;
    })), e.specializers && (t.specializers = this.specializers.slice(), t.specializerSpecs = this.specializerSpecs.map((l, i) => {
      let o = e.specializers.find((s) => s.from == l.external);
      if (!o)
        return l;
      let n = Object.assign(Object.assign({}, l), { external: o.to });
      return t.specializers[i] = Cu(n), n;
    })), e.contextTracker && (t.context = e.contextTracker), e.dialect && (t.dialect = this.parseDialect(e.dialect)), e.strict != null && (t.strict = e.strict), e.wrap && (t.wrappers = t.wrappers.concat(e.wrap)), e.bufferLength != null && (t.bufferLength = e.bufferLength), t;
  }
  /// Tells you whether any [parse wrappers](#lr.ParserConfig.wrap)
  /// are registered for this parser.
  hasWrappers() {
    return this.wrappers.length > 0;
  }
  /// Returns the name associated with a given term. This will only
  /// work for all terms when the parser was generated with the
  /// `--names` option. By default, only the names of tagged terms are
  /// stored.
  getName(e) {
    return this.termNames ? this.termNames[e] : String(e <= this.maxNode && this.nodeSet.types[e].name || e);
  }
  /// The eof term id is always allocated directly after the node
  /// types. @internal
  get eofTerm() {
    return this.maxNode + 1;
  }
  /// The type of top node produced by the parser.
  get topNode() {
    return this.nodeSet.types[this.top[1]];
  }
  /// @internal
  dynamicPrecedence(e) {
    let t = this.dynamicPrecedences;
    return t == null ? 0 : t[e] || 0;
  }
  /// @internal
  parseDialect(e) {
    let t = Object.keys(this.dialects), l = t.map(() => !1);
    if (e)
      for (let o of e.split(" ")) {
        let n = t.indexOf(o);
        n >= 0 && (l[n] = !0);
      }
    let i = null;
    for (let o = 0; o < t.length; o++)
      if (!l[o])
        for (let n = this.dialects[t[o]], s; (s = this.data[n++]) != 65535; )
          (i || (i = new Uint8Array(this.maxTerm + 1)))[s] = 1;
    return new t6(e, l, i);
  }
  /// Used by the output of the parser generator. Not available to
  /// user code. @hide
  static deserialize(e) {
    return new ri(e);
  }
}
function cr(r, e) {
  return r[e] | r[e + 1] << 16;
}
function r6(r) {
  let e = null;
  for (let t of r) {
    let l = t.p.stoppedAt;
    (t.pos == t.p.stream.end || l != null && t.pos > l) && t.p.parser.stateFlag(
      t.state,
      2
      /* StateFlag.Accepting */
    ) && (!e || e.score < t.score) && (e = t);
  }
  return e;
}
function Cu(r) {
  if (r.external) {
    let e = r.extend ? 1 : 0;
    return (t, l) => r.external(t, l) << 1 | e;
  }
  return r.get;
}
const l6 = 94, Tu = 1, i6 = 95, o6 = 96, zu = 2, iO = [
  9,
  10,
  11,
  12,
  13,
  32,
  133,
  160,
  5760,
  8192,
  8193,
  8194,
  8195,
  8196,
  8197,
  8198,
  8199,
  8200,
  8201,
  8202,
  8232,
  8233,
  8239,
  8287,
  12288
], n6 = 58, s6 = 40, oO = 95, a6 = 91, bn = 45, c6 = 46, d6 = 35, h6 = 37;
function Gn(r) {
  return r >= 65 && r <= 90 || r >= 97 && r <= 122 || r >= 161;
}
function p6(r) {
  return r >= 48 && r <= 57;
}
const u6 = new Or((r, e) => {
  for (let t = !1, l = 0, i = 0; ; i++) {
    let { next: o } = r;
    if (Gn(o) || o == bn || o == oO || t && p6(o))
      !t && (o != bn || i > 0) && (t = !0), l === i && o == bn && l++, r.advance();
    else {
      t && r.acceptToken(o == s6 ? i6 : l == 2 && e.canShift(zu) ? zu : o6);
      break;
    }
  }
}), f6 = new Or((r) => {
  if (iO.includes(r.peek(-1))) {
    let { next: e } = r;
    (Gn(e) || e == oO || e == d6 || e == c6 || e == a6 || e == n6 || e == bn) && r.acceptToken(l6);
  }
}), g6 = new Or((r) => {
  if (!iO.includes(r.peek(-1))) {
    let { next: e } = r;
    if (e == h6 && (r.advance(), r.acceptToken(Tu)), Gn(e)) {
      do
        r.advance();
      while (Gn(r.next));
      r.acceptToken(Tu);
    }
  }
}), m6 = Cs({
  "AtKeyword import charset namespace keyframes media supports": v.definitionKeyword,
  "from to selector": v.keyword,
  NamespaceName: v.namespace,
  KeyframeName: v.labelName,
  TagName: v.tagName,
  ClassName: v.className,
  PseudoClassName: v.constant(v.className),
  IdName: v.labelName,
  "FeatureName PropertyName": v.propertyName,
  AttributeName: v.attributeName,
  NumberLiteral: v.number,
  KeywordQuery: v.keyword,
  UnaryQueryOp: v.operatorKeyword,
  "CallTag ValueName": v.atom,
  VariableName: v.variableName,
  Callee: v.operatorKeyword,
  Unit: v.unit,
  "UniversalSelector NestingSelector": v.definitionOperator,
  MatchOp: v.compareOperator,
  "ChildOp SiblingOp, LogicOp": v.logicOperator,
  BinOp: v.arithmeticOperator,
  Important: v.modifier,
  Comment: v.blockComment,
  ParenthesizedContent: v.special(v.name),
  ColorLiteral: v.color,
  StringLiteral: v.string,
  ":": v.punctuation,
  "PseudoOp #": v.derefOperator,
  "; ,": v.separator,
  "( )": v.paren,
  "[ ]": v.squareBracket,
  "{ }": v.brace
}), b6 = { __proto__: null, lang: 32, "nth-child": 32, "nth-last-child": 32, "nth-of-type": 32, "nth-last-of-type": 32, dir: 32, "host-context": 32, url: 60, "url-prefix": 60, domain: 60, regexp: 60, selector: 134 }, O6 = { __proto__: null, "@import": 114, "@media": 138, "@charset": 142, "@namespace": 146, "@keyframes": 152, "@supports": 164 }, v6 = { __proto__: null, not: 128, only: 128, from: 158, to: 160 }, x6 = ri.deserialize({
  version: 14,
  states: "7WQYQ[OOO#_Q[OOOOQP'#Cd'#CdOOQP'#Cc'#CcO#fQ[O'#CfO$YQXO'#CaO$aQ[O'#ChO$lQ[O'#DPO$qQ[O'#DTOOQP'#Ed'#EdO$vQdO'#DeO%bQ[O'#DrO$vQdO'#DtO%sQ[O'#DvO&OQ[O'#DyO&TQ[O'#EPO&cQ[O'#EROOQS'#Ec'#EcOOQS'#ET'#ETQYQ[OOO&jQXO'#CdO'_QWO'#DaO'dQWO'#EjO'oQ[O'#EjQOQWOOOOQP'#Cg'#CgOOQP,59Q,59QO#fQ[O,59QO'yQ[O'#EWO(eQWO,58{O(mQ[O,59SO$lQ[O,59kO$qQ[O,59oO'yQ[O,59sO'yQ[O,59uO'yQ[O,59vO(xQ[O'#D`OOQS,58{,58{OOQP'#Ck'#CkOOQO'#C}'#C}OOQP,59S,59SO)PQWO,59SO)UQWO,59SOOQP'#DR'#DROOQP,59k,59kOOQO'#DV'#DVO)ZQ`O,59oOOQS'#Cp'#CpO$vQdO'#CqO)cQvO'#CsO*pQtO,5:POOQO'#Cx'#CxO)UQWO'#CwO+UQWO'#CyOOQS'#Eg'#EgOOQO'#Dh'#DhO+ZQ[O'#DoO+iQWO'#EkO&TQ[O'#DmO+wQWO'#DpOOQO'#El'#ElO(hQWO,5:^O+|QpO,5:`OOQS'#Dx'#DxO,UQWO,5:bO,ZQ[O,5:bOOQO'#D{'#D{O,cQWO,5:eO,hQWO,5:kO,pQWO,5:mOOQS-E8R-E8RO$vQdO,59{O,xQ[O'#EYO-VQWO,5;UO-VQWO,5;UOOQP1G.l1G.lO-|QXO,5:rOOQO-E8U-E8UOOQS1G.g1G.gOOQP1G.n1G.nO)PQWO1G.nO)UQWO1G.nOOQP1G/V1G/VO.ZQ`O1G/ZO.tQXO1G/_O/[QXO1G/aO/rQXO1G/bO0YQWO,59zO0_Q[O'#DOO0fQdO'#CoOOQP1G/Z1G/ZO$vQdO1G/ZO0mQpO,59]OOQS,59_,59_O$vQdO,59aO0uQWO1G/kOOQS,59c,59cO0zQ!bO,59eO1SQWO'#DhO1_QWO,5:TO1dQWO,5:ZO&TQ[O,5:VO&TQ[O'#EZO1lQWO,5;VO1wQWO,5:XO'yQ[O,5:[OOQS1G/x1G/xOOQS1G/z1G/zOOQS1G/|1G/|O2YQWO1G/|O2_QdO'#D|OOQS1G0P1G0POOQS1G0V1G0VOOQS1G0X1G0XO2mQtO1G/gOOQO,5:t,5:tO3TQ[O,5:tOOQO-E8W-E8WO3bQWO1G0pOOQP7+$Y7+$YOOQP7+$u7+$uO$vQdO7+$uOOQS1G/f1G/fO3mQXO'#EiO3tQWO,59jO3yQtO'#EUO4nQdO'#EfO4xQWO,59ZO4}QpO7+$uOOQS1G.w1G.wOOQS1G.{1G.{OOQS7+%V7+%VO5VQWO1G/PO$vQdO1G/oOOQO1G/u1G/uOOQO1G/q1G/qO5[QWO,5:uOOQO-E8X-E8XO5jQXO1G/vOOQS7+%h7+%hO5qQYO'#CsO(hQWO'#E[O5yQdO,5:hOOQS,5:h,5:hO6XQtO'#EXO$vQdO'#EXO7VQdO7+%ROOQO7+%R7+%ROOQO1G0`1G0`O7jQpO<<HaO7rQWO,5;TOOQP1G/U1G/UOOQS-E8S-E8SO$vQdO'#EVO7zQWO,5;QOOQT1G.u1G.uOOQP<<Ha<<HaOOQS7+$k7+$kO8SQdO7+%ZOOQO7+%b7+%bOOQS,5:v,5:vOOQS-E8Y-E8YOOQS1G0S1G0SO8ZQtO,5:sOOQS-E8V-E8VOOQO<<Hm<<HmOOQPAN={AN={O9XQdO,5:qOOQO-E8T-E8TOOQO<<Hu<<Hu",
  stateData: "9i~O#UOSROS~OUXOXXO]UO^UOtVOxWO!Y`O!ZYO!gZO!i[O!k]O!n^O!t_O#SQO#XSO~OQeOUXOXXO]UO^UOtVOxWO!Y`O!ZYO!gZO!i[O!k]O!n^O!t_O#SdO#XSO~O#P#^P~P!ZO#SiO~O]nO^nOplOtoOxpO|qO!PsO#QrO#XkO~O!RtO~P#kO`zO#RwO#SvO~O#S{O~O#S}O~OQ!WOb!QOf!WOh!WOn!VO#R!TO#S!PO#[!RO~Ob!YO!b![O!e!]O#S!XO!R#_P~Oh!bOn!VO#S!aO~O#S!dO~Ob!YO!b![O!e!]O#S!XO~O!W#_P~P%bO]WX]!UX^WXpWXtWXxWX|WX!PWX!RWX#QWX#XWX~O]!iO~O!W!jO#P#^X!Q#^X~O#P#^X!Q#^X~P!ZOUXOXXO]UO^UOtVOxWO#SQO#XSO~OplO!RtO~O`!sO#RwO#SvO~O!Q#^P~P!ZOb!zO~Ob!{O~Ov!|Oz!}O~OP#PObgXjgX!WgX!bgX!egX#SgXagXQgXfgXhgXngXpgX!VgX#PgX#RgX#[gXvgX!QgX~Ob!YOj#QO!b![O!e!]O#S!XO!W#_P~Ob#TO~Ob!YO!b![O!e!]O#S#UO~Op#YO!`#XO!R#_X!W#_X~Ob#]O~Oj#QO!W#_O~O!W#`O~Oh#aOn!VO~O!R#bO~O!RtO!`#XO~O!RtO!W#eO~O!W!|X#P!|X!Q!|X~P!ZO!W!jO#P#^a!Q#^a~O]nO^nOtoOxpO|qO!PsO#QrO#XkO~Op!za!R!zaa!za~P-bOv#lOz#mO~O]nO^nOtoOxpO#XkO~Op{i|{i!P{i!R{i#Q{ia{i~P.cOp}i|}i!P}i!R}i#Q}ia}i~P.cOp!Oi|!Oi!P!Oi!R!Oi#Q!Oia!Oi~P.cO!Q#nO~Oa#]P~P'yOa#YP~P$vOa#uOj#QO~O!W#wO~Oh#xOo#xO~O]!^Xa![X!`![X~O]#yO~Oa#zO!`#XO~Op#YO!R#_a!W#_a~O!`#XOp!aa!R!aa!W!aaa!aa~O!W$PO~O!Q$TO!q$RO!r$RO#[$QO~Oj#QOp$VO!V$XO!W!Ti#P!Ti!Q!Ti~P$vO!W!|a#P!|a!Q!|a~P!ZO!W!jO#P#^i!Q#^i~Oa#]X~P#kOa$]O~Oj#QOQ!xXa!xXb!xXf!xXh!xXn!xXp!xX#R!xX#S!xX#[!xX~Op$_Oa#YX~P$vOa$aO~Oj#QOv$bO~Oa$cO~O!`#XOp!}a!R!}a!W!}a~Oa$eO~P-bOP#PO!RgX~O!Q$hO!q$RO!r$RO#[$QO~Oj#QOQ!{Xb!{Xf!{Xh!{Xn!{Xp!{X!V!{X!W!{X#P!{X#R!{X#S!{X#[!{X!Q!{X~Op$VO!V$kO!W!Tq#P!Tq!Q!Tq~P$vOj#QOv$lO~OplOa#]a~Op$_Oa#Ya~Oa$oO~P$vOj#QOQ!{ab!{af!{ah!{an!{ap!{a!V!{a!W!{a#P!{a#R!{a#S!{a#[!{a!Q!{a~Oa!yap!ya~P$vOo#[j!Pj~",
  goto: ",`#aPPPPP#bP#k#zP#k$Z#kPP$aPPP$g$p$pP%SP$pP$p%j%|PPP&f&l#kP&rP#kP&xP#kP#k#kPPP'O'b'oPP#bPP'v'v(Q'vP'vP'v'vP#bP#bP#bP(T#bP(W(ZPP#bP#bP(^(m({)R)])c)m)sPPPPPP)y*SP*o*rP+h+k+q+z_aOPcgt!j#hkXOPcglqrst!j!z#]#hkROPcglqrst!j!z#]#hQjSR!mkQxUR!qnQ!qzQ#S!UR#k!sq!WY[!Q!i!{!}#Q#f#m#r#y$V$W$_$d$mp!WY[!Q!i!{!}#Q#f#m#r#y$V$W$_$d$mT$R#b$Sq!UY[!Q!i!{!}#Q#f#m#r#y$V$W$_$d$mp!WY[!Q!i!{!}#Q#f#m#r#y$V$W$_$d$mQ!b]R#a!cQyUR!rnQ!qyR#k!rQ|VR!toQ!OWR!upQuTQ!pmQ#^!_Q#d!fQ#e!gR$f$RSfPtQ!lgQ#g!jR$Y#hZePgt!j#ha!^Z_`!S!Y![#X#YR#V!YR!c]R!e^R#c!eQcOSgPtU!hcg#hR#h!jQ#r!{U$^#r$d$mQ$d#yR$m$_Q$`#rR$n$`QmTS!om$[R$[#oQ$W#fR$j$WQ!kfS#i!k#jR#j!lQ#Z!ZR#}#ZQ$S#bR$g$S_bOPcgt!j#h^TOPcgt!j#hQ!nlQ!vqQ!wrQ!xsQ#o!zR$O#]R#s!{Q!SYQ!`[Q#O!QQ#f!i[#q!{#r#y$_$d$mQ#t!}Q#v#QS$U#f$WQ$Z#mR$i$VR#p!zQhPR!ytQ!_ZQ!g`R#R!SU!ZZ`!SQ!f_Q#W!YQ#[![Q#{#XR#|#Y",
  nodeNames: "⚠ Unit VariableName Comment StyleSheet RuleSet UniversalSelector TagSelector TagName NestingSelector ClassSelector ClassName PseudoClassSelector : :: PseudoClassName PseudoClassName ) ( ArgList ValueName ParenthesizedValue ColorLiteral NumberLiteral StringLiteral BinaryExpression BinOp CallExpression Callee CallLiteral CallTag ParenthesizedContent , PseudoClassName ArgList IdSelector # IdName ] AttributeSelector [ AttributeName MatchOp ChildSelector ChildOp DescendantSelector SiblingSelector SiblingOp } { Block Declaration PropertyName Important ; ImportStatement AtKeyword import KeywordQuery FeatureQuery FeatureName BinaryQuery LogicOp UnaryQuery UnaryQueryOp ParenthesizedQuery SelectorQuery selector MediaStatement media CharsetStatement charset NamespaceStatement namespace NamespaceName KeyframesStatement keyframes KeyframeName KeyframeList from to SupportsStatement supports AtRule Styles",
  maxTerm: 108,
  nodeProps: [
    ["openedBy", 17, "(", 48, "{"],
    ["closedBy", 18, ")", 49, "}"]
  ],
  propSources: [m6],
  skippedNodes: [0, 3],
  repeatNodeCount: 8,
  tokenData: "Lq~R!^OX$}X^%u^p$}pq%uqr)Xrs.Rst/utu6duv$}vw7^wx7oxy9^yz9oz{9t{|:_|}?Q}!O?c!O!P@Q!P!Q@i!Q![Cu![!]Dp!]!^El!^!_$}!_!`E}!`!aF`!a!b$}!b!cG[!c!}$}!}#OHt#O#P$}#P#QIV#Q#R6d#R#T$}#T#UIh#U#c$}#c#dJy#d#o$}#o#pK`#p#q6d#q#rKq#r#sLS#s#y$}#y#z%u#z$f$}$f$g%u$g#BY$}#BY#BZ%u#BZ$IS$}$IS$I_%u$I_$I|$}$I|$JO%u$JO$JT$}$JT$JU%u$JU$KV$}$KV$KW%u$KW&FU$}&FU&FV%u&FV;'S$};'S;=`Lk<%lO$}W%QSOy%^z;'S%^;'S;=`%o<%lO%^W%cSoWOy%^z;'S%^;'S;=`%o<%lO%^W%rP;=`<%l%^~%zh#U~OX%^X^'f^p%^pq'fqy%^z#y%^#y#z'f#z$f%^$f$g'f$g#BY%^#BY#BZ'f#BZ$IS%^$IS$I_'f$I_$I|%^$I|$JO'f$JO$JT%^$JT$JU'f$JU$KV%^$KV$KW'f$KW&FU%^&FU&FV'f&FV;'S%^;'S;=`%o<%lO%^~'mh#U~oWOX%^X^'f^p%^pq'fqy%^z#y%^#y#z'f#z$f%^$f$g'f$g#BY%^#BY#BZ'f#BZ$IS%^$IS$I_'f$I_$I|%^$I|$JO'f$JO$JT%^$JT$JU'f$JU$KV%^$KV$KW'f$KW&FU%^&FU&FV'f&FV;'S%^;'S;=`%o<%lO%^^)[UOy%^z#]%^#]#^)n#^;'S%^;'S;=`%o<%lO%^^)sUoWOy%^z#a%^#a#b*V#b;'S%^;'S;=`%o<%lO%^^*[UoWOy%^z#d%^#d#e*n#e;'S%^;'S;=`%o<%lO%^^*sUoWOy%^z#c%^#c#d+V#d;'S%^;'S;=`%o<%lO%^^+[UoWOy%^z#f%^#f#g+n#g;'S%^;'S;=`%o<%lO%^^+sUoWOy%^z#h%^#h#i,V#i;'S%^;'S;=`%o<%lO%^^,[UoWOy%^z#T%^#T#U,n#U;'S%^;'S;=`%o<%lO%^^,sUoWOy%^z#b%^#b#c-V#c;'S%^;'S;=`%o<%lO%^^-[UoWOy%^z#h%^#h#i-n#i;'S%^;'S;=`%o<%lO%^^-uS!VUoWOy%^z;'S%^;'S;=`%o<%lO%^~.UWOY.RZr.Rrs.ns#O.R#O#P.s#P;'S.R;'S;=`/o<%lO.R~.sOh~~.vRO;'S.R;'S;=`/P;=`O.R~/SXOY.RZr.Rrs.ns#O.R#O#P.s#P;'S.R;'S;=`/o;=`<%l.R<%lO.R~/rP;=`<%l.R_/zYtPOy%^z!Q%^!Q![0j![!c%^!c!i0j!i#T%^#T#Z0j#Z;'S%^;'S;=`%o<%lO%^^0oYoWOy%^z!Q%^!Q![1_![!c%^!c!i1_!i#T%^#T#Z1_#Z;'S%^;'S;=`%o<%lO%^^1dYoWOy%^z!Q%^!Q![2S![!c%^!c!i2S!i#T%^#T#Z2S#Z;'S%^;'S;=`%o<%lO%^^2ZYfUoWOy%^z!Q%^!Q![2y![!c%^!c!i2y!i#T%^#T#Z2y#Z;'S%^;'S;=`%o<%lO%^^3QYfUoWOy%^z!Q%^!Q![3p![!c%^!c!i3p!i#T%^#T#Z3p#Z;'S%^;'S;=`%o<%lO%^^3uYoWOy%^z!Q%^!Q![4e![!c%^!c!i4e!i#T%^#T#Z4e#Z;'S%^;'S;=`%o<%lO%^^4lYfUoWOy%^z!Q%^!Q![5[![!c%^!c!i5[!i#T%^#T#Z5[#Z;'S%^;'S;=`%o<%lO%^^5aYoWOy%^z!Q%^!Q![6P![!c%^!c!i6P!i#T%^#T#Z6P#Z;'S%^;'S;=`%o<%lO%^^6WSfUoWOy%^z;'S%^;'S;=`%o<%lO%^Y6gUOy%^z!_%^!_!`6y!`;'S%^;'S;=`%o<%lO%^Y7QSzQoWOy%^z;'S%^;'S;=`%o<%lO%^X7cSXPOy%^z;'S%^;'S;=`%o<%lO%^~7rWOY7oZw7owx.nx#O7o#O#P8[#P;'S7o;'S;=`9W<%lO7o~8_RO;'S7o;'S;=`8h;=`O7o~8kXOY7oZw7owx.nx#O7o#O#P8[#P;'S7o;'S;=`9W;=`<%l7o<%lO7o~9ZP;=`<%l7o_9cSbVOy%^z;'S%^;'S;=`%o<%lO%^~9tOa~_9{UUPjSOy%^z!_%^!_!`6y!`;'S%^;'S;=`%o<%lO%^_:fWjS!PPOy%^z!O%^!O!P;O!P!Q%^!Q![>T![;'S%^;'S;=`%o<%lO%^^;TUoWOy%^z!Q%^!Q![;g![;'S%^;'S;=`%o<%lO%^^;nYoW#[UOy%^z!Q%^!Q![;g![!g%^!g!h<^!h#X%^#X#Y<^#Y;'S%^;'S;=`%o<%lO%^^<cYoWOy%^z{%^{|=R|}%^}!O=R!O!Q%^!Q![=j![;'S%^;'S;=`%o<%lO%^^=WUoWOy%^z!Q%^!Q![=j![;'S%^;'S;=`%o<%lO%^^=qUoW#[UOy%^z!Q%^!Q![=j![;'S%^;'S;=`%o<%lO%^^>[[oW#[UOy%^z!O%^!O!P;g!P!Q%^!Q![>T![!g%^!g!h<^!h#X%^#X#Y<^#Y;'S%^;'S;=`%o<%lO%^_?VSpVOy%^z;'S%^;'S;=`%o<%lO%^^?hWjSOy%^z!O%^!O!P;O!P!Q%^!Q![>T![;'S%^;'S;=`%o<%lO%^_@VU#XPOy%^z!Q%^!Q![;g![;'S%^;'S;=`%o<%lO%^~@nTjSOy%^z{@}{;'S%^;'S;=`%o<%lO%^~ASUoWOy@}yzAfz{Bm{;'S@};'S;=`Co<%lO@}~AiTOzAfz{Ax{;'SAf;'S;=`Bg<%lOAf~A{VOzAfz{Ax{!PAf!P!QBb!Q;'SAf;'S;=`Bg<%lOAf~BgOR~~BjP;=`<%lAf~BrWoWOy@}yzAfz{Bm{!P@}!P!QC[!Q;'S@};'S;=`Co<%lO@}~CcSoWR~Oy%^z;'S%^;'S;=`%o<%lO%^~CrP;=`<%l@}^Cz[#[UOy%^z!O%^!O!P;g!P!Q%^!Q![>T![!g%^!g!h<^!h#X%^#X#Y<^#Y;'S%^;'S;=`%o<%lO%^XDuU]POy%^z![%^![!]EX!];'S%^;'S;=`%o<%lO%^XE`S^PoWOy%^z;'S%^;'S;=`%o<%lO%^_EqS!WVOy%^z;'S%^;'S;=`%o<%lO%^YFSSzQOy%^z;'S%^;'S;=`%o<%lO%^XFeU|POy%^z!`%^!`!aFw!a;'S%^;'S;=`%o<%lO%^XGOS|PoWOy%^z;'S%^;'S;=`%o<%lO%^XG_WOy%^z!c%^!c!}Gw!}#T%^#T#oGw#o;'S%^;'S;=`%o<%lO%^XHO[!YPoWOy%^z}%^}!OGw!O!Q%^!Q![Gw![!c%^!c!}Gw!}#T%^#T#oGw#o;'S%^;'S;=`%o<%lO%^XHySxPOy%^z;'S%^;'S;=`%o<%lO%^^I[SvUOy%^z;'S%^;'S;=`%o<%lO%^XIkUOy%^z#b%^#b#cI}#c;'S%^;'S;=`%o<%lO%^XJSUoWOy%^z#W%^#W#XJf#X;'S%^;'S;=`%o<%lO%^XJmS!`PoWOy%^z;'S%^;'S;=`%o<%lO%^XJ|UOy%^z#f%^#f#gJf#g;'S%^;'S;=`%o<%lO%^XKeS!RPOy%^z;'S%^;'S;=`%o<%lO%^_KvS!QVOy%^z;'S%^;'S;=`%o<%lO%^ZLXU!PPOy%^z!_%^!_!`6y!`;'S%^;'S;=`%o<%lO%^WLnP;=`<%l$}",
  tokenizers: [f6, g6, u6, 0, 1, 2, 3],
  topRules: { StyleSheet: [0, 4], Styles: [1, 84] },
  specialized: [{ term: 95, get: (r) => b6[r] || -1 }, { term: 56, get: (r) => O6[r] || -1 }, { term: 96, get: (r) => v6[r] || -1 }],
  tokenPrec: 1123
});
let xa = null;
function _a() {
  if (!xa && typeof document == "object" && document.body) {
    let r = [];
    for (let e in document.body.style)
      /[A-Z]|^-|^(item|length)$/.test(e) || r.push(e);
    xa = r.sort().map((e) => ({ type: "property", label: e }));
  }
  return xa || [];
}
const Xu = /* @__PURE__ */ [
  "active",
  "after",
  "any-link",
  "autofill",
  "backdrop",
  "before",
  "checked",
  "cue",
  "default",
  "defined",
  "disabled",
  "empty",
  "enabled",
  "file-selector-button",
  "first",
  "first-child",
  "first-letter",
  "first-line",
  "first-of-type",
  "focus",
  "focus-visible",
  "focus-within",
  "fullscreen",
  "has",
  "host",
  "host-context",
  "hover",
  "in-range",
  "indeterminate",
  "invalid",
  "is",
  "lang",
  "last-child",
  "last-of-type",
  "left",
  "link",
  "marker",
  "modal",
  "not",
  "nth-child",
  "nth-last-child",
  "nth-last-of-type",
  "nth-of-type",
  "only-child",
  "only-of-type",
  "optional",
  "out-of-range",
  "part",
  "placeholder",
  "placeholder-shown",
  "read-only",
  "read-write",
  "required",
  "right",
  "root",
  "scope",
  "selection",
  "slotted",
  "target",
  "target-text",
  "valid",
  "visited",
  "where"
].map((r) => ({ type: "class", label: r })), Au = /* @__PURE__ */ [
  "above",
  "absolute",
  "activeborder",
  "additive",
  "activecaption",
  "after-white-space",
  "ahead",
  "alias",
  "all",
  "all-scroll",
  "alphabetic",
  "alternate",
  "always",
  "antialiased",
  "appworkspace",
  "asterisks",
  "attr",
  "auto",
  "auto-flow",
  "avoid",
  "avoid-column",
  "avoid-page",
  "avoid-region",
  "axis-pan",
  "background",
  "backwards",
  "baseline",
  "below",
  "bidi-override",
  "blink",
  "block",
  "block-axis",
  "bold",
  "bolder",
  "border",
  "border-box",
  "both",
  "bottom",
  "break",
  "break-all",
  "break-word",
  "bullets",
  "button",
  "button-bevel",
  "buttonface",
  "buttonhighlight",
  "buttonshadow",
  "buttontext",
  "calc",
  "capitalize",
  "caps-lock-indicator",
  "caption",
  "captiontext",
  "caret",
  "cell",
  "center",
  "checkbox",
  "circle",
  "cjk-decimal",
  "clear",
  "clip",
  "close-quote",
  "col-resize",
  "collapse",
  "color",
  "color-burn",
  "color-dodge",
  "column",
  "column-reverse",
  "compact",
  "condensed",
  "contain",
  "content",
  "contents",
  "content-box",
  "context-menu",
  "continuous",
  "copy",
  "counter",
  "counters",
  "cover",
  "crop",
  "cross",
  "crosshair",
  "currentcolor",
  "cursive",
  "cyclic",
  "darken",
  "dashed",
  "decimal",
  "decimal-leading-zero",
  "default",
  "default-button",
  "dense",
  "destination-atop",
  "destination-in",
  "destination-out",
  "destination-over",
  "difference",
  "disc",
  "discard",
  "disclosure-closed",
  "disclosure-open",
  "document",
  "dot-dash",
  "dot-dot-dash",
  "dotted",
  "double",
  "down",
  "e-resize",
  "ease",
  "ease-in",
  "ease-in-out",
  "ease-out",
  "element",
  "ellipse",
  "ellipsis",
  "embed",
  "end",
  "ethiopic-abegede-gez",
  "ethiopic-halehame-aa-er",
  "ethiopic-halehame-gez",
  "ew-resize",
  "exclusion",
  "expanded",
  "extends",
  "extra-condensed",
  "extra-expanded",
  "fantasy",
  "fast",
  "fill",
  "fill-box",
  "fixed",
  "flat",
  "flex",
  "flex-end",
  "flex-start",
  "footnotes",
  "forwards",
  "from",
  "geometricPrecision",
  "graytext",
  "grid",
  "groove",
  "hand",
  "hard-light",
  "help",
  "hidden",
  "hide",
  "higher",
  "highlight",
  "highlighttext",
  "horizontal",
  "hsl",
  "hsla",
  "hue",
  "icon",
  "ignore",
  "inactiveborder",
  "inactivecaption",
  "inactivecaptiontext",
  "infinite",
  "infobackground",
  "infotext",
  "inherit",
  "initial",
  "inline",
  "inline-axis",
  "inline-block",
  "inline-flex",
  "inline-grid",
  "inline-table",
  "inset",
  "inside",
  "intrinsic",
  "invert",
  "italic",
  "justify",
  "keep-all",
  "landscape",
  "large",
  "larger",
  "left",
  "level",
  "lighter",
  "lighten",
  "line-through",
  "linear",
  "linear-gradient",
  "lines",
  "list-item",
  "listbox",
  "listitem",
  "local",
  "logical",
  "loud",
  "lower",
  "lower-hexadecimal",
  "lower-latin",
  "lower-norwegian",
  "lowercase",
  "ltr",
  "luminosity",
  "manipulation",
  "match",
  "matrix",
  "matrix3d",
  "medium",
  "menu",
  "menutext",
  "message-box",
  "middle",
  "min-intrinsic",
  "mix",
  "monospace",
  "move",
  "multiple",
  "multiple_mask_images",
  "multiply",
  "n-resize",
  "narrower",
  "ne-resize",
  "nesw-resize",
  "no-close-quote",
  "no-drop",
  "no-open-quote",
  "no-repeat",
  "none",
  "normal",
  "not-allowed",
  "nowrap",
  "ns-resize",
  "numbers",
  "numeric",
  "nw-resize",
  "nwse-resize",
  "oblique",
  "opacity",
  "open-quote",
  "optimizeLegibility",
  "optimizeSpeed",
  "outset",
  "outside",
  "outside-shape",
  "overlay",
  "overline",
  "padding",
  "padding-box",
  "painted",
  "page",
  "paused",
  "perspective",
  "pinch-zoom",
  "plus-darker",
  "plus-lighter",
  "pointer",
  "polygon",
  "portrait",
  "pre",
  "pre-line",
  "pre-wrap",
  "preserve-3d",
  "progress",
  "push-button",
  "radial-gradient",
  "radio",
  "read-only",
  "read-write",
  "read-write-plaintext-only",
  "rectangle",
  "region",
  "relative",
  "repeat",
  "repeating-linear-gradient",
  "repeating-radial-gradient",
  "repeat-x",
  "repeat-y",
  "reset",
  "reverse",
  "rgb",
  "rgba",
  "ridge",
  "right",
  "rotate",
  "rotate3d",
  "rotateX",
  "rotateY",
  "rotateZ",
  "round",
  "row",
  "row-resize",
  "row-reverse",
  "rtl",
  "run-in",
  "running",
  "s-resize",
  "sans-serif",
  "saturation",
  "scale",
  "scale3d",
  "scaleX",
  "scaleY",
  "scaleZ",
  "screen",
  "scroll",
  "scrollbar",
  "scroll-position",
  "se-resize",
  "self-start",
  "self-end",
  "semi-condensed",
  "semi-expanded",
  "separate",
  "serif",
  "show",
  "single",
  "skew",
  "skewX",
  "skewY",
  "skip-white-space",
  "slide",
  "slider-horizontal",
  "slider-vertical",
  "sliderthumb-horizontal",
  "sliderthumb-vertical",
  "slow",
  "small",
  "small-caps",
  "small-caption",
  "smaller",
  "soft-light",
  "solid",
  "source-atop",
  "source-in",
  "source-out",
  "source-over",
  "space",
  "space-around",
  "space-between",
  "space-evenly",
  "spell-out",
  "square",
  "start",
  "static",
  "status-bar",
  "stretch",
  "stroke",
  "stroke-box",
  "sub",
  "subpixel-antialiased",
  "svg_masks",
  "super",
  "sw-resize",
  "symbolic",
  "symbols",
  "system-ui",
  "table",
  "table-caption",
  "table-cell",
  "table-column",
  "table-column-group",
  "table-footer-group",
  "table-header-group",
  "table-row",
  "table-row-group",
  "text",
  "text-bottom",
  "text-top",
  "textarea",
  "textfield",
  "thick",
  "thin",
  "threeddarkshadow",
  "threedface",
  "threedhighlight",
  "threedlightshadow",
  "threedshadow",
  "to",
  "top",
  "transform",
  "translate",
  "translate3d",
  "translateX",
  "translateY",
  "translateZ",
  "transparent",
  "ultra-condensed",
  "ultra-expanded",
  "underline",
  "unidirectional-pan",
  "unset",
  "up",
  "upper-latin",
  "uppercase",
  "url",
  "var",
  "vertical",
  "vertical-text",
  "view-box",
  "visible",
  "visibleFill",
  "visiblePainted",
  "visibleStroke",
  "visual",
  "w-resize",
  "wait",
  "wave",
  "wider",
  "window",
  "windowframe",
  "windowtext",
  "words",
  "wrap",
  "wrap-reverse",
  "x-large",
  "x-small",
  "xor",
  "xx-large",
  "xx-small"
].map((r) => ({ type: "keyword", label: r })).concat(/* @__PURE__ */ [
  "aliceblue",
  "antiquewhite",
  "aqua",
  "aquamarine",
  "azure",
  "beige",
  "bisque",
  "black",
  "blanchedalmond",
  "blue",
  "blueviolet",
  "brown",
  "burlywood",
  "cadetblue",
  "chartreuse",
  "chocolate",
  "coral",
  "cornflowerblue",
  "cornsilk",
  "crimson",
  "cyan",
  "darkblue",
  "darkcyan",
  "darkgoldenrod",
  "darkgray",
  "darkgreen",
  "darkkhaki",
  "darkmagenta",
  "darkolivegreen",
  "darkorange",
  "darkorchid",
  "darkred",
  "darksalmon",
  "darkseagreen",
  "darkslateblue",
  "darkslategray",
  "darkturquoise",
  "darkviolet",
  "deeppink",
  "deepskyblue",
  "dimgray",
  "dodgerblue",
  "firebrick",
  "floralwhite",
  "forestgreen",
  "fuchsia",
  "gainsboro",
  "ghostwhite",
  "gold",
  "goldenrod",
  "gray",
  "grey",
  "green",
  "greenyellow",
  "honeydew",
  "hotpink",
  "indianred",
  "indigo",
  "ivory",
  "khaki",
  "lavender",
  "lavenderblush",
  "lawngreen",
  "lemonchiffon",
  "lightblue",
  "lightcoral",
  "lightcyan",
  "lightgoldenrodyellow",
  "lightgray",
  "lightgreen",
  "lightpink",
  "lightsalmon",
  "lightseagreen",
  "lightskyblue",
  "lightslategray",
  "lightsteelblue",
  "lightyellow",
  "lime",
  "limegreen",
  "linen",
  "magenta",
  "maroon",
  "mediumaquamarine",
  "mediumblue",
  "mediumorchid",
  "mediumpurple",
  "mediumseagreen",
  "mediumslateblue",
  "mediumspringgreen",
  "mediumturquoise",
  "mediumvioletred",
  "midnightblue",
  "mintcream",
  "mistyrose",
  "moccasin",
  "navajowhite",
  "navy",
  "oldlace",
  "olive",
  "olivedrab",
  "orange",
  "orangered",
  "orchid",
  "palegoldenrod",
  "palegreen",
  "paleturquoise",
  "palevioletred",
  "papayawhip",
  "peachpuff",
  "peru",
  "pink",
  "plum",
  "powderblue",
  "purple",
  "rebeccapurple",
  "red",
  "rosybrown",
  "royalblue",
  "saddlebrown",
  "salmon",
  "sandybrown",
  "seagreen",
  "seashell",
  "sienna",
  "silver",
  "skyblue",
  "slateblue",
  "slategray",
  "snow",
  "springgreen",
  "steelblue",
  "tan",
  "teal",
  "thistle",
  "tomato",
  "turquoise",
  "violet",
  "wheat",
  "white",
  "whitesmoke",
  "yellow",
  "yellowgreen"
].map((r) => ({ type: "constant", label: r }))), _6 = /* @__PURE__ */ [
  "a",
  "abbr",
  "address",
  "article",
  "aside",
  "b",
  "bdi",
  "bdo",
  "blockquote",
  "body",
  "br",
  "button",
  "canvas",
  "caption",
  "cite",
  "code",
  "col",
  "colgroup",
  "dd",
  "del",
  "details",
  "dfn",
  "dialog",
  "div",
  "dl",
  "dt",
  "em",
  "figcaption",
  "figure",
  "footer",
  "form",
  "header",
  "hgroup",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "hr",
  "html",
  "i",
  "iframe",
  "img",
  "input",
  "ins",
  "kbd",
  "label",
  "legend",
  "li",
  "main",
  "meter",
  "nav",
  "ol",
  "output",
  "p",
  "pre",
  "ruby",
  "section",
  "select",
  "small",
  "source",
  "span",
  "strong",
  "sub",
  "summary",
  "sup",
  "table",
  "tbody",
  "td",
  "template",
  "textarea",
  "tfoot",
  "th",
  "thead",
  "tr",
  "u",
  "ul"
].map((r) => ({ type: "type", label: r })), xr = /^[\w-]*/, w6 = (r) => {
  let { state: e, pos: t } = r, l = ze(e).resolveInner(t, -1);
  if (l.name == "PropertyName")
    return { from: l.from, options: _a(), validFor: xr };
  if (l.name == "ValueName")
    return { from: l.from, options: Au, validFor: xr };
  if (l.name == "PseudoClassName")
    return { from: l.from, options: Xu, validFor: xr };
  if (l.name == "TagName") {
    for (let { parent: n } = l; n; n = n.parent)
      if (n.name == "Block")
        return { from: l.from, options: _a(), validFor: xr };
    return { from: l.from, options: _6, validFor: xr };
  }
  if (!r.explicit)
    return null;
  let i = l.resolve(t), o = i.childBefore(t);
  return o && o.name == ":" && i.name == "PseudoClassSelector" ? { from: t, options: Xu, validFor: xr } : o && o.name == ":" && i.name == "Declaration" || i.name == "ArgList" ? { from: t, options: Au, validFor: xr } : i.name == "Block" ? { from: t, options: _a(), validFor: xr } : null;
}, Fn = /* @__PURE__ */ ei.define({
  name: "css",
  parser: /* @__PURE__ */ x6.configure({
    props: [
      /* @__PURE__ */ Xs.add({
        Declaration: /* @__PURE__ */ gn()
      }),
      /* @__PURE__ */ As.add({
        Block: pb
      })
    ]
  }),
  languageData: {
    commentTokens: { block: { open: "/*", close: "*/" } },
    indentOnInput: /^\s*\}$/,
    wordChars: "-"
  }
});
function nO() {
  return new Nd(Fn, Fn.data.of({ autocomplete: w6 }));
}
const y6 = 54, k6 = 1, S6 = 55, Q6 = 2, $6 = 56, P6 = 3, Hn = 4, sO = 5, aO = 6, cO = 7, dO = 8, C6 = 9, T6 = 10, z6 = 11, wa = 57, X6 = 12, Eu = 58, A6 = 18, E6 = 20, hO = 21, V6 = 22, Yc = 24, pO = 25, Z6 = 27, R6 = 30, D6 = 33, uO = 35, W6 = 36, N6 = 0, M6 = {
  area: !0,
  base: !0,
  br: !0,
  col: !0,
  command: !0,
  embed: !0,
  frame: !0,
  hr: !0,
  img: !0,
  input: !0,
  keygen: !0,
  link: !0,
  meta: !0,
  param: !0,
  source: !0,
  track: !0,
  wbr: !0,
  menuitem: !0
}, Y6 = {
  dd: !0,
  li: !0,
  optgroup: !0,
  option: !0,
  p: !0,
  rp: !0,
  rt: !0,
  tbody: !0,
  td: !0,
  tfoot: !0,
  th: !0,
  tr: !0
}, Vu = {
  dd: { dd: !0, dt: !0 },
  dt: { dd: !0, dt: !0 },
  li: { li: !0 },
  option: { option: !0, optgroup: !0 },
  optgroup: { optgroup: !0 },
  p: {
    address: !0,
    article: !0,
    aside: !0,
    blockquote: !0,
    dir: !0,
    div: !0,
    dl: !0,
    fieldset: !0,
    footer: !0,
    form: !0,
    h1: !0,
    h2: !0,
    h3: !0,
    h4: !0,
    h5: !0,
    h6: !0,
    header: !0,
    hgroup: !0,
    hr: !0,
    menu: !0,
    nav: !0,
    ol: !0,
    p: !0,
    pre: !0,
    section: !0,
    table: !0,
    ul: !0
  },
  rp: { rp: !0, rt: !0 },
  rt: { rp: !0, rt: !0 },
  tbody: { tbody: !0, tfoot: !0 },
  td: { td: !0, th: !0 },
  tfoot: { tbody: !0 },
  th: { td: !0, th: !0 },
  thead: { tbody: !0, tfoot: !0 },
  tr: { tr: !0 }
};
function j6(r) {
  return r == 45 || r == 46 || r == 58 || r >= 65 && r <= 90 || r == 95 || r >= 97 && r <= 122 || r >= 161;
}
function fO(r) {
  return r == 9 || r == 10 || r == 13 || r == 32;
}
let Zu = null, Ru = null, Du = 0;
function jc(r, e) {
  let t = r.pos + e;
  if (Du == t && Ru == r)
    return Zu;
  let l = r.peek(e);
  for (; fO(l); )
    l = r.peek(++e);
  let i = "";
  for (; j6(l); )
    i += String.fromCharCode(l), l = r.peek(++e);
  return Ru = r, Du = t, Zu = i ? i.toLowerCase() : l == I6 || l == U6 ? void 0 : null;
}
const gO = 60, mO = 62, bO = 47, I6 = 63, U6 = 33, q6 = 45;
function Wu(r, e) {
  this.name = r, this.parent = e, this.hash = e ? e.hash : 0;
  for (let t = 0; t < r.length; t++)
    this.hash += (this.hash << 4) + r.charCodeAt(t) + (r.charCodeAt(t) << 8);
}
const B6 = [Hn, dO, sO, aO, cO], L6 = new lO({
  start: null,
  shift(r, e, t, l) {
    return B6.indexOf(e) > -1 ? new Wu(jc(l, 1) || "", r) : r;
  },
  reduce(r, e) {
    return e == A6 && r ? r.parent : r;
  },
  reuse(r, e, t, l) {
    let i = e.type.id;
    return i == Hn || i == uO ? new Wu(jc(l, 1) || "", r) : r;
  },
  hash(r) {
    return r ? r.hash : 0;
  },
  strict: !1
}), G6 = new Or((r, e) => {
  if (r.next != gO) {
    r.next < 0 && e.context && r.acceptToken(wa);
    return;
  }
  r.advance();
  let t = r.next == bO;
  t && r.advance();
  let l = jc(r, 0);
  if (l === void 0)
    return;
  if (!l)
    return r.acceptToken(t ? X6 : Hn);
  let i = e.context ? e.context.name : null;
  if (t) {
    if (l == i)
      return r.acceptToken(C6);
    if (i && Y6[i])
      return r.acceptToken(wa, -2);
    if (e.dialectEnabled(N6))
      return r.acceptToken(T6);
    for (let o = e.context; o; o = o.parent)
      if (o.name == l)
        return;
    r.acceptToken(z6);
  } else {
    if (l == "script")
      return r.acceptToken(sO);
    if (l == "style")
      return r.acceptToken(aO);
    if (l == "textarea")
      return r.acceptToken(cO);
    if (M6.hasOwnProperty(l))
      return r.acceptToken(dO);
    i && Vu[i] && Vu[i][l] ? r.acceptToken(wa, -1) : r.acceptToken(Hn);
  }
}, { contextual: !0 }), F6 = new Or((r) => {
  for (let e = 0, t = 0; ; t++) {
    if (r.next < 0) {
      t && r.acceptToken(Eu);
      break;
    }
    if (r.next == q6)
      e++;
    else if (r.next == mO && e >= 2) {
      t > 3 && r.acceptToken(Eu, -2);
      break;
    } else
      e = 0;
    r.advance();
  }
});
function qd(r, e, t) {
  let l = 2 + r.length;
  return new Or((i) => {
    for (let o = 0, n = 0, s = 0; ; s++) {
      if (i.next < 0) {
        s && i.acceptToken(e);
        break;
      }
      if (o == 0 && i.next == gO || o == 1 && i.next == bO || o >= 2 && o < l && i.next == r.charCodeAt(o - 2))
        o++, n++;
      else if ((o == 2 || o == l) && fO(i.next))
        n++;
      else if (o == l && i.next == mO) {
        s > n ? i.acceptToken(e, -n) : i.acceptToken(t, -(n - 2));
        break;
      } else if ((i.next == 10 || i.next == 13) && s) {
        i.acceptToken(e, 1);
        break;
      } else
        o = n = 0;
      i.advance();
    }
  });
}
const H6 = qd("script", y6, k6), K6 = qd("style", S6, Q6), J6 = qd("textarea", $6, P6), eQ = Cs({
  "Text RawText": v.content,
  "StartTag StartCloseTag SelfClosingEndTag EndTag": v.angleBracket,
  TagName: v.tagName,
  "MismatchedCloseTag/TagName": [v.tagName, v.invalid],
  AttributeName: v.attributeName,
  "AttributeValue UnquotedAttributeValue": v.attributeValue,
  Is: v.definitionOperator,
  "EntityReference CharacterReference": v.character,
  Comment: v.blockComment,
  ProcessingInst: v.processingInstruction,
  DoctypeDecl: v.documentMeta
}), tQ = ri.deserialize({
  version: 14,
  states: ",xOVOxOOO!WQ!bO'#CoO!]Q!bO'#CyO!bQ!bO'#C|O!gQ!bO'#DPO!lQ!bO'#DRO!qOXO'#CnO!|OYO'#CnO#XO[O'#CnO$eOxO'#CnOOOW'#Cn'#CnO$lO!rO'#DTO$tQ!bO'#DVO$yQ!bO'#DWOOOW'#Dk'#DkOOOW'#DY'#DYQVOxOOO%OQ#tO,59ZO%WQ#tO,59eO%`Q#tO,59hO%hQ#tO,59kO%sQ#tO,59mOOOX'#D^'#D^O%{OXO'#CwO&WOXO,59YOOOY'#D_'#D_O&`OYO'#CzO&kOYO,59YOOO['#D`'#D`O&sO[O'#C}O'OO[O,59YOOOW'#Da'#DaO'WOxO,59YO'_Q!bO'#DQOOOW,59Y,59YOOO`'#Db'#DbO'dO!rO,59oOOOW,59o,59oO'lQ!bO,59qO'qQ!bO,59rOOOW-E7W-E7WO'vQ#tO'#CqOOQO'#DZ'#DZO(UQ#tO1G.uOOOX1G.u1G.uO(^Q#tO1G/POOOY1G/P1G/PO(fQ#tO1G/SOOO[1G/S1G/SO(nQ#tO1G/VOOOW1G/V1G/VOOOW1G/X1G/XO(yQ#tO1G/XOOOX-E7[-E7[O)RQ!bO'#CxOOOW1G.t1G.tOOOY-E7]-E7]O)WQ!bO'#C{OOO[-E7^-E7^O)]Q!bO'#DOOOOW-E7_-E7_O)bQ!bO,59lOOO`-E7`-E7`OOOW1G/Z1G/ZOOOW1G/]1G/]OOOW1G/^1G/^O)gQ&jO,59]OOQO-E7X-E7XOOOX7+$a7+$aOOOY7+$k7+$kOOO[7+$n7+$nOOOW7+$q7+$qOOOW7+$s7+$sO)rQ!bO,59dO)wQ!bO,59gO)|Q!bO,59jOOOW1G/W1G/WO*RO,UO'#CtO*dO7[O'#CtOOQO1G.w1G.wOOOW1G/O1G/OOOOW1G/R1G/ROOOW1G/U1G/UOOOO'#D['#D[O*uO,UO,59`OOQO,59`,59`OOOO'#D]'#D]O+WO7[O,59`OOOO-E7Y-E7YOOQO1G.z1G.zOOOO-E7Z-E7Z",
  stateData: "+u~O!^OS~OSSOTPOUQOVROWTOY]OZ[O[^O^^O_^O`^Oa^Ox^O{_O!dZO~OdaO~OdbO~OdcO~OddO~OdeO~O!WfOPkP!ZkP~O!XiOQnP!ZnP~O!YlORqP!ZqP~OSSOTPOUQOVROWTOXqOY]OZ[O[^O^^O_^O`^Oa^Ox^O!dZO~O!ZrO~P#dO![sO!euO~OdvO~OdwO~OfyOj|O~OfyOj!OO~OfyOj!QO~OfyOj!SOv!TO~OfyOj!TO~O!WfOPkX!ZkX~OP!WO!Z!XO~O!XiOQnX!ZnX~OQ!ZO!Z!XO~O!YlORqX!ZqX~OR!]O!Z!XO~O!Z!XO~P#dOd!_O~O![sO!e!aO~Oj!bO~Oj!cO~Og!dOfeXjeXveX~OfyOj!fO~OfyOj!gO~OfyOj!hO~OfyOj!iOv!jO~OfyOj!jO~Od!kO~Od!lO~Od!mO~Oj!nO~Oi!qO!`!oO!b!pO~Oj!rO~Oj!sO~Oj!tO~O_!uO`!uOa!uO!`!wO!a!uO~O_!xO`!xOa!xO!b!wO!c!xO~O_!uO`!uOa!uO!`!{O!a!uO~O_!xO`!xOa!xO!b!{O!c!xO~Ov~vj`!dx{_a_~",
  goto: "%p!`PPPPPPPPPPPPPPPPPP!a!gP!mPP!yPP!|#P#S#Y#]#`#f#i#l#r#xP!aP!a!aP$O$U$l$r$x%O%U%[%bPPPPPPPP%hX^OX`pXUOX`pezabcde{}!P!R!UR!q!dRhUR!XhXVOX`pRkVR!XkXWOX`pRnWR!XnXXOX`pQrXR!XpXYOX`pQ`ORx`Q{aQ}bQ!PcQ!RdQ!UeZ!e{}!P!R!UQ!v!oR!z!vQ!y!pR!|!yQgUR!VgQjVR!YjQmWR![mQpXR!^pQtZR!`tS_O`ToXp",
  nodeNames: "⚠ StartCloseTag StartCloseTag StartCloseTag StartTag StartTag StartTag StartTag StartTag StartCloseTag StartCloseTag StartCloseTag IncompleteCloseTag Document Text EntityReference CharacterReference InvalidEntity Element OpenTag TagName Attribute AttributeName Is AttributeValue UnquotedAttributeValue EndTag ScriptText CloseTag OpenTag StyleText CloseTag OpenTag TextareaText CloseTag OpenTag CloseTag SelfClosingTag SelfClosingEndTag Comment ProcessingInst MismatchedCloseTag CloseTag DoctypeDecl",
  maxTerm: 67,
  context: L6,
  nodeProps: [
    ["closedBy", -10, 1, 2, 3, 5, 6, 7, 8, 9, 10, 11, "EndTag", 4, "EndTag SelfClosingEndTag", -4, 19, 29, 32, 35, "CloseTag"],
    ["group", -9, 12, 15, 16, 17, 18, 39, 40, 41, 42, "Entity", 14, "Entity TextContent", -3, 27, 30, 33, "TextContent Entity"],
    ["openedBy", 26, "StartTag StartCloseTag", -4, 28, 31, 34, 36, "OpenTag", 38, "StartTag"]
  ],
  propSources: [eQ],
  skippedNodes: [0],
  repeatNodeCount: 9,
  tokenData: "#(r!aR!YOX$qXY,QYZ,QZ[$q[]&X]^,Q^p$qpq,Qqr-_rs4ysv-_vw5iwxJ^x}-_}!OKP!O!P-_!P!Q!!O!Q![-_![!]!$c!]!^-_!^!_!(k!_!`#'S!`!a#'z!a!c-_!c!}!$c!}#R-_#R#S!$c#S#T3V#T#o!$c#o#s-_#s$f$q$f%W-_%W%o!$c%o%p-_%p&a!$c&a&b-_&b1p!$c1p4U-_4U4d!$c4d4e-_4e$IS!$c$IS$I`-_$I`$Ib!$c$Ib$Kh-_$Kh%#t!$c%#t&/x-_&/x&Et!$c&Et&FV-_&FV;'S!$c;'S;:j!(e;:j;=`4s<%l?&r-_?&r?Ah!$c?Ah?BY$q?BY?Mn!$c?MnO$q!Z$|c^PiW!a`!cpOX$qXZ&XZ[$q[^&X^p$qpq&Xqr$qrs&}sv$qvw+Pwx(tx!^$q!^!_*V!_!a&X!a#S$q#S#T&X#T;'S$q;'S;=`+z<%lO$q!R&bX^P!a`!cpOr&Xrs&}sv&Xwx(tx!^&X!^!_*V!_;'S&X;'S;=`*y<%lO&Xq'UV^P!cpOv&}wx'kx!^&}!^!_(V!_;'S&};'S;=`(n<%lO&}P'pT^POv'kw!^'k!_;'S'k;'S;=`(P<%lO'kP(SP;=`<%l'kp([S!cpOv(Vx;'S(V;'S;=`(h<%lO(Vp(kP;=`<%l(Vq(qP;=`<%l&}a({W^P!a`Or(trs'ksv(tw!^(t!^!_)e!_;'S(t;'S;=`*P<%lO(t`)jT!a`Or)esv)ew;'S)e;'S;=`)y<%lO)e`)|P;=`<%l)ea*SP;=`<%l(t!Q*^V!a`!cpOr*Vrs(Vsv*Vwx)ex;'S*V;'S;=`*s<%lO*V!Q*vP;=`<%l*V!R*|P;=`<%l&XW+UYiWOX+PZ[+P^p+Pqr+Psw+Px!^+P!a#S+P#T;'S+P;'S;=`+t<%lO+PW+wP;=`<%l+P!Z+}P;=`<%l$q!a,]`^P!a`!cp!^^OX&XXY,QYZ,QZ]&X]^,Q^p&Xpq,Qqr&Xrs&}sv&Xwx(tx!^&X!^!_*V!_;'S&X;'S;=`*y<%lO&X!_-ljfS^PiW!a`!cpOX$qXZ&XZ[$q[^&X^p$qpq&Xqr-_rs&}sv-_vw/^wx(tx!P-_!P!Q$q!Q!^-_!^!_1n!_!a&X!a#S-_#S#T3V#T#s-_#s$f$q$f;'S-_;'S;=`4s<%l?Ah-_?Ah?BY$q?BY?Mn-_?MnO$q[/ecfSiWOX+PZ[+P^p+Pqr/^sw/^x!P/^!P!Q+P!Q!^/^!^!_0p!a#S/^#S#T0p#T#s/^#s$f+P$f;'S/^;'S;=`1h<%l?Ah/^?Ah?BY+P?BY?Mn/^?MnO+PS0uXfSqr0psw0px!P0p!Q!_0p!a#s0p$f;'S0p;'S;=`1b<%l?Ah0p?BY?Mn0pS1eP;=`<%l0p[1kP;=`<%l/^!U1wbfS!a`!cpOq*Vqr1nrs(Vsv1nvw0pwx)ex!P1n!P!Q*V!Q!_1n!_!a*V!a#s1n#s$f*V$f;'S1n;'S;=`3P<%l?Ah1n?Ah?BY*V?BY?Mn1n?MnO*V!U3SP;=`<%l1n!V3bcfS^P!a`!cpOq&Xqr3Vrs&}sv3Vvw0pwx(tx!P3V!P!Q&X!Q!^3V!^!_1n!_!a&X!a#s3V#s$f&X$f;'S3V;'S;=`4m<%l?Ah3V?Ah?BY&X?BY?Mn3V?MnO&X!V4pP;=`<%l3V!_4vP;=`<%l-_!Z5SV!`h^P!cpOv&}wx'kx!^&}!^!_(V!_;'S&};'S;=`(n<%lO&}!_5rjfSiWa!ROX7dXZ8qZ[7d[^8q^p7dqr:crs8qst@Ttw:cwx8qx!P:c!P!Q7d!Q!]:c!]!^/^!^!_=p!_!a8q!a#S:c#S#T=p#T#s:c#s$f7d$f;'S:c;'S;=`?}<%l?Ah:c?Ah?BY7d?BY?Mn:c?MnO7d!Z7ibiWOX7dXZ8qZ[7d[^8q^p7dqr7drs8qst+Ptw7dwx8qx!]7d!]!^9f!^!a8q!a#S7d#S#T8q#T;'S7d;'S;=`:]<%lO7d!R8tVOp8qqs8qt!]8q!]!^9Z!^;'S8q;'S;=`9`<%lO8q!R9`O_!R!R9cP;=`<%l8q!Z9mYiW_!ROX+PZ[+P^p+Pqr+Psw+Px!^+P!a#S+P#T;'S+P;'S;=`+t<%lO+P!Z:`P;=`<%l7d!_:jjfSiWOX7dXZ8qZ[7d[^8q^p7dqr:crs8qst/^tw:cwx8qx!P:c!P!Q7d!Q!]:c!]!^<[!^!_=p!_!a8q!a#S:c#S#T=p#T#s:c#s$f7d$f;'S:c;'S;=`?}<%l?Ah:c?Ah?BY7d?BY?Mn:c?MnO7d!_<ecfSiW_!ROX+PZ[+P^p+Pqr/^sw/^x!P/^!P!Q+P!Q!^/^!^!_0p!a#S/^#S#T0p#T#s/^#s$f+P$f;'S/^;'S;=`1h<%l?Ah/^?Ah?BY+P?BY?Mn/^?MnO+P!V=udfSOp8qqr=prs8qst0ptw=pwx8qx!P=p!P!Q8q!Q!]=p!]!^?T!^!_=p!_!a8q!a#s=p#s$f8q$f;'S=p;'S;=`?w<%l?Ah=p?Ah?BY8q?BY?Mn=p?MnO8q!V?[XfS_!Rqr0psw0px!P0p!Q!_0p!a#s0p$f;'S0p;'S;=`1b<%l?Ah0p?BY?Mn0p!V?zP;=`<%l=p!_@QP;=`<%l:c!_@[ifSiWOXAyXZCTZ[Ay[^CT^pAyqrDrrsCTswDrwxCTx!PDr!P!QAy!Q!]Dr!]!^/^!^!_G|!_!aCT!a#SDr#S#TG|#T#sDr#s$fAy$f;'SDr;'S;=`JW<%l?AhDr?Ah?BYAy?BY?MnDr?MnOAy!ZBOaiWOXAyXZCTZ[Ay[^CT^pAyqrAyrsCTswAywxCTx!]Ay!]!^Cu!^!aCT!a#SAy#S#TCT#T;'SAy;'S;=`Dl<%lOAy!RCWUOpCTq!]CT!]!^Cj!^;'SCT;'S;=`Co<%lOCT!RCoO`!R!RCrP;=`<%lCT!ZC|YiW`!ROX+PZ[+P^p+Pqr+Psw+Px!^+P!a#S+P#T;'S+P;'S;=`+t<%lO+P!ZDoP;=`<%lAy!_DyifSiWOXAyXZCTZ[Ay[^CT^pAyqrDrrsCTswDrwxCTx!PDr!P!QAy!Q!]Dr!]!^Fh!^!_G|!_!aCT!a#SDr#S#TG|#T#sDr#s$fAy$f;'SDr;'S;=`JW<%l?AhDr?Ah?BYAy?BY?MnDr?MnOAy!_FqcfSiW`!ROX+PZ[+P^p+Pqr/^sw/^x!P/^!P!Q+P!Q!^/^!^!_0p!a#S/^#S#T0p#T#s/^#s$f+P$f;'S/^;'S;=`1h<%l?Ah/^?Ah?BY+P?BY?Mn/^?MnO+P!VHRcfSOpCTqrG|rsCTswG|wxCTx!PG|!P!QCT!Q!]G|!]!^I^!^!_G|!_!aCT!a#sG|#s$fCT$f;'SG|;'S;=`JQ<%l?AhG|?Ah?BYCT?BY?MnG|?MnOCT!VIeXfS`!Rqr0psw0px!P0p!Q!_0p!a#s0p$f;'S0p;'S;=`1b<%l?Ah0p?BY?Mn0p!VJTP;=`<%lG|!_JZP;=`<%lDr!ZJgW!bx^P!a`Or(trs'ksv(tw!^(t!^!_)e!_;'S(t;'S;=`*P<%lO(t!aK^lfS^PiW!a`!cpOX$qXZ&XZ[$q[^&X^p$qpq&Xqr-_rs&}sv-_vw/^wx(tx}-_}!OMU!O!P-_!P!Q$q!Q!^-_!^!_1n!_!a&X!a#S-_#S#T3V#T#s-_#s$f$q$f;'S-_;'S;=`4s<%l?Ah-_?Ah?BY$q?BY?Mn-_?MnO$q!aMckfS^PiW!a`!cpOX$qXZ&XZ[$q[^&X^p$qpq&Xqr-_rs&}sv-_vw/^wx(tx!P-_!P!Q$q!Q!^-_!^!_1n!_!`&X!`!a! W!a#S-_#S#T3V#T#s-_#s$f$q$f;'S-_;'S;=`4s<%l?Ah-_?Ah?BY$q?BY?Mn-_?MnO$q!T! cX^P!a`!cp!eQOr&Xrs&}sv&Xwx(tx!^&X!^!_*V!_;'S&X;'S;=`*y<%lO&X!a!!Zd^PiW!a`!cpOX$qXZ&XZ[$q[^&X^p$qpq&Xqr$qrs&}sv$qvw+Pwx(tx!^$q!^!_*V!_!`&X!`!a!#i!a#S$q#S#T&X#T;'S$q;'S;=`+z<%lO$q!X!#vX^P!a`!cpvSjUOr&Xrs&}sv&Xwx(tx!^&X!^!_*V!_;'S&X;'S;=`*y<%lO&X!a!$r!ZfSdQ^PiW!a`!cpOX$qXZ&XZ[$q[^&X^p$qpq&Xqr-_rs&}sv-_vw/^wx(tx}-_}!O!$c!O!P!$c!P!Q$q!Q![!$c![!]!$c!]!^-_!^!_1n!_!a&X!a!c-_!c!}!$c!}#R-_#R#S!$c#S#T3V#T#o!$c#o#s-_#s$f$q$f$}-_$}%O!$c%O%W-_%W%o!$c%o%p-_%p&a!$c&a&b-_&b1p!$c1p4U!$c4U4d!$c4d4e-_4e$IS!$c$IS$I`-_$I`$Ib!$c$Ib$Je-_$Je$Jg!$c$Jg$Kh-_$Kh%#t!$c%#t&/x-_&/x&Et!$c&Et&FV-_&FV;'S!$c;'S;:j!(e;:j;=`4s<%l?&r-_?&r?Ah!$c?Ah?BY$q?BY?Mn!$c?MnO$q!a!(hP;=`<%l!$c!V!(tcfS!a`!cpOq*Vqr!*Prs(Vsv1nvw0pwx)ex!P1n!P!Q*V!Q!_1n!_!a*V!a!b!H^!b#s1n#s$f*V$f;'S1n;'S;=`3P<%l?Ah1n?Ah?BY*V?BY?Mn1n?MnO*V!V!*YhfS!a`!cpOq*Vqr1nrs(Vsv1nvw0pwx)ex}1n}!O!+t!O!P1n!P!Q*V!Q!_1n!_!a*V!a!f1n!f!g!.p!g#W1n#W#X!?^#X#s1n#s$f*V$f;'S1n;'S;=`3P<%l?Ah1n?Ah?BY*V?BY?Mn1n?MnO*V!V!+}dfS!a`!cpOq*Vqr1nrs(Vsv1nvw0pwx)ex}1n}!O!-]!O!P1n!P!Q*V!Q!_1n!_!a*V!a#s1n#s$f*V$f;'S1n;'S;=`3P<%l?Ah1n?Ah?BY*V?BY?Mn1n?MnO*V!V!-hbfS!a`!cp!dPOq*Vqr1nrs(Vsv1nvw0pwx)ex!P1n!P!Q*V!Q!_1n!_!a*V!a#s1n#s$f*V$f;'S1n;'S;=`3P<%l?Ah1n?Ah?BY*V?BY?Mn1n?MnO*V!V!.ydfS!a`!cpOq*Vqr1nrs(Vsv1nvw0pwx)ex!P1n!P!Q*V!Q!_1n!_!a*V!a!q1n!q!r!0X!r#s1n#s$f*V$f;'S1n;'S;=`3P<%l?Ah1n?Ah?BY*V?BY?Mn1n?MnO*V!V!0bdfS!a`!cpOq*Vqr1nrs(Vsv1nvw0pwx)ex!P1n!P!Q*V!Q!_1n!_!a*V!a!e1n!e!f!1p!f#s1n#s$f*V$f;'S1n;'S;=`3P<%l?Ah1n?Ah?BY*V?BY?Mn1n?MnO*V!V!1ydfS!a`!cpOq*Vqr1nrs(Vsv1nvw0pwx)ex!P1n!P!Q*V!Q!_1n!_!a*V!a!v1n!v!w!3X!w#s1n#s$f*V$f;'S1n;'S;=`3P<%l?Ah1n?Ah?BY*V?BY?Mn1n?MnO*V!V!3bdfS!a`!cpOq*Vqr1nrs(Vsv1nvw0pwx)ex!P1n!P!Q*V!Q!_1n!_!a*V!a!{1n!{!|!4p!|#s1n#s$f*V$f;'S1n;'S;=`3P<%l?Ah1n?Ah?BY*V?BY?Mn1n?MnO*V!V!4ydfS!a`!cpOq*Vqr1nrs(Vsv1nvw0pwx)ex!P1n!P!Q*V!Q!_1n!_!a*V!a!r1n!r!s!6X!s#s1n#s$f*V$f;'S1n;'S;=`3P<%l?Ah1n?Ah?BY*V?BY?Mn1n?MnO*V!V!6bdfS!a`!cpOq*Vqr1nrs(Vsv1nvw0pwx)ex!P1n!P!Q*V!Q!_1n!_!a*V!a!g1n!g!h!7p!h#s1n#s$f*V$f;'S1n;'S;=`3P<%l?Ah1n?Ah?BY*V?BY?Mn1n?MnO*V!V!7ycfS!a`!cpOq!9Uqr!7prs!9{sv!7pvw!=swx!;ox!P!7p!P!Q!9U!Q!_!7p!_!`!9U!`!a!<}!a#s!7p#s$f!9U$f;'S!7p;'S;=`!?W<%l?Ah!7p?Ah?BY!9U?BY?Mn!7p?MnO!9U!R!9]Y!a`!cpOr!9Urs!9{sv!9Uvw!:gwx!;ox!`!9U!`!a!<}!a;'S!9U;'S;=`!=m<%lO!9Uq!:QV!cpOv!9{vx!:gx!`!9{!`!a!;U!a;'S!9{;'S;=`!;i<%lO!9{P!:jTO!`!:g!`!a!:y!a;'S!:g;'S;=`!;O<%lO!:gP!;OO{PP!;RP;=`<%l!:gq!;]S!cp{POv(Vx;'S(V;'S;=`(h<%lO(Vq!;lP;=`<%l!9{a!;tX!a`Or!;ors!:gsv!;ovw!:gw!`!;o!`!a!<a!a;'S!;o;'S;=`!<w<%lO!;oa!<hT!a`{POr)esv)ew;'S)e;'S;=`)y<%lO)ea!<zP;=`<%l!;o!R!=WV!a`!cp{POr*Vrs(Vsv*Vwx)ex;'S*V;'S;=`*s<%lO*V!R!=pP;=`<%l!9UT!=xbfSOq!:gqr!=srs!:gsw!=swx!:gx!P!=s!P!Q!:g!Q!_!=s!_!`!:g!`!a!:y!a#s!=s#s$f!:g$f;'S!=s;'S;=`!?Q<%l?Ah!=s?Ah?BY!:g?BY?Mn!=s?MnO!:gT!?TP;=`<%l!=s!V!?ZP;=`<%l!7p!V!?gdfS!a`!cpOq*Vqr1nrs(Vsv1nvw0pwx)ex!P1n!P!Q*V!Q!_1n!_!a*V!a#c1n#c#d!@u#d#s1n#s$f*V$f;'S1n;'S;=`3P<%l?Ah1n?Ah?BY*V?BY?Mn1n?MnO*V!V!AOdfS!a`!cpOq*Vqr1nrs(Vsv1nvw0pwx)ex!P1n!P!Q*V!Q!_1n!_!a*V!a#V1n#V#W!B^#W#s1n#s$f*V$f;'S1n;'S;=`3P<%l?Ah1n?Ah?BY*V?BY?Mn1n?MnO*V!V!BgdfS!a`!cpOq*Vqr1nrs(Vsv1nvw0pwx)ex!P1n!P!Q*V!Q!_1n!_!a*V!a#h1n#h#i!Cu#i#s1n#s$f*V$f;'S1n;'S;=`3P<%l?Ah1n?Ah?BY*V?BY?Mn1n?MnO*V!V!DOdfS!a`!cpOq*Vqr1nrs(Vsv1nvw0pwx)ex!P1n!P!Q*V!Q!_1n!_!a*V!a#m1n#m#n!E^#n#s1n#s$f*V$f;'S1n;'S;=`3P<%l?Ah1n?Ah?BY*V?BY?Mn1n?MnO*V!V!EgdfS!a`!cpOq*Vqr1nrs(Vsv1nvw0pwx)ex!P1n!P!Q*V!Q!_1n!_!a*V!a#d1n#d#e!Fu#e#s1n#s$f*V$f;'S1n;'S;=`3P<%l?Ah1n?Ah?BY*V?BY?Mn1n?MnO*V!V!GOdfS!a`!cpOq*Vqr1nrs(Vsv1nvw0pwx)ex!P1n!P!Q*V!Q!_1n!_!a*V!a#X1n#X#Y!7p#Y#s1n#s$f*V$f;'S1n;'S;=`3P<%l?Ah1n?Ah?BY*V?BY?Mn1n?MnO*V!V!HgcfS!a`!cpOq!Irqr!H^rs!Jisv!H^vw#!vwx!MZx!P!H^!P!Q!Ir!Q!_!H^!_!a!Ir!a!b#%h!b#s!H^#s$f!Ir$f;'S!H^;'S;=`#&|<%l?Ah!H^?Ah?BY!Ir?BY?Mn!H^?MnO!Ir!R!IyY!a`!cpOr!Irrs!Jisv!Irvw!KTwx!MZx!a!Ir!a!b# Z!b;'S!Ir;'S;=`#!p<%lO!Irq!JnV!cpOv!Jivx!KTx!a!Ji!a!b!LU!b;'S!Ji;'S;=`!MT<%lO!JiP!KWTO!a!KT!a!b!Kg!b;'S!KT;'S;=`!LO<%lO!KTP!KjTO!`!KT!`!a!Ky!a;'S!KT;'S;=`!LO<%lO!KTP!LOOxPP!LRP;=`<%l!KTq!LZV!cpOv!Jivx!KTx!`!Ji!`!a!Lp!a;'S!Ji;'S;=`!MT<%lO!Jiq!LwS!cpxPOv(Vx;'S(V;'S;=`(h<%lO(Vq!MWP;=`<%l!Jia!M`X!a`Or!MZrs!KTsv!MZvw!KTw!a!MZ!a!b!M{!b;'S!MZ;'S;=`# T<%lO!MZa!NQX!a`Or!MZrs!KTsv!MZvw!KTw!`!MZ!`!a!Nm!a;'S!MZ;'S;=`# T<%lO!MZa!NtT!a`xPOr)esv)ew;'S)e;'S;=`)y<%lO)ea# WP;=`<%l!MZ!R# bY!a`!cpOr!Irrs!Jisv!Irvw!KTwx!MZx!`!Ir!`!a#!Q!a;'S!Ir;'S;=`#!p<%lO!Ir!R#!ZV!a`!cpxPOr*Vrs(Vsv*Vwx)ex;'S*V;'S;=`*s<%lO*V!R#!sP;=`<%l!IrT#!{bfSOq!KTqr#!vrs!KTsw#!vwx!KTx!P#!v!P!Q!KT!Q!_#!v!_!a!KT!a!b#$T!b#s#!v#s$f!KT$f;'S#!v;'S;=`#%b<%l?Ah#!v?Ah?BY!KT?BY?Mn#!v?MnO!KTT#$YbfSOq!KTqr#!vrs!KTsw#!vwx!KTx!P#!v!P!Q!KT!Q!_#!v!_!`!KT!`!a!Ky!a#s#!v#s$f!KT$f;'S#!v;'S;=`#%b<%l?Ah#!v?Ah?BY!KT?BY?Mn#!v?MnO!KTT#%eP;=`<%l#!v!V#%qcfS!a`!cpOq!Irqr!H^rs!Jisv!H^vw#!vwx!MZx!P!H^!P!Q!Ir!Q!_!H^!_!`!Ir!`!a#!Q!a#s!H^#s$f!Ir$f;'S!H^;'S;=`#&|<%l?Ah!H^?Ah?BY!Ir?BY?Mn!H^?MnO!Ir!V#'PP;=`<%l!H^!V#'_XgS^P!a`!cpOr&Xrs&}sv&Xwx(tx!^&X!^!_*V!_;'S&X;'S;=`*y<%lO&X!X#(VX^P!a`!cpjUOr&Xrs&}sv&Xwx(tx!^&X!^!_*V!_;'S&X;'S;=`*y<%lO&X",
  tokenizers: [H6, K6, J6, G6, F6, 0, 1, 2, 3, 4, 5],
  topRules: { Document: [0, 13] },
  dialects: { noMatch: 0, selfClosing: 485 },
  tokenPrec: 487
});
function OO(r, e) {
  let t = /* @__PURE__ */ Object.create(null);
  for (let l of r.getChildren(hO)) {
    let i = l.getChild(V6), o = l.getChild(Yc) || l.getChild(pO);
    i && (t[e.read(i.from, i.to)] = o ? o.type.id == Yc ? e.read(o.from + 1, o.to - 1) : e.read(o.from, o.to) : "");
  }
  return t;
}
function Nu(r, e) {
  let t = r.getChild(E6);
  return t ? e.read(t.from, t.to) : " ";
}
function ya(r, e, t) {
  let l;
  for (let i of t)
    if (!i.attrs || i.attrs(l || (l = OO(r.node.parent.firstChild, e))))
      return { parser: i.parser };
  return null;
}
function vO(r = [], e = []) {
  let t = [], l = [], i = [], o = [];
  for (let s of r)
    (s.tag == "script" ? t : s.tag == "style" ? l : s.tag == "textarea" ? i : o).push(s);
  let n = e.length ? /* @__PURE__ */ Object.create(null) : null;
  for (let s of e)
    (n[s.name] || (n[s.name] = [])).push(s);
  return Vk((s, a) => {
    let c = s.type.id;
    if (c == Z6)
      return ya(s, a, t);
    if (c == R6)
      return ya(s, a, l);
    if (c == D6)
      return ya(s, a, i);
    if (c == uO && o.length) {
      let d = s.node, h = Nu(d, a), p;
      for (let u of o)
        if (u.tag == h && (!u.attrs || u.attrs(p || (p = OO(d, a))))) {
          let f = d.parent.lastChild;
          return { parser: u.parser, overlay: [{ from: s.to, to: f.type.id == W6 ? f.from : d.parent.to }] };
        }
    }
    if (n && c == hO) {
      let d = s.node, h;
      if (h = d.firstChild) {
        let p = n[a.read(h.from, h.to)];
        if (p)
          for (let u of p) {
            if (u.tagName && u.tagName != Nu(d.parent, a))
              continue;
            let f = d.lastChild;
            if (f.type.id == Yc)
              return { parser: u.parser, overlay: [{ from: f.from + 1, to: f.to - 1 }] };
            if (f.type.id == pO)
              return { parser: u.parser, overlay: [{ from: f.from, to: f.to }] };
          }
      }
    }
    return null;
  });
}
const Mu = 301, Yu = 1, rQ = 2, ju = 302, lQ = 304, iQ = 305, oQ = 3, nQ = 4, sQ = [
  9,
  10,
  11,
  12,
  13,
  32,
  133,
  160,
  5760,
  8192,
  8193,
  8194,
  8195,
  8196,
  8197,
  8198,
  8199,
  8200,
  8201,
  8202,
  8232,
  8233,
  8239,
  8287,
  12288
], xO = 125, aQ = 59, Iu = 47, cQ = 42, dQ = 43, hQ = 45, pQ = new lO({
  start: !1,
  shift(r, e) {
    return e == oQ || e == nQ || e == lQ ? r : e == iQ;
  },
  strict: !1
}), uQ = new Or((r, e) => {
  let { next: t } = r;
  (t == xO || t == -1 || e.context) && e.canShift(ju) && r.acceptToken(ju);
}, { contextual: !0, fallback: !0 }), fQ = new Or((r, e) => {
  let { next: t } = r, l;
  sQ.indexOf(t) > -1 || t == Iu && ((l = r.peek(1)) == Iu || l == cQ) || t != xO && t != aQ && t != -1 && !e.context && e.canShift(Mu) && r.acceptToken(Mu);
}, { contextual: !0 }), gQ = new Or((r, e) => {
  let { next: t } = r;
  if ((t == dQ || t == hQ) && (r.advance(), t == r.next)) {
    r.advance();
    let l = !e.context && e.canShift(Yu);
    r.acceptToken(l ? Yu : rQ);
  }
}, { contextual: !0 }), mQ = Cs({
  "get set async static": v.modifier,
  "for while do if else switch try catch finally return throw break continue default case": v.controlKeyword,
  "in of await yield void typeof delete instanceof": v.operatorKeyword,
  "let var const function class extends": v.definitionKeyword,
  "import export from": v.moduleKeyword,
  "with debugger as new": v.keyword,
  TemplateString: v.special(v.string),
  super: v.atom,
  BooleanLiteral: v.bool,
  this: v.self,
  null: v.null,
  Star: v.modifier,
  VariableName: v.variableName,
  "CallExpression/VariableName TaggedTemplateExpression/VariableName": v.function(v.variableName),
  VariableDefinition: v.definition(v.variableName),
  Label: v.labelName,
  PropertyName: v.propertyName,
  PrivatePropertyName: v.special(v.propertyName),
  "CallExpression/MemberExpression/PropertyName": v.function(v.propertyName),
  "FunctionDeclaration/VariableDefinition": v.function(v.definition(v.variableName)),
  "ClassDeclaration/VariableDefinition": v.definition(v.className),
  PropertyDefinition: v.definition(v.propertyName),
  PrivatePropertyDefinition: v.definition(v.special(v.propertyName)),
  UpdateOp: v.updateOperator,
  LineComment: v.lineComment,
  BlockComment: v.blockComment,
  Number: v.number,
  String: v.string,
  Escape: v.escape,
  ArithOp: v.arithmeticOperator,
  LogicOp: v.logicOperator,
  BitOp: v.bitwiseOperator,
  CompareOp: v.compareOperator,
  RegExp: v.regexp,
  Equals: v.definitionOperator,
  Arrow: v.function(v.punctuation),
  ": Spread": v.punctuation,
  "( )": v.paren,
  "[ ]": v.squareBracket,
  "{ }": v.brace,
  "InterpolationStart InterpolationEnd": v.special(v.brace),
  ".": v.derefOperator,
  ", ;": v.separator,
  "@": v.meta,
  TypeName: v.typeName,
  TypeDefinition: v.definition(v.typeName),
  "type enum interface implements namespace module declare": v.definitionKeyword,
  "abstract global Privacy readonly override": v.modifier,
  "is keyof unique infer": v.operatorKeyword,
  JSXAttributeValue: v.attributeValue,
  JSXText: v.content,
  "JSXStartTag JSXStartCloseTag JSXSelfCloseEndTag JSXEndTag": v.angleBracket,
  "JSXIdentifier JSXNameSpacedName": v.tagName,
  "JSXAttribute/JSXIdentifier JSXAttribute/JSXNameSpacedName": v.attributeName,
  "JSXBuiltin/JSXIdentifier": v.standard(v.tagName)
}), bQ = { __proto__: null, export: 14, as: 19, from: 27, default: 30, async: 35, function: 36, extends: 46, this: 50, true: 58, false: 58, null: 70, void: 74, typeof: 78, super: 96, new: 130, delete: 146, yield: 155, await: 159, class: 164, public: 219, private: 219, protected: 219, readonly: 221, instanceof: 240, satisfies: 243, in: 244, const: 246, import: 278, keyof: 333, unique: 337, infer: 343, is: 379, abstract: 399, implements: 401, type: 403, let: 406, var: 408, interface: 415, enum: 419, namespace: 425, module: 427, declare: 431, global: 435, for: 456, of: 465, while: 468, with: 472, do: 476, if: 480, else: 482, switch: 486, case: 492, try: 498, catch: 502, finally: 506, return: 510, throw: 514, break: 518, continue: 522, debugger: 526 }, OQ = { __proto__: null, async: 117, get: 119, set: 121, public: 181, private: 181, protected: 181, static: 183, abstract: 185, override: 187, readonly: 193, accessor: 195, new: 383 }, vQ = { __proto__: null, "<": 137 }, xQ = ri.deserialize({
  version: 14,
  states: "$BhO`QUOOO%QQUOOO'TQWOOP(_OSOOO*mQ(CjO'#CfO*tOpO'#CgO+SO!bO'#CgO+bO07`O'#DZO-sQUO'#DaO.TQUO'#DlO%QQUO'#DvO0[QUO'#EOOOQ(CY'#EW'#EWO0rQSO'#ETOOQO'#I_'#I_O0zQSO'#GjOOQO'#Eh'#EhO1VQSO'#EgO1[QSO'#EgO3^Q(CjO'#JbO5}Q(CjO'#JcO6kQSO'#FVO6pQ#tO'#FnOOQ(CY'#F_'#F_O6{O&jO'#F_O7ZQ,UO'#FuO8qQSO'#FtOOQ(CY'#Jc'#JcOOQ(CW'#Jb'#JbOOQQ'#J|'#J|O8vQSO'#IOO8{Q(C[O'#IPOOQQ'#JO'#JOOOQQ'#IT'#ITQ`QUOOO%QQUO'#DnO9TQUO'#DzO%QQUO'#D|O9[QSO'#GjO9aQ,UO'#ClO9oQSO'#EfO9zQSO'#EqO:PQ,UO'#F^O:nQSO'#GjO:sQSO'#GnO;OQSO'#GnO;^QSO'#GqO;^QSO'#GrO;^QSO'#GtO9[QSO'#GwO;}QSO'#GzO=`QSO'#CbO=pQSO'#HXO=xQSO'#H_O=xQSO'#HaO`QUO'#HcO=xQSO'#HeO=xQSO'#HhO=}QSO'#HnO>SQ(C]O'#HtO%QQUO'#HvO>_Q(C]O'#HxO>jQ(C]O'#HzO8{Q(C[O'#H|O>uQ(CjO'#CfO?wQWO'#DfQOQSOOO@_QSO'#EPO9aQ,UO'#EfO@jQSO'#EfO@uQ`O'#F^OOQQ'#Cd'#CdOOQ(CW'#Dk'#DkOOQ(CW'#Jf'#JfO%QQUO'#JfOBOQWO'#E_OOQ(CW'#E^'#E^OBYQ(C`O'#E_OBtQWO'#ESOOQO'#Ji'#JiOCYQWO'#ESOCgQWO'#E_OC}QWO'#EeODQQWO'#E_O@}QWO'#E_OBtQWO'#E_PDkO?MpO'#C`POOO)CDm)CDmOOOO'#IU'#IUODvOpO,59ROOQ(CY,59R,59ROOOO'#IV'#IVOEUO!bO,59RO%QQUO'#D]OOOO'#IX'#IXOEdO07`O,59uOOQ(CY,59u,59uOErQUO'#IYOFVQSO'#JdOHXQbO'#JdO+pQUO'#JdOH`QSO,59{OHvQSO'#EhOITQSO'#JqOI`QSO'#JpOI`QSO'#JpOIhQSO,5;UOImQSO'#JoOOQ(CY,5:W,5:WOItQUO,5:WOKuQ(CjO,5:bOLfQSO,5:jOLkQSO'#JmOMeQ(C[O'#JnO:sQSO'#JmOMlQSO'#JmOMtQSO,5;TOMyQSO'#JmOOQ(CY'#Cf'#CfO%QQUO'#EOONmQ`O,5:oOOQO'#Jj'#JjOOQO-E<]-E<]O9[QSO,5=UO! TQSO,5=UO! YQUO,5;RO!#]Q,UO'#EcO!$pQSO,5;RO!&YQ,UO'#DpO!&aQUO'#DuO!&kQWO,5;[O!&sQWO,5;[O%QQUO,5;[OOQQ'#E}'#E}OOQQ'#FP'#FPO%QQUO,5;]O%QQUO,5;]O%QQUO,5;]O%QQUO,5;]O%QQUO,5;]O%QQUO,5;]O%QQUO,5;]O%QQUO,5;]O%QQUO,5;]O%QQUO,5;]O%QQUO,5;]OOQQ'#FT'#FTO!'RQUO,5;nOOQ(CY,5;s,5;sOOQ(CY,5;t,5;tO!)UQSO,5;tOOQ(CY,5;u,5;uO%QQUO'#IeO!)^Q(C[O,5<bO!#]Q,UO,5;]O!){Q,UO,5;]O%QQUO,5;qO!*SQ#tO'#FdO!+PQ#tO'#JuO!*kQ#tO'#JuO!+WQ#tO'#JuOOQO'#Ju'#JuO!+lQ#tO,5;|OOOO,5<Y,5<YO!+}QUO'#FpOOOO'#Id'#IdO6{O&jO,5;yO!,UQ#tO'#FrOOQ(CY,5;y,5;yO!,uQ7[O'#CrOOQ(CY'#Cv'#CvO!-YQSO'#CvO!-_O07`O'#CzO!-{Q,UO,5<_O!.SQSO,5<aO!/iQMhO'#GPO!/vQSO'#GQO!/{QSO'#GQO!0QQMhO'#GUO!1PQWO'#GYO!1rQ7[O'#J]OOQ(CY'#J]'#J]O!1|QSO'#J[O!2[QSO'#JZO!2dQSO'#CqOOQ(CY'#Ct'#CtOOQ(CY'#DO'#DOOOQ(CY'#DQ'#DQO0uQSO'#DSO!$uQ,UO'#FwO!$uQ,UO'#FyO!2lQSO'#F{O!2qQSO'#F|O!/{QSO'#GSO!$uQ,UO'#GXO!2vQSO'#EiO!3bQSO,5<`O`QUO,5>jOOQQ'#JW'#JWOOQQ,5>k,5>kOOQQ-E<R-E<RO!5aQ(CjO,5:YO!7}Q(CjO,5:fO%QQUO,5:fO!:hQ(CjO,5:hOOQ(CW'#Co'#CoO!;XQ,UO,5=UO!;gQ(C[O'#JXO8qQSO'#JXO=}QSO,59WO!;xQWO,59WO!<QQ,UO,59WO9aQ,UO,59WO!<]QSO,5;RO!<eQSO'#HWO!<vQSO'#KQO%QQUO,5;vO!=OQWO,5;xO!=TQSO,5=qO!=YQSO,5=qO!=_QSO,5=qO8{Q(C[O,5=qO!=mQSO'#EjO!>gQWO'#EkOOQ(CW'#Jo'#JoO!>nQ(C[O'#J}O8{Q(C[O,5=YO;^QSO,5=`OOQO'#Cr'#CrO!>yQWO,5=]O!?RQ,UO,5=^O!?^QSO,5=`O!?cQ`O,5=cO=}QSO'#G|O9[QSO'#HOO!?kQSO'#HOO9aQ,UO'#HRO!?pQSO'#HROOQQ,5=f,5=fO!?uQSO'#HSO!?}QSO'#ClO!@SQSO,58|O!@^QSO,58|O!BfQUO,58|OOQQ,58|,58|O!BsQ(C[O,58|O%QQUO,58|O!COQUO'#HZOOQQ'#H['#H[OOQQ'#H]'#H]O`QUO,5=sO!C`QSO,5=sO`QUO,5=yO`QUO,5={O!CeQSO,5=}O`QUO,5>PO!CjQSO,5>SO!CoQUO,5>YOOQQ,5>`,5>`O%QQUO,5>`O8{Q(C[O,5>bOOQQ,5>d,5>dO!GvQSO,5>dOOQQ,5>f,5>fO!GvQSO,5>fOOQQ,5>h,5>hO!G{QWO'#DXO%QQUO'#JfO!HjQWO'#JfO!IXQWO'#DgO!IjQWO'#DgO!K{QUO'#DgO!LSQSO'#JeO!L[QSO,5:QO!LaQSO'#ElO!LoQSO'#JrO!LwQSO,5;VO!L|QWO'#DgO!MZQWO'#EROOQ(CY,5:k,5:kO%QQUO,5:kO!MbQSO,5:kO=}QSO,5;QO!;xQWO,5;QO!<QQ,UO,5;QO9aQ,UO,5;QO!MjQSO,5@QO!MoQ!LQO,5:oO!NrQ(C`O,5:yOBtQWO,5:nO# ^QWO,5:nO# kQWO,5:yO#!RQWO,5:yO#!lQWO,5:yOBtQWO,5:yO=}QSO,5:nOOQ(CW'#Eb'#EbOOQO,5:y,5:yO%QQUO,5:yO##]Q(C[O,5:yO##hQ(C[O,5:yO!;xQWO,5:nOOQO,5;P,5;PO##vQ(C[O,5:yPOOO'#IS'#ISP#$[O?MpO,58zPOOO,58z,58zOOOO-E<S-E<SOOQ(CY1G.m1G.mOOOO-E<T-E<TO#$gQ`O,59wOOOO-E<V-E<VOOQ(CY1G/a1G/aO#$lQbO,5>tO+pQUO,5>tOOQO,5>z,5>zO#$vQUO'#IYOOQO-E<W-E<WO#%TQSO,5@OO#%]QbO,5@OO#%dQSO,5@[OOQ(CY1G/g1G/gO%QQUO,5@]O#%lQSO'#I`OOQO-E<^-E<^O#%dQSO,5@[OOQ(CW1G0p1G0pOOQ(CY1G/r1G/rOOQ(CY1G0U1G0UO#&QQSO,5@XO:sQSO,5@XO#&YQSO,5@XO%QQUO,5@YO#&hQ(C[O,5@YO#&yQ(C[O,5@YO#'QQSO'#IbO#&QQSO,5@XOOQ(CW1G0o1G0oO!&kQWO,5:qO!&vQWO,5:qOOQO,5:s,5:sO#'oQSO,5:sO#'wQ,UO1G2pO9[QSO1G2pOOQ(CY1G0m1G0mO#(VQ(CjO1G0mO#)[Q(ChO,5:}OOQ(CY'#GO'#GOO#)xQ(CjO'#J]O! YQUO1G0mO#,QQ,UO'#JgO#,[QSO,5:[O#,aQbO'#JhO%QQUO'#JhO#,kQSO,5:aOOQ(CY'#DX'#DXOOQ(CY1G0v1G0vO%QQUO1G0vOOQ(CY1G1`1G1`O#,pQSO1G0vO#/XQ(CjO1G0wO#/`Q(CjO1G0wO#1yQ(CjO1G0wO#2QQ(CjO1G0wO#4[Q(CjO1G0wO#4rQ(CjO1G0wO#7lQ(CjO1G0wO#7sQ(CjO1G0wO#:^Q(CjO1G0wO#:eQ(CjO1G0wO#<]Q(CjO1G0wO#?]Q$IUO'#CfO#AZQ$IUO1G1YO#CXQ$IUO'#JcO!)XQSO1G1`O#ClQ(CjO,5?POOQ(CW-E<c-E<cO#D`Q(CjO1G0wOOQ(CY1G0w1G0wO#FkQ(CjO1G1]O#G_Q#tO,5<QO#GgQ#tO,5<RO#GoQ#tO'#FiO#HWQSO'#FhOOQO'#Jv'#JvOOQO'#Ic'#IcO#H]Q#tO1G1hOOQ(CY1G1h1G1hOOOO1G1s1G1sO#HnQ$IUO'#JbO#HxQSO,5<[O!'RQUO,5<[OOOO-E<b-E<bOOQ(CY1G1e1G1eO#H}QWO'#JuOOQ(CY,5<^,5<^O#IVQWO,5<^OOQ(CY,59b,59bO!#]Q,UO'#C|OOOO'#IW'#IWO#I[O07`O,59fOOQ(CY,59f,59fO%QQUO1G1yO!2qQSO'#IgO#IgQSO,5<rOOQ(CY,5<o,5<oOOQO'#Ge'#GeO!$uQ,UO,5=OOOQO'#Gg'#GgO!$uQ,UO,5=QO!#]Q,UO,5=SOOQO1G1{1G1{O#IuQ`O'#CoO#JYQ`O,5<kO#JaQSO'#JyO9[QSO'#JyO#JoQSO,5<mO!$uQ,UO,5<lO#JtQSO'#GRO#KPQSO,5<lO#KUQ`O'#GOO#KcQ`O'#JzO#KmQSO'#JzO!#]Q,UO'#JzO#KrQSO,5<pO#KwQWO'#GZO!0zQWO'#GZO#LYQSO'#G]O#L_QSO'#G_O!/{QSO'#GbO#LdQ(C[O'#IiO#LoQWO,5<tOOQ(CY,5<t,5<tO#LvQWO'#GZO#MUQWO'#G[O#M^QWO'#G[OOQ(CY,5=T,5=TO!$uQ,UO,5?vO!$uQ,UO,5?vO#McQSO'#IjO#MnQSO,5?uO#MvQSO,59]O#NgQ,UO,59nOOQ(CY,59n,59nO$ YQ,UO,5<cO$ {Q,UO,5<eO?oQSO,5<gOOQ(CY,5<h,5<hO$!VQSO,5<nO$![Q,UO,5<sO! YQUO1G1zO$!lQSO1G1zOOQQ1G4U1G4UOOQ(CY1G/t1G/tO!)UQSO1G/tO$$kQ(CjO1G0QOOQQ1G2p1G2pO!#]Q,UO1G2pO%QQUO1G2pO$%[QSO1G2pO$%gQ,UO'#EcOOQ(CW,5?s,5?sO$%qQ(C[O,5?sOOQQ1G.r1G.rO=}QSO1G.rO!;xQWO1G.rO!<QQ,UO1G.rO$&SQSO1G0mO$&XQSO'#CfO$&dQSO'#KRO$&lQSO,5=rO$&qQSO'#KRO$&vQSO'#KRO$'RQSO'#IrO$'aQSO,5@lO$'iQbO1G1bOOQ(CY1G1d1G1dO9[QSO1G3]O?oQSO1G3]O$'pQSO1G3]O$'uQSO1G3]OOQQ1G3]1G3]O:sQSO'#JpO:sQSO'#ElO%QQUO'#ElO:sQSO'#IlO$'zQ(C[O,5@iOOQQ1G2t1G2tO!?^QSO1G2zO!#]Q,UO1G2wO$(VQSO1G2wOOQQ1G2x1G2xO!#]Q,UO1G2xO$([QSO1G2xO$(dQWO'#GvOOQQ1G2z1G2zO!0zQWO'#InO!?cQ`O1G2}OOQQ1G2}1G2}OOQQ,5=h,5=hO$(lQ,UO,5=jO9[QSO,5=jO#L_QSO,5=mO8qQSO,5=mO!;xQWO,5=mO!<QQ,UO,5=mO9aQ,UO,5=mO$(zQSO'#KPO$)VQSO,5=nOOQQ1G.h1G.hO$)[Q(C[O1G.hO?oQSO1G.hO$)gQSO1G.hO8{Q(C[O1G.hO$)rQbO,5@nO$*VQSO,5@nO$*bQUO,5=uO$*iQSO,5=uO:sQSO,5@nOOQQ1G3_1G3_O`QUO1G3_OOQQ1G3e1G3eOOQQ1G3g1G3gO=xQSO1G3iO$*nQUO1G3kO$.oQUO'#HjOOQQ1G3n1G3nO$.|QSO'#HpO=}QSO'#HrOOQQ1G3t1G3tO$/UQUO1G3tO8{Q(C[O1G3zOOQQ1G3|1G3|OOQ(CW'#GV'#GVO8{Q(C[O1G4OO8{Q(C[O1G4QO$3YQSO,5@QO!'RQUO,5;WO:sQSO,5;WO=}QSO,5:RO!'RQUO,5:RO!;xQWO,5:RO$3_Q$IUO,5:ROOQO,5;W,5;WO$3iQWO'#IZO$4PQSO,5@POOQ(CY1G/l1G/lO$4XQWO'#IaO$4cQSO,5@^OOQ(CW1G0q1G0qO!IjQWO,5:ROOQO'#I^'#I^O$4kQWO,5:mOOQ(CY,5:m,5:mO!MeQSO1G0VOOQ(CY1G0V1G0VO%QQUO1G0VOOQ(CY1G0l1G0lO=}QSO1G0lO!;xQWO1G0lO!<QQ,UO1G0lOOQ(CW1G5l1G5lO=}QSO1G0YOOQO1G0e1G0eO%QQUO1G0eO$4rQ(C[O1G0eO$4}Q(C[O1G0eO!;xQWO1G0YOBtQWO1G0YO$5]Q(C`O1G0eO$5wQWO1G0YOBtQWO1G0eO$6UQWO1G0eO$6lQWO1G0eO$7VQ(C[O1G0eOOQO1G0Y1G0YO$7kQ(CjO1G0ePOOO-E<Q-E<QPOOO1G.f1G.fOOOO1G/c1G/cO$7uQ`O,5<bO$7}QbO1G4`OOQO1G4f1G4fO%QQUO,5>tO$8XQSO1G5jO$8aQSO1G5vO$8iQbO1G5wO:sQSO,5>zO$8sQSO1G5sO$8sQSO1G5sO:sQSO1G5sO$8{Q(CjO1G5tO%QQUO1G5tO$9]Q(C[O1G5tO$9nQSO,5>|O:sQSO,5>|OOQO,5>|,5>|O$:SQSO,5>|OOQO-E<`-E<`OOQO1G0]1G0]OOQO1G0_1G0_O!)XQSO1G0_OOQQ7+([7+([O!#]Q,UO7+([O%QQUO7+([O$:bQSO7+([O$:mQ,UO7+([O$:{Q(CjO,59nO$=TQ(CjO,5<cO$?`Q(CjO,5<eO$AkQ(CjO,5<sOOQ(CY7+&X7+&XO$C|Q(CjO7+&XO$DpQ,UO'#I[O$DzQSO,5@ROOQ(CY1G/v1G/vO$ESQUO'#I]O$EaQSO,5@SO$EiQbO,5@SOOQ(CY1G/{1G/{O$EsQSO7+&bOOQ(CY7+&b7+&bO$ExQ$IUO,5:bO%QQUO7+&tO$FSQ$IUO,5:YO$FaQ$IUO,5:fO$FkQ$IUO,5:hOOQ(CY7+&z7+&zOOQO1G1l1G1lOOQO1G1m1G1mO$FuQ#tO,5<TO!'RQUO,5<SOOQO-E<a-E<aOOQ(CY7+'S7+'SOOOO7+'_7+'_OOOO1G1v1G1vO$GQQSO1G1vOOQ(CY1G1x1G1xO$GVQ`O,59hOOOO-E<U-E<UOOQ(CY1G/Q1G/QO$G^Q(CjO7+'eOOQ(CY,5?R,5?RO$HQQSO,5?ROOQ(CY1G2^1G2^P$HVQSO'#IgPOQ(CY-E<e-E<eO$HyQ,UO1G2jO$IlQ,UO1G2lO$IvQ`O1G2nOOQ(CY1G2V1G2VO$I}QSO'#IfO$J]QSO,5@eO$J]QSO,5@eO$JeQSO,5@eO$JpQSO,5@eOOQO1G2X1G2XO$KOQ,UO1G2WO!$uQ,UO1G2WO$K`QMhO'#IhO$KpQSO,5@fO!#]Q,UO,5@fO$KxQ`O,5@fOOQ(CY1G2[1G2[OOQ(CW,5<u,5<uOOQ(CW,5<v,5<vO$LSQSO,5<vOBoQSO,5<vO!;xQWO,5<uOOQO'#G^'#G^O$LXQSO,5<wOOQ(CW,5<y,5<yO$LSQSO,5<|OOQO,5?T,5?TOOQO-E<g-E<gOOQ(CY1G2`1G2`O!0zQWO,5<uO$LaQSO,5<vO#LYQSO,5<wO!0zQWO,5<vO$LlQ,UO1G5bO$LvQ,UO1G5bOOQO,5?U,5?UOOQO-E<h-E<hOOQO1G.w1G.wO!=OQWO,59pO%QQUO,59pO$MTQSO1G2RO!$uQ,UO1G2YO$MYQ(CjO7+'fOOQ(CY7+'f7+'fO! YQUO7+'fOOQ(CY7+%`7+%`O$M|Q`O'#J{O!MeQSO7+([O$NWQbO7+([O$:eQSO7+([O$N_Q(ChO'#CfO$NrQ(ChO,5<zO% dQSO,5<zOOQ(CW1G5_1G5_OOQQ7+$^7+$^O=}QSO7+$^O!;xQWO7+$^O! YQUO7+&XO% iQSO'#IqO% }QSO,5@mOOQO1G3^1G3^O9[QSO,5@mO% }QSO,5@mO%!VQSO,5@mOOQO,5?^,5?^OOQO-E<p-E<pOOQ(CY7+&|7+&|O%![QSO7+(wO8{Q(C[O7+(wO9[QSO7+(wO?oQSO7+(wO%!aQSO,5;WOOQ(CW,5?W,5?WOOQ(CW-E<j-E<jOOQQ7+(f7+(fO%!fQ(ChO7+(cO!#]Q,UO7+(cO%!pQ`O7+(dOOQQ7+(d7+(dO!#]Q,UO7+(dO%!wQSO'#KOO%#SQSO,5=bOOQO,5?Y,5?YOOQO-E<l-E<lOOQQ7+(i7+(iO%$`QWO'#HPOOQQ1G3U1G3UO!#]Q,UO1G3UO%QQUO1G3UO%$gQSO1G3UO%$rQ,UO1G3UO8{Q(C[O1G3XO#L_QSO1G3XO8qQSO1G3XO!;xQWO1G3XO!<QQ,UO1G3XO%%QQSO'#IpO%%]QSO,5@kO%%eQWO,5@kOOQ(CW1G3Y1G3YOOQQ7+$S7+$SO?oQSO7+$SO8{Q(C[O7+$SO%%pQSO7+$SO%QQUO1G6YO%QQUO1G6ZO%%uQUO1G3aO%%|QSO1G3aO%&RQUO1G3aO%&YQ(C[O1G6YOOQQ7+(y7+(yO8{Q(C[O7+)TO`QUO7+)VOOQQ'#KU'#KUOOQQ'#Is'#IsO%&dQUO,5>UOOQQ,5>U,5>UO%QQUO'#HkO%&qQSO'#HmOOQQ,5>[,5>[O:sQSO,5>[OOQQ,5>^,5>^OOQQ7+)`7+)`OOQQ7+)f7+)fOOQQ7+)j7+)jOOQQ7+)l7+)lO%&vQWO1G5lO%'[Q$IUO1G0rO%'fQSO1G0rOOQO1G/m1G/mO%'qQ$IUO1G/mO=}QSO1G/mO!'RQUO'#DgOOQO,5>u,5>uOOQO-E<X-E<XOOQO,5>{,5>{OOQO-E<_-E<_O!;xQWO1G/mOOQO-E<[-E<[OOQ(CY1G0X1G0XOOQ(CY7+%q7+%qO!MeQSO7+%qOOQ(CY7+&W7+&WO=}QSO7+&WO!;xQWO7+&WOOQO7+%t7+%tO$7kQ(CjO7+&POOQO7+&P7+&PO%QQUO7+&PO%'{Q(C[O7+&PO=}QSO7+%tO!;xQWO7+%tO%(WQ(C[O7+&POBtQWO7+%tO%(fQ(C[O7+&PO%(zQ(C`O7+&PO%)UQWO7+%tOBtQWO7+&PO%)cQWO7+&PO%)yQSO7++_O%)yQSO7++_O%*RQ(CjO7++`O%QQUO7++`OOQO1G4h1G4hO:sQSO1G4hO%*cQSO1G4hOOQO7+%y7+%yO!MeQSO<<KvO$NWQbO<<KvO%*qQSO<<KvOOQQ<<Kv<<KvO!#]Q,UO<<KvO%QQUO<<KvO%*yQSO<<KvO%+UQ(CjO1G2jO%-aQ(CjO1G2lO%/lQ(CjO1G2WO%1}Q,UO,5>vOOQO-E<Y-E<YO%2XQbO,5>wO%QQUO,5>wOOQO-E<Z-E<ZO%2cQSO1G5nOOQ(CY<<I|<<I|O%2kQ$IUO1G0mO%4uQ$IUO1G0wO%4|Q$IUO1G0wO%7QQ$IUO1G0wO%7XQ$IUO1G0wO%8|Q$IUO1G0wO%9dQ$IUO1G0wO%;wQ$IUO1G0wO%<OQ$IUO1G0wO%>SQ$IUO1G0wO%>ZQ$IUO1G0wO%@RQ$IUO1G0wO%@fQ(CjO<<J`O%AkQ$IUO1G0wO%CaQ$IUO'#J]O%EdQ$IUO1G1]O%EqQ$IUO1G0QO!'RQUO'#FkOOQO'#Jw'#JwOOQO1G1o1G1oO%E{QSO1G1nO%FQQ$IUO,5?POOOO7+'b7+'bOOOO1G/S1G/SOOQ(CY1G4m1G4mO!$uQ,UO7+(YO%F[QSO,5?QO9[QSO,5?QOOQO-E<d-E<dO%FjQSO1G6PO%FjQSO1G6PO%FrQSO1G6PO%F}Q,UO7+'rO%G_Q`O,5?SO%GiQSO,5?SO!#]Q,UO,5?SOOQO-E<f-E<fO%GnQ`O1G6QO%GxQSO1G6QOOQ(CW1G2b1G2bO$LSQSO1G2bOOQ(CW1G2a1G2aO%HQQSO1G2cO!#]Q,UO1G2cOOQ(CW1G2h1G2hO!;xQWO1G2aOBoQSO1G2bO%HVQSO1G2cO%H_QSO1G2bO!$uQ,UO7+*|OOQ(CY1G/[1G/[O%HjQSO1G/[OOQ(CY7+'m7+'mO%HoQ,UO7+'tO%IPQ(CjO<<KQOOQ(CY<<KQ<<KQO!#]Q,UO'#IkO%IsQSO,5@gO!#]Q,UO1G2fOOQQ<<Gx<<GxO=}QSO<<GxO%I{Q(CjO<<IsOOQ(CY<<Is<<IsOOQO,5?],5?]O%JoQSO,5?]O$&vQSO,5?]OOQO-E<o-E<oO%JtQSO1G6XO%JtQSO1G6XO9[QSO1G6XO?oQSO<<LcOOQQ<<Lc<<LcO%J|QSO<<LcO8{Q(C[O<<LcO%KRQSO1G0rOOQQ<<K}<<K}O%!fQ(ChO<<K}OOQQ<<LO<<LOO%!pQ`O<<LOO%KWQWO'#ImO%KcQSO,5@jO!'RQUO,5@jOOQQ1G2|1G2|O%KkQ(C`O'#JfO%LVQUO'#JfO%L^QWO'#E_O%LwQ(C[O'#E_OBYQ(C`O'#E_O(VQWO'#HQOOQO'#Io'#IoO8{Q(C[O'#IoO%M]QWO,5=kOOQQ,5=k,5=kO%MuQWO'#E_O%LmQWO'#E_O%M|QWO'#E_O%NgQWO'#E_O& WQWO'#HQO& iQSO7+(pO& nQSO7+(pOOQQ7+(p7+(pO!#]Q,UO7+(pO%QQUO7+(pO& vQSO7+(pOOQQ7+(s7+(sO8{Q(C[O7+(sO#L_QSO7+(sO8qQSO7+(sO!;xQWO7+(sO&!RQSO,5?[OOQO-E<n-E<nOOQO'#HT'#HTO&!^QSO1G6VO8{Q(C[O<<GnOOQQ<<Gn<<GnO?oQSO<<GnO&!fQSO7++tO&!kQSO7++uOOQQ7+({7+({O&!pQSO7+({O&!uQUO7+({O&!|QSO7+({O%QQUO7++tO%QQUO7++uOOQQ<<Lo<<LoOOQQ<<Lq<<LqOOQQ-E<q-E<qOOQQ1G3p1G3pO&#RQSO,5>VOOQQ,5>X,5>XO&#WQSO1G3vO:sQSO7+&^O!'RQUO7+&^OOQO7+%X7+%XO&#]Q$IUO1G5wO=}QSO7+%XOOQ(CY<<I]<<I]OOQ(CY<<Ir<<IrO=}QSO<<IrOOQO<<Ik<<IkO$7kQ(CjO<<IkO%QQUO<<IkOOQO<<I`<<I`O=}QSO<<I`O&#gQ(C[O<<IkO!;xQWO<<I`O&#rQ(C[O<<IkOBtQWO<<I`O&$QQ(C[O<<IkO&$fQ(C`O<<IkO&$pQWO<<I`OBtQWO<<IkO&$}QSO<<NyO&%VQ(CjO<<NzOOQO7+*S7+*SO:sQSO7+*SOOQQANAbANAbO&%gQSOANAbO!#]Q,UOANAbO!MeQSOANAbO$NWQbOANAbO%QQUOANAbO&%oQ(CjO7+'rO&(QQ(CjO7+'tO&*cQbO1G4cO&*mQ$IUO7+&XO&*zQ$IUO,59nO&,}Q$IUO,5<cO&/QQ$IUO,5<eO&1TQ$IUO,5<sO&2yQ$IUO7+'eO&3WQ$IUO7+'fO&3eQSO,5<VOOQO7+'Y7+'YO&3jQ,UO<<KtOOQO1G4l1G4lO&3qQSO1G4lO&3|QSO1G4lO&4[QSO7++kO&4[QSO7++kO!#]Q,UO1G4nO&4dQ`O1G4nO&4nQSO7++lOOQ(CW7+'|7+'|O$LSQSO7+'}O&4vQ`O7+'}OOQ(CW7+'{7+'{O$LSQSO7+'|O&4}QSO7+'}O!#]Q,UO7+'}OBoQSO7+'|O&5SQ,UO<<NhOOQ(CY7+$v7+$vO&5^Q`O,5?VOOQO-E<i-E<iO&5hQ(ChO7+(QOOQQAN=dAN=dO9[QSO1G4wOOQO1G4w1G4wO&5xQSO1G4wO&5}QSO7++sO&5}QSO7++sO8{Q(C[OANA}O?oQSOANA}OOQQANA}ANA}OOQQANAiANAiOOQQANAjANAjO&6VQSO,5?XOOQO-E<k-E<kO&6bQ$IUO1G6UO#L_QSO,5=lO8qQSO,5=lO&8rQbO'#CfO&8|QWO,5:yO&9WQWO,5:yO&9eQWO,5:yO!;xQWO,5=lOOQO,5?Z,5?ZOOQO-E<m-E<mOOQQ1G3V1G3VO%LVQUO,5<wO%KkQ(C`O,5=lO!NrQ(C`O,5:yO(VQWO,5=lO&9xQWO,5=lO&:ZQWO,5:yOOQQ<<L[<<L[O!#]Q,UO<<L[O& iQSO<<L[O&:tQSO<<L[O%QQUO<<L[OOQQ<<L_<<L_O8{Q(C[O<<L_O#L_QSO<<L_O8qQSO<<L_O&:|QWO1G4vO&;XQSO7++qOOQQAN=YAN=YO8{Q(C[OAN=YOOQQ<= `<= `OOQQ<= a<= aOOQQ<<Lg<<LgO&;aQSO<<LgO&;fQUO<<LgO&;mQSO<= `O&;rQSO<= aOOQQ1G3q1G3qO=}QSO7+)bO&;wQSO<<IxO&<SQ$IUO<<IxOOQO<<Hs<<HsOOQ(CYAN?^AN?^OOQOAN?VAN?VO$7kQ(CjOAN?VOOQOAN>zAN>zO%QQUOAN?VO=}QSOAN>zO&<^Q(C[OAN?VO!;xQWOAN>zO&<iQ(C[OAN?VOBtQWOAN>zO&<wQ(C[OAN?VOOQO<<Mn<<MnOOQQG26|G26|O!#]Q,UOG26|O!MeQSOG26|O&=]QSOG26|O$NWQbOG26|O&=eQ$IUO<<J`O&=rQ$IUO1G2WO&?hQ$IUO1G2jO&AkQ$IUO1G2lO&CnQ$IUO<<KQO&C{Q$IUO<<IsOOQO1G1q1G1qO!$uQ,UOANA`OOQO7+*W7+*WO&DYQSO7+*WO&DeQSO<= VO&DmQ`O7+*YOOQ(CW<<Ki<<KiO$LSQSO<<KiOOQ(CW<<Kh<<KhO&DwQ`O<<KiO$LSQSO<<KhOOQO7+*c7+*cO9[QSO7+*cO&EOQSO<= _OOQQG27iG27iO8{Q(C[OG27iO!'RQUO1G4sO&EWQSO7++pO8{Q(C[O1G3WO#L_QSO1G3WO&E`QWO1G0eO&EjQWO1G0eO8qQSO1G3WO!;xQWO1G3WO(VQWO1G3WO%KkQ(C`O1G3WO$5]Q(C`O1G0eO&EwQWO1G3WO& iQSOANAvOOQQANAvANAvO!#]Q,UOANAvO&FYQSOANAvOOQQANAyANAyO8{Q(C[OANAyO#L_QSOANAyOOQO'#HU'#HUOOQO7+*b7+*bOOQQG22tG22tOOQQANBRANBRO&FbQSOANBROOQQANDzANDzOOQQAND{AND{OOQQ<<L|<<L|O!'RQUOAN?dOOQOG24qG24qO$7kQ(CjOG24qOOQOG24fG24fO%QQUOG24qO=}QSOG24fO&FgQ(C[OG24qO!;xQWOG24fO&FrQ(C[OG24qO!MeQSOLD,hOOQQLD,hLD,hO!#]Q,UOLD,hO&GQQSOLD,hO&GYQ$IUO7+'rO&IOQ$IUO7+'tO&JtQ,UOG26zOOQO<<Mr<<MrOOQ(CWANATANATO$LSQSOANATOOQ(CWANASANASOOQO<<M}<<M}OOQQLD-TLD-TO&KUQ$IUO7+*_OOQO7+(r7+(rO8{Q(C[O7+(rO&K`QWO7+&PO#L_QSO7+(rO8qQSO7+(rO!;xQWO7+(rO(VQWO7+(rOOQQG27bG27bO& iQSOG27bO!#]Q,UOG27bOOQQG27eG27eO8{Q(C[OG27eOOQQG27mG27mO&KjQ$IUOG25OOOQOLD*]LD*]O$7kQ(CjOLD*]OOQOLD*QLD*QO%QQUOLD*]O=}QSOLD*QO&KtQ(C[OLD*]OOQQ!$(!S!$(!SO!MeQSO!$(!SO!#]Q,UO!$(!SO&LPQ(CjOG26zOOQ(CWG26oG26oOOQO<<L^<<L^O8{Q(C[O<<L^O#L_QSO<<L^O8qQSO<<L^O!;xQWO<<L^OOQQLD,|LD,|O& iQSOLD,|OOQQLD-PLD-POOQO!$'Mw!$'MwO$7kQ(CjO!$'MwOOQO!$'Ml!$'MlO%QQUO!$'MwOOQQ!)9En!)9EnO!MeQSO!)9EnOOQOANAxANAxO8{Q(C[OANAxO#L_QSOANAxO8qQSOANAxOOQQ!$(!h!$(!hOOQO!)9Cc!)9CcO$7kQ(CjO!)9CcOOQQ!.K;Y!.K;YO&NbQ$IUOG26zOOQOG27dG27dO8{Q(C[OG27dO#L_QSOG27dOOQO!.K8}!.K8}OOQOLD-OLD-OO8{Q(C[OLD-OOOQO!$(!j!$(!jO!'RQUO'#DvO0rQSO'#ETO'!WQbO'#JbO!'RQUO'#DnO'!_QUO'#DzO!'RQUO'#D|O'!fQbO'#CfO'$|QbO'#CfO'%^QUO,5;RO!'RQUO,5;]O!'RQUO,5;]O!'RQUO,5;]O!'RQUO,5;]O!'RQUO,5;]O!'RQUO,5;]O!'RQUO,5;]O!'RQUO,5;]O!'RQUO,5;]O!'RQUO,5;]O!'RQUO,5;]O!'RQUO'#IeO''aQSO,5<bO''iQ,UO,5;]O'(|Q,UO,5;]O!'RQUO,5;qO0uQSO'#DSO0uQSO'#DSO!#]Q,UO'#FwO''iQ,UO'#FwO!#]Q,UO'#FyO''iQ,UO'#FyO!#]Q,UO'#GXO''iQ,UO'#GXO!'RQUO,5:fO!'RQUO,5@]O'%^QUO1G0mO')TQ$IUO'#CfO!'RQUO1G1yO!#]Q,UO,5=OO''iQ,UO,5=OO!#]Q,UO,5=QO''iQ,UO,5=QO!#]Q,UO,5<lO''iQ,UO,5<lO'%^QUO1G1zO!'RQUO7+&tO!#]Q,UO1G2WO''iQ,UO1G2WO!#]Q,UO1G2YO''iQ,UO1G2YO'%^QUO7+'fO'%^QUO7+&XO!#]Q,UOANA`O''iQ,UOANA`O')_QSO'#EgO')dQSO'#EgO')lQSO'#FVO')qQSO'#EqO')vQSO'#JqO'*RQSO'#JoO'*^QSO,5;RO'*cQ,UO,5<_O'*jQSO'#GQO'*oQSO'#GQO'*tQSO,5<`O'*|QSO,5;RO'+UQ$IUO1G1YO'+]QSO,5<lO'+bQSO,5<lO'+gQSO,5<nO'+lQSO,5<nO'+qQSO1G1zO'+vQSO1G0mO'+{Q,UO<<KtO',SQ,UO<<KtO7ZQ,UO'#FuO8qQSO'#FtO@jQSO'#EfO!'RQUO,5;nO!/{QSO'#GQO!/{QSO'#GQO!/{QSO'#GSO!/{QSO'#GSO!$uQ,UO7+(YO!$uQ,UO7+(YO$IvQ`O1G2nO$IvQ`O1G2nO!#]Q,UO,5=SO!#]Q,UO,5=S",
  stateData: "'-[~O'lOS'mOSROS'nRQ~OPYOQYOV!TO^pOaxObwOikOkYOlkOmkOskOuYOwYO|WO!QkO!RkO!XXO!csO!hZO!kYO!lYO!mYO!otO!quO!tvO!x]O#o}O$PzO$TfO%_{O%a!OO%c|O%d|O%g!PO%i!QO%l!RO%m!RO%o!SO%|!UO&S!VO&U!WO&W!XO&Y!YO&]!ZO&c![O&i!]O&k!^O&m!_O&o!`O&q!aO'sSO'uTO'xUO(QVO(_[O(liO~OPYOQYOa!gOb!fOikOkYOlkOmkOskOuYOwYO|WO!QkO!RkO!X!cO!csO!hZO!kYO!lYO!mYO!otO!quO!t!eO$P!hO$TfO's!bO'uTO'xUO(QVO(_[O(liO~O^!qOl!kO|!lO![!rO!]!pO!^!pO!x;oO!|!vO!}!tO#O!uO#P!sO#S!wO#T!wO't!iO'uTO'xUO(T!jO(_!nO~O'n!xO~OPYXXYX^YXkYXyYXzYX|YX!VYX!eYX!fYX!hYX!lYX#WYX#ccX#fYX#gYX#hYX#iYX#jYX#kYX#lYX#mYX#nYX#pYX#rYX#tYX#uYX#zYX'jYX(QYX(`YX(gYX(hYX~O!a$yX~P(dO[!zO'u!|O'v!zO'w!|O~O[!}O'w!|O'x!|O'y!}O~Oq#PO!O#QO(R#QO(S#SO~OPYOQYOa!gOb!fOikOkYOlkOmkOskOuYOwYO|WO!QkO!RkO!X!cO!csO!hZO!kYO!lYO!mYO!otO!quO!t!eO$P!hO$TfO's;tO'uTO'xUO(QVO(_[O(liO~O!U#WO!V#TO!S(WP!S(dP~P+pO!W#`O~P`OPYOQYOa!gOb!fOikOkYOlkOmkOskOuYOwYO|WO!QkO!RkO!X!cO!csO!hZO!kYO!lYO!mYO!otO!quO!t!eO$P!hO$TfO'uTO'xUO(QVO(_[O(liO~O!U#fO!x]O#a#iO#b#fO's;uO!g(aP~P.[O!h#kO's#jO~O!t#oO!x]O%_#pO~O#c#qO~O!a#rO#c#qO~OP$YOX$aOk#}Oy#vOz#wO|#xO!V$^O!e$PO!f#tO!h#uO!l$YO#f#{O#g#|O#h#|O#i#|O#j$OO#k$PO#l$PO#m$`O#n$PO#p$QO#r$SO#t$UO#u$VO(QVO(`$WO(g#yO(h#zO~O^(UX'j(UX'h(UX!g(UX!S(UX!X(UX%`(UX!a(UX~P1dO#W$bO#z$bOP(VXX(VXk(VXy(VXz(VX|(VX!V(VX!e(VX!h(VX!l(VX#f(VX#g(VX#h(VX#i(VX#j(VX#k(VX#l(VX#m(VX#n(VX#p(VX#r(VX#t(VX#u(VX(Q(VX(`(VX(g(VX(h(VX!X(VX%`(VX~O^(VX!f(VX'j(VX'h(VX!S(VX!g(VXo(VX!a(VX~P3zO#W$bO~O$V$dO$X$cO$`$iO~O!X$jO$TfO$c$kO$e$mO~Oi%POk$qOl$pOm$pOs%QOu%ROw%SO|$xO!X$yO!c%XO!h$uO#b%YO$P%VO$l%TO$n%UO$q%WO's$oO'uTO'xUO'|%OO(Q$rOd'}P~O!h%ZO~O!a%]O~O^%^O'j%^O~O't!iO~P%QO's%eO~O!h%ZO's%eO't!iO'|%OO~Ob%lO!h%ZO's%eO~O#n$PO~Oy%qO!X%nO!h%pO%a%tO's%eO't!iO'uTO'xUO](tP~O!t#oO~O|%vO!X%wO's%eO~O|%vO!X%wO%i%{O's%eO~O's%|O~O#o}O%a!OO%c|O%d|O%g!PO%i!QO%l!RO%m!RO~Oa&VOb&UO!t&SO%_&TO%q&RO~P;cOa&YObwO!X&XO!tvO!x]O#o}O%_{O%c|O%d|O%g!PO%i!QO%l!RO%m!RO%o!SO~O_&]O#W&`O%a&ZO't!iO~P<bO!h&aO!q&eO~O!h#kO~O!XXO~O^%^O'i&mO'j%^O~O^%^O'i&pO'j%^O~O^%^O'i&rO'j%^O~O'hYX!SYXoYX!gYX&QYX!XYX%`YX!aYX~P(dO!['PO!]&xO!^&xO't!iO'uTO'xUO~Ol&vO|&uO!U&yO(T&tO!W(XP!W(fP~P?cOg'SO!X'QO's%eO~Ob'XO!h%ZO's%eO~Oy%qO!h%pO~Ol!kO|!lO!['^O!]']O!^']O!}'`O#O'`O#P'_O#S'bO#T'bO't!iO'uTO'xUO(T!jO(_!nO~O!x;oO!|'aO~P@}O^%^O!a#rO!h%ZO!l'hO#W'fO'j%^O'|%OO(`'dO~Ol!kO|!lO'uTO'xUO(T!jO(_!nO~O!]']O!^']O't!iO~PBtO!['^O!]']O!^']O#S'bO#T'bO't!iO~PBtO!XXO!['^O!]']O!^']O#P'_O#S'bO#T'bO't!iO~PBtO'o'lO'p'lO'q'nO~O[!zO'u'pO'v!zO'w'pO~O[!}O'w'pO'x'pO'y!}O~Oq#PO!O#QO(R#QO(S'tO~O!U'vO!S&|X!S'SX!V&|X!V'SX~P+pO!V'xO!S(WX~OP$YOX$aOk#}Oy#vOz#wO|#xO!V'xO!e$PO!f#tO!h#uO!l$YO#f#{O#g#|O#h#|O#i#|O#j$OO#k$PO#l$PO#m$`O#n$PO#p$QO#r$SO#t$UO#u$VO(QVO(`$WO(g#yO(h#zO~O!S(WX~PF_O!S'}O~O!S(cX!V(cX!a(cX!g(cX(`(cX~O#W(cX#c#[X!W(cX~PHeO#W(OO!S(eX!V(eX~O!V(PO!S(dX~O!S(SO~O#W$bO~PHeO!W(TO~P`Oy#vOz#wO|#xO!f#tO!h#uO(QVOP!jaX!jak!ja!V!ja!e!ja!l!ja#f!ja#g!ja#h!ja#i!ja#j!ja#k!ja#l!ja#m!ja#n!ja#p!ja#r!ja#t!ja#u!ja(`!ja(g!ja(h!ja~O^!ja'j!ja'h!ja!S!ja!g!jao!ja!X!ja%`!ja!a!ja~PI{O!g(UO~O|%vO!X%wO!x]O#a(XO#b(WO's%eO~O!a#rO#W(YO(`'dO!V(bX^(bX'j(bX~O!g(bX~PMPO!V(]O!g(aX~O!g(_O~O|%vO!X%wO#b(WO's%eO~Oy(`Oz(aO!f#tO!h#uO!x!wa|!wa~O!t!wa%_!wa!X!wa#a!wa#b!wa's!wa~PNXO!t(eO~OPYOQYOa!gOb!fOikOkYOlkOmkOskOuYOwYO|WO!QkO!RkO!XXO!csO!hZO!kYO!lYO!mYO!otO!quO!t!eO$P!hO$TfO's!bO'uTO'xUO(QVO(_[O(liO~Oi%POk$qOl$pOm$pOs%QOu%ROw<XO|$xO!X$yO!c=cO!h$uO#b<_O$P%VO$l<ZO$n<]O$q%WO's(iO'uTO'xUO'|%OO(Q$rO~O#c(kO~Oi%POk$qOl$pOm$pOs%QOu%ROw%SO|$xO!X$yO!c%XO!h$uO#b%YO$P%VO$l%TO$n%UO$q%WO's(iO'uTO'xUO'|%OO(Q$rO~Od(ZP~P!$uO!U(oO!g([P~P%QO(T(qO(_[O~O|(sO!h#uO(T(qO(_[O~OP;nOQ;nOa=_Ob!fOikOk;nOlkOmkOskOu;nOw;nO|WO!QkO!RkO!X!cO!c;qO!hZO!k;nO!l;nO!m;nO!o;rO!q;sO!t!eO$P!hO$TfO's)RO'uTO'xUO(QVO(_[O(l=]O~Oz)UO!h#uO~O!V$^O^$ja'j$ja'h$ja!g$ja!S$ja!X$ja%`$ja!a$ja~O#o)YO~P!#]Oy)]O!a)[O!X$WX$S$WX$V$WX$X$WX$`$WX~O!a)[O!X(iX$S(iX$V(iX$X(iX$`(iX~Oy)]O~P!*kOy)]O!X(iX$S(iX$V(iX$X(iX$`(iX~O!X)_O$S)cO$V)^O$X)^O$`)dO~O!U)gO~P!'RO$V$dO$X$cO$`)kO~Og$rXy$rX|$rX!f$rX(g$rX(h$rX~OdfXd$rXgfX!VfX#WfX~P!,aOl)mO~Oq)nO(R)oO(S)qO~Og)zOy)sO|)tO(g)vO(h)xO~Od)rO~P!-jOd){O~Oi%POk$qOl$pOm$pOs%QOu%ROw<XO|$xO!X$yO!c=cO!h$uO#b<_O$P%VO$l<ZO$n<]O$q%WO'uTO'xUO'|%OO(Q$rO~O!U*PO's)|O!g(mP~P!.XO#c*RO~O!h*SO~O!U*XO's*UO!S(nP~P!.XOk*eO|*]O![*cO!]*[O!^*[O!h*SO#S*dO%V*_O't!iO(T!jO~O!W*bO~P!0_O!f#tOg(PXy(PX|(PX(g(PX(h(PX!V(PX#W(PX~Od(PX#x(PX~P!1WOg*hO#W*gOd(OX!V(OX~O!V*iOd'}X~O's%|Od'}P~O!h*pO~O's(iO~O|%vO!U#fO!X%wO!x]O#a#iO#b#fO's%eO!g(aP~O!a#rO#c*tO~OP$YOX$aOk#}Oy#vOz#wO|#xO!e$PO!f#tO!h#uO!l$YO#f#{O#g#|O#h#|O#i#|O#j$OO#k$PO#l$PO#m$`O#n$PO#p$QO#r$SO#t$UO#u$VO(QVO(`$WO(g#yO(h#zO~O^!ba!V!ba'j!ba'h!ba!S!ba!g!bao!ba!X!ba%`!ba!a!ba~P!3jOy#vOz#wO|#xO!f#tO!h#uO(QVOP!naX!nak!na!V!na!e!na!l!na#f!na#g!na#h!na#i!na#j!na#k!na#l!na#m!na#n!na#p!na#r!na#t!na#u!na(`!na(g!na(h!na~O^!na'j!na'h!na!S!na!g!nao!na!X!na%`!na!a!na~P!6TOy#vOz#wO|#xO!f#tO!h#uO(QVOP!paX!pak!pa!V!pa!e!pa!l!pa#f!pa#g!pa#h!pa#i!pa#j!pa#k!pa#l!pa#m!pa#n!pa#p!pa#r!pa#t!pa#u!pa(`!pa(g!pa(h!pa~O^!pa'j!pa'h!pa!S!pa!g!pao!pa!X!pa%`!pa!a!pa~P!8nOg*|O!X'QO%`*{O'|%OO~O!a+OO!X'{X^'{X!V'{X'j'{X~O!h%ZO'|%OO~O!h%ZO's%eO'|%OO~O!a#rO#c(kO~O%a+[O's+WO'uTO'xUO!W(uP~O!V+]O](tX~O(T(qO~OX+aO~O]+bO~O!X%nO's%eO't!iO](tP~O|%vO!U+fO!V(PO!X%wO's%eO!S(dP~Ol&|O|+hO!U+gO'uTO'xUO(T(qO~O!W(fP~P!>RO!V+iO^(qX'j(qX~O#W+mO'|%OO~Og+pO!X$yO'|%OO~O!X+rO~Oy+tO!XXO~O!t+yO~Ob,OO~O's#jO!W(sP~Ob%lO~O%a!OO's%|O~P<bOX,UO],TO~OPYOQYOaxObwOikOkYOlkOmkOskOuYOwYO|WO!QkO!RkO!csO!hZO!kYO!lYO!mYO!otO!quO!tvO!x]O$TfO%_{O'uTO'xUO(QVO(_[O(liO~O!X!cO$P!hO's!bO~P!@fO],TO^%^O'j%^O~O^,YO#o,[O%c,[O%d,[O~P%QO!h&aO~O&S,aO~O!X,cO~O&e,eO&g,fOP&baQ&baV&ba^&baa&bab&bai&bak&bal&bam&bas&bau&baw&ba|&ba!Q&ba!R&ba!X&ba!c&ba!h&ba!k&ba!l&ba!m&ba!o&ba!q&ba!t&ba!x&ba#o&ba$P&ba$T&ba%_&ba%a&ba%c&ba%d&ba%g&ba%i&ba%l&ba%m&ba%o&ba%|&ba&S&ba&U&ba&W&ba&Y&ba&]&ba&c&ba&i&ba&k&ba&m&ba&o&ba&q&ba'h&ba's&ba'u&ba'x&ba(Q&ba(_&ba(l&ba!W&ba&Z&ba_&ba&`&ba~O's,kO~O!V{X!V!_X!W{X!W!_X!a{X!a!_X!h!_X#W{X'|!_X~O!a,pO#W,oO!V#`X!V(YX!W#`X!W(YX!a(YX!h(YX'|(YX~O!a,rO!h%ZO'|%OO!V!ZX!W!ZX~Ol!kO|!lO'uTO'xUO(T!jO~OP;nOQ;nOa=_Ob!fOikOk;nOlkOmkOskOu;nOw;nO|WO!QkO!RkO!X!cO!c;qO!hZO!k;nO!l;nO!m;nO!o;rO!q;sO!t!eO$P!hO$TfO'uTO'xUO(QVO(_[O(l=]O~O's<dO~P!I{O!V,vO!W(XX~O!W,xO~O!a,pO#W,oO!V#`X!W#`X~O!V,yO!W(fX~O!W,{O~O!],|O!^,|O't!iO~P!IjO!W-PO~P'TOg-SO!X'QO~O!S-XO~Ol!wa![!wa!]!wa!^!wa!|!wa!}!wa#O!wa#P!wa#S!wa#T!wa't!wa'u!wa'x!wa(T!wa(_!wa~PNXO^%^O!a#rO!h%ZO!l-^O#W-[O'j%^O'|%OO(`'dO~O!]-`O!^-`O't!iO~PBtO![-bO!]-`O!^-`O#S-cO#T-cO't!iO~PBtO![-bO!]-`O!^-`O#P-dO#S-cO#T-cO't!iO~PBtO![-bO!]-`O!^-`O!}-eO#O-eO#P-dO#S-cO#T-cO't!iO~PBtO^%^O#W-[O'j%^O~O^%^O!a#rO#W-[O'j%^O~O^%^O!a#rO!l-^O#W-[O'j%^O(`'dO~O'o'lO'p'lO'q-jO~Oo-kO~O!S&|a!V&|a~P!3jO!U-oO!S&|X!V&|X~P%QO!V'xO!S(Wa~O!S(Wa~PF_O!V(PO!S(da~O|%vO!U-sO!X%wO's%eO!S'SX!V'SX~O!V(]O!g(aa~O|%vO!X%wO#b-vO's%eO~O#W-xO!V(ba!g(ba^(ba'j(ba~O!a#rO~P#&hO|%vO!U-{O!X%wO!x]O#a-}O#b-{O's%eO!V'UX!g'UX~Oz.RO!h#uO~Og.UO!X'QO%`.TO'|%OO~O^#Zi!V#Zi'j#Zi'h#Zi!S#Zi!g#Zio#Zi!X#Zi%`#Zi!a#Zi~P!3jOg=iOy)sO|)tO(g)vO(h)xO~O#c#Va^#Va#W#Va'j#Va!V#Va!g#Va!X#Va!S#Va~P#(yO#c(PXP(PXX(PX^(PXk(PXz(PX!e(PX!h(PX!l(PX#f(PX#g(PX#h(PX#i(PX#j(PX#k(PX#l(PX#m(PX#n(PX#p(PX#r(PX#t(PX#u(PX'j(PX(Q(PX(`(PX!g(PX!S(PX'h(PXo(PX!X(PX%`(PX!a(PX~P!1WO!V._Od(ZX~P!-jOd.aO~O!V.bO!g([X~P!3jO!g.eO~O!S.gO~OP$YOy#vOz#wO|#xO!f#tO!h#uO!l$YO(QVOX#ei^#eik#ei!V#ei!e#ei#g#ei#h#ei#i#ei#j#ei#k#ei#l#ei#m#ei#n#ei#p#ei#r#ei#t#ei#u#ei'j#ei(`#ei(g#ei(h#ei'h#ei!S#ei!g#eio#ei!X#ei%`#ei!a#ei~O#f#ei~P#,uO#f#{O~P#,uOP$YOy#vOz#wO|#xO!f#tO!h#uO!l$YO#f#{O#g#|O#h#|O#i#|O(QVOX#ei^#ei!V#ei!e#ei#j#ei#k#ei#l#ei#m#ei#n#ei#p#ei#r#ei#t#ei#u#ei'j#ei(`#ei(g#ei(h#ei'h#ei!S#ei!g#eio#ei!X#ei%`#ei!a#ei~Ok#ei~P#/gOk#}O~P#/gOP$YOk#}Oy#vOz#wO|#xO!f#tO!h#uO!l$YO#f#{O#g#|O#h#|O#i#|O#j$OO(QVO^#ei!V#ei#p#ei#r#ei#t#ei#u#ei'j#ei(`#ei(g#ei(h#ei'h#ei!S#ei!g#eio#ei!X#ei%`#ei!a#ei~OX#ei!e#ei#k#ei#l#ei#m#ei#n#ei~P#2XOX$aO!e$PO#k$PO#l$PO#m$`O#n$PO~P#2XOP$YOX$aOk#}Oy#vOz#wO|#xO!e$PO!f#tO!h#uO!l$YO#f#{O#g#|O#h#|O#i#|O#j$OO#k$PO#l$PO#m$`O#n$PO#p$QO(QVO^#ei!V#ei#r#ei#t#ei#u#ei'j#ei(`#ei(h#ei'h#ei!S#ei!g#eio#ei!X#ei%`#ei!a#ei~O(g#ei~P#5YO(g#yO~P#5YOP$YOX$aOk#}Oy#vOz#wO|#xO!e$PO!f#tO!h#uO!l$YO#f#{O#g#|O#h#|O#i#|O#j$OO#k$PO#l$PO#m$`O#n$PO#p$QO#r$SO(QVO(g#yO^#ei!V#ei#t#ei#u#ei'j#ei(`#ei'h#ei!S#ei!g#eio#ei!X#ei%`#ei!a#ei~O(h#ei~P#7zO(h#zO~P#7zOP$YOX$aOk#}Oy#vOz#wO|#xO!e$PO!f#tO!h#uO!l$YO#f#{O#g#|O#h#|O#i#|O#j$OO#k$PO#l$PO#m$`O#n$PO#p$QO#r$SO#t$UO(QVO(g#yO(h#zO~O^#ei!V#ei#u#ei'j#ei(`#ei'h#ei!S#ei!g#eio#ei!X#ei%`#ei!a#ei~P#:lOPYXXYXkYXyYXzYX|YX!eYX!fYX!hYX!lYX#WYX#ccX#fYX#gYX#hYX#iYX#jYX#kYX#lYX#mYX#nYX#pYX#rYX#tYX#uYX#zYX(QYX(`YX(gYX(hYX!VYX!WYX~O#xYX~P#=VOP$YOX<VOk;yOy#vOz#wO|#xO!e;{O!f#tO!h#uO!l$YO#f;wO#g;xO#h;xO#i;xO#j;zO#k;{O#l;{O#m<UO#n;{O#p;|O#r<OO#t<QO#u<RO(QVO(`$WO(g#yO(h#zO~O#x.iO~P#?dOP(VXX(VXk(VXy(VXz(VX|(VX!e(VX!f(VX!h(VX!l(VX#f(VX#g(VX#h(VX#i(VX#j(VX#k(VX#l(VX#m(VX#p(VX#r(VX#t(VX#u(VX(Q(VX(`(VX(g(VX(h(VX!V(VX~O#W<WO#z<WO#n(VX#x(VX!W(VX~P#AbO^'Xa!V'Xa'j'Xa'h'Xa!g'Xa!S'Xao'Xa!X'Xa%`'Xa!a'Xa~P!3jOP#eiX#ei^#eik#eiz#ei!V#ei!e#ei!f#ei!h#ei!l#ei#f#ei#g#ei#h#ei#i#ei#j#ei#k#ei#l#ei#m#ei#n#ei#p#ei#r#ei#t#ei#u#ei'j#ei(Q#ei(`#ei'h#ei!S#ei!g#eio#ei!X#ei%`#ei!a#ei~P#(yO^#yi!V#yi'j#yi'h#yi!S#yi!g#yio#yi!X#yi%`#yi!a#yi~P!3jO$V.nO$X.nO~O$V.oO$X.oO~O!a)[O#W.pO!X$]X$S$]X$V$]X$X$]X$`$]X~O!U.qO~O!X)_O$S.sO$V)^O$X)^O$`.tO~O!V<SO!W(UX~P#?dO!W.uO~O!a)[O$`(iX~O$`.wO~Oq)nO(R)oO(S.zO~Ol.}O!S/OO'uTO'xUO~O!VcX!acX!gcX!g$rX(`cX~P!,aO!g/UO~P#(yO!V/VO!a#rO(`'dO!g(mX~O!g/[O~O!U*PO's%eO!g(mP~O#c/^O~O!S$rX!V$rX!a$yX~P!,aO!V/_O!S(nX~P#(yO!a/aO~O!S/cO~Ok/gO!a#rO!h%ZO'|%OO(`'dO~O's/iO~O!a+OO~O^%^O!V/mO'j%^O~O!W/oO~P!0_O!]/pO!^/pO't!iO(T!jO~O|/rO(T!jO~O#S/sO~O's%|Od'^X!V'^X~O!V*iOd'}a~Od/xO~Oy/yOz/yO|/zOgva(gva(hva!Vva#Wva~Odva#xva~P#M{Oy)sO|)tOg$ka(g$ka(h$ka!V$ka#W$ka~Od$ka#x$ka~P#NqOy)sO|)tOg$ma(g$ma(h$ma!V$ma#W$ma~Od$ma#x$ma~P$ dO#c/|O~Od${a!V${a#W${a#x${a~P!-jO#c0PO~Oy#vOz#wO|#xO!f#tO!h#uO(QVOP!niX!nik!ni!V!ni!e!ni!l!ni#f!ni#g!ni#h!ni#i!ni#j!ni#k!ni#l!ni#m!ni#n!ni#p!ni#r!ni#t!ni#u!ni(`!ni(g!ni(h!ni~O^!ni'j!ni'h!ni!S!ni!g!nio!ni!X!ni%`!ni!a!ni~P$!qOg.UO!X'QO%`.TO~Oi0WO's0VO~P!.[O!a+OO!X'{a^'{a!V'{a'j'{a~O#c0^O~OXYX!VcX!WcX~O!V0_O!W(uX~O!W0aO~OX0bO~O's+WO'uTO'xUO~O!X%nO's%eO]'fX!V'fX~O!V+]O](ta~O!g0gO~P!3jOX0jO~O]0kO~O!V+iO^(qa'j(qa~O#W0qO~Og0tO!X$yO~O(T(qO!W(rP~Og0}O!X0zO%`0|O'|%OO~OX1XO!V1VO!W(sX~O!W1YO~O]1[O^%^O'j%^O~O's#jO'uTO'xUO~O#W$bO#n1_O#z$bO&Q1`O^(VX~P#AbO#W$bO#n1_O&Q1`O~O^1aO~P%QO^1cO~O&Z1gOP&XiQ&XiV&Xi^&Xia&Xib&Xii&Xik&Xil&Xim&Xis&Xiu&Xiw&Xi|&Xi!Q&Xi!R&Xi!X&Xi!c&Xi!h&Xi!k&Xi!l&Xi!m&Xi!o&Xi!q&Xi!t&Xi!x&Xi#o&Xi$P&Xi$T&Xi%_&Xi%a&Xi%c&Xi%d&Xi%g&Xi%i&Xi%l&Xi%m&Xi%o&Xi%|&Xi&S&Xi&U&Xi&W&Xi&Y&Xi&]&Xi&c&Xi&i&Xi&k&Xi&m&Xi&o&Xi&q&Xi'h&Xi's&Xi'u&Xi'x&Xi(Q&Xi(_&Xi(l&Xi!W&Xi_&Xi&`&Xi~O_1mO!W1kO&`1lO~P`O!XXO!h1oO~O&g,fOP&biQ&biV&bi^&bia&bib&bii&bik&bil&bim&bis&biu&biw&bi|&bi!Q&bi!R&bi!X&bi!c&bi!h&bi!k&bi!l&bi!m&bi!o&bi!q&bi!t&bi!x&bi#o&bi$P&bi$T&bi%_&bi%a&bi%c&bi%d&bi%g&bi%i&bi%l&bi%m&bi%o&bi%|&bi&S&bi&U&bi&W&bi&Y&bi&]&bi&c&bi&i&bi&k&bi&m&bi&o&bi&q&bi'h&bi's&bi'u&bi'x&bi(Q&bi(_&bi(l&bi!W&bi&Z&bi_&bi&`&bi~O!S1uO~O!V!Za!W!Za~P#?dOl!kO|!lO!U1{O(T!jO!V&}X!W&}X~P?cO!V,vO!W(Xa~O!V'TX!W'TX~P!>RO!V,yO!W(fa~O!W2SO~P'TO^%^O#W2]O'j%^O~O^%^O!a#rO#W2]O'j%^O~O^%^O!a#rO!h%ZO!l2aO#W2]O'j%^O'|%OO(`'dO~O!]2bO!^2bO't!iO~PBtO![2eO!]2bO!^2bO#S2fO#T2fO't!iO~PBtO![2eO!]2bO!^2bO#P2gO#S2fO#T2fO't!iO~PBtO^%^O!a#rO!l2aO#W2]O'j%^O(`'dO~O^%^O'j%^O~P!3jO!V$^Oo$ja~O!S&|i!V&|i~P!3jO!V'xO!S(Wi~O!V(PO!S(di~O!S(ei!V(ei~P!3jO!V(]O!g(ai~O!V(bi!g(bi^(bi'j(bi~P!3jO#W2kO!V(bi!g(bi^(bi'j(bi~O|%vO!X%wO!x]O#a2nO#b2mO's%eO~O|%vO!X%wO#b2mO's%eO~Og2uO!X'QO%`2tO~Og2uO!X'QO%`2tO'|%OO~O#cvaPvaXva^vakva!eva!fva!hva!lva#fva#gva#hva#iva#jva#kva#lva#mva#nva#pva#rva#tva#uva'jva(Qva(`va!gva!Sva'hvaova!Xva%`va!ava~P#M{O#c$kaP$kaX$ka^$kak$kaz$ka!e$ka!f$ka!h$ka!l$ka#f$ka#g$ka#h$ka#i$ka#j$ka#k$ka#l$ka#m$ka#n$ka#p$ka#r$ka#t$ka#u$ka'j$ka(Q$ka(`$ka!g$ka!S$ka'h$kao$ka!X$ka%`$ka!a$ka~P#NqO#c$maP$maX$ma^$mak$maz$ma!e$ma!f$ma!h$ma!l$ma#f$ma#g$ma#h$ma#i$ma#j$ma#k$ma#l$ma#m$ma#n$ma#p$ma#r$ma#t$ma#u$ma'j$ma(Q$ma(`$ma!g$ma!S$ma'h$mao$ma!X$ma%`$ma!a$ma~P$ dO#c${aP${aX${a^${ak${az${a!V${a!e${a!f${a!h${a!l${a#f${a#g${a#h${a#i${a#j${a#k${a#l${a#m${a#n${a#p${a#r${a#t${a#u${a'j${a(Q${a(`${a!g${a!S${a'h${a#W${ao${a!X${a%`${a!a${a~P#(yO^#Zq!V#Zq'j#Zq'h#Zq!S#Zq!g#Zqo#Zq!X#Zq%`#Zq!a#Zq~P!3jOd'OX!V'OX~P!$uO!V._Od(Za~O!U2}O!V'PX!g'PX~P%QO!V.bO!g([a~O!V.bO!g([a~P!3jO!S3QO~O#x!ja!W!ja~PI{O#x!ba!V!ba!W!ba~P#?dO#x!na!W!na~P!6TO#x!pa!W!pa~P!8nO!X3dO$TfO$^3eO~O!W3iO~Oo3jO~P#(yO^$gq!V$gq'j$gq'h$gq!S$gq!g$gqo$gq!X$gq%`$gq!a$gq~P!3jO!S3kO~Ol.}O'uTO'xUO~Oy)sO|)tO(h)xOg%Wi(g%Wi!V%Wi#W%Wi~Od%Wi#x%Wi~P$HbOy)sO|)tOg%Yi(g%Yi(h%Yi!V%Yi#W%Yi~Od%Yi#x%Yi~P$ITO(`$WO~P#(yO!U3nO's%eO!V'YX!g'YX~O!V/VO!g(ma~O!V/VO!a#rO!g(ma~O!V/VO!a#rO(`'dO!g(ma~Od$ti!V$ti#W$ti#x$ti~P!-jO!U3vO's*UO!S'[X!V'[X~P!.XO!V/_O!S(na~O!V/_O!S(na~P#(yO!a#rO~O!a#rO#n4OO~Ok4RO!a#rO(`'dO~Od(Oi!V(Oi~P!-jO#W4UOd(Oi!V(Oi~P!-jO!g4XO~O^$hq!V$hq'j$hq'h$hq!S$hq!g$hqo$hq!X$hq%`$hq!a$hq~P!3jO!V4]O!X(oX~P#(yO!f#tO~P3zO!X$rX%TYX^$rX!V$rX'j$rX~P!,aO%T4_OghXyhX|hX!XhX(ghX(hhX^hX!VhX'jhX~O%T4_O~O%a4fO's+WO'uTO'xUO!V'eX!W'eX~O!V0_O!W(ua~OX4jO~O]4kO~O!S4oO~O^%^O'j%^O~P#(yO!X$yO~P#(yO!V4tO#W4vO!W(rX~O!W4wO~Ol!kO|4yO![5WO!]4}O!^4}O!x;oO!|5VO!}5UO#O5UO#P5TO#S5SO#T!wO't!iO'uTO'xUO(T!jO(_!nO~O!W5RO~P%#XOg5]O!X0zO%`5[O~Og5]O!X0zO%`5[O'|%OO~O's#jO!V'dX!W'dX~O!V1VO!W(sa~O'uTO'xUO(T5fO~O]5jO~O!g5mO~P%QO^5oO~O^5oO~P%QO#n5qO&Q5rO~PMPO_1mO!W5vO&`1lO~P`O!a5xO~O!a5zO!V(Yi!W(Yi!a(Yi!h(Yi'|(Yi~O!V#`i!W#`i~P#?dO#W5{O!V#`i!W#`i~O!V!Zi!W!Zi~P#?dO^%^O#W6UO'j%^O~O^%^O!a#rO#W6UO'j%^O~O^%^O!a#rO!l6ZO#W6UO'j%^O(`'dO~O!h%ZO'|%OO~P%(fO!]6[O!^6[O't!iO~PBtO![6_O!]6[O!^6[O#S6`O#T6`O't!iO~PBtO!V(]O!g(aq~O!V(bq!g(bq^(bq'j(bq~P!3jO|%vO!X%wO#b6dO's%eO~O!X'QO%`6gO~Og6jO!X'QO%`6gO~O#c%WiP%WiX%Wi^%Wik%Wiz%Wi!e%Wi!f%Wi!h%Wi!l%Wi#f%Wi#g%Wi#h%Wi#i%Wi#j%Wi#k%Wi#l%Wi#m%Wi#n%Wi#p%Wi#r%Wi#t%Wi#u%Wi'j%Wi(Q%Wi(`%Wi!g%Wi!S%Wi'h%Wio%Wi!X%Wi%`%Wi!a%Wi~P$HbO#c%YiP%YiX%Yi^%Yik%Yiz%Yi!e%Yi!f%Yi!h%Yi!l%Yi#f%Yi#g%Yi#h%Yi#i%Yi#j%Yi#k%Yi#l%Yi#m%Yi#n%Yi#p%Yi#r%Yi#t%Yi#u%Yi'j%Yi(Q%Yi(`%Yi!g%Yi!S%Yi'h%Yio%Yi!X%Yi%`%Yi!a%Yi~P$ITO#c$tiP$tiX$ti^$tik$tiz$ti!V$ti!e$ti!f$ti!h$ti!l$ti#f$ti#g$ti#h$ti#i$ti#j$ti#k$ti#l$ti#m$ti#n$ti#p$ti#r$ti#t$ti#u$ti'j$ti(Q$ti(`$ti!g$ti!S$ti'h$ti#W$tio$ti!X$ti%`$ti!a$ti~P#(yOd'Oa!V'Oa~P!-jO!V'Pa!g'Pa~P!3jO!V.bO!g([i~O#x#Zi!V#Zi!W#Zi~P#?dOP$YOy#vOz#wO|#xO!f#tO!h#uO!l$YO(QVOX#eik#ei!e#ei#g#ei#h#ei#i#ei#j#ei#k#ei#l#ei#m#ei#n#ei#p#ei#r#ei#t#ei#u#ei#x#ei(`#ei(g#ei(h#ei!V#ei!W#ei~O#f#ei~P%2xO#f;wO~P%2xOP$YOy#vOz#wO|#xO!f#tO!h#uO!l$YO#f;wO#g;xO#h;xO#i;xO(QVOX#ei!e#ei#j#ei#k#ei#l#ei#m#ei#n#ei#p#ei#r#ei#t#ei#u#ei#x#ei(`#ei(g#ei(h#ei!V#ei!W#ei~Ok#ei~P%5TOk;yO~P%5TOP$YOk;yOy#vOz#wO|#xO!f#tO!h#uO!l$YO#f;wO#g;xO#h;xO#i;xO#j;zO(QVO#p#ei#r#ei#t#ei#u#ei#x#ei(`#ei(g#ei(h#ei!V#ei!W#ei~OX#ei!e#ei#k#ei#l#ei#m#ei#n#ei~P%7`OX<VO!e;{O#k;{O#l;{O#m<UO#n;{O~P%7`OP$YOX<VOk;yOy#vOz#wO|#xO!e;{O!f#tO!h#uO!l$YO#f;wO#g;xO#h;xO#i;xO#j;zO#k;{O#l;{O#m<UO#n;{O#p;|O(QVO#r#ei#t#ei#u#ei#x#ei(`#ei(h#ei!V#ei!W#ei~O(g#ei~P%9zO(g#yO~P%9zOP$YOX<VOk;yOy#vOz#wO|#xO!e;{O!f#tO!h#uO!l$YO#f;wO#g;xO#h;xO#i;xO#j;zO#k;{O#l;{O#m<UO#n;{O#p;|O#r<OO(QVO(g#yO#t#ei#u#ei#x#ei(`#ei!V#ei!W#ei~O(h#ei~P%<VO(h#zO~P%<VOP$YOX<VOk;yOy#vOz#wO|#xO!e;{O!f#tO!h#uO!l$YO#f;wO#g;xO#h;xO#i;xO#j;zO#k;{O#l;{O#m<UO#n;{O#p;|O#r<OO#t<QO(QVO(g#yO(h#zO~O#u#ei#x#ei(`#ei!V#ei!W#ei~P%>bO^#vy!V#vy'j#vy'h#vy!S#vy!g#vyo#vy!X#vy%`#vy!a#vy~P!3jOg=jOy)sO|)tO(g)vO(h)xO~OP#eiX#eik#eiz#ei!e#ei!f#ei!h#ei!l#ei#f#ei#g#ei#h#ei#i#ei#j#ei#k#ei#l#ei#m#ei#n#ei#p#ei#r#ei#t#ei#u#ei#x#ei(Q#ei(`#ei!V#ei!W#ei~P%AYO!f#tOP(PXX(PXg(PXk(PXy(PXz(PX|(PX!e(PX!h(PX!l(PX#f(PX#g(PX#h(PX#i(PX#j(PX#k(PX#l(PX#m(PX#n(PX#p(PX#r(PX#t(PX#u(PX#x(PX(Q(PX(`(PX(g(PX(h(PX!V(PX!W(PX~O#x#yi!V#yi!W#yi~P#?dO#x!ni!W!ni~P$!qO!W6vO~O!V'Xa!W'Xa~P#?dO!a#rO(`'dO!V'Ya!g'Ya~O!V/VO!g(mi~O!V/VO!a#rO!g(mi~Od$tq!V$tq#W$tq#x$tq~P!-jO!S'[a!V'[a~P#(yO!a6}O~O!V/_O!S(ni~P#(yO!V/_O!S(ni~O!S7RO~O!a#rO#n7WO~Ok7XO!a#rO(`'dO~O!S7ZO~Od$vq!V$vq#W$vq#x$vq~P!-jO^$hy!V$hy'j$hy'h$hy!S$hy!g$hyo$hy!X$hy%`$hy!a$hy~P!3jO!V4]O!X(oa~O^#Zy!V#Zy'j#Zy'h#Zy!S#Zy!g#Zyo#Zy!X#Zy%`#Zy!a#Zy~P!3jOX7`O~O!V0_O!W(ui~O]7fO~O!a5zO~O(T(qO!V'aX!W'aX~O!V4tO!W(ra~O!h%ZO'|%OO^(YX!a(YX!l(YX#W(YX'j(YX(`(YX~O's7oO~P.[O!x;oO!|7rO!}7qO#O7qO#P7pO#S'bO#T'bO~PBtO^%^O!a#rO!l'hO#W'fO'j%^O(`'dO~O!W7vO~P%#XOl!kO'uTO'xUO(T!jO(_!nO~O|7wO~P%MdO![7{O!]7zO!^7zO#P7pO#S'bO#T'bO't!iO~PBtO![7{O!]7zO!^7zO!}7|O#O7|O#P7pO#S'bO#T'bO't!iO~PBtO!]7zO!^7zO't!iO(T!jO(_!nO~O!X0zO~O!X0zO%`8OO~Og8RO!X0zO%`8OO~OX8WO!V'da!W'da~O!V1VO!W(si~O!g8[O~O!g8]O~O!g8^O~O!g8^O~P%QO^8`O~O!a8cO~O!g8dO~O!V(ei!W(ei~P#?dO^%^O#W8lO'j%^O~O^%^O!a#rO#W8lO'j%^O~O^%^O!a#rO!l8pO#W8lO'j%^O(`'dO~O!h%ZO'|%OO~P&$QO!]8qO!^8qO't!iO~PBtO!V(]O!g(ay~O!V(by!g(by^(by'j(by~P!3jO!X'QO%`8uO~O#c$tqP$tqX$tq^$tqk$tqz$tq!V$tq!e$tq!f$tq!h$tq!l$tq#f$tq#g$tq#h$tq#i$tq#j$tq#k$tq#l$tq#m$tq#n$tq#p$tq#r$tq#t$tq#u$tq'j$tq(Q$tq(`$tq!g$tq!S$tq'h$tq#W$tqo$tq!X$tq%`$tq!a$tq~P#(yO#c$vqP$vqX$vq^$vqk$vqz$vq!V$vq!e$vq!f$vq!h$vq!l$vq#f$vq#g$vq#h$vq#i$vq#j$vq#k$vq#l$vq#m$vq#n$vq#p$vq#r$vq#t$vq#u$vq'j$vq(Q$vq(`$vq!g$vq!S$vq'h$vq#W$vqo$vq!X$vq%`$vq!a$vq~P#(yO!V'Pi!g'Pi~P!3jO#x#Zq!V#Zq!W#Zq~P#?dOy/yOz/yO|/zOPvaXvagvakva!eva!fva!hva!lva#fva#gva#hva#iva#jva#kva#lva#mva#nva#pva#rva#tva#uva#xva(Qva(`va(gva(hva!Vva!Wva~Oy)sO|)tOP$kaX$kag$kak$kaz$ka!e$ka!f$ka!h$ka!l$ka#f$ka#g$ka#h$ka#i$ka#j$ka#k$ka#l$ka#m$ka#n$ka#p$ka#r$ka#t$ka#u$ka#x$ka(Q$ka(`$ka(g$ka(h$ka!V$ka!W$ka~Oy)sO|)tOP$maX$mag$mak$maz$ma!e$ma!f$ma!h$ma!l$ma#f$ma#g$ma#h$ma#i$ma#j$ma#k$ma#l$ma#m$ma#n$ma#p$ma#r$ma#t$ma#u$ma#x$ma(Q$ma(`$ma(g$ma(h$ma!V$ma!W$ma~OP${aX${ak${az${a!e${a!f${a!h${a!l${a#f${a#g${a#h${a#i${a#j${a#k${a#l${a#m${a#n${a#p${a#r${a#t${a#u${a#x${a(Q${a(`${a!V${a!W${a~P%AYO#x$gq!V$gq!W$gq~P#?dO#x$hq!V$hq!W$hq~P#?dO!W9PO~O#x9QO~P!-jO!a#rO!V'Yi!g'Yi~O!a#rO(`'dO!V'Yi!g'Yi~O!V/VO!g(mq~O!S'[i!V'[i~P#(yO!V/_O!S(nq~O!S9WO~P#(yO!S9WO~Od(Oy!V(Oy~P!-jO!V'_a!X'_a~P#(yO!X%Sq^%Sq!V%Sq'j%Sq~P#(yOX9]O~O!V0_O!W(uq~O#W9aO!V'aa!W'aa~O!V4tO!W(ri~P#?dOPYXXYXkYXyYXzYX|YX!SYX!VYX!eYX!fYX!hYX!lYX#WYX#ccX#fYX#gYX#hYX#iYX#jYX#kYX#lYX#mYX#nYX#pYX#rYX#tYX#uYX#zYX(QYX(`YX(gYX(hYX~O!a%QX#n%QX~P&6lO#S-cO#T-cO~PBtO#P9eO#S-cO#T-cO~PBtO!}9fO#O9fO#P9eO#S-cO#T-cO~PBtO!]9iO!^9iO't!iO(T!jO(_!nO~O![9lO!]9iO!^9iO#P9eO#S-cO#T-cO't!iO~PBtO!X0zO%`9oO~O'uTO'xUO(T9tO~O!V1VO!W(sq~O!g9wO~O!g9wO~P%QO!g9yO~O!g9zO~O#W9|O!V#`y!W#`y~O!V#`y!W#`y~P#?dO^%^O#W:QO'j%^O~O^%^O!a#rO#W:QO'j%^O~O^%^O!a#rO!l:UO#W:QO'j%^O(`'dO~O!X'QO%`:XO~O#x#vy!V#vy!W#vy~P#?dOP$tiX$tik$tiz$ti!e$ti!f$ti!h$ti!l$ti#f$ti#g$ti#h$ti#i$ti#j$ti#k$ti#l$ti#m$ti#n$ti#p$ti#r$ti#t$ti#u$ti#x$ti(Q$ti(`$ti!V$ti!W$ti~P%AYOy)sO|)tO(h)xOP%WiX%Wig%Wik%Wiz%Wi!e%Wi!f%Wi!h%Wi!l%Wi#f%Wi#g%Wi#h%Wi#i%Wi#j%Wi#k%Wi#l%Wi#m%Wi#n%Wi#p%Wi#r%Wi#t%Wi#u%Wi#x%Wi(Q%Wi(`%Wi(g%Wi!V%Wi!W%Wi~Oy)sO|)tOP%YiX%Yig%Yik%Yiz%Yi!e%Yi!f%Yi!h%Yi!l%Yi#f%Yi#g%Yi#h%Yi#i%Yi#j%Yi#k%Yi#l%Yi#m%Yi#n%Yi#p%Yi#r%Yi#t%Yi#u%Yi#x%Yi(Q%Yi(`%Yi(g%Yi(h%Yi!V%Yi!W%Yi~O#x$hy!V$hy!W$hy~P#?dO#x#Zy!V#Zy!W#Zy~P#?dO!a#rO!V'Yq!g'Yq~O!V/VO!g(my~O!S'[q!V'[q~P#(yO!S:`O~P#(yO!V0_O!W(uy~O!V4tO!W(rq~O#S2fO#T2fO~PBtO#P:gO#S2fO#T2fO~PBtO!]:kO!^:kO't!iO(T!jO(_!nO~O!X0zO%`:nO~O!g:qO~O^%^O#W:vO'j%^O~O^%^O!a#rO#W:vO'j%^O~O!X'QO%`:{O~OP$tqX$tqk$tqz$tq!e$tq!f$tq!h$tq!l$tq#f$tq#g$tq#h$tq#i$tq#j$tq#k$tq#l$tq#m$tq#n$tq#p$tq#r$tq#t$tq#u$tq#x$tq(Q$tq(`$tq!V$tq!W$tq~P%AYOP$vqX$vqk$vqz$vq!e$vq!f$vq!h$vq!l$vq#f$vq#g$vq#h$vq#i$vq#j$vq#k$vq#l$vq#m$vq#n$vq#p$vq#r$vq#t$vq#u$vq#x$vq(Q$vq(`$vq!V$vq!W$vq~P%AYOd%[!Z!V%[!Z#W%[!Z#x%[!Z~P!-jO!V'aq!W'aq~P#?dO#S6`O#T6`O~PBtO!V#`!Z!W#`!Z~P#?dO^%^O#W;ZO'j%^O~O#c%[!ZP%[!ZX%[!Z^%[!Zk%[!Zz%[!Z!V%[!Z!e%[!Z!f%[!Z!h%[!Z!l%[!Z#f%[!Z#g%[!Z#h%[!Z#i%[!Z#j%[!Z#k%[!Z#l%[!Z#m%[!Z#n%[!Z#p%[!Z#r%[!Z#t%[!Z#u%[!Z'j%[!Z(Q%[!Z(`%[!Z!g%[!Z!S%[!Z'h%[!Z#W%[!Zo%[!Z!X%[!Z%`%[!Z!a%[!Z~P#(yOP%[!ZX%[!Zk%[!Zz%[!Z!e%[!Z!f%[!Z!h%[!Z!l%[!Z#f%[!Z#g%[!Z#h%[!Z#i%[!Z#j%[!Z#k%[!Z#l%[!Z#m%[!Z#n%[!Z#p%[!Z#r%[!Z#t%[!Z#u%[!Z#x%[!Z(Q%[!Z(`%[!Z!V%[!Z!W%[!Z~P%AYOo(UX~P1dO't!iO~P!'RO!ScX!VcX#WcX~P&6lOPYXXYXkYXyYXzYX|YX!VYX!VcX!eYX!fYX!hYX!lYX#WYX#WcX#ccX#fYX#gYX#hYX#iYX#jYX#kYX#lYX#mYX#nYX#pYX#rYX#tYX#uYX#zYX(QYX(`YX(gYX(hYX~O!acX!gYX!gcX(`cX~P'!sOP;nOQ;nOa=_Ob!fOikOk;nOlkOmkOskOu;nOw;nO|WO!QkO!RkO!XXO!c;qO!hZO!k;nO!l;nO!m;nO!o;rO!q;sO!t!eO$P!hO$TfO's)RO'uTO'xUO(QVO(_[O(l=]O~O!V<SO!W$ja~Oi%POk$qOl$pOm$pOs%QOu%ROw<YO|$xO!X$yO!c=dO!h$uO#b<`O$P%VO$l<[O$n<^O$q%WO's(iO'uTO'xUO'|%OO(Q$rO~O#o)YO~P''iO!WYX!WcX~P'!sO#c;vO~O!a#rO#c;vO~O#W<WO~O#n;{O~O#W<bO!V(eX!W(eX~O#W<WO!V(cX!W(cX~O#c<cO~Od<eO~P!-jO#c<jO~O#c<kO~O!a#rO#c<lO~O!a#rO#c<cO~O#x<mO~P#?dO#c<nO~O#c<oO~O#c<pO~O#c<qO~O#c<rO~O#c<sO~O#x<tO~P!-jO#x<uO~P!-jO$T~!f!|#O#P#S#a#b#m(l$l$n$q%T%_%`%a%g%i%l%m%o%q~'nR$T(l#g!R'l't#hl#f#iky'm(T'm's$V$X$V~",
  goto: "$/X(yPPPP(zP(}P)_P+a/fPPPP6iPP7OP<|@mPAQPAQPPPAQPBpPAQPAQPAQPBtPPByPCdPH`PPPHdPPPPHdKfPPPKlMlPHdP!!SPPPP!$eHdPPPHdPHdP!&vHdP!*]!+_!+dP!,U!,Y!,UPPPP!/f!1kPP!1t!3OP!+_HdHd!6b!9m!>v!>v!BnPPP!BuHdPPPPPPPPPPP!FTP!GiPPHd!HyPHdPHdHdHdHdPHd!J`PP!MiP#!nP#!r#!|##Q##QP!MfP##U##UP#&ZP#&_HdHd#&e#)iAQPAQPAQAQP#*sAQAQ#,mAQ#.zAQ#0nAQAQ#1[#3W#3W#3[#3d#3W#3lP#3WPAQ#4hAQ#5pAQAQ6iPPP#6{PP#7e#7eP#7eP#7z#7ePP#8QP#7wP#7w#8d!1p#7w#9O#9U6f(}#9X(}P#9`#9`#9`P(}P(}P(}P(}PP(}P#9f#9iP#9i(}P#9mP#9pP(}P(}P(}P(}P(}P(}(}PP#9v#9|#:W#:^#:d#:j#:p#;O#;U#;[#;f#;l#<h#<w#<}#=a#=g#=m#={#>b#?r#@Q#@W#@^#@d#@j#@t#@z#AQ#A[#An#AtPPPPPPPPPP#AzPPPPPPP#Bn#FYP#Gu#G|#HUPPPP#L`$ U$'t$'w$'z$)w$)z$)}$*UPP$*[$*`$+X$,X$,]$,qPP$,u$,{$-PP$-S$-W$-Z$.P$.g$.l$.o$.r$.x$.{$/P$/TR!yRmpOXr!X#a%]&d&f&g&i,^,c1g1jU!pQ'Q-OQ%ctQ%kwQ%rzQ&[!TS&x!c,vQ'W!f[']!m!r!s!t!u!vS*[$y*aQ+U%lQ+c%tQ+}&UQ,|'PQ-W'XW-`'^'_'`'aQ/p*cQ1U,OU2b-b-d-eS4}0z5QS6[2e2gU7z5U5V5WQ8q6_S9i7{7|Q:k9lR<a;r%QdOPWXYZrstu!X!^!l#P#T#W#a#k#q#u#x#{#|#}$O$P$Q$R$S$T$U$V$^$b%]%c%p&]&`&d&f&g&i&m&u'S'f'v'x(O(Y(k(o(s)r*t+h,Y,^,c-S-[-o-x.b.i/z0P0^0}1_1`1a1c1g1j1l2]2k2}4y5]5o5q5r6U7w8R8`8l:Q:v;ZS#m];o!r)T$X$j&y)g,o,r.q1{3d4v5{9a9|;n;q;r;s;v;w;x;y;z;{;|;}<O<P<Q<R<S<W<a<b<c<e<l<m<r<s=`Q*l%SQ+Z%nQ,P&XQ,W&aQ.X<XQ0T*|Q0X+OQ0d+[Q1^,UQ2q.UQ4e0_Q5d1VQ6i2uQ6o<YQ7b4fR8x6j'OkOPWXYZrstu!X!^!l#P#T#W#a#k#q#u#x#{#|#}$O$P$Q$R$S$T$U$V$X$^$b$j%]%c%p&]&`&a&d&f&g&i&m&u&y'S'f'v'x(O(Y(k(o(s)g)r*t*|+h,Y,^,c,o,r-S-[-o-x.U.b.i.q/z0P0^0}1_1`1a1c1g1j1l1{2]2k2u2}3d4v4y5]5o5q5r5{6U6j7w8R8`8l9a9|:Q:v;Z;n;q;r;s;v;w;x;y;z;{;|;}<O<P<Q<R<S<W<a<b<c<e<l<m<r<s=`#S!kQ!m!p!r!s!t!u!v!w&x'P'Q']'^'_'`'a'b,v,|-O-`-b-c-d-e0z2b2e2f2g4z5Q5S5T5U5V6[6_6`7p7q7r7|8q9e9f:g$Y$pi#r#t$`$a$u$x%T%U%Y)n)w)y)z*R*X*g*h*{+O+m+p.T._/^/_/a/|0q0t0|2t3l3v4O4U4]4_5[6g6}7W8O8u9Q9o:X:n:{<U<V<Z<[<]<^<_<`<f<g<h<i<j<k<n<o<p<q<t<u=]=e=f=i=jQ%uzQ&v!cS&|%w,yQ+Z%nS.})t/PQ/{*pQ0d+[Q0i+bQ1],TQ1^,UQ4e0_Q4n0kQ5g1XQ5h1[Q7b4fQ7e4kQ8Z5jQ9`7fR9u8WpmOXr!T!X#a%]&Z&d&f&g&i,^,c1g1jR,R&]&x`OPXYrstux!X!^!g!l#P#a#k#q#u#x#{#|#}$O$P$Q$R$S$T$U$V$X$^$b$j%]%c%p&]&`&a&d&f&g&i&m&u'S'f'x(O(Y(k(o(s)g)r*t*|+h,Y,^,c,o,r-S-[-o-x.U.b.i.q/z0P0^0}1_1`1a1c1g1j1l1{2]2k2u2}3d4v4y5]5o5q5r5{6U6j7w8R8`8l9a9|:Q:v;Z;n;q;r;s;v;w;x;y;z;{;|;}<O<P<Q<R<S<W<a<b<c<e<l<m<r<s=_=`[#YWZ#T#W&y'vQ%fvQ%jwS%oz%t!U%x|}#d#f#i%Z%v(P(W(X(]+f+g+i,[,p-s-v-z-{-}1o2m2n5z6dQ&Q!RQ'T!eQ'V!fQ(d#oS*O$u*SS+T%k%lQ+X%nQ+x&SQ+|&US-V'W'XQ.W(eQ/Z*PQ0]+UQ0c+[Q0e+]Q0h+aQ1P+yS1T+},OQ2X-WQ3m/VQ4d0_Q4h0bQ4m0jQ5c1UQ6z3nQ7a4fQ7d4jQ9[7`R:b9]v$wi#t%T%U%Y)w)y*R*g*h._/^/|3l4U9Q=]=e=f!`%hw!f!o%j%k%l&w'V'W'X'['i*Z+T+U,s-V-W-_-a/h0]2Q2X2`2d4Q6Y6^8o:TQ*}%fQ+n%}Q+q&OQ+{&UQ.V(dQ1O+xU1S+|+},OQ2v.WQ5^1PS5b1T1US7n4x4|Q8V5cU9g7s7x7yU:i9h9j9kQ;R:jQ;a;S!z=a#r$`$a$u$x)n)z*X*{+O+m+p.T/_/a0q0t0|2t3v4O4]4_5[6g6}7W8O8u9o:X:n:{<Z<]<_<f<h<j<n<p<t=i=jg=b<U<V<[<^<`<g<i<k<o<q<uW$|i%O*i=]S%}!O&ZQ&O!PQ&P!QR+l%{$Z${i#r#t$`$a$u$x%T%U%Y)n)w)y)z*R*X*g*h*{+O+m+p.T._/^/_/a/|0q0t0|2t3l3v4O4U4]4_5[6g6}7W8O8u9Q9o:X:n:{<U<V<Z<[<]<^<_<`<f<g<h<i<j<k<n<o<p<q<t<u=]=e=f=i=jT)o$r)pV*m%S<X<YU&|!c%w,yS(r#v#wQ+`%qS.P(`(aQ0u+rQ4V/yR7j4t'OkOPWXYZrstu!X!^!l#P#T#W#a#k#q#u#x#{#|#}$O$P$Q$R$S$T$U$V$X$^$b$j%]%c%p&]&`&a&d&f&g&i&m&u&y'S'f'v'x(O(Y(k(o(s)g)r*t*|+h,Y,^,c,o,r-S-[-o-x.U.b.i.q/z0P0^0}1_1`1a1c1g1j1l1{2]2k2u2}3d4v4y5]5o5q5r5{6U6j7w8R8`8l9a9|:Q:v;Z;n;q;r;s;v;w;x;y;z;{;|;}<O<P<Q<R<S<W<a<b<c<e<l<m<r<s=`$o$]c#V#b%a%b%d'u'{(g(n(v(w(x(y(z({(|(})O)P)Q)S)V)Z)e*y+_,t-h-m-r-w.^.d.h.j.k.l.{/}1v1y2Z2j2|3R3S3T3U3V3W3X3Y3Z3[3]3^3_3b3c3h4Z4b5}6T6b6m6n6s6t7l8f8j8y8}9O:O:d:r:t;X;d;p=ST#QV#R'PkOPWXYZrstu!X!^!l#P#T#W#a#k#q#u#x#{#|#}$O$P$Q$R$S$T$U$V$X$^$b$j%]%c%p&]&`&a&d&f&g&i&m&u&y'S'f'v'x(O(Y(k(o(s)g)r*t*|+h,Y,^,c,o,r-S-[-o-x.U.b.i.q/z0P0^0}1_1`1a1c1g1j1l1{2]2k2u2}3d4v4y5]5o5q5r5{6U6j7w8R8`8l9a9|:Q:v;Z;n;q;r;s;v;w;x;y;z;{;|;}<O<P<Q<R<S<W<a<b<c<e<l<m<r<s=`Q&z!cR1|,v!z!kQ!c!m!p!r!s!t!u!v!w&x'P'Q']'^'_'`'a'b,v,|-O-`-b-c-d-e2b2e2f2g4z5S5T6[6_6`7p7q7r8q9e9f:gS*Z$y*aS/h*[*cQ/q*dQ0w+tQ4Q/pQ4T/sS4x0z5QS7s4}5WS7x5U5VS9h7z7{Q9j7|S:j9i9lR;S:klpOXr!X#a%]&d&f&g&i,^,c1g1jQ&k![Q'j!tS(f#q;vQ+R%iQ+v&QQ+w&RQ-T'UQ-g'cS.](k<cS0O*t<lQ0Z+SQ0y+uQ1n,eQ1p,fQ1x,qQ2V-UQ2Y-YS4[0P<rQ4`0[S4c0^<sQ5|1zQ6Q2WQ6V2_Q7_4aQ8g6OQ8h6RQ8k6WQ9{8dQ:P8mQ:u:RR;Y:w$j$[c#V#b%b%d'u'{(g(n(v(w(x(y(z({(|(})O)P)Q)S)V)Z)e*y+_,t-h-m-r-w.^.d.h.k.l.{/}1v1y2Z2j2|3R3S3T3U3V3W3X3Y3Z3[3]3^3_3b3c3h4Z4b5}6T6b6m6n6s6t7l8f8j8y8}9O:O:d:r:t;X;d;p=SS(c#l'ZU*f$z(j3aS*x%a.jQ2r0TQ6f2qQ8w6iR:Y8x$j$Zc#V#b%b%d'u'{(g(n(v(w(x(y(z({(|(})O)P)Q)S)V)Z)e*y+_,t-h-m-r-w.^.d.h.k.l.{/}1v1y2Z2j2|3R3S3T3U3V3W3X3Y3Z3[3]3^3_3b3c3h4Z4b5}6T6b6m6n6s6t7l8f8j8y8}9O:O:d:r:t;X;d;p=SS(b#l'ZS(t#w$[S*w%a.jS.Q(a(cQ.m)UQ0Q*xR2o.R'OkOPWXYZrstu!X!^!l#P#T#W#a#k#q#u#x#{#|#}$O$P$Q$R$S$T$U$V$X$^$b$j%]%c%p&]&`&a&d&f&g&i&m&u&y'S'f'v'x(O(Y(k(o(s)g)r*t*|+h,Y,^,c,o,r-S-[-o-x.U.b.i.q/z0P0^0}1_1`1a1c1g1j1l1{2]2k2u2}3d4v4y5]5o5q5r5{6U6j7w8R8`8l9a9|:Q:v;Z;n;q;r;s;v;w;x;y;z;{;|;}<O<P<Q<R<S<W<a<b<c<e<l<m<r<s=`S#m];oQ&f!VQ&g!WQ&i!YQ&j!ZR1f,aQ'R!eQ*z%fQ-R'TS.S(d*}Q2T-QW2s.V.W0S0UQ6P2UU6e2p2r2vS8t6f6hS:W8v8wS:y:V:YQ;[:zR;e;]V!qQ'Q-O!_^OQXZ_r!T!X!m#a#d%Z%]&Z&]&d&f&g&i'Q(],^,c-O-z0z1g1j4z5QT#m];o%[yOPWXYZrstu!X!^!l#P#T#W#a#k#q#u#x#{#|#}$O$P$Q$R$S$T$U$V$^$b%]%c%p&]&`&a&d&f&g&i&m&u'S'f'v'x(O(Y(k(o(s)r*t*|+h,Y,^,c-S-[-o-x.U.b.i/z0P0^0}1_1`1a1c1g1j1l2]2k2u2}4y5]5o5q5r6U6j7w8R8`8l:Q:v;ZS(r#v#wS.P(`(a!s<y$X$j&y)g,o,r.q1{3d4v5{9a9|;n;q;r;s;v;w;x;y;z;{;|;}<O<P<Q<R<S<W<a<b<c<e<l<m<r<s=`U!oQ'Q-OY'[!m!s!t!u!vS'i!p!rW'k!w4z5S5TS-_']'^U-a'_'`'aW-f'b7p7q7rS2`-`-bU2c-c9e9fS2d-d-eS4|0z5QS6Y2b2eS6]2f:gQ6^2gS7s4}5WS7y5U5VS8o6[6_Q8r6`S9h7z7{Q9k7|Q:T8qS:j9i9lR;S:kU!qQ'Q-OT5O0z5QU'h!o4{4|S([#e1dU-^'['k7yQ/Y*OQ/f*ZU2a-a-f9kQ3r/ZS3{/g/qS6Z2c2dQ6y3mS7U4R4TS8p6]6^Q9S6zQ9Z7XR:U8rQ#sbU'g!o4{4|S(Z#e1dQ*u%[Q+P%gQ+V%mW-]'['h'k7yQ-y([Q/X*OQ/e*ZQ/k*^Q0Y+QQ1Q+zW2^-^-a-f9kS3q/Y/ZS3z/f/qQ3}/jQ4P/lQ5`1RU6X2a2c2dQ6x3mQ6|3rS7Q3{4TQ7V4SQ8T5aU8n6Z6]6^S9R6y6zQ9V7RQ9X7UQ9c7mQ9r8US:S8p8rQ:^9SQ:_9WQ:a9ZQ:f9dQ:p9sQ:x:UQ:}:`Q;P:hQ;_;QQ;h;`Q;l;iQ<|<wQ=X=QR=Y=R%[aOPWXYZrstu!X!^!l#P#T#W#a#k#q#u#x#{#|#}$O$P$Q$R$S$T$U$V$^$b%]%c%p&]&`&a&d&f&g&i&m&u'S'f'v'x(O(Y(k(o(s)r*t*|+h,Y,^,c-S-[-o-x.U.b.i/z0P0^0}1_1`1a1c1g1j1l2]2k2u2}4y5]5o5q5r6U6j7w8R8`8l:Q:v;ZS#sx!g!r<v$X$j&y)g,o,r.q1{3d4v5{9a9|;n;q;r;s;v;w;x;y;z;{;|;}<O<P<Q<R<S<W<a<b<c<e<l<m<r<s=`R<|=_%[bOPWXYZrstu!X!^!l#P#T#W#a#k#q#u#x#{#|#}$O$P$Q$R$S$T$U$V$^$b%]%c%p&]&`&a&d&f&g&i&m&u'S'f'v'x(O(Y(k(o(s)r*t*|+h,Y,^,c-S-[-o-x.U.b.i/z0P0^0}1_1`1a1c1g1j1l2]2k2u2}4y5]5o5q5r6U6j7w8R8`8l:Q:v;ZQ%[j!`%gw!f!o%j%k%l&w'V'W'X'['i*Z+T+U,s-V-W-_-a/h0]2Q2X2`2d4Q6Y6^8o:TS%mx!gQ+Q%hQ+z&UW1R+{+|+},OU5a1S1T1US7m4x4|S8U5b5cW9d7n7s7x7yQ9s8VW:h9g9h9j9kS;Q:i:jS;`;R;SQ;i;a!r<w$X$j&y)g,o,r.q1{3d4v5{9a9|;n;q;r;s;v;w;x;y;z;{;|;}<O<P<Q<R<S<W<a<b<c<e<l<m<r<s=`Q=Q=^R=R=_%OeOPXYrstu!X!^!l#P#a#k#q#u#x#{#|#}$O$P$Q$R$S$T$U$V$^$b%]%c%p&]&`&d&f&g&i&m&u'S'f'x(O(Y(k(o(s)r*t*|+h,Y,^,c-S-[-o-x.U.b.i/z0P0^0}1_1`1a1c1g1j1l2]2k2u2}4y5]5o5q5r6U6j7w8R8`8l:Q:v;ZY#_WZ#T#W'v!U%x|}#d#f#i%Z%v(P(W(X(]+f+g+i,[,p-s-v-z-{-}1o2m2n5z6dQ,X&a!p<x$X$j)g,o,r.q1{3d4v5{9a9|;n;q;r;s;v;w;x;y;z;{;|;}<O<P<Q<R<S<W<a<b<c<e<l<m<r<s=`R<{&yS&}!c%wR2O,y%QdOPWXYZrstu!X!^!l#P#T#W#a#k#q#u#x#{#|#}$O$P$Q$R$S$T$U$V$^$b%]%c%p&]&`&d&f&g&i&m&u'S'f'v'x(O(Y(k(o(s)r*t+h,Y,^,c-S-[-o-x.b.i/z0P0^0}1_1`1a1c1g1j1l2]2k2}4y5]5o5q5r6U7w8R8`8l:Q:v;Z!r)T$X$j&y)g,o,r.q1{3d4v5{9a9|;n;q;r;s;v;w;x;y;z;{;|;}<O<P<Q<R<S<W<a<b<c<e<l<m<r<s=`Q,W&aQ0T*|Q2q.UQ6i2uR8x6j!l$Rc#V%a'u'{(g(n(})O)P)Q)V)Z+_-h-m-r-w.^.d.{/}2Z2j2|3_4Z4b6T6b6m8j:O:t;X;d;p!T;})S)e,t.j1v1y3R3Z3[3]3^3b3h5}6n6s6t7l8f8y8}9O:d:r=S!h$Tc#V%a'u'{(g(n)P)Q)V)Z+_-h-m-r-w.^.d.{/}2Z2j2|3_4Z4b6T6b6m8j:O:t;X;d;p!P<P)S)e,t.j1v1y3R3]3^3b3h5}6n6s6t7l8f8y8}9O:d:r=S!d$Xc#V%a'u'{(g(n)V)Z+_-h-m-r-w.^.d.{/}2Z2j2|3_4Z4b6T6b6m8j:O:t;X;d;pQ3l/Tz=`)S)e,t.j1v1y3R3b3h5}6n6s6t7l8f8y8}9O:d:r=SQ=e=gR=f=h'OkOPWXYZrstu!X!^!l#P#T#W#a#k#q#u#x#{#|#}$O$P$Q$R$S$T$U$V$X$^$b$j%]%c%p&]&`&a&d&f&g&i&m&u&y'S'f'v'x(O(Y(k(o(s)g)r*t*|+h,Y,^,c,o,r-S-[-o-x.U.b.i.q/z0P0^0}1_1`1a1c1g1j1l1{2]2k2u2}3d4v4y5]5o5q5r5{6U6j7w8R8`8l9a9|:Q:v;Z;n;q;r;s;v;w;x;y;z;{;|;}<O<P<Q<R<S<W<a<b<c<e<l<m<r<s=`S$kh$lR3e.p'VgOPWXYZhrstu!X!^!l#P#T#W#a#k#q#u#x#{#|#}$O$P$Q$R$S$T$U$V$X$^$b$j$l%]%c%p&]&`&a&d&f&g&i&m&u&y'S'f'v'x(O(Y(k(o(s)g)r*t*|+h,Y,^,c,o,r-S-[-o-x.U.b.i.p.q/z0P0^0}1_1`1a1c1g1j1l1{2]2k2u2}3d4v4y5]5o5q5r5{6U6j7w8R8`8l9a9|:Q:v;Z;n;q;r;s;v;w;x;y;z;{;|;}<O<P<Q<R<S<W<a<b<c<e<l<m<r<s=`T$gf$mQ$efS)^$h)bR)j$mT$ff$mT)`$h)b'VhOPWXYZhrstu!X!^!l#P#T#W#a#k#q#u#x#{#|#}$O$P$Q$R$S$T$U$V$X$^$b$j$l%]%c%p&]&`&a&d&f&g&i&m&u&y'S'f'v'x(O(Y(k(o(s)g)r*t*|+h,Y,^,c,o,r-S-[-o-x.U.b.i.p.q/z0P0^0}1_1`1a1c1g1j1l1{2]2k2u2}3d4v4y5]5o5q5r5{6U6j7w8R8`8l9a9|:Q:v;Z;n;q;r;s;v;w;x;y;z;{;|;}<O<P<Q<R<S<W<a<b<c<e<l<m<r<s=`T$kh$lQ$nhR)i$l%[jOPWXYZrstu!X!^!l#P#T#W#a#k#q#u#x#{#|#}$O$P$Q$R$S$T$U$V$^$b%]%c%p&]&`&a&d&f&g&i&m&u'S'f'v'x(O(Y(k(o(s)r*t*|+h,Y,^,c-S-[-o-x.U.b.i/z0P0^0}1_1`1a1c1g1j1l2]2k2u2}4y5]5o5q5r6U6j7w8R8`8l:Q:v;Z!s=^$X$j&y)g,o,r.q1{3d4v5{9a9|;n;q;r;s;v;w;x;y;z;{;|;}<O<P<Q<R<S<W<a<b<c<e<l<m<r<s=`#alOPXZr!X!^!l#P#a#k#x$j%]&]&`&a&d&f&g&i&m&u'S(s)g*|+h,Y,^,c-S.U.q/z0}1_1`1a1c1g1j1l2u3d4y5]5o5q5r6j7w8R8`v$zi#t%T%U%Y)w)y*R*g*h._/^/|3l4U9Q=]=e=f!z(j#r$`$a$u$x)n)z*X*{+O+m+p.T/_/a0q0t0|2t3v4O4]4_5[6g6}7W8O8u9o:X:n:{<Z<]<_<f<h<j<n<p<t=i=jQ*q%WQ.|)sg3a<U<V<[<^<`<g<i<k<o<q<uv$vi#t%T%U%Y)w)y*R*g*h._/^/|3l4U9Q=]=e=fQ*T$wS*^$y*aQ*r%XQ/l*_!z=O#r$`$a$u$x)n)z*X*{+O+m+p.T/_/a0q0t0|2t3v4O4]4_5[6g6}7W8O8u9o:X:n:{<Z<]<_<f<h<j<n<p<t=i=jf=P<U<V<[<^<`<g<i<k<o<q<uQ=T=aQ=U=bQ=V=cR=W=dv$zi#t%T%U%Y)w)y*R*g*h._/^/|3l4U9Q=]=e=f!z(j#r$`$a$u$x)n)z*X*{+O+m+p.T/_/a0q0t0|2t3v4O4]4_5[6g6}7W8O8u9o:X:n:{<Z<]<_<f<h<j<n<p<t=i=jg3a<U<V<[<^<`<g<i<k<o<q<ulnOXr!X#a%]&d&f&g&i,^,c1g1jQ*W$xQ,l&pQ,m&rR3u/_$Y${i#r#t$`$a$u$x%T%U%Y)n)w)y)z*R*X*g*h*{+O+m+p.T._/^/_/a/|0q0t0|2t3l3v4O4U4]4_5[6g6}7W8O8u9Q9o:X:n:{<U<V<Z<[<]<^<_<`<f<g<h<i<j<k<n<o<p<q<t<u=]=e=f=i=jQ+o&OQ0s+qQ4r0rR7i4sT*`$y*aS*`$y*aT5P0z5QS/j*]4yT4S/r7wQ+P%gQ/k*^Q0Y+QQ1Q+zQ5`1RQ8T5aQ9c7mQ9r8UQ:f9dQ:p9sQ;P:hQ;_;QQ;h;`R;l;in)w$s(l*s/]/t/u2z3s4Y6w7Y:]<}=Z=[!W<f(h)X)}*V.[.x/T/b0R0p0r2y3t3x4q4s6k6l7O7S7[7^9U9Y:|=g=h]<g3`6r8z:Z:[;fp)y$s(l*s/R/]/t/u2z3s4Y6w7Y:]<}=Z=[!Y<h(h)X)}*V.[.x/T/b0R0p0r2w2y3t3x4q4s6k6l7O7S7[7^9U9Y:|=g=h_<i3`6r8z8{:Z:[;fpmOXr!T!X#a%]&Z&d&f&g&i,^,c1g1jQ&W!SR,Y&apmOXr!T!X#a%]&Z&d&f&g&i,^,c1g1jR&W!SQ+s&PR0o+lqmOXr!T!X#a%]&Z&d&f&g&i,^,c1g1jQ0{+xS5Z1O1PU7}5X5Y5^S9n8P8QS:l9m9pQ;T:mR;b;UQ&_!TR,S&ZR5g1XS%oz%tR0e+]Q&d!UR,^&eR,d&jT1h,c1jR,h&kQ,g&kR1q,hQ'm!xR-i'mQrOQ#aXT%`r#aQ!{TR'o!{Q#OUR'q#OQ)p$rR.y)pQ#RVR's#RQ#UWU'y#U'z-pQ'z#VR-p'{Q,w&zR1},wQ.`(lR2{.`Q.c(nS3O.c3PR3P.dQ-O'QR2R-Or_OXr!T!X#a%]&Z&]&d&f&g&i,^,c1g1jU!mQ'Q-OS#dZ%ZY#n_!m#d-z4zQ-z(]T4z0z5QS#[W%vU(Q#[(R-qQ(R#]R-q'|Q,z&}R2P,zQ(^#gQ-t(VW.O(^-t2h6aQ2h-uR6a2iQ)b$hR.r)bQ$lhR)h$lQ$_cU)W$_-l<TQ-l;pR<T)eQ/W*OW3o/W3p6{9TU3p/X/Y/ZS6{3q3rR9T6|#m)u$s(h(l)X)}*V*n*o*s.Y.Z.[.x/R/S/T/]/b/t/u0R0p0r2w2x2y2z3`3s3t3x4Y4q4s6k6l6p6q6r6w7O7S7Y7[7^8z8{8|9U9Y:Z:[:]:|;f<}=Z=[=g=hQ/`*VU3w/`3y7PQ3y/bR7P3xQ*a$yR/n*aQ*j$}R/w*jQ4^0RR7]4^Q+j%yR0n+jQ4u0uS7k4u9bR9b7lQ+u&QR0x+uQ5Q0zR7u5QQ1W,PS5e1W8XR8X5gQ0`+XW4g0`4i7c9^Q4i0cQ7c4hR9^7dQ+^%oR0f+^Q1j,cR5u1jWqOXr#aQ&h!XQ*v%]Q,]&dQ,_&fQ,`&gQ,b&iQ1e,^S1h,c1jR5t1gQ%_oQ&l!]Q&o!_Q&q!`Q&s!aU'e!o4{4|Q+e%uQ+k%zQ,R&_Q,j&nY-Z'['g'h'k7yQ/m*`S1Z,S,VQ1r,iQ1s,lQ1t,m[2[-]-^-a-f-h9kQ4l0iQ4p0pQ5_1QQ5i1]Q5s1fY6S2Z2^2a2c2dQ7g4nQ7h4qQ7t5PQ8S5`Q8Y5hY8i6T6X6Z6]6^Q9_7eQ9q8TQ9v8ZW9}8j8n8p8rQ:c9`Q:e9cQ:o9rU:s:O:S:UQ;O:fQ;V:pS;W:t:xQ;^;PQ;c;XQ;g;_Q;j;dQ;k;hR;m;lQ%iwQ'U!fQ'c!oU+S%j%k%lQ,q&wU-U'V'W'XS-Y'['iQ/d*ZS0[+T+UQ1z,sS2W-V-WS2_-_-aQ3|/hQ4a0]Q6O2QQ6R2XS6W2`2dQ7T4QS8m6Y6^Q:R8oR:w:TS$ti=]R*k%OU$}i%O=]R/v*iQ$siS(h#r+OQ(l#tS)X$`$aQ)}$uQ*V$xQ*n%TQ*o%UQ*s%YQ.Y<ZQ.Z<]Q.[<_Q.x)nQ/R)wQ/S)yQ/T)zQ/]*RQ/b*XQ/t*gQ/u*hh0R*{.T0|2t5[6g8O8u9o:X:n:{Q0p+mQ0r+pQ2w<fQ2x<hQ2y<jQ2z._S3`<U<VQ3s/^Q3t/_Q3x/aQ4Y/|Q4q0qQ4s0tQ6k<nQ6l<pQ6p<[Q6q<^Q6r<`Q6w3lQ7O3vQ7S4OQ7Y4UQ7[4]Q7^4_Q8z<kQ8{<gQ8|<iQ9U6}Q9Y7WQ:Z<oQ:[<qQ:]9QQ:|<tQ;f<uQ<}=]Q=Z=eQ=[=fQ=g=iR=h=jloOXr!X#a%]&d&f&g&i,^,c1g1jQ!dPS#cZ#kQ&n!^U'Y!l4y7wQ'r#PQ(u#xQ)f$jS,V&]&`Q,Z&aQ,i&mQ,n&uQ-Q'SQ.f(sQ.v)gQ0U*|Q0l+hQ1b,YQ2U-SQ2r.UQ3g.qQ4W/zQ5Y0}Q5k1_Q5l1`Q5n1aQ5p1cQ5w1lQ6f2uQ6u3dQ8Q5]Q8_5oQ8a5qQ8b5rQ8w6jQ9p8RR9x8`#UcOPXZr!X!^!l#a#k#x%]&]&`&a&d&f&g&i&m&u'S(s*|+h,Y,^,c-S.U/z0}1_1`1a1c1g1j1l2u4y5]5o5q5r6j7w8R8`Q#VWQ#bYQ%asQ%btQ%duS'u#T'xQ'{#WQ(g#qQ(n#uQ(v#{Q(w#|Q(x#}Q(y$OQ(z$PQ({$QQ(|$RQ(}$SQ)O$TQ)P$UQ)Q$VQ)S$XQ)V$^Q)Z$bW)e$j)g.q3dQ*y%cQ+_%pS,t&y1{Q-h'fS-m'v-oQ-r(OQ-w(YQ.^(kQ.d(oQ.h;nQ.j;qQ.k;rQ.l;sQ.{)rQ/}*tQ1v,oQ1y,rQ2Z-[Q2j-xQ2|.bQ3R;vQ3S;wQ3T;xQ3U;yQ3V;zQ3W;{Q3X;|Q3Y;}Q3Z<OQ3[<PQ3]<QQ3^<RQ3_.iQ3b<WQ3c<aQ3h<SQ4Z0PQ4b0^Q5}<bQ6T2]Q6b2kQ6m2}Q6n<cQ6s<eQ6t<lQ7l4vQ8f5{Q8j6UQ8y<mQ8}<rQ9O<sQ:O8lQ:d9aQ:r9|Q:t:QQ;X:vQ;d;ZQ;p#PR=S=`R#XWR&{!cU!oQ'Q-OS&w!c,vY'[!m!s!t!u!vS'i!p!r['k!w4z5S5T5U5VS,s&x'PS-_']'^U-a'_'`'aY-f'b7p7q7r7|Q2Q,|S2`-`-bU2c-c9e9fS2d-d-eS4{0z5QS6Y2b2eS6]2f:gQ6^2gS8o6[6_Q8r6`R:T8qR(m#tR(p#uQ!dQT,}'Q-OQ#l]R'Z;oT#hZ%ZS#gZ%ZU%y|},[U(V#d#f#iS-u(W(XQ-|(]Q0m+iQ2i-vU2l-z-{-}S6c2m2nR8s6d`#ZW#T#W%v'v(P+f-st#eZ|}#d#f#i%Z(W(X(]+i-v-z-{-}2m2n6dQ1d,[Q1w,pQ5y1oQ8e5zT<z&y+gT#^W%vS#]W%vS'w#T(PS'|#W+fS,u&y+gT-n'v-sT'O!c%wQ$hfR)l$mT)a$h)bR3f.pT*Q$u*SR*Y$xQ0S*{Q2p.TQ5X0|Q6h2tQ8P5[Q8v6gQ9m8OQ:V8uQ:m9oQ:z:XQ;U:nR;]:{lpOXr!X#a%]&d&f&g&i,^,c1g1jQ&^!TR,R&ZV%z|},[R0v+rR,Q&XQ%szR+d%tR+Y%nT&b!U&eT&c!U&eT1i,c1j",
  nodeNames: "⚠ ArithOp ArithOp LineComment BlockComment Script ExportDeclaration export Star as VariableName String Escape from ; default FunctionDeclaration async function VariableDefinition > TypeParamList TypeDefinition extends ThisType this LiteralType ArithOp Number BooleanLiteral TemplateType InterpolationEnd Interpolation InterpolationStart NullType null VoidType void TypeofType typeof MemberExpression . ?. PropertyName [ TemplateString Escape Interpolation super RegExp ] ArrayExpression Spread , } { ObjectExpression Property async get set PropertyDefinition Block : NewExpression new TypeArgList CompareOp < ) ( ArgList UnaryExpression delete LogicOp BitOp YieldExpression yield AwaitExpression await ParenthesizedExpression ClassExpression class ClassBody MethodDeclaration Decorator @ MemberExpression PrivatePropertyName CallExpression Privacy static abstract override PrivatePropertyDefinition PropertyDeclaration readonly accessor Optional TypeAnnotation Equals StaticBlock FunctionExpression ArrowFunction ParamList ParamList ArrayPattern ObjectPattern PatternProperty Privacy readonly Arrow MemberExpression BinaryExpression ArithOp ArithOp ArithOp ArithOp BitOp CompareOp instanceof satisfies in const CompareOp BitOp BitOp BitOp LogicOp LogicOp ConditionalExpression LogicOp LogicOp AssignmentExpression UpdateOp PostfixExpression CallExpression TaggedTemplateExpression DynamicImport import ImportMeta JSXElement JSXSelfCloseEndTag JSXStartTag JSXSelfClosingTag JSXIdentifier JSXBuiltin JSXIdentifier JSXNamespacedName JSXMemberExpression JSXSpreadAttribute JSXAttribute JSXAttributeValue JSXEscape JSXEndTag JSXOpenTag JSXFragmentTag JSXText JSXEscape JSXStartCloseTag JSXCloseTag PrefixCast ArrowFunction TypeParamList SequenceExpression KeyofType keyof UniqueType unique ImportType InferredType infer TypeName ParenthesizedType FunctionSignature ParamList NewSignature IndexedType TupleType Label ArrayType ReadonlyType ObjectType MethodType PropertyType IndexSignature PropertyDefinition CallSignature TypePredicate is NewSignature new UnionType LogicOp IntersectionType LogicOp ConditionalType ParameterizedType ClassDeclaration abstract implements type VariableDeclaration let var TypeAliasDeclaration InterfaceDeclaration interface EnumDeclaration enum EnumBody NamespaceDeclaration namespace module AmbientDeclaration declare GlobalDeclaration global ClassDeclaration ClassBody MethodDeclaration AmbientFunctionDeclaration ExportGroup VariableName VariableName ImportDeclaration ImportGroup ForStatement for ForSpec ForInSpec ForOfSpec of WhileStatement while WithStatement with DoStatement do IfStatement if else SwitchStatement switch SwitchBody CaseLabel case DefaultLabel TryStatement try CatchClause catch FinallyClause finally ReturnStatement return ThrowStatement throw BreakStatement break ContinueStatement continue DebuggerStatement debugger LabeledStatement ExpressionStatement SingleExpression SingleClassItem",
  maxTerm: 362,
  context: pQ,
  nodeProps: [
    ["group", -26, 6, 14, 16, 62, 198, 202, 205, 206, 208, 211, 214, 225, 227, 233, 235, 237, 239, 242, 248, 254, 256, 258, 260, 262, 264, 265, "Statement", -32, 10, 11, 25, 28, 29, 35, 45, 48, 49, 51, 56, 64, 72, 76, 78, 80, 81, 102, 103, 112, 113, 130, 133, 135, 136, 137, 138, 140, 141, 161, 162, 164, "Expression", -23, 24, 26, 30, 34, 36, 38, 165, 167, 169, 170, 172, 173, 174, 176, 177, 178, 180, 181, 182, 192, 194, 196, 197, "Type", -3, 84, 95, 101, "ClassItem"],
    ["openedBy", 31, "InterpolationStart", 50, "[", 54, "{", 69, "(", 142, "JSXStartTag", 154, "JSXStartTag JSXStartCloseTag"],
    ["closedBy", 33, "InterpolationEnd", 44, "]", 55, "}", 70, ")", 143, "JSXSelfCloseEndTag JSXEndTag", 159, "JSXEndTag"]
  ],
  propSources: [mQ],
  skippedNodes: [0, 3, 4, 268],
  repeatNodeCount: 32,
  tokenData: "$>y(CSR!bOX%ZXY+gYZ-yZ[+g[]%Z]^.c^p%Zpq+gqr/mrs3cst:_tu>PuvBavwDxwxGgxyMvyz! Qz{!![{|!%O|}!&]}!O!%O!O!P!'g!P!Q!1w!Q!R#0t!R![#3T![!]#@T!]!^#Aa!^!_#Bk!_!`#GS!`!a#In!a!b#N{!b!c$$z!c!}>P!}#O$&U#O#P$'`#P#Q$,w#Q#R$.R#R#S>P#S#T$/`#T#o$0j#o#p$4z#p#q$5p#q#r$7Q#r#s$8^#s$f%Z$f$g+g$g#BY>P#BY#BZ$9h#BZ$IS>P$IS$I_$9h$I_$I|>P$I|$I}$<s$I}$JO$<s$JO$JT>P$JT$JU$9h$JU$KV>P$KV$KW$9h$KW&FU>P&FU&FV$9h&FV;'S>P;'S;=`BZ<%l?HT>P?HT?HU$9h?HUO>P(n%d_$c&j'vp'y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z&j&hT$c&jO!^&c!_#o&c#p;'S&c;'S;=`&w<%lO&c&j&zP;=`<%l&c'|'U]$c&j'y!bOY&}YZ&cZw&}wx&cx!^&}!^!_'}!_#O&}#O#P&c#P#o&}#o#p'}#p;'S&};'S;=`(l<%lO&}!b(SU'y!bOY'}Zw'}x#O'}#P;'S'};'S;=`(f<%lO'}!b(iP;=`<%l'}'|(oP;=`<%l&}'[(y]$c&j'vpOY(rYZ&cZr(rrs&cs!^(r!^!_)r!_#O(r#O#P&c#P#o(r#o#p)r#p;'S(r;'S;=`*a<%lO(rp)wU'vpOY)rZr)rs#O)r#P;'S)r;'S;=`*Z<%lO)rp*^P;=`<%l)r'[*dP;=`<%l(r#S*nX'vp'y!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g#S+^P;=`<%l*g(n+dP;=`<%l%Z(CS+rq$c&j'vp'y!b'l(;dOX%ZXY+gYZ&cZ[+g[p%Zpq+gqr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p$f%Z$f$g+g$g#BY%Z#BY#BZ+g#BZ$IS%Z$IS$I_+g$I_$JT%Z$JT$JU+g$JU$KV%Z$KV$KW+g$KW&FU%Z&FU&FV+g&FV;'S%Z;'S;=`+a<%l?HT%Z?HT?HU+g?HUO%Z(CS.ST'w#S$c&j'm(;dO!^&c!_#o&c#p;'S&c;'S;=`&w<%lO&c(CS.n_$c&j'vp'y!b'm(;dOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#`/x`$c&j!l$Ip'vp'y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`0z!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#S1V`#p$Id$c&j'vp'y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`2X!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#S2d_#p$Id$c&j'vp'y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$2b3l_'u$(n$c&j'y!bOY4kYZ5qZr4krs7nsw4kwx5qx!^4k!^!_8p!_#O4k#O#P5q#P#o4k#o#p8p#p;'S4k;'S;=`:X<%lO4k*r4r_$c&j'y!bOY4kYZ5qZr4krs7nsw4kwx5qx!^4k!^!_8p!_#O4k#O#P5q#P#o4k#o#p8p#p;'S4k;'S;=`:X<%lO4k)`5vX$c&jOr5qrs6cs!^5q!^!_6y!_#o5q#o#p6y#p;'S5q;'S;=`7h<%lO5q)`6jT$^#t$c&jO!^&c!_#o&c#p;'S&c;'S;=`&w<%lO&c#t6|TOr6yrs7]s;'S6y;'S;=`7b<%lO6y#t7bO$^#t#t7eP;=`<%l6y)`7kP;=`<%l5q*r7w]$^#t$c&j'y!bOY&}YZ&cZw&}wx&cx!^&}!^!_'}!_#O&}#O#P&c#P#o&}#o#p'}#p;'S&};'S;=`(l<%lO&}%W8uZ'y!bOY8pYZ6yZr8prs9hsw8pwx6yx#O8p#O#P6y#P;'S8p;'S;=`:R<%lO8p%W9oU$^#t'y!bOY'}Zw'}x#O'}#P;'S'};'S;=`(f<%lO'}%W:UP;=`<%l8p*r:[P;=`<%l4k#%|:hg$c&j'vp'y!bOY%ZYZ&cZr%Zrs&}st%Ztu<Puw%Zwx(rx!^%Z!^!_*g!_!c%Z!c!}<P!}#O%Z#O#P&c#P#R%Z#R#S<P#S#T%Z#T#o<P#o#p*g#p$g%Z$g;'S<P;'S;=`=y<%lO<P#%|<[i$c&j(_!L^'vp'y!bOY%ZYZ&cZr%Zrs&}st%Ztu<Puw%Zwx(rx!Q%Z!Q![<P![!^%Z!^!_*g!_!c%Z!c!}<P!}#O%Z#O#P&c#P#R%Z#R#S<P#S#T%Z#T#o<P#o#p*g#p$g%Z$g;'S<P;'S;=`=y<%lO<P#%|=|P;=`<%l<P(CS>`k$c&j'vp'y!b(T!LY's&;d$V#tOY%ZYZ&cZr%Zrs&}st%Ztu>Puw%Zwx(rx}%Z}!O@T!O!Q%Z!Q![>P![!^%Z!^!_*g!_!c%Z!c!}>P!}#O%Z#O#P&c#P#R%Z#R#S>P#S#T%Z#T#o>P#o#p*g#p$g%Z$g;'S>P;'S;=`BZ<%lO>P+d@`k$c&j'vp'y!b$V#tOY%ZYZ&cZr%Zrs&}st%Ztu@Tuw%Zwx(rx}%Z}!O@T!O!Q%Z!Q![@T![!^%Z!^!_*g!_!c%Z!c!}@T!}#O%Z#O#P&c#P#R%Z#R#S@T#S#T%Z#T#o@T#o#p*g#p$g%Z$g;'S@T;'S;=`BT<%lO@T+dBWP;=`<%l@T(CSB^P;=`<%l>P%#SBl`$c&j'vp'y!b#h$IdOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Cn!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#SCy_$c&j#z$Id'vp'y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%DfETa(h%<v$c&j'vp'y!bOY%ZYZ&cZr%Zrs&}sv%ZvwFYwx(rx!^%Z!^!_*g!_!`Cn!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#SFe`$c&j#t$Id'vp'y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Cn!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$2bGp_'x$)`$c&j'vpOYHoYZIuZrHorsIuswHowxKVx!^Ho!^!_LX!_#OHo#O#PIu#P#oHo#o#pLX#p;'SHo;'S;=`Mp<%lOHo*QHv_$c&j'vpOYHoYZIuZrHorsIuswHowxKVx!^Ho!^!_LX!_#OHo#O#PIu#P#oHo#o#pLX#p;'SHo;'S;=`Mp<%lOHo)`IzX$c&jOwIuwx6cx!^Iu!^!_Jg!_#oIu#o#pJg#p;'SIu;'S;=`KP<%lOIu#tJjTOwJgwx7]x;'SJg;'S;=`Jy<%lOJg#tJ|P;=`<%lJg)`KSP;=`<%lIu*QK`]$^#t$c&j'vpOY(rYZ&cZr(rrs&cs!^(r!^!_)r!_#O(r#O#P&c#P#o(r#o#p)r#p;'S(r;'S;=`*a<%lO(r$fL^Z'vpOYLXYZJgZrLXrsJgswLXwxMPx#OLX#O#PJg#P;'SLX;'S;=`Mj<%lOLX$fMWU$^#t'vpOY)rZr)rs#O)r#P;'S)r;'S;=`*Z<%lO)r$fMmP;=`<%lLX*QMsP;=`<%lHo(*QNR_!h(!b$c&j'vp'y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z!'l! ]_!gM|$c&j'vp'y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'+h!!ib$c&j'vp'y!b't#)d#i$IdOY%ZYZ&cZr%Zrs&}sw%Zwx(rxz%Zz{!#q{!^%Z!^!_*g!_!`Cn!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#S!#|`$c&j'vp'y!b#f$IdOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Cn!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z&-O!%Z`$c&j'vp'y!bk&%`OY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Cn!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z&C[!&h_!V&;l$c&j'vp'y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(CS!'rc$c&j'vp'y!by'<nOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!O%Z!O!P!(}!P!Q%Z!Q![!+g![!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z!'d!)Wa$c&j'vp'y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!O%Z!O!P!*]!P!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z!'d!*h_!UMt$c&j'vp'y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/l!+rg$c&j'vp'y!bl$'|OY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![!+g![!^%Z!^!_*g!_!g%Z!g!h!-Z!h#O%Z#O#P&c#P#R%Z#R#S!+g#S#X%Z#X#Y!-Z#Y#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/l!-dg$c&j'vp'y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx{%Z{|!.{|}%Z}!O!.{!O!Q%Z!Q![!0a![!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S!0a#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/l!/Uc$c&j'vp'y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![!0a![!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S!0a#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/l!0lc$c&j'vp'y!bl$'|OY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![!0a![!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S!0a#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(CS!2Sf$c&j'vp'y!b#g$IdOY!3hYZ&cZr!3hrs!4{sw!3hwx!C}xz!3hz{#$s{!P!3h!P!Q#&Y!Q!^!3h!^!_!Mh!_!`#-x!`!a#/_!a!}!3h!}#O##[#O#P!<w#P#o!3h#o#p!Mh#p;'S!3h;'S;=`#$m<%lO!3h(r!3sb$c&j'vp'y!b!RSOY!3hYZ&cZr!3hrs!4{sw!3hwx!C}x!P!3h!P!Q!Kh!Q!^!3h!^!_!Mh!_!}!3h!}#O##[#O#P!<w#P#o!3h#o#p!Mh#p;'S!3h;'S;=`#$m<%lO!3h(Q!5U`$c&j'y!b!RSOY!4{YZ&cZw!4{wx!6Wx!P!4{!P!Q!=o!Q!^!4{!^!_!?g!_!}!4{!}#O!Bn#O#P!<w#P#o!4{#o#p!?g#p;'S!4{;'S;=`!Cw<%lO!4{&n!6_^$c&j!RSOY!6WYZ&cZ!P!6W!P!Q!7Z!Q!^!6W!^!_!8g!_!}!6W!}#O!;U#O#P!<w#P#o!6W#o#p!8g#p;'S!6W;'S;=`!=i<%lO!6W&n!7ba$c&j!RSO!^&c!_#Z&c#Z#[!7Z#[#]&c#]#^!7Z#^#a&c#a#b!7Z#b#g&c#g#h!7Z#h#i&c#i#j!7Z#j#m&c#m#n!7Z#n#o&c#p;'S&c;'S;=`&w<%lO&cS!8lX!RSOY!8gZ!P!8g!P!Q!9X!Q!}!8g!}#O!9p#O#P!:o#P;'S!8g;'S;=`!;O<%lO!8gS!9^U!RS#Z#[!9X#]#^!9X#a#b!9X#g#h!9X#i#j!9X#m#n!9XS!9sVOY!9pZ#O!9p#O#P!:Y#P#Q!8g#Q;'S!9p;'S;=`!:i<%lO!9pS!:]SOY!9pZ;'S!9p;'S;=`!:i<%lO!9pS!:lP;=`<%l!9pS!:rSOY!8gZ;'S!8g;'S;=`!;O<%lO!8gS!;RP;=`<%l!8g&n!;Z[$c&jOY!;UYZ&cZ!^!;U!^!_!9p!_#O!;U#O#P!<P#P#Q!6W#Q#o!;U#o#p!9p#p;'S!;U;'S;=`!<q<%lO!;U&n!<UX$c&jOY!;UYZ&cZ!^!;U!^!_!9p!_#o!;U#o#p!9p#p;'S!;U;'S;=`!<q<%lO!;U&n!<tP;=`<%l!;U&n!<|X$c&jOY!6WYZ&cZ!^!6W!^!_!8g!_#o!6W#o#p!8g#p;'S!6W;'S;=`!=i<%lO!6W&n!=lP;=`<%l!6W(Q!=xi$c&j'y!b!RSOY&}YZ&cZw&}wx&cx!^&}!^!_'}!_#O&}#O#P&c#P#Z&}#Z#[!=o#[#]&}#]#^!=o#^#a&}#a#b!=o#b#g&}#g#h!=o#h#i&}#i#j!=o#j#m&}#m#n!=o#n#o&}#o#p'}#p;'S&};'S;=`(l<%lO&}!f!?nZ'y!b!RSOY!?gZw!?gwx!8gx!P!?g!P!Q!@a!Q!}!?g!}#O!Ap#O#P!:o#P;'S!?g;'S;=`!Bh<%lO!?g!f!@hb'y!b!RSOY'}Zw'}x#O'}#P#Z'}#Z#[!@a#[#]'}#]#^!@a#^#a'}#a#b!@a#b#g'}#g#h!@a#h#i'}#i#j!@a#j#m'}#m#n!@a#n;'S'};'S;=`(f<%lO'}!f!AuX'y!bOY!ApZw!Apwx!9px#O!Ap#O#P!:Y#P#Q!?g#Q;'S!Ap;'S;=`!Bb<%lO!Ap!f!BeP;=`<%l!Ap!f!BkP;=`<%l!?g(Q!Bu^$c&j'y!bOY!BnYZ&cZw!Bnwx!;Ux!^!Bn!^!_!Ap!_#O!Bn#O#P!<P#P#Q!4{#Q#o!Bn#o#p!Ap#p;'S!Bn;'S;=`!Cq<%lO!Bn(Q!CtP;=`<%l!Bn(Q!CzP;=`<%l!4{'`!DW`$c&j'vp!RSOY!C}YZ&cZr!C}rs!6Ws!P!C}!P!Q!EY!Q!^!C}!^!_!GQ!_!}!C}!}#O!JX#O#P!<w#P#o!C}#o#p!GQ#p;'S!C};'S;=`!Kb<%lO!C}'`!Eci$c&j'vp!RSOY(rYZ&cZr(rrs&cs!^(r!^!_)r!_#O(r#O#P&c#P#Z(r#Z#[!EY#[#](r#]#^!EY#^#a(r#a#b!EY#b#g(r#g#h!EY#h#i(r#i#j!EY#j#m(r#m#n!EY#n#o(r#o#p)r#p;'S(r;'S;=`*a<%lO(rt!GXZ'vp!RSOY!GQZr!GQrs!8gs!P!GQ!P!Q!Gz!Q!}!GQ!}#O!IZ#O#P!:o#P;'S!GQ;'S;=`!JR<%lO!GQt!HRb'vp!RSOY)rZr)rs#O)r#P#Z)r#Z#[!Gz#[#])r#]#^!Gz#^#a)r#a#b!Gz#b#g)r#g#h!Gz#h#i)r#i#j!Gz#j#m)r#m#n!Gz#n;'S)r;'S;=`*Z<%lO)rt!I`X'vpOY!IZZr!IZrs!9ps#O!IZ#O#P!:Y#P#Q!GQ#Q;'S!IZ;'S;=`!I{<%lO!IZt!JOP;=`<%l!IZt!JUP;=`<%l!GQ'`!J`^$c&j'vpOY!JXYZ&cZr!JXrs!;Us!^!JX!^!_!IZ!_#O!JX#O#P!<P#P#Q!C}#Q#o!JX#o#p!IZ#p;'S!JX;'S;=`!K[<%lO!JX'`!K_P;=`<%l!JX'`!KeP;=`<%l!C}(r!Ksk$c&j'vp'y!b!RSOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#Z%Z#Z#[!Kh#[#]%Z#]#^!Kh#^#a%Z#a#b!Kh#b#g%Z#g#h!Kh#h#i%Z#i#j!Kh#j#m%Z#m#n!Kh#n#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z#W!Mq]'vp'y!b!RSOY!MhZr!Mhrs!?gsw!Mhwx!GQx!P!Mh!P!Q!Nj!Q!}!Mh!}#O#!U#O#P!:o#P;'S!Mh;'S;=`##U<%lO!Mh#W!Nse'vp'y!b!RSOY*gZr*grs'}sw*gwx)rx#O*g#P#Z*g#Z#[!Nj#[#]*g#]#^!Nj#^#a*g#a#b!Nj#b#g*g#g#h!Nj#h#i*g#i#j!Nj#j#m*g#m#n!Nj#n;'S*g;'S;=`+Z<%lO*g#W#!]Z'vp'y!bOY#!UZr#!Urs!Apsw#!Uwx!IZx#O#!U#O#P!:Y#P#Q!Mh#Q;'S#!U;'S;=`##O<%lO#!U#W##RP;=`<%l#!U#W##XP;=`<%l!Mh(r##e`$c&j'vp'y!bOY##[YZ&cZr##[rs!Bnsw##[wx!JXx!^##[!^!_#!U!_#O##[#O#P!<P#P#Q!3h#Q#o##[#o#p#!U#p;'S##[;'S;=`#$g<%lO##[(r#$jP;=`<%l##[(r#$pP;=`<%l!3h(CS#%Qb$c&j'vp'y!b'n(;d!RSOY!3hYZ&cZr!3hrs!4{sw!3hwx!C}x!P!3h!P!Q!Kh!Q!^!3h!^!_!Mh!_!}!3h!}#O##[#O#P!<w#P#o!3h#o#p!Mh#p;'S!3h;'S;=`#$m<%lO!3h(CS#&e_$c&j'vp'y!bR(;dOY#&YYZ&cZr#&Yrs#'dsw#&Ywx#*tx!^#&Y!^!_#,s!_#O#&Y#O#P#(f#P#o#&Y#o#p#,s#p;'S#&Y;'S;=`#-r<%lO#&Y(Bb#'m]$c&j'y!bR(;dOY#'dYZ&cZw#'dwx#(fx!^#'d!^!_#)w!_#O#'d#O#P#(f#P#o#'d#o#p#)w#p;'S#'d;'S;=`#*n<%lO#'d(AO#(mX$c&jR(;dOY#(fYZ&cZ!^#(f!^!_#)Y!_#o#(f#o#p#)Y#p;'S#(f;'S;=`#)q<%lO#(f(;d#)_SR(;dOY#)YZ;'S#)Y;'S;=`#)k<%lO#)Y(;d#)nP;=`<%l#)Y(AO#)tP;=`<%l#(f(<v#*OW'y!bR(;dOY#)wZw#)wwx#)Yx#O#)w#O#P#)Y#P;'S#)w;'S;=`#*h<%lO#)w(<v#*kP;=`<%l#)w(Bb#*qP;=`<%l#'d(Ap#*}]$c&j'vpR(;dOY#*tYZ&cZr#*trs#(fs!^#*t!^!_#+v!_#O#*t#O#P#(f#P#o#*t#o#p#+v#p;'S#*t;'S;=`#,m<%lO#*t(<U#+}W'vpR(;dOY#+vZr#+vrs#)Ys#O#+v#O#P#)Y#P;'S#+v;'S;=`#,g<%lO#+v(<U#,jP;=`<%l#+v(Ap#,pP;=`<%l#*t(=h#,|Y'vp'y!bR(;dOY#,sZr#,srs#)wsw#,swx#+vx#O#,s#O#P#)Y#P;'S#,s;'S;=`#-l<%lO#,s(=h#-oP;=`<%l#,s(CS#-uP;=`<%l#&Y%#W#.Vb$c&j#z$Id'vp'y!b!RSOY!3hYZ&cZr!3hrs!4{sw!3hwx!C}x!P!3h!P!Q!Kh!Q!^!3h!^!_!Mh!_!}!3h!}#O##[#O#P!<w#P#o!3h#o#p!Mh#p;'S!3h;'S;=`#$m<%lO!3h+h#/lb$S#t$c&j'vp'y!b!RSOY!3hYZ&cZr!3hrs!4{sw!3hwx!C}x!P!3h!P!Q!Kh!Q!^!3h!^!_!Mh!_!}!3h!}#O##[#O#P!<w#P#o!3h#o#p!Mh#p;'S!3h;'S;=`#$m<%lO!3h$/l#1Pp$c&j'vp'y!bl$'|OY%ZYZ&cZr%Zrs&}sw%Zwx(rx!O%Z!O!P!+g!P!Q%Z!Q![#3T![!^%Z!^!_*g!_!g%Z!g!h!-Z!h#O%Z#O#P&c#P#R%Z#R#S#3T#S#U%Z#U#V#6_#V#X%Z#X#Y!-Z#Y#b%Z#b#c#5T#c#d#9g#d#l%Z#l#m#<i#m#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/l#3`k$c&j'vp'y!bl$'|OY%ZYZ&cZr%Zrs&}sw%Zwx(rx!O%Z!O!P!+g!P!Q%Z!Q![#3T![!^%Z!^!_*g!_!g%Z!g!h!-Z!h#O%Z#O#P&c#P#R%Z#R#S#3T#S#X%Z#X#Y!-Z#Y#b%Z#b#c#5T#c#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/l#5`_$c&j'vp'y!bl$'|OY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/l#6hd$c&j'vp'y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q!R#7v!R!S#7v!S!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S#7v#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/l#8Rf$c&j'vp'y!bl$'|OY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q!R#7v!R!S#7v!S!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S#7v#S#b%Z#b#c#5T#c#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/l#9pc$c&j'vp'y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q!Y#:{!Y!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S#:{#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/l#;We$c&j'vp'y!bl$'|OY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q!Y#:{!Y!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S#:{#S#b%Z#b#c#5T#c#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/l#<rg$c&j'vp'y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![#>Z![!^%Z!^!_*g!_!c%Z!c!i#>Z!i#O%Z#O#P&c#P#R%Z#R#S#>Z#S#T%Z#T#Z#>Z#Z#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/l#>fi$c&j'vp'y!bl$'|OY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![#>Z![!^%Z!^!_*g!_!c%Z!c!i#>Z!i#O%Z#O#P&c#P#R%Z#R#S#>Z#S#T%Z#T#Z#>Z#Z#b%Z#b#c#5T#c#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%Gh#@b_!a$b$c&j#x%<f'vp'y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z)[#Al_^l$c&j'vp'y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(CS#Bz^'|!*v!e'.r'vp'y!b$T)d(lSOY*gZr*grs'}sw*gwx)rx!P*g!P!Q#Cv!Q!^*g!^!_#Dl!_!`#F^!`#O*g#P;'S*g;'S;=`+Z<%lO*g(n#DPX$e&j'vp'y!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g$Kh#DuZ#j$Id'vp'y!bOY*gZr*grs'}sw*gwx)rx!_*g!_!`#Eh!`#O*g#P;'S*g;'S;=`+Z<%lO*g$Kh#EqX#z$Id'vp'y!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g$Kh#FgX#k$Id'vp'y!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g%Gh#G_a#W%?x$c&j'vp'y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`0z!`!a#Hd!a#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#W#Ho_#c$Ih$c&j'vp'y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%Gh#I}adBf#k$Id$`#|$c&j'vp'y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`#KS!`!a#L^!a#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#S#K__#k$Id$c&j'vp'y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#S#Lia#j$Id$c&j'vp'y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Cn!`!a#Mn!a#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#S#My`#j$Id$c&j'vp'y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Cn!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'+h$ Wc(`$Ip$c&j'vp'y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!O%Z!O!P$!c!P!^%Z!^!_*g!_!a%Z!a!b$#m!b#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'+`$!n_z'#p$c&j'vp'y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#S$#x`$c&j#u$Id'vp'y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Cn!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z#&^$%V_!x!Ln$c&j'vp'y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(@^$&a_|(8n$c&j'vp'y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(n$'eZ$c&jO!^$(W!^!_$(n!_#i$(W#i#j$(s#j#l$(W#l#m$*f#m#o$(W#o#p$(n#p;'S$(W;'S;=`$,q<%lO$(W(n$(_T[#S$c&jO!^&c!_#o&c#p;'S&c;'S;=`&w<%lO&c#S$(sO[#S(n$(x[$c&jO!Q&c!Q![$)n![!^&c!_!c&c!c!i$)n!i#T&c#T#Z$)n#Z#o&c#o#p$,U#p;'S&c;'S;=`&w<%lO&c(n$)sZ$c&jO!Q&c!Q![$*f![!^&c!_!c&c!c!i$*f!i#T&c#T#Z$*f#Z#o&c#p;'S&c;'S;=`&w<%lO&c(n$*kZ$c&jO!Q&c!Q![$+^![!^&c!_!c&c!c!i$+^!i#T&c#T#Z$+^#Z#o&c#p;'S&c;'S;=`&w<%lO&c(n$+cZ$c&jO!Q&c!Q![$(W![!^&c!_!c&c!c!i$(W!i#T&c#T#Z$(W#Z#o&c#p;'S&c;'S;=`&w<%lO&c#S$,XR!Q![$,b!c!i$,b#T#Z$,b#S$,eS!Q![$,b!c!i$,b#T#Z$,b#q#r$(n(n$,tP;=`<%l$(W!'l$-S_!SM|$c&j'vp'y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#S$.^`#r$Id$c&j'vp'y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Cn!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z&,v$/k_$c&j'vp'y!b(Q&%WOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(CS$0yk$c&j'vp'y!b(T!LY's&;d$X#tOY%ZYZ&cZr%Zrs&}st%Ztu$0juw%Zwx(rx}%Z}!O$2n!O!Q%Z!Q![$0j![!^%Z!^!_*g!_!c%Z!c!}$0j!}#O%Z#O#P&c#P#R%Z#R#S$0j#S#T%Z#T#o$0j#o#p*g#p$g%Z$g;'S$0j;'S;=`$4t<%lO$0j+d$2yk$c&j'vp'y!b$X#tOY%ZYZ&cZr%Zrs&}st%Ztu$2nuw%Zwx(rx}%Z}!O$2n!O!Q%Z!Q![$2n![!^%Z!^!_*g!_!c%Z!c!}$2n!}#O%Z#O#P&c#P#R%Z#R#S$2n#S#T%Z#T#o$2n#o#p*g#p$g%Z$g;'S$2n;'S;=`$4n<%lO$2n+d$4qP;=`<%l$2n(CS$4wP;=`<%l$0j!5p$5TX!X!3l'vp'y!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g%Df$5{a(g%<v$c&j'vp'y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Cn!`#O%Z#O#P&c#P#o%Z#o#p*g#p#q$#m#q;'S%Z;'S;=`+a<%lO%Z%#`$7__!W$I`o`$c&j'vp'y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(r$8i_!mS$c&j'vp'y!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(CS$9y|$c&j'vp'y!b'l(;d(T!LY's&;d$V#tOX%ZXY+gYZ&cZ[+g[p%Zpq+gqr%Zrs&}st%Ztu>Puw%Zwx(rx}%Z}!O@T!O!Q%Z!Q![>P![!^%Z!^!_*g!_!c%Z!c!}>P!}#O%Z#O#P&c#P#R%Z#R#S>P#S#T%Z#T#o>P#o#p*g#p$f%Z$f$g+g$g#BY>P#BY#BZ$9h#BZ$IS>P$IS$I_$9h$I_$JT>P$JT$JU$9h$JU$KV>P$KV$KW$9h$KW&FU>P&FU&FV$9h&FV;'S>P;'S;=`BZ<%l?HT>P?HT?HU$9h?HUO>P(CS$=Uk$c&j'vp'y!b'm(;d(T!LY's&;d$V#tOY%ZYZ&cZr%Zrs&}st%Ztu>Puw%Zwx(rx}%Z}!O@T!O!Q%Z!Q![>P![!^%Z!^!_*g!_!c%Z!c!}>P!}#O%Z#O#P&c#P#R%Z#R#S>P#S#T%Z#T#o>P#o#p*g#p$g%Z$g;'S>P;'S;=`BZ<%lO>P",
  tokenizers: [fQ, gQ, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, uQ, new Mc("$S~RRtu[#O#Pg#S#T#|~_P#o#pb~gOq~~jVO#i!P#i#j!U#j#l!P#l#m!q#m;'S!P;'S;=`#v<%lO!P~!UO!O~~!XS!Q![!e!c!i!e#T#Z!e#o#p#Z~!hR!Q![!q!c!i!q#T#Z!q~!tR!Q![!}!c!i!}#T#Z!}~#QR!Q![!P!c!i!P#T#Z!P~#^R!Q![#g!c!i#g#T#Z#g~#jS!Q![#g!c!i#g#T#Z#g#q#r!P~#yP;=`<%l!P~$RO(S~~", 141, 325), new Mc("j~RQYZXz{^~^O'p~~aP!P!Qd~iO'q~~", 25, 307)],
  topRules: { Script: [0, 5], SingleExpression: [1, 266], SingleClassItem: [2, 267] },
  dialects: { jsx: 13213, ts: 13215 },
  dynamicPrecedences: { 76: 1, 78: 1, 162: 1, 190: 1 },
  specialized: [{ term: 311, get: (r) => bQ[r] || -1 }, { term: 327, get: (r) => OQ[r] || -1 }, { term: 67, get: (r) => vQ[r] || -1 }],
  tokenPrec: 13238
});
class _O {
  /**
  Create a new completion context. (Mostly useful for testing
  completion sources—in the editor, the extension will create
  these for you.)
  */
  constructor(e, t, l) {
    this.state = e, this.pos = t, this.explicit = l, this.abortListeners = [];
  }
  /**
  Get the extent, content, and (if there is a token) type of the
  token before `this.pos`.
  */
  tokenBefore(e) {
    let t = ze(this.state).resolveInner(this.pos, -1);
    for (; t && e.indexOf(t.name) < 0; )
      t = t.parent;
    return t ? {
      from: t.from,
      to: this.pos,
      text: this.state.sliceDoc(t.from, this.pos),
      type: t.type
    } : null;
  }
  /**
  Get the match of the given expression directly before the
  cursor.
  */
  matchBefore(e) {
    let t = this.state.doc.lineAt(this.pos), l = Math.max(t.from, this.pos - 250), i = t.text.slice(l - t.from, this.pos - t.from), o = i.search(yO(e, !1));
    return o < 0 ? null : { from: l + o, to: this.pos, text: i.slice(o) };
  }
  /**
  Yields true when the query has been aborted. Can be useful in
  asynchronous queries to avoid doing work that will be ignored.
  */
  get aborted() {
    return this.abortListeners == null;
  }
  /**
  Allows you to register abort handlers, which will be called when
  the query is
  [aborted](https://codemirror.net/6/docs/ref/#autocomplete.CompletionContext.aborted).
  */
  addEventListener(e, t) {
    e == "abort" && this.abortListeners && this.abortListeners.push(t);
  }
}
function Uu(r) {
  let e = Object.keys(r).join(""), t = /\w/.test(e);
  return t && (e = e.replace(/\w/g, "")), `[${t ? "\\w" : ""}${e.replace(/[^\w\s]/g, "\\$&")}]`;
}
function _Q(r) {
  let e = /* @__PURE__ */ Object.create(null), t = /* @__PURE__ */ Object.create(null);
  for (let { label: i } of r) {
    e[i[0]] = !0;
    for (let o = 1; o < i.length; o++)
      t[i[o]] = !0;
  }
  let l = Uu(e) + Uu(t) + "*$";
  return [new RegExp("^" + l), new RegExp(l)];
}
function wO(r) {
  let e = r.map((i) => typeof i == "string" ? { label: i } : i), [t, l] = e.every((i) => /^\w+$/.test(i.label)) ? [/\w*$/, /\w+$/] : _Q(e);
  return (i) => {
    let o = i.matchBefore(l);
    return o || i.explicit ? { from: o ? o.from : i.pos, options: e, validFor: t } : null;
  };
}
function wQ(r, e) {
  return (t) => {
    for (let l = ze(t.state).resolveInner(t.pos, -1); l; l = l.parent)
      if (r.indexOf(l.name) > -1)
        return null;
    return e(t);
  };
}
class qu {
  constructor(e, t, l) {
    this.completion = e, this.source = t, this.match = l;
  }
}
function Vr(r) {
  return r.selection.main.head;
}
function yO(r, e) {
  var t;
  let { source: l } = r, i = e && l[0] != "^", o = l[l.length - 1] != "$";
  return !i && !o ? r : new RegExp(`${i ? "^" : ""}(?:${l})${o ? "$" : ""}`, (t = r.flags) !== null && t !== void 0 ? t : r.ignoreCase ? "i" : "");
}
const yQ = /* @__PURE__ */ Lr.define();
function kQ(r, e, t, l) {
  return Object.assign(Object.assign({}, r.changeByRange((i) => {
    if (i == r.selection.main)
      return {
        changes: { from: t, to: l, insert: e },
        range: w.cursor(t + e.length)
      };
    let o = l - t;
    return !i.empty || o && r.sliceDoc(i.from - o, i.from) != r.sliceDoc(t, l) ? { range: i } : {
      changes: { from: i.from - o, to: i.from, insert: e },
      range: w.cursor(i.from - o + e.length)
    };
  })), { userEvent: "input.complete" });
}
function kO(r, e) {
  const t = e.completion.apply || e.completion.label;
  let l = e.source;
  typeof t == "string" ? r.dispatch(Object.assign(Object.assign({}, kQ(r.state, t, l.from, l.to)), { annotations: yQ.of(e.completion) })) : t(r, e.completion, l.from, l.to);
}
const Bu = /* @__PURE__ */ new WeakMap();
function SQ(r) {
  if (!Array.isArray(r))
    return r;
  let e = Bu.get(r);
  return e || Bu.set(r, e = wO(r)), e;
}
class QQ {
  constructor(e) {
    this.pattern = e, this.chars = [], this.folded = [], this.any = [], this.precise = [], this.byWord = [];
    for (let t = 0; t < e.length; ) {
      let l = Be(e, t), i = xt(l);
      this.chars.push(l);
      let o = e.slice(t, t + i), n = o.toUpperCase();
      this.folded.push(Be(n == o ? o.toLowerCase() : n, 0)), t += i;
    }
    this.astral = e.length != this.chars.length;
  }
  // Matches a given word (completion) against the pattern (input).
  // Will return null for no match, and otherwise an array that starts
  // with the match score, followed by any number of `from, to` pairs
  // indicating the matched parts of `word`.
  //
  // The score is a number that is more negative the worse the match
  // is. See `Penalty` above.
  match(e) {
    if (this.pattern.length == 0)
      return [0];
    if (e.length < this.pattern.length)
      return null;
    let { chars: t, folded: l, any: i, precise: o, byWord: n } = this;
    if (t.length == 1) {
      let Q = Be(e, 0);
      return Q == t[0] ? [0, 0, xt(Q)] : Q == l[0] ? [-200, 0, xt(Q)] : null;
    }
    let s = e.indexOf(this.pattern);
    if (s == 0)
      return [0, 0, this.pattern.length];
    let a = t.length, c = 0;
    if (s < 0) {
      for (let Q = 0, P = Math.min(e.length, 200); Q < P && c < a; ) {
        let y = Be(e, Q);
        (y == t[c] || y == l[c]) && (i[c++] = Q), Q += xt(y);
      }
      if (c < a)
        return null;
    }
    let d = 0, h = 0, p = !1, u = 0, f = -1, m = -1, O = /[a-z]/.test(e), x = !0;
    for (let Q = 0, P = Math.min(e.length, 200), y = 0; Q < P && h < a; ) {
      let C = Be(e, Q);
      s < 0 && (d < a && C == t[d] && (o[d++] = Q), u < a && (C == t[u] || C == l[u] ? (u == 0 && (f = Q), m = Q + 1, u++) : u = 0));
      let Z, G = C < 255 ? C >= 48 && C <= 57 || C >= 97 && C <= 122 ? 2 : C >= 65 && C <= 90 ? 1 : 0 : (Z = kd(C)) != Z.toLowerCase() ? 1 : Z != Z.toUpperCase() ? 2 : 0;
      (!Q || G == 1 && O || y == 0 && G != 0) && (t[h] == C || l[h] == C && (p = !0) ? n[h++] = Q : n.length && (x = !1)), y = G, Q += xt(C);
    }
    return h == a && n[0] == 0 && x ? this.result(-100 + (p ? -200 : 0), n, e) : u == a && f == 0 ? [-200 - e.length, 0, m] : s > -1 ? [-700 - e.length, s, s + this.pattern.length] : u == a ? [-200 + -700 - e.length, f, m] : h == a ? this.result(-100 + (p ? -200 : 0) + -700 + (x ? 0 : -1100), n, e) : t.length == 2 ? null : this.result((i[0] ? -700 : 0) + -200 + -1100, i, e);
  }
  result(e, t, l) {
    let i = [e - l.length], o = 1;
    for (let n of t) {
      let s = n + (this.astral ? xt(Be(l, n)) : 1);
      o > 1 && i[o - 1] == n ? i[o - 1] = s : (i[o++] = n, i[o++] = s);
    }
    return i;
  }
}
const Ct = /* @__PURE__ */ Y.define({
  combine(r) {
    return ir(r, {
      activateOnTyping: !0,
      selectOnOpen: !0,
      override: null,
      closeOnBlur: !0,
      maxRenderedOptions: 100,
      defaultKeymap: !0,
      tooltipClass: () => "",
      optionClass: () => "",
      aboveCursor: !1,
      icons: !0,
      addToOptions: [],
      compareCompletions: (e, t) => e.label.localeCompare(t.label),
      interactionDelay: 75
    }, {
      defaultKeymap: (e, t) => e && t,
      closeOnBlur: (e, t) => e && t,
      icons: (e, t) => e && t,
      tooltipClass: (e, t) => (l) => Lu(e(l), t(l)),
      optionClass: (e, t) => (l) => Lu(e(l), t(l)),
      addToOptions: (e, t) => e.concat(t)
    });
  }
});
function Lu(r, e) {
  return r ? e ? r + " " + e : r : e;
}
function $Q(r) {
  let e = r.addToOptions.slice();
  return r.icons && e.push({
    render(t) {
      let l = document.createElement("div");
      return l.classList.add("cm-completionIcon"), t.type && l.classList.add(...t.type.split(/\s+/g).map((i) => "cm-completionIcon-" + i)), l.setAttribute("aria-hidden", "true"), l;
    },
    position: 20
  }), e.push({
    render(t, l, i) {
      let o = document.createElement("span");
      o.className = "cm-completionLabel";
      let { label: n } = t, s = 0;
      for (let a = 1; a < i.length; ) {
        let c = i[a++], d = i[a++];
        c > s && o.appendChild(document.createTextNode(n.slice(s, c)));
        let h = o.appendChild(document.createElement("span"));
        h.appendChild(document.createTextNode(n.slice(c, d))), h.className = "cm-completionMatchedText", s = d;
      }
      return s < n.length && o.appendChild(document.createTextNode(n.slice(s))), o;
    },
    position: 50
  }, {
    render(t) {
      if (!t.detail)
        return null;
      let l = document.createElement("span");
      return l.className = "cm-completionDetail", l.textContent = t.detail, l;
    },
    position: 80
  }), e.sort((t, l) => t.position - l.position).map((t) => t.render);
}
function Gu(r, e, t) {
  if (r <= t)
    return { from: 0, to: r };
  if (e < 0 && (e = 0), e <= r >> 1) {
    let i = Math.floor(e / t);
    return { from: i * t, to: (i + 1) * t };
  }
  let l = Math.floor((r - e) / t);
  return { from: r - (l + 1) * t, to: r - l * t };
}
class PQ {
  constructor(e, t) {
    this.view = e, this.stateField = t, this.info = null, this.placeInfo = {
      read: () => this.measureInfo(),
      write: (s) => this.positionInfo(s),
      key: this
    }, this.space = null, this.currentClass = "";
    let l = e.state.field(t), { options: i, selected: o } = l.open, n = e.state.facet(Ct);
    this.optionContent = $Q(n), this.optionClass = n.optionClass, this.tooltipClass = n.tooltipClass, this.range = Gu(i.length, o, n.maxRenderedOptions), this.dom = document.createElement("div"), this.dom.className = "cm-tooltip-autocomplete", this.updateTooltipClass(e.state), this.dom.addEventListener("mousedown", (s) => {
      for (let a = s.target, c; a && a != this.dom; a = a.parentNode)
        if (a.nodeName == "LI" && (c = /-(\d+)$/.exec(a.id)) && +c[1] < i.length) {
          kO(e, i[+c[1]]), s.preventDefault();
          return;
        }
    }), this.list = this.dom.appendChild(this.createListBox(i, l.id, this.range)), this.list.addEventListener("scroll", () => {
      this.info && this.view.requestMeasure(this.placeInfo);
    });
  }
  mount() {
    this.updateSel();
  }
  update(e) {
    var t, l, i;
    let o = e.state.field(this.stateField), n = e.startState.field(this.stateField);
    this.updateTooltipClass(e.state), o != n && (this.updateSel(), ((t = o.open) === null || t === void 0 ? void 0 : t.disabled) != ((l = n.open) === null || l === void 0 ? void 0 : l.disabled) && this.dom.classList.toggle("cm-tooltip-autocomplete-disabled", !!(!((i = o.open) === null || i === void 0) && i.disabled)));
  }
  updateTooltipClass(e) {
    let t = this.tooltipClass(e);
    if (t != this.currentClass) {
      for (let l of this.currentClass.split(" "))
        l && this.dom.classList.remove(l);
      for (let l of t.split(" "))
        l && this.dom.classList.add(l);
      this.currentClass = t;
    }
  }
  positioned(e) {
    this.space = e, this.info && this.view.requestMeasure(this.placeInfo);
  }
  updateSel() {
    let e = this.view.state.field(this.stateField), t = e.open;
    if ((t.selected > -1 && t.selected < this.range.from || t.selected >= this.range.to) && (this.range = Gu(t.options.length, t.selected, this.view.state.facet(Ct).maxRenderedOptions), this.list.remove(), this.list = this.dom.appendChild(this.createListBox(t.options, e.id, this.range)), this.list.addEventListener("scroll", () => {
      this.info && this.view.requestMeasure(this.placeInfo);
    })), this.updateSelectedOption(t.selected)) {
      this.info && (this.info.remove(), this.info = null);
      let { completion: l } = t.options[t.selected], { info: i } = l;
      if (!i)
        return;
      let o = typeof i == "string" ? document.createTextNode(i) : i(l);
      if (!o)
        return;
      "then" in o ? o.then((n) => {
        n && this.view.state.field(this.stateField, !1) == e && this.addInfoPane(n);
      }).catch((n) => yt(this.view.state, n, "completion info")) : this.addInfoPane(o);
    }
  }
  addInfoPane(e) {
    let t = this.info = document.createElement("div");
    t.className = "cm-tooltip cm-completionInfo", t.appendChild(e), this.dom.appendChild(t), this.view.requestMeasure(this.placeInfo);
  }
  updateSelectedOption(e) {
    let t = null;
    for (let l = this.list.firstChild, i = this.range.from; l; l = l.nextSibling, i++)
      i == e ? l.hasAttribute("aria-selected") || (l.setAttribute("aria-selected", "true"), t = l) : l.hasAttribute("aria-selected") && l.removeAttribute("aria-selected");
    return t && TQ(this.list, t), t;
  }
  measureInfo() {
    let e = this.dom.querySelector("[aria-selected]");
    if (!e || !this.info)
      return null;
    let t = this.dom.getBoundingClientRect(), l = this.info.getBoundingClientRect(), i = e.getBoundingClientRect(), o = this.space;
    if (!o) {
      let f = this.dom.ownerDocument.defaultView || window;
      o = { left: 0, top: 0, right: f.innerWidth, bottom: f.innerHeight };
    }
    if (i.top > Math.min(o.bottom, t.bottom) - 10 || i.bottom < Math.max(o.top, t.top) + 10)
      return null;
    let n = this.view.textDirection == Ce.RTL, s = n, a = !1, c, d = "", h = "", p = t.left - o.left, u = o.right - t.right;
    if (s && p < Math.min(l.width, u) ? s = !1 : !s && u < Math.min(l.width, p) && (s = !0), l.width <= (s ? p : u))
      d = Math.max(o.top, Math.min(i.top, o.bottom - l.height)) - t.top + "px", c = Math.min(400, s ? p : u) + "px";
    else {
      a = !0, c = Math.min(
        400,
        (n ? t.right : o.right - t.left) - 30
        /* Info.Margin */
      ) + "px";
      let f = o.bottom - t.bottom;
      f >= l.height || f > t.top ? d = i.bottom - t.top + "px" : h = t.bottom - i.top + "px";
    }
    return {
      top: d,
      bottom: h,
      maxWidth: c,
      class: a ? n ? "left-narrow" : "right-narrow" : s ? "left" : "right"
    };
  }
  positionInfo(e) {
    this.info && (e ? (this.info.style.top = e.top, this.info.style.bottom = e.bottom, this.info.style.maxWidth = e.maxWidth, this.info.className = "cm-tooltip cm-completionInfo cm-completionInfo-" + e.class) : this.info.style.top = "-1e6px");
  }
  createListBox(e, t, l) {
    const i = document.createElement("ul");
    i.id = t, i.setAttribute("role", "listbox"), i.setAttribute("aria-expanded", "true"), i.setAttribute("aria-label", this.view.state.phrase("Completions"));
    for (let o = l.from; o < l.to; o++) {
      let { completion: n, match: s } = e[o];
      const a = i.appendChild(document.createElement("li"));
      a.id = t + "-" + o, a.setAttribute("role", "option");
      let c = this.optionClass(n);
      c && (a.className = c);
      for (let d of this.optionContent) {
        let h = d(n, this.view.state, s);
        h && a.appendChild(h);
      }
    }
    return l.from && i.classList.add("cm-completionListIncompleteTop"), l.to < e.length && i.classList.add("cm-completionListIncompleteBottom"), i;
  }
}
function CQ(r) {
  return (e) => new PQ(e, r);
}
function TQ(r, e) {
  let t = r.getBoundingClientRect(), l = e.getBoundingClientRect();
  l.top < t.top ? r.scrollTop -= t.top - l.top : l.bottom > t.bottom && (r.scrollTop += l.bottom - t.bottom);
}
function Fu(r) {
  return (r.boost || 0) * 100 + (r.apply ? 10 : 0) + (r.info ? 5 : 0) + (r.type ? 1 : 0);
}
function zQ(r, e) {
  let t = [], l = 0;
  for (let s of r)
    if (s.hasResult())
      if (s.result.filter === !1) {
        let a = s.result.getMatch;
        for (let c of s.result.options) {
          let d = [1e9 - l++];
          if (a)
            for (let h of a(c))
              d.push(h);
          t.push(new qu(c, s, d));
        }
      } else {
        let a = new QQ(e.sliceDoc(s.from, s.to)), c;
        for (let d of s.result.options)
          (c = a.match(d.label)) && (d.boost != null && (c[0] += d.boost), t.push(new qu(d, s, c)));
      }
  let i = [], o = null, n = e.facet(Ct).compareCompletions;
  for (let s of t.sort((a, c) => c.match[0] - a.match[0] || n(a.completion, c.completion)))
    !o || o.label != s.completion.label || o.detail != s.completion.detail || o.type != null && s.completion.type != null && o.type != s.completion.type || o.apply != s.completion.apply ? i.push(s) : Fu(s.completion) > Fu(o) && (i[i.length - 1] = s), o = s.completion;
  return i;
}
class Rl {
  constructor(e, t, l, i, o, n) {
    this.options = e, this.attrs = t, this.tooltip = l, this.timestamp = i, this.selected = o, this.disabled = n;
  }
  setSelected(e, t) {
    return e == this.selected || e >= this.options.length ? this : new Rl(this.options, Hu(t, e), this.tooltip, this.timestamp, e, this.disabled);
  }
  static build(e, t, l, i, o) {
    let n = zQ(e, t);
    if (!n.length)
      return i && e.some(
        (a) => a.state == 1
        /* State.Pending */
      ) ? new Rl(i.options, i.attrs, i.tooltip, i.timestamp, i.selected, !0) : null;
    let s = t.facet(Ct).selectOnOpen ? 0 : -1;
    if (i && i.selected != s && i.selected != -1) {
      let a = i.options[i.selected].completion;
      for (let c = 0; c < n.length; c++)
        if (n[c].completion == a) {
          s = c;
          break;
        }
    }
    return new Rl(n, Hu(l, s), {
      pos: e.reduce((a, c) => c.hasResult() ? Math.min(a, c.from) : a, 1e8),
      create: CQ(St),
      above: o.aboveCursor
    }, i ? i.timestamp : Date.now(), s, !1);
  }
  map(e) {
    return new Rl(this.options, this.attrs, Object.assign(Object.assign({}, this.tooltip), { pos: e.mapPos(this.tooltip.pos) }), this.timestamp, this.selected, this.disabled);
  }
}
class Kn {
  constructor(e, t, l) {
    this.active = e, this.id = t, this.open = l;
  }
  static start() {
    return new Kn(EQ, "cm-ac-" + Math.floor(Math.random() * 2e6).toString(36), null);
  }
  update(e) {
    let { state: t } = e, l = t.facet(Ct), o = (l.override || t.languageDataAt("autocomplete", Vr(t)).map(SQ)).map((s) => (this.active.find((c) => c.source == s) || new ht(
      s,
      this.active.some(
        (c) => c.state != 0
        /* State.Inactive */
      ) ? 1 : 0
      /* State.Inactive */
    )).update(e, l));
    o.length == this.active.length && o.every((s, a) => s == this.active[a]) && (o = this.active);
    let n = this.open;
    n && e.docChanged && (n = n.map(e.changes)), e.selection || o.some((s) => s.hasResult() && e.changes.touchesRange(s.from, s.to)) || !XQ(o, this.active) ? n = Rl.build(o, t, this.id, n, l) : n && n.disabled && !o.some(
      (s) => s.state == 1
      /* State.Pending */
    ) && (n = null), !n && o.every(
      (s) => s.state != 1
      /* State.Pending */
    ) && o.some((s) => s.hasResult()) && (o = o.map((s) => s.hasResult() ? new ht(
      s.source,
      0
      /* State.Inactive */
    ) : s));
    for (let s of e.effects)
      s.is(QO) && (n = n && n.setSelected(s.value, this.id));
    return o == this.active && n == this.open ? this : new Kn(o, this.id, n);
  }
  get tooltip() {
    return this.open ? this.open.tooltip : null;
  }
  get attrs() {
    return this.open ? this.open.attrs : AQ;
  }
}
function XQ(r, e) {
  if (r == e)
    return !0;
  for (let t = 0, l = 0; ; ) {
    for (; t < r.length && !r[t].hasResult; )
      t++;
    for (; l < e.length && !e[l].hasResult; )
      l++;
    let i = t == r.length, o = l == e.length;
    if (i || o)
      return i == o;
    if (r[t++].result != e[l++].result)
      return !1;
  }
}
const AQ = {
  "aria-autocomplete": "list"
};
function Hu(r, e) {
  let t = {
    "aria-autocomplete": "list",
    "aria-haspopup": "listbox",
    "aria-controls": r
  };
  return e > -1 && (t["aria-activedescendant"] = r + "-" + e), t;
}
const EQ = [];
function Ic(r) {
  return r.isUserEvent("input.type") ? "input" : r.isUserEvent("delete.backward") ? "delete" : null;
}
class ht {
  constructor(e, t, l = -1) {
    this.source = e, this.state = t, this.explicitPos = l;
  }
  hasResult() {
    return !1;
  }
  update(e, t) {
    let l = Ic(e), i = this;
    l ? i = i.handleUserEvent(e, l, t) : e.docChanged ? i = i.handleChange(e) : e.selection && i.state != 0 && (i = new ht(
      i.source,
      0
      /* State.Inactive */
    ));
    for (let o of e.effects)
      if (o.is(Bd))
        i = new ht(i.source, 1, o.value ? Vr(e.state) : -1);
      else if (o.is(Jn))
        i = new ht(
          i.source,
          0
          /* State.Inactive */
        );
      else if (o.is(SO))
        for (let n of o.value)
          n.source == i.source && (i = n);
    return i;
  }
  handleUserEvent(e, t, l) {
    return t == "delete" || !l.activateOnTyping ? this.map(e.changes) : new ht(
      this.source,
      1
      /* State.Pending */
    );
  }
  handleChange(e) {
    return e.changes.touchesRange(Vr(e.startState)) ? new ht(
      this.source,
      0
      /* State.Inactive */
    ) : this.map(e.changes);
  }
  map(e) {
    return e.empty || this.explicitPos < 0 ? this : new ht(this.source, this.state, e.mapPos(this.explicitPos));
  }
}
class Vi extends ht {
  constructor(e, t, l, i, o) {
    super(e, 2, t), this.result = l, this.from = i, this.to = o;
  }
  hasResult() {
    return !0;
  }
  handleUserEvent(e, t, l) {
    var i;
    let o = e.changes.mapPos(this.from), n = e.changes.mapPos(this.to, 1), s = Vr(e.state);
    if ((this.explicitPos < 0 ? s <= o : s < this.from) || s > n || t == "delete" && Vr(e.startState) == this.from)
      return new ht(
        this.source,
        t == "input" && l.activateOnTyping ? 1 : 0
        /* State.Inactive */
      );
    let a = this.explicitPos < 0 ? -1 : e.changes.mapPos(this.explicitPos), c;
    return VQ(this.result.validFor, e.state, o, n) ? new Vi(this.source, a, this.result, o, n) : this.result.update && (c = this.result.update(this.result, o, n, new _O(e.state, s, a >= 0))) ? new Vi(this.source, a, c, c.from, (i = c.to) !== null && i !== void 0 ? i : Vr(e.state)) : new ht(this.source, 1, a);
  }
  handleChange(e) {
    return e.changes.touchesRange(this.from, this.to) ? new ht(
      this.source,
      0
      /* State.Inactive */
    ) : this.map(e.changes);
  }
  map(e) {
    return e.empty ? this : new Vi(this.source, this.explicitPos < 0 ? -1 : e.mapPos(this.explicitPos), this.result, e.mapPos(this.from), e.mapPos(this.to, 1));
  }
}
function VQ(r, e, t, l) {
  if (!r)
    return !1;
  let i = e.sliceDoc(t, l);
  return typeof r == "function" ? r(i, t, l, e) : yO(r, !0).test(i);
}
const Bd = /* @__PURE__ */ le.define(), Jn = /* @__PURE__ */ le.define(), SO = /* @__PURE__ */ le.define({
  map(r, e) {
    return r.map((t) => t.map(e));
  }
}), QO = /* @__PURE__ */ le.define(), St = /* @__PURE__ */ Ue.define({
  create() {
    return Kn.start();
  },
  update(r, e) {
    return r.update(e);
  },
  provide: (r) => [
    Ed.from(r, (e) => e.tooltip),
    I.contentAttributes.from(r, (e) => e.attrs)
  ]
});
function qo(r, e = "option") {
  return (t) => {
    let l = t.state.field(St, !1);
    if (!l || !l.open || l.open.disabled || Date.now() - l.open.timestamp < t.state.facet(Ct).interactionDelay)
      return !1;
    let i = 1, o;
    e == "page" && (o = gk(t, l.open.tooltip)) && (i = Math.max(2, Math.floor(o.dom.offsetHeight / o.dom.querySelector("li").offsetHeight) - 1));
    let { length: n } = l.open.options, s = l.open.selected > -1 ? l.open.selected + i * (r ? 1 : -1) : r ? 0 : n - 1;
    return s < 0 ? s = e == "page" ? 0 : n - 1 : s >= n && (s = e == "page" ? n - 1 : 0), t.dispatch({ effects: QO.of(s) }), !0;
  };
}
const ZQ = (r) => {
  let e = r.state.field(St, !1);
  return r.state.readOnly || !e || !e.open || e.open.selected < 0 || Date.now() - e.open.timestamp < r.state.facet(Ct).interactionDelay ? !1 : (e.open.disabled || kO(r, e.open.options[e.open.selected]), !0);
}, RQ = (r) => r.state.field(St, !1) ? (r.dispatch({ effects: Bd.of(!0) }), !0) : !1, DQ = (r) => {
  let e = r.state.field(St, !1);
  return !e || !e.active.some(
    (t) => t.state != 0
    /* State.Inactive */
  ) ? !1 : (r.dispatch({ effects: Jn.of(null) }), !0);
};
class WQ {
  constructor(e, t) {
    this.active = e, this.context = t, this.time = Date.now(), this.updates = [], this.done = void 0;
  }
}
const Ku = 50, NQ = 50, MQ = 1e3, YQ = /* @__PURE__ */ Ze.fromClass(class {
  constructor(r) {
    this.view = r, this.debounceUpdate = -1, this.running = [], this.debounceAccept = -1, this.composing = 0;
    for (let e of r.state.field(St).active)
      e.state == 1 && this.startQuery(e);
  }
  update(r) {
    let e = r.state.field(St);
    if (!r.selectionSet && !r.docChanged && r.startState.field(St) == e)
      return;
    let t = r.transactions.some((l) => (l.selection || l.docChanged) && !Ic(l));
    for (let l = 0; l < this.running.length; l++) {
      let i = this.running[l];
      if (t || i.updates.length + r.transactions.length > NQ && Date.now() - i.time > MQ) {
        for (let o of i.context.abortListeners)
          try {
            o();
          } catch (n) {
            yt(this.view.state, n);
          }
        i.context.abortListeners = null, this.running.splice(l--, 1);
      } else
        i.updates.push(...r.transactions);
    }
    if (this.debounceUpdate > -1 && clearTimeout(this.debounceUpdate), this.debounceUpdate = e.active.some((l) => l.state == 1 && !this.running.some((i) => i.active.source == l.source)) ? setTimeout(() => this.startUpdate(), Ku) : -1, this.composing != 0)
      for (let l of r.transactions)
        Ic(l) == "input" ? this.composing = 2 : this.composing == 2 && l.selection && (this.composing = 3);
  }
  startUpdate() {
    this.debounceUpdate = -1;
    let { state: r } = this.view, e = r.field(St);
    for (let t of e.active)
      t.state == 1 && !this.running.some((l) => l.active.source == t.source) && this.startQuery(t);
  }
  startQuery(r) {
    let { state: e } = this.view, t = Vr(e), l = new _O(e, t, r.explicitPos == t), i = new WQ(r, l);
    this.running.push(i), Promise.resolve(r.source(l)).then((o) => {
      i.context.aborted || (i.done = o || null, this.scheduleAccept());
    }, (o) => {
      this.view.dispatch({ effects: Jn.of(null) }), yt(this.view.state, o);
    });
  }
  scheduleAccept() {
    this.running.every((r) => r.done !== void 0) ? this.accept() : this.debounceAccept < 0 && (this.debounceAccept = setTimeout(() => this.accept(), Ku));
  }
  // For each finished query in this.running, try to create a result
  // or, if appropriate, restart the query.
  accept() {
    var r;
    this.debounceAccept > -1 && clearTimeout(this.debounceAccept), this.debounceAccept = -1;
    let e = [], t = this.view.state.facet(Ct);
    for (let l = 0; l < this.running.length; l++) {
      let i = this.running[l];
      if (i.done === void 0)
        continue;
      if (this.running.splice(l--, 1), i.done) {
        let n = new Vi(i.active.source, i.active.explicitPos, i.done, i.done.from, (r = i.done.to) !== null && r !== void 0 ? r : Vr(i.updates.length ? i.updates[0].startState : this.view.state));
        for (let s of i.updates)
          n = n.update(s, t);
        if (n.hasResult()) {
          e.push(n);
          continue;
        }
      }
      let o = this.view.state.field(St).active.find((n) => n.source == i.active.source);
      if (o && o.state == 1)
        if (i.done == null) {
          let n = new ht(
            i.active.source,
            0
            /* State.Inactive */
          );
          for (let s of i.updates)
            n = n.update(s, t);
          n.state != 1 && e.push(n);
        } else
          this.startQuery(o);
    }
    e.length && this.view.dispatch({ effects: SO.of(e) });
  }
}, {
  eventHandlers: {
    blur() {
      let r = this.view.state.field(St, !1);
      r && r.tooltip && this.view.state.facet(Ct).closeOnBlur && this.view.dispatch({ effects: Jn.of(null) });
    },
    compositionstart() {
      this.composing = 1;
    },
    compositionend() {
      this.composing == 3 && setTimeout(() => this.view.dispatch({ effects: Bd.of(!1) }), 20), this.composing = 0;
    }
  }
}), $O = /* @__PURE__ */ I.baseTheme({
  ".cm-tooltip.cm-tooltip-autocomplete": {
    "& > ul": {
      fontFamily: "monospace",
      whiteSpace: "nowrap",
      overflow: "hidden auto",
      maxWidth_fallback: "700px",
      maxWidth: "min(700px, 95vw)",
      minWidth: "250px",
      maxHeight: "10em",
      height: "100%",
      listStyle: "none",
      margin: 0,
      padding: 0,
      "& > li": {
        overflowX: "hidden",
        textOverflow: "ellipsis",
        cursor: "pointer",
        padding: "1px 3px",
        lineHeight: 1.2
      }
    }
  },
  "&light .cm-tooltip-autocomplete ul li[aria-selected]": {
    background: "#17c",
    color: "white"
  },
  "&light .cm-tooltip-autocomplete-disabled ul li[aria-selected]": {
    background: "#777"
  },
  "&dark .cm-tooltip-autocomplete ul li[aria-selected]": {
    background: "#347",
    color: "white"
  },
  "&dark .cm-tooltip-autocomplete-disabled ul li[aria-selected]": {
    background: "#444"
  },
  ".cm-completionListIncompleteTop:before, .cm-completionListIncompleteBottom:after": {
    content: '"···"',
    opacity: 0.5,
    display: "block",
    textAlign: "center"
  },
  ".cm-tooltip.cm-completionInfo": {
    position: "absolute",
    padding: "3px 9px",
    width: "max-content",
    maxWidth: `${400}px`,
    boxSizing: "border-box"
  },
  ".cm-completionInfo.cm-completionInfo-left": { right: "100%" },
  ".cm-completionInfo.cm-completionInfo-right": { left: "100%" },
  ".cm-completionInfo.cm-completionInfo-left-narrow": { right: `${30}px` },
  ".cm-completionInfo.cm-completionInfo-right-narrow": { left: `${30}px` },
  "&light .cm-snippetField": { backgroundColor: "#00000022" },
  "&dark .cm-snippetField": { backgroundColor: "#ffffff22" },
  ".cm-snippetFieldPosition": {
    verticalAlign: "text-top",
    width: 0,
    height: "1.15em",
    display: "inline-block",
    margin: "0 -0.7px -.7em",
    borderLeft: "1.4px dotted #888"
  },
  ".cm-completionMatchedText": {
    textDecoration: "underline"
  },
  ".cm-completionDetail": {
    marginLeft: "0.5em",
    fontStyle: "italic"
  },
  ".cm-completionIcon": {
    fontSize: "90%",
    width: ".8em",
    display: "inline-block",
    textAlign: "center",
    paddingRight: ".6em",
    opacity: "0.6",
    boxSizing: "content-box"
  },
  ".cm-completionIcon-function, .cm-completionIcon-method": {
    "&:after": { content: "'ƒ'" }
  },
  ".cm-completionIcon-class": {
    "&:after": { content: "'○'" }
  },
  ".cm-completionIcon-interface": {
    "&:after": { content: "'◌'" }
  },
  ".cm-completionIcon-variable": {
    "&:after": { content: "'𝑥'" }
  },
  ".cm-completionIcon-constant": {
    "&:after": { content: "'𝐶'" }
  },
  ".cm-completionIcon-type": {
    "&:after": { content: "'𝑡'" }
  },
  ".cm-completionIcon-enum": {
    "&:after": { content: "'∪'" }
  },
  ".cm-completionIcon-property": {
    "&:after": { content: "'□'" }
  },
  ".cm-completionIcon-keyword": {
    "&:after": { content: "'🔑︎'" }
    // Disable emoji rendering
  },
  ".cm-completionIcon-namespace": {
    "&:after": { content: "'▢'" }
  },
  ".cm-completionIcon-text": {
    "&:after": { content: "'abc'", fontSize: "50%", verticalAlign: "middle" }
  }
});
class jQ {
  constructor(e, t, l, i) {
    this.field = e, this.line = t, this.from = l, this.to = i;
  }
}
class Ld {
  constructor(e, t, l) {
    this.field = e, this.from = t, this.to = l;
  }
  map(e) {
    let t = e.mapPos(this.from, -1, Ge.TrackDel), l = e.mapPos(this.to, 1, Ge.TrackDel);
    return t == null || l == null ? null : new Ld(this.field, t, l);
  }
}
class Gd {
  constructor(e, t) {
    this.lines = e, this.fieldPositions = t;
  }
  instantiate(e, t) {
    let l = [], i = [t], o = e.doc.lineAt(t), n = /^\s*/.exec(o.text)[0];
    for (let a of this.lines) {
      if (l.length) {
        let c = n, d = /^\t*/.exec(a)[0].length;
        for (let h = 0; h < d; h++)
          c += e.facet(Ts);
        i.push(t + c.length - d), a = c + a.slice(d);
      }
      l.push(a), t += a.length + 1;
    }
    let s = this.fieldPositions.map((a) => new Ld(a.field, i[a.line] + a.from, i[a.line] + a.to));
    return { text: l, ranges: s };
  }
  static parse(e) {
    let t = [], l = [], i = [], o;
    for (let n of e.split(/\r\n?|\n/)) {
      for (; o = /[#$]\{(?:(\d+)(?::([^}]*))?|([^}]*))\}/.exec(n); ) {
        let s = o[1] ? +o[1] : null, a = o[2] || o[3] || "", c = -1;
        for (let d = 0; d < t.length; d++)
          (s != null ? t[d].seq == s : a && t[d].name == a) && (c = d);
        if (c < 0) {
          let d = 0;
          for (; d < t.length && (s == null || t[d].seq != null && t[d].seq < s); )
            d++;
          t.splice(d, 0, { seq: s, name: a }), c = d;
          for (let h of i)
            h.field >= c && h.field++;
        }
        i.push(new jQ(c, l.length, o.index, o.index + a.length)), n = n.slice(0, o.index) + a + n.slice(o.index + o[0].length);
      }
      for (let s; s = /\\([{}])/.exec(n); ) {
        n = n.slice(0, s.index) + s[1] + n.slice(s.index + s[0].length);
        for (let a of i)
          a.line == l.length && a.from > s.index && (a.from--, a.to--);
      }
      l.push(n);
    }
    return new Gd(l, i);
  }
}
let IQ = /* @__PURE__ */ B.widget({ widget: /* @__PURE__ */ new class extends br {
  toDOM() {
    let r = document.createElement("span");
    return r.className = "cm-snippetFieldPosition", r;
  }
  ignoreEvent() {
    return !1;
  }
}() }), UQ = /* @__PURE__ */ B.mark({ class: "cm-snippetField" });
class ai {
  constructor(e, t) {
    this.ranges = e, this.active = t, this.deco = B.set(e.map((l) => (l.from == l.to ? IQ : UQ).range(l.from, l.to)));
  }
  map(e) {
    let t = [];
    for (let l of this.ranges) {
      let i = l.map(e);
      if (!i)
        return null;
      t.push(i);
    }
    return new ai(t, this.active);
  }
  selectionInsideField(e) {
    return e.ranges.every((t) => this.ranges.some((l) => l.field == this.active && l.from <= t.from && l.to >= t.to));
  }
}
const vo = /* @__PURE__ */ le.define({
  map(r, e) {
    return r && r.map(e);
  }
}), qQ = /* @__PURE__ */ le.define(), to = /* @__PURE__ */ Ue.define({
  create() {
    return null;
  },
  update(r, e) {
    for (let t of e.effects) {
      if (t.is(vo))
        return t.value;
      if (t.is(qQ) && r)
        return new ai(r.ranges, t.value);
    }
    return r && e.docChanged && (r = r.map(e.changes)), r && e.selection && !r.selectionInsideField(e.selection) && (r = null), r;
  },
  provide: (r) => I.decorations.from(r, (e) => e ? e.deco : B.none)
});
function Fd(r, e) {
  return w.create(r.filter((t) => t.field == e).map((t) => w.range(t.from, t.to)));
}
function BQ(r) {
  let e = Gd.parse(r);
  return (t, l, i, o) => {
    let { text: n, ranges: s } = e.instantiate(t.state, i), a = {
      changes: { from: i, to: o, insert: ue.of(n) },
      scrollIntoView: !0
    };
    if (s.length && (a.selection = Fd(s, 0)), s.length > 1) {
      let c = new ai(s, 0), d = a.effects = [vo.of(c)];
      t.state.field(to, !1) === void 0 && d.push(le.appendConfig.of([to, KQ, JQ, $O]));
    }
    t.dispatch(t.state.update(a));
  };
}
function PO(r) {
  return ({ state: e, dispatch: t }) => {
    let l = e.field(to, !1);
    if (!l || r < 0 && l.active == 0)
      return !1;
    let i = l.active + r, o = r > 0 && !l.ranges.some((n) => n.field == i + r);
    return t(e.update({
      selection: Fd(l.ranges, i),
      effects: vo.of(o ? null : new ai(l.ranges, i))
    })), !0;
  };
}
const LQ = ({ state: r, dispatch: e }) => r.field(to, !1) ? (e(r.update({ effects: vo.of(null) })), !0) : !1, GQ = /* @__PURE__ */ PO(1), FQ = /* @__PURE__ */ PO(-1), HQ = [
  { key: "Tab", run: GQ, shift: FQ },
  { key: "Escape", run: LQ }
], Ju = /* @__PURE__ */ Y.define({
  combine(r) {
    return r.length ? r[0] : HQ;
  }
}), KQ = /* @__PURE__ */ kl.highest(/* @__PURE__ */ mo.compute([Ju], (r) => r.facet(Ju)));
function Et(r, e) {
  return Object.assign(Object.assign({}, e), { apply: BQ(r) });
}
const JQ = /* @__PURE__ */ I.domEventHandlers({
  mousedown(r, e) {
    let t = e.state.field(to, !1), l;
    if (!t || (l = e.posAtCoords({ x: r.clientX, y: r.clientY })) == null)
      return !1;
    let i = t.ranges.find((o) => o.from <= l && o.to >= l);
    return !i || i.field == t.active ? !1 : (e.dispatch({
      selection: Fd(t.ranges, i.field),
      effects: vo.of(t.ranges.some((o) => o.field > i.field) ? new ai(t.ranges, i.field) : null)
    }), !0);
  }
}), ro = {
  brackets: ["(", "[", "{", "'", '"'],
  before: ")]}:;>",
  stringPrefixes: []
}, al = /* @__PURE__ */ le.define({
  map(r, e) {
    let t = e.mapPos(r, -1, Ge.TrackAfter);
    return t ?? void 0;
  }
}), Hd = /* @__PURE__ */ le.define({
  map(r, e) {
    return e.mapPos(r);
  }
}), Kd = /* @__PURE__ */ new class extends Ol {
}();
Kd.startSide = 1;
Kd.endSide = -1;
const CO = /* @__PURE__ */ Ue.define({
  create() {
    return ge.empty;
  },
  update(r, e) {
    if (e.selection) {
      let t = e.state.doc.lineAt(e.selection.main.head).from, l = e.startState.doc.lineAt(e.startState.selection.main.head).from;
      t != e.changes.mapPos(l, -1) && (r = ge.empty);
    }
    r = r.map(e.changes);
    for (let t of e.effects)
      t.is(al) ? r = r.update({ add: [Kd.range(t.value, t.value + 1)] }) : t.is(Hd) && (r = r.update({ filter: (l) => l != t.value }));
    return r;
  }
});
function e2() {
  return [r2, CO];
}
const ka = "()[]{}<>";
function TO(r) {
  for (let e = 0; e < ka.length; e += 2)
    if (ka.charCodeAt(e) == r)
      return ka.charAt(e + 1);
  return kd(r < 128 ? r : r + 1);
}
function zO(r, e) {
  return r.languageDataAt("closeBrackets", e)[0] || ro;
}
const t2 = typeof navigator == "object" && /* @__PURE__ */ /Android\b/.test(navigator.userAgent), r2 = /* @__PURE__ */ I.inputHandler.of((r, e, t, l) => {
  if ((t2 ? r.composing : r.compositionStarted) || r.state.readOnly)
    return !1;
  let i = r.state.selection.main;
  if (l.length > 2 || l.length == 2 && xt(Be(l, 0)) == 1 || e != i.from || t != i.to)
    return !1;
  let o = o2(r.state, l);
  return o ? (r.dispatch(o), !0) : !1;
}), l2 = ({ state: r, dispatch: e }) => {
  if (r.readOnly)
    return !1;
  let l = zO(r, r.selection.main.head).brackets || ro.brackets, i = null, o = r.changeByRange((n) => {
    if (n.empty) {
      let s = n2(r.doc, n.head);
      for (let a of l)
        if (a == s && Ms(r.doc, n.head) == TO(Be(a, 0)))
          return {
            changes: { from: n.head - a.length, to: n.head + a.length },
            range: w.cursor(n.head - a.length)
          };
    }
    return { range: i = n };
  });
  return i || e(r.update(o, { scrollIntoView: !0, userEvent: "delete.backward" })), !i;
}, i2 = [
  { key: "Backspace", run: l2 }
];
function o2(r, e) {
  let t = zO(r, r.selection.main.head), l = t.brackets || ro.brackets;
  for (let i of l) {
    let o = TO(Be(i, 0));
    if (e == i)
      return o == i ? c2(r, i, l.indexOf(i + i + i) > -1, t) : s2(r, i, o, t.before || ro.before);
    if (e == o && XO(r, r.selection.main.from))
      return a2(r, i, o);
  }
  return null;
}
function XO(r, e) {
  let t = !1;
  return r.field(CO).between(0, r.doc.length, (l) => {
    l == e && (t = !0);
  }), t;
}
function Ms(r, e) {
  let t = r.sliceString(e, e + 2);
  return t.slice(0, xt(Be(t, 0)));
}
function n2(r, e) {
  let t = r.sliceString(e - 2, e);
  return xt(Be(t, 0)) == t.length ? t : t.slice(1);
}
function s2(r, e, t, l) {
  let i = null, o = r.changeByRange((n) => {
    if (!n.empty)
      return {
        changes: [{ insert: e, from: n.from }, { insert: t, from: n.to }],
        effects: al.of(n.to + e.length),
        range: w.range(n.anchor + e.length, n.head + e.length)
      };
    let s = Ms(r.doc, n.head);
    return !s || /\s/.test(s) || l.indexOf(s) > -1 ? {
      changes: { insert: e + t, from: n.head },
      effects: al.of(n.head + e.length),
      range: w.cursor(n.head + e.length)
    } : { range: i = n };
  });
  return i ? null : r.update(o, {
    scrollIntoView: !0,
    userEvent: "input.type"
  });
}
function a2(r, e, t) {
  let l = null, i = r.selection.ranges.map((o) => o.empty && Ms(r.doc, o.head) == t ? w.cursor(o.head + t.length) : l = o);
  return l ? null : r.update({
    selection: w.create(i, r.selection.mainIndex),
    scrollIntoView: !0,
    effects: r.selection.ranges.map(({ from: o }) => Hd.of(o))
  });
}
function c2(r, e, t, l) {
  let i = l.stringPrefixes || ro.stringPrefixes, o = null, n = r.changeByRange((s) => {
    if (!s.empty)
      return {
        changes: [{ insert: e, from: s.from }, { insert: e, from: s.to }],
        effects: al.of(s.to + e.length),
        range: w.range(s.anchor + e.length, s.head + e.length)
      };
    let a = s.head, c = Ms(r.doc, a), d;
    if (c == e) {
      if (ef(r, a))
        return {
          changes: { insert: e + e, from: a },
          effects: al.of(a + e.length),
          range: w.cursor(a + e.length)
        };
      if (XO(r, a)) {
        let h = t && r.sliceDoc(a, a + e.length * 3) == e + e + e;
        return {
          range: w.cursor(a + e.length * (h ? 3 : 1)),
          effects: Hd.of(a)
        };
      }
    } else {
      if (t && r.sliceDoc(a - 2 * e.length, a) == e + e && (d = tf(r, a - 2 * e.length, i)) > -1 && ef(r, d))
        return {
          changes: { insert: e + e + e + e, from: a },
          effects: al.of(a + e.length),
          range: w.cursor(a + e.length)
        };
      if (r.charCategorizer(a)(c) != Qe.Word && tf(r, a, i) > -1 && !d2(r, a, e, i))
        return {
          changes: { insert: e + e, from: a },
          effects: al.of(a + e.length),
          range: w.cursor(a + e.length)
        };
    }
    return { range: o = s };
  });
  return o ? null : r.update(n, {
    scrollIntoView: !0,
    userEvent: "input.type"
  });
}
function ef(r, e) {
  let t = ze(r).resolveInner(e + 1);
  return t.parent && t.from == e;
}
function d2(r, e, t, l) {
  let i = ze(r).resolveInner(e, -1), o = l.reduce((n, s) => Math.max(n, s.length), 0);
  for (let n = 0; n < 5; n++) {
    let s = r.sliceDoc(i.from, Math.min(i.to, i.from + t.length + o)), a = s.indexOf(t);
    if (!a || a > -1 && l.indexOf(s.slice(0, a)) > -1) {
      let d = i.firstChild;
      for (; d && d.from == i.from && d.to - d.from > t.length + a; ) {
        if (r.sliceDoc(d.to - t.length, d.to) == t)
          return !1;
        d = d.firstChild;
      }
      return !0;
    }
    let c = i.to == e && i.parent;
    if (!c)
      break;
    i = c;
  }
  return !1;
}
function tf(r, e, t) {
  let l = r.charCategorizer(e);
  if (l(r.sliceDoc(e - 1, e)) != Qe.Word)
    return e;
  for (let i of t) {
    let o = e - i.length;
    if (r.sliceDoc(o, e) == i && l(r.sliceDoc(o - 1, o)) != Qe.Word)
      return o;
  }
  return -1;
}
function h2(r = {}) {
  return [
    St,
    Ct.of(r),
    YQ,
    p2,
    $O
  ];
}
const AO = [
  { key: "Ctrl-Space", run: RQ },
  { key: "Escape", run: DQ },
  { key: "ArrowDown", run: /* @__PURE__ */ qo(!0) },
  { key: "ArrowUp", run: /* @__PURE__ */ qo(!1) },
  { key: "PageDown", run: /* @__PURE__ */ qo(!0, "page") },
  { key: "PageUp", run: /* @__PURE__ */ qo(!1, "page") },
  { key: "Enter", run: ZQ }
], p2 = /* @__PURE__ */ kl.highest(/* @__PURE__ */ mo.computeN([Ct], (r) => r.facet(Ct).defaultKeymap ? [AO] : [])), u2 = [
  /* @__PURE__ */ Et("function ${name}(${params}) {\n	${}\n}", {
    label: "function",
    detail: "definition",
    type: "keyword"
  }),
  /* @__PURE__ */ Et("for (let ${index} = 0; ${index} < ${bound}; ${index}++) {\n	${}\n}", {
    label: "for",
    detail: "loop",
    type: "keyword"
  }),
  /* @__PURE__ */ Et("for (let ${name} of ${collection}) {\n	${}\n}", {
    label: "for",
    detail: "of loop",
    type: "keyword"
  }),
  /* @__PURE__ */ Et("do {\n	${}\n} while (${})", {
    label: "do",
    detail: "loop",
    type: "keyword"
  }),
  /* @__PURE__ */ Et("while (${}) {\n	${}\n}", {
    label: "while",
    detail: "loop",
    type: "keyword"
  }),
  /* @__PURE__ */ Et(`try {
	\${}
} catch (\${error}) {
	\${}
}`, {
    label: "try",
    detail: "/ catch block",
    type: "keyword"
  }),
  /* @__PURE__ */ Et("if (${}) {\n	${}\n}", {
    label: "if",
    detail: "block",
    type: "keyword"
  }),
  /* @__PURE__ */ Et(`if (\${}) {
	\${}
} else {
	\${}
}`, {
    label: "if",
    detail: "/ else block",
    type: "keyword"
  }),
  /* @__PURE__ */ Et(`class \${name} {
	constructor(\${params}) {
		\${}
	}
}`, {
    label: "class",
    detail: "definition",
    type: "keyword"
  }),
  /* @__PURE__ */ Et('import {${names}} from "${module}"\n${}', {
    label: "import",
    detail: "named",
    type: "keyword"
  }),
  /* @__PURE__ */ Et('import ${name} from "${module}"\n${}', {
    label: "import",
    detail: "default",
    type: "keyword"
  })
], rf = /* @__PURE__ */ new Ak(), EO = /* @__PURE__ */ new Set([
  "Script",
  "Block",
  "FunctionExpression",
  "FunctionDeclaration",
  "ArrowFunction",
  "MethodDeclaration",
  "ForStatement"
]);
function vi(r) {
  return (e, t) => {
    let l = e.node.getChild("VariableDefinition");
    return l && t(l, r), !0;
  };
}
const f2 = ["FunctionDeclaration"], g2 = {
  FunctionDeclaration: /* @__PURE__ */ vi("function"),
  ClassDeclaration: /* @__PURE__ */ vi("class"),
  ClassExpression: () => !0,
  EnumDeclaration: /* @__PURE__ */ vi("constant"),
  TypeAliasDeclaration: /* @__PURE__ */ vi("type"),
  NamespaceDeclaration: /* @__PURE__ */ vi("namespace"),
  VariableDefinition(r, e) {
    r.matchContext(f2) || e(r, "variable");
  },
  TypeDefinition(r, e) {
    e(r, "type");
  },
  __proto__: null
};
function VO(r, e) {
  let t = rf.get(e);
  if (t)
    return t;
  let l = [], i = !0;
  function o(n, s) {
    let a = r.sliceString(n.from, n.to);
    l.push({ label: a, type: s });
  }
  return e.cursor(Se.IncludeAnonymous).iterate((n) => {
    if (i)
      i = !1;
    else if (n.name) {
      let s = g2[n.name];
      if (s && s(n, o) || EO.has(n.name))
        return !1;
    } else if (n.to - n.from > 8192) {
      for (let s of VO(r, n.node))
        l.push(s);
      return !1;
    }
  }), rf.set(e, l), l;
}
const lf = /^[\w$\xa1-\uffff][\w$\d\xa1-\uffff]*$/, ZO = [
  "TemplateString",
  "String",
  "RegExp",
  "LineComment",
  "BlockComment",
  "VariableDefinition",
  "TypeDefinition",
  "Label",
  "PropertyDefinition",
  "PropertyName",
  "PrivatePropertyDefinition",
  "PrivatePropertyName"
];
function m2(r) {
  let e = ze(r.state).resolveInner(r.pos, -1);
  if (ZO.indexOf(e.name) > -1)
    return null;
  let t = e.name == "VariableName" || e.to - e.from < 20 && lf.test(r.state.sliceDoc(e.from, e.to));
  if (!t && !r.explicit)
    return null;
  let l = [];
  for (let i = e; i; i = i.parent)
    EO.has(i.name) && (l = l.concat(VO(r.state.doc, i)));
  return {
    options: l,
    from: t ? e.from : r.pos,
    validFor: lf
  };
}
const pr = /* @__PURE__ */ ei.define({
  name: "javascript",
  parser: /* @__PURE__ */ xQ.configure({
    props: [
      /* @__PURE__ */ Xs.add({
        IfStatement: /* @__PURE__ */ gn({ except: /^\s*({|else\b)/ }),
        TryStatement: /* @__PURE__ */ gn({ except: /^\s*({|catch\b|finally\b)/ }),
        LabeledStatement: s3,
        SwitchBody: (r) => {
          let e = r.textAfter, t = /^\s*\}/.test(e), l = /^\s*(case|default)\b/.test(e);
          return r.baseIndent + (t ? 0 : l ? 1 : 2) * r.unit;
        },
        Block: /* @__PURE__ */ n3({ closing: "}" }),
        ArrowFunction: (r) => r.baseIndent + r.unit,
        "TemplateString BlockComment": () => null,
        "Statement Property": /* @__PURE__ */ gn({ except: /^{/ }),
        JSXElement(r) {
          let e = /^\s*<\//.test(r.textAfter);
          return r.lineIndent(r.node.from) + (e ? 0 : r.unit);
        },
        JSXEscape(r) {
          let e = /\s*\}/.test(r.textAfter);
          return r.lineIndent(r.node.from) + (e ? 0 : r.unit);
        },
        "JSXOpenTag JSXSelfClosingTag"(r) {
          return r.column(r.node.from) + r.unit;
        }
      }),
      /* @__PURE__ */ As.add({
        "Block ClassBody SwitchBody EnumBody ObjectExpression ArrayExpression": pb,
        BlockComment(r) {
          return { from: r.from + 2, to: r.to - 2 };
        }
      })
    ]
  }),
  languageData: {
    closeBrackets: { brackets: ["(", "[", "{", "'", '"', "`"] },
    commentTokens: { line: "//", block: { open: "/*", close: "*/" } },
    indentOnInput: /^\s*(?:case |default:|\{|\}|<\/)$/,
    wordChars: "$"
  }
}), RO = /* @__PURE__ */ pr.configure({ dialect: "ts" }, "typescript"), DO = /* @__PURE__ */ pr.configure({ dialect: "jsx" }), WO = /* @__PURE__ */ pr.configure({ dialect: "jsx ts" }, "typescript"), b2 = /* @__PURE__ */ "break case const continue default delete export extends false finally in instanceof let new return static super switch this throw true typeof var yield".split(" ").map((r) => ({ label: r, type: "keyword" }));
function NO(r = {}) {
  let e = r.jsx ? r.typescript ? WO : DO : r.typescript ? RO : pr;
  return new Nd(e, [
    pr.data.of({
      autocomplete: wQ(ZO, wO(u2.concat(b2)))
    }),
    pr.data.of({
      autocomplete: m2
    }),
    r.jsx ? x2 : []
  ]);
}
function O2(r) {
  for (; ; ) {
    if (r.name == "JSXOpenTag" || r.name == "JSXSelfClosingTag" || r.name == "JSXFragmentTag")
      return r;
    if (!r.parent)
      return null;
    r = r.parent;
  }
}
function of(r, e, t = r.length) {
  for (let l = e == null ? void 0 : e.firstChild; l; l = l.nextSibling)
    if (l.name == "JSXIdentifier" || l.name == "JSXBuiltin" || l.name == "JSXNamespacedName" || l.name == "JSXMemberExpression")
      return r.sliceString(l.from, Math.min(l.to, t));
  return "";
}
const v2 = typeof navigator == "object" && /* @__PURE__ */ /Android\b/.test(navigator.userAgent), x2 = /* @__PURE__ */ I.inputHandler.of((r, e, t, l) => {
  if ((v2 ? r.composing : r.compositionStarted) || r.state.readOnly || e != t || l != ">" && l != "/" || !pr.isActiveAt(r.state, e, -1))
    return !1;
  let { state: i } = r, o = i.changeByRange((n) => {
    var s, a;
    let { head: c } = n, d = ze(i).resolveInner(c, -1), h;
    if (d.name == "JSXStartTag" && (d = d.parent), l == ">" && d.name == "JSXFragmentTag")
      return { range: w.cursor(c + 1), changes: { from: c, insert: "><>" } };
    if (l == "/" && d.name == "JSXFragmentTag") {
      let p = d.parent, u = p == null ? void 0 : p.parent;
      if (p.from == c - 1 && ((s = u.lastChild) === null || s === void 0 ? void 0 : s.name) != "JSXEndTag" && (h = of(i.doc, u == null ? void 0 : u.firstChild, c))) {
        let f = `/${h}>`;
        return { range: w.cursor(c + f.length), changes: { from: c, insert: f } };
      }
    } else if (l == ">") {
      let p = O2(d);
      if (p && ((a = p.lastChild) === null || a === void 0 ? void 0 : a.name) != "JSXEndTag" && i.sliceDoc(c, c + 2) != "</" && (h = of(i.doc, p, c)))
        return { range: w.cursor(c + 1), changes: { from: c, insert: `></${h}>` } };
    }
    return { range: n };
  });
  return o.changes.empty ? !1 : (r.dispatch(o, { userEvent: "input.type", scrollIntoView: !0 }), !0);
}), xi = ["_blank", "_self", "_top", "_parent"], Sa = ["ascii", "utf-8", "utf-16", "latin1", "latin1"], Qa = ["get", "post", "put", "delete"], $a = ["application/x-www-form-urlencoded", "multipart/form-data", "text/plain"], mt = ["true", "false"], j = {}, _2 = {
  a: {
    attrs: {
      href: null,
      ping: null,
      type: null,
      media: null,
      target: xi,
      hreflang: null
    }
  },
  abbr: j,
  address: j,
  area: {
    attrs: {
      alt: null,
      coords: null,
      href: null,
      target: null,
      ping: null,
      media: null,
      hreflang: null,
      type: null,
      shape: ["default", "rect", "circle", "poly"]
    }
  },
  article: j,
  aside: j,
  audio: {
    attrs: {
      src: null,
      mediagroup: null,
      crossorigin: ["anonymous", "use-credentials"],
      preload: ["none", "metadata", "auto"],
      autoplay: ["autoplay"],
      loop: ["loop"],
      controls: ["controls"]
    }
  },
  b: j,
  base: { attrs: { href: null, target: xi } },
  bdi: j,
  bdo: j,
  blockquote: { attrs: { cite: null } },
  body: j,
  br: j,
  button: {
    attrs: {
      form: null,
      formaction: null,
      name: null,
      value: null,
      autofocus: ["autofocus"],
      disabled: ["autofocus"],
      formenctype: $a,
      formmethod: Qa,
      formnovalidate: ["novalidate"],
      formtarget: xi,
      type: ["submit", "reset", "button"]
    }
  },
  canvas: { attrs: { width: null, height: null } },
  caption: j,
  center: j,
  cite: j,
  code: j,
  col: { attrs: { span: null } },
  colgroup: { attrs: { span: null } },
  command: {
    attrs: {
      type: ["command", "checkbox", "radio"],
      label: null,
      icon: null,
      radiogroup: null,
      command: null,
      title: null,
      disabled: ["disabled"],
      checked: ["checked"]
    }
  },
  data: { attrs: { value: null } },
  datagrid: { attrs: { disabled: ["disabled"], multiple: ["multiple"] } },
  datalist: { attrs: { data: null } },
  dd: j,
  del: { attrs: { cite: null, datetime: null } },
  details: { attrs: { open: ["open"] } },
  dfn: j,
  div: j,
  dl: j,
  dt: j,
  em: j,
  embed: { attrs: { src: null, type: null, width: null, height: null } },
  eventsource: { attrs: { src: null } },
  fieldset: { attrs: { disabled: ["disabled"], form: null, name: null } },
  figcaption: j,
  figure: j,
  footer: j,
  form: {
    attrs: {
      action: null,
      name: null,
      "accept-charset": Sa,
      autocomplete: ["on", "off"],
      enctype: $a,
      method: Qa,
      novalidate: ["novalidate"],
      target: xi
    }
  },
  h1: j,
  h2: j,
  h3: j,
  h4: j,
  h5: j,
  h6: j,
  head: {
    children: ["title", "base", "link", "style", "meta", "script", "noscript", "command"]
  },
  header: j,
  hgroup: j,
  hr: j,
  html: {
    attrs: { manifest: null }
  },
  i: j,
  iframe: {
    attrs: {
      src: null,
      srcdoc: null,
      name: null,
      width: null,
      height: null,
      sandbox: ["allow-top-navigation", "allow-same-origin", "allow-forms", "allow-scripts"],
      seamless: ["seamless"]
    }
  },
  img: {
    attrs: {
      alt: null,
      src: null,
      ismap: null,
      usemap: null,
      width: null,
      height: null,
      crossorigin: ["anonymous", "use-credentials"]
    }
  },
  input: {
    attrs: {
      alt: null,
      dirname: null,
      form: null,
      formaction: null,
      height: null,
      list: null,
      max: null,
      maxlength: null,
      min: null,
      name: null,
      pattern: null,
      placeholder: null,
      size: null,
      src: null,
      step: null,
      value: null,
      width: null,
      accept: ["audio/*", "video/*", "image/*"],
      autocomplete: ["on", "off"],
      autofocus: ["autofocus"],
      checked: ["checked"],
      disabled: ["disabled"],
      formenctype: $a,
      formmethod: Qa,
      formnovalidate: ["novalidate"],
      formtarget: xi,
      multiple: ["multiple"],
      readonly: ["readonly"],
      required: ["required"],
      type: [
        "hidden",
        "text",
        "search",
        "tel",
        "url",
        "email",
        "password",
        "datetime",
        "date",
        "month",
        "week",
        "time",
        "datetime-local",
        "number",
        "range",
        "color",
        "checkbox",
        "radio",
        "file",
        "submit",
        "image",
        "reset",
        "button"
      ]
    }
  },
  ins: { attrs: { cite: null, datetime: null } },
  kbd: j,
  keygen: {
    attrs: {
      challenge: null,
      form: null,
      name: null,
      autofocus: ["autofocus"],
      disabled: ["disabled"],
      keytype: ["RSA"]
    }
  },
  label: { attrs: { for: null, form: null } },
  legend: j,
  li: { attrs: { value: null } },
  link: {
    attrs: {
      href: null,
      type: null,
      hreflang: null,
      media: null,
      sizes: ["all", "16x16", "16x16 32x32", "16x16 32x32 64x64"]
    }
  },
  map: { attrs: { name: null } },
  mark: j,
  menu: { attrs: { label: null, type: ["list", "context", "toolbar"] } },
  meta: {
    attrs: {
      content: null,
      charset: Sa,
      name: ["viewport", "application-name", "author", "description", "generator", "keywords"],
      "http-equiv": ["content-language", "content-type", "default-style", "refresh"]
    }
  },
  meter: { attrs: { value: null, min: null, low: null, high: null, max: null, optimum: null } },
  nav: j,
  noscript: j,
  object: {
    attrs: {
      data: null,
      type: null,
      name: null,
      usemap: null,
      form: null,
      width: null,
      height: null,
      typemustmatch: ["typemustmatch"]
    }
  },
  ol: {
    attrs: { reversed: ["reversed"], start: null, type: ["1", "a", "A", "i", "I"] },
    children: ["li", "script", "template", "ul", "ol"]
  },
  optgroup: { attrs: { disabled: ["disabled"], label: null } },
  option: { attrs: { disabled: ["disabled"], label: null, selected: ["selected"], value: null } },
  output: { attrs: { for: null, form: null, name: null } },
  p: j,
  param: { attrs: { name: null, value: null } },
  pre: j,
  progress: { attrs: { value: null, max: null } },
  q: { attrs: { cite: null } },
  rp: j,
  rt: j,
  ruby: j,
  samp: j,
  script: {
    attrs: {
      type: ["text/javascript"],
      src: null,
      async: ["async"],
      defer: ["defer"],
      charset: Sa
    }
  },
  section: j,
  select: {
    attrs: {
      form: null,
      name: null,
      size: null,
      autofocus: ["autofocus"],
      disabled: ["disabled"],
      multiple: ["multiple"]
    }
  },
  slot: { attrs: { name: null } },
  small: j,
  source: { attrs: { src: null, type: null, media: null } },
  span: j,
  strong: j,
  style: {
    attrs: {
      type: ["text/css"],
      media: null,
      scoped: null
    }
  },
  sub: j,
  summary: j,
  sup: j,
  table: j,
  tbody: j,
  td: { attrs: { colspan: null, rowspan: null, headers: null } },
  template: j,
  textarea: {
    attrs: {
      dirname: null,
      form: null,
      maxlength: null,
      name: null,
      placeholder: null,
      rows: null,
      cols: null,
      autofocus: ["autofocus"],
      disabled: ["disabled"],
      readonly: ["readonly"],
      required: ["required"],
      wrap: ["soft", "hard"]
    }
  },
  tfoot: j,
  th: { attrs: { colspan: null, rowspan: null, headers: null, scope: ["row", "col", "rowgroup", "colgroup"] } },
  thead: j,
  time: { attrs: { datetime: null } },
  title: j,
  tr: j,
  track: {
    attrs: {
      src: null,
      label: null,
      default: null,
      kind: ["subtitles", "captions", "descriptions", "chapters", "metadata"],
      srclang: null
    }
  },
  ul: { children: ["li", "script", "template", "ul", "ol"] },
  var: j,
  video: {
    attrs: {
      src: null,
      poster: null,
      width: null,
      height: null,
      crossorigin: ["anonymous", "use-credentials"],
      preload: ["auto", "metadata", "none"],
      autoplay: ["autoplay"],
      mediagroup: ["movie"],
      muted: ["muted"],
      controls: ["controls"]
    }
  },
  wbr: j
}, MO = {
  accesskey: null,
  class: null,
  contenteditable: mt,
  contextmenu: null,
  dir: ["ltr", "rtl", "auto"],
  draggable: ["true", "false", "auto"],
  dropzone: ["copy", "move", "link", "string:", "file:"],
  hidden: ["hidden"],
  id: null,
  inert: ["inert"],
  itemid: null,
  itemprop: null,
  itemref: null,
  itemscope: ["itemscope"],
  itemtype: null,
  lang: ["ar", "bn", "de", "en-GB", "en-US", "es", "fr", "hi", "id", "ja", "pa", "pt", "ru", "tr", "zh"],
  spellcheck: mt,
  autocorrect: mt,
  autocapitalize: mt,
  style: null,
  tabindex: null,
  title: null,
  translate: ["yes", "no"],
  rel: ["stylesheet", "alternate", "author", "bookmark", "help", "license", "next", "nofollow", "noreferrer", "prefetch", "prev", "search", "tag"],
  role: /* @__PURE__ */ "alert application article banner button cell checkbox complementary contentinfo dialog document feed figure form grid gridcell heading img list listbox listitem main navigation region row rowgroup search switch tab table tabpanel textbox timer".split(" "),
  "aria-activedescendant": null,
  "aria-atomic": mt,
  "aria-autocomplete": ["inline", "list", "both", "none"],
  "aria-busy": mt,
  "aria-checked": ["true", "false", "mixed", "undefined"],
  "aria-controls": null,
  "aria-describedby": null,
  "aria-disabled": mt,
  "aria-dropeffect": null,
  "aria-expanded": ["true", "false", "undefined"],
  "aria-flowto": null,
  "aria-grabbed": ["true", "false", "undefined"],
  "aria-haspopup": mt,
  "aria-hidden": mt,
  "aria-invalid": ["true", "false", "grammar", "spelling"],
  "aria-label": null,
  "aria-labelledby": null,
  "aria-level": null,
  "aria-live": ["off", "polite", "assertive"],
  "aria-multiline": mt,
  "aria-multiselectable": mt,
  "aria-owns": null,
  "aria-posinset": null,
  "aria-pressed": ["true", "false", "mixed", "undefined"],
  "aria-readonly": mt,
  "aria-relevant": null,
  "aria-required": mt,
  "aria-selected": ["true", "false", "undefined"],
  "aria-setsize": null,
  "aria-sort": ["ascending", "descending", "none", "other"],
  "aria-valuemax": null,
  "aria-valuemin": null,
  "aria-valuenow": null,
  "aria-valuetext": null
}, YO = /* @__PURE__ */ "beforeunload copy cut dragstart dragover dragleave dragenter dragend drag paste focus blur change click load mousedown mouseenter mouseleave mouseup keydown keyup resize scroll unload".split(" ").map((r) => "on" + r);
for (let r of YO)
  MO[r] = null;
class es {
  constructor(e, t) {
    this.tags = Object.assign(Object.assign({}, _2), e), this.globalAttrs = Object.assign(Object.assign({}, MO), t), this.allTags = Object.keys(this.tags), this.globalAttrNames = Object.keys(this.globalAttrs);
  }
}
es.default = /* @__PURE__ */ new es();
function li(r, e, t = r.length) {
  if (!e)
    return "";
  let l = e.firstChild, i = l && l.getChild("TagName");
  return i ? r.sliceString(i.from, Math.min(i.to, t)) : "";
}
function Ys(r, e = !1) {
  for (let t = r.parent; t; t = t.parent)
    if (t.name == "Element")
      if (e)
        e = !1;
      else
        return t;
  return null;
}
function jO(r, e, t) {
  let l = t.tags[li(r, Ys(e, !0))];
  return (l == null ? void 0 : l.children) || t.allTags;
}
function Jd(r, e) {
  let t = [];
  for (let l = e; l = Ys(l); ) {
    let i = li(r, l);
    if (i && l.lastChild.name == "CloseTag")
      break;
    i && t.indexOf(i) < 0 && (e.name == "EndTag" || e.from >= l.firstChild.to) && t.push(i);
  }
  return t;
}
const IO = /^[:\-\.\w\u00b7-\uffff]*$/;
function nf(r, e, t, l, i) {
  let o = /\s*>/.test(r.sliceDoc(i, i + 5)) ? "" : ">";
  return {
    from: l,
    to: i,
    options: jO(r.doc, t, e).map((n) => ({ label: n, type: "type" })).concat(Jd(r.doc, t).map((n, s) => ({
      label: "/" + n,
      apply: "/" + n + o,
      type: "type",
      boost: 99 - s
    }))),
    validFor: /^\/?[:\-\.\w\u00b7-\uffff]*$/
  };
}
function sf(r, e, t, l) {
  let i = /\s*>/.test(r.sliceDoc(l, l + 5)) ? "" : ">";
  return {
    from: t,
    to: l,
    options: Jd(r.doc, e).map((o, n) => ({ label: o, apply: o + i, type: "type", boost: 99 - n })),
    validFor: IO
  };
}
function w2(r, e, t, l) {
  let i = [], o = 0;
  for (let n of jO(r.doc, t, e))
    i.push({ label: "<" + n, type: "type" });
  for (let n of Jd(r.doc, t))
    i.push({ label: "</" + n + ">", type: "type", boost: 99 - o++ });
  return { from: l, to: l, options: i, validFor: /^<\/?[:\-\.\w\u00b7-\uffff]*$/ };
}
function y2(r, e, t, l, i) {
  let o = Ys(t), n = o ? e.tags[li(r.doc, o)] : null, s = n && n.attrs ? Object.keys(n.attrs) : [], a = n && n.globalAttrs === !1 ? s : s.length ? s.concat(e.globalAttrNames) : e.globalAttrNames;
  return {
    from: l,
    to: i,
    options: a.map((c) => ({ label: c, type: "property" })),
    validFor: IO
  };
}
function k2(r, e, t, l, i) {
  var o;
  let n = (o = t.parent) === null || o === void 0 ? void 0 : o.getChild("AttributeName"), s = [], a;
  if (n) {
    let c = r.sliceDoc(n.from, n.to), d = e.globalAttrs[c];
    if (!d) {
      let h = Ys(t), p = h ? e.tags[li(r.doc, h)] : null;
      d = (p == null ? void 0 : p.attrs) && p.attrs[c];
    }
    if (d) {
      let h = r.sliceDoc(l, i).toLowerCase(), p = '"', u = '"';
      /^['"]/.test(h) ? (a = h[0] == '"' ? /^[^"]*$/ : /^[^']*$/, p = "", u = r.sliceDoc(i, i + 1) == h[0] ? "" : h[0], h = h.slice(1), l++) : a = /^[^\s<>='"]*$/;
      for (let f of d)
        s.push({ label: f, apply: p + f + u, type: "constant" });
    }
  }
  return { from: l, to: i, options: s, validFor: a };
}
function S2(r, e) {
  let { state: t, pos: l } = e, i = ze(t).resolveInner(l), o = i.resolve(l, -1);
  for (let n = l, s; i == o && (s = o.childBefore(n)); ) {
    let a = s.lastChild;
    if (!a || !a.type.isError || a.from < a.to)
      break;
    i = o = s, n = a.from;
  }
  return o.name == "TagName" ? o.parent && /CloseTag$/.test(o.parent.name) ? sf(t, o, o.from, l) : nf(t, r, o, o.from, l) : o.name == "StartTag" ? nf(t, r, o, l, l) : o.name == "StartCloseTag" || o.name == "IncompleteCloseTag" ? sf(t, o, l, l) : e.explicit && (o.name == "OpenTag" || o.name == "SelfClosingTag") || o.name == "AttributeName" ? y2(t, r, o, o.name == "AttributeName" ? o.from : l, l) : o.name == "Is" || o.name == "AttributeValue" || o.name == "UnquotedAttributeValue" ? k2(t, r, o, o.name == "Is" ? l : o.from, l) : e.explicit && (i.name == "Element" || i.name == "Text" || i.name == "Document") ? w2(t, r, o, l) : null;
}
function Q2(r) {
  let { extraTags: e, extraGlobalAttributes: t } = r, l = t || e ? new es(e, t) : es.default;
  return (i) => S2(l, i);
}
const UO = [
  {
    tag: "script",
    attrs: (r) => r.type == "text/typescript" || r.lang == "ts",
    parser: RO.parser
  },
  {
    tag: "script",
    attrs: (r) => r.type == "text/babel" || r.type == "text/jsx",
    parser: DO.parser
  },
  {
    tag: "script",
    attrs: (r) => r.type == "text/typescript-jsx",
    parser: WO.parser
  },
  {
    tag: "script",
    attrs(r) {
      return !r.type || /^(?:text|application)\/(?:x-)?(?:java|ecma)script$|^module$|^$/i.test(r.type);
    },
    parser: pr.parser
  },
  {
    tag: "style",
    attrs(r) {
      return (!r.lang || r.lang == "css") && (!r.type || /^(text\/)?(x-)?(stylesheet|css)$/i.test(r.type));
    },
    parser: Fn.parser
  }
], qO = /* @__PURE__ */ [
  {
    name: "style",
    parser: /* @__PURE__ */ Fn.parser.configure({ top: "Styles" })
  }
].concat(/* @__PURE__ */ YO.map((r) => ({ name: r, parser: pr.parser }))), On = /* @__PURE__ */ ei.define({
  name: "html",
  parser: /* @__PURE__ */ tQ.configure({
    props: [
      /* @__PURE__ */ Xs.add({
        Element(r) {
          let e = /^(\s*)(<\/)?/.exec(r.textAfter);
          return r.node.to <= r.pos + e[0].length ? r.continue() : r.lineIndent(r.node.from) + (e[2] ? 0 : r.unit);
        },
        "OpenTag CloseTag SelfClosingTag"(r) {
          return r.column(r.node.from) + r.unit;
        },
        Document(r) {
          if (r.pos + /\s*/.exec(r.textAfter)[0].length < r.node.to)
            return r.continue();
          let e = null, t;
          for (let l = r.node; ; ) {
            let i = l.lastChild;
            if (!i || i.name != "Element" || i.to != l.to)
              break;
            e = l = i;
          }
          return e && !((t = e.lastChild) && (t.name == "CloseTag" || t.name == "SelfClosingTag")) ? r.lineIndent(e.from) + r.unit : null;
        }
      }),
      /* @__PURE__ */ As.add({
        Element(r) {
          let e = r.firstChild, t = r.lastChild;
          return !e || e.name != "OpenTag" ? null : { from: e.to, to: t.name == "CloseTag" ? t.from : r.to };
        }
      }),
      /* @__PURE__ */ yb.add({
        "OpenTag CloseTag": (r) => r.getChild("TagName")
      })
    ],
    wrap: /* @__PURE__ */ vO(UO, qO)
  }),
  languageData: {
    commentTokens: { block: { open: "<!--", close: "-->" } },
    indentOnInput: /^\s*<\/\w+\W$/,
    wordChars: "-._"
  }
});
function $2(r = {}) {
  let e = "", t;
  r.matchClosingTags === !1 && (e = "noMatch"), r.selfClosingTags === !0 && (e = (e ? e + " " : "") + "selfClosing"), (r.nestedLanguages && r.nestedLanguages.length || r.nestedAttributes && r.nestedAttributes.length) && (t = vO((r.nestedLanguages || []).concat(UO), (r.nestedAttributes || []).concat(qO)));
  let l = t || e ? On.configure({ dialect: e, wrap: t }) : On;
  return new Nd(l, [
    On.data.of({ autocomplete: Q2(r) }),
    r.autoCloseTags !== !1 ? P2 : [],
    NO().support,
    nO().support
  ]);
}
const P2 = /* @__PURE__ */ I.inputHandler.of((r, e, t, l) => {
  if (r.composing || r.state.readOnly || e != t || l != ">" && l != "/" || !On.isActiveAt(r.state, e, -1))
    return !1;
  let { state: i } = r, o = i.changeByRange((n) => {
    var s, a, c;
    let { head: d } = n, h = ze(i).resolveInner(d, -1), p;
    if ((h.name == "TagName" || h.name == "StartTag") && (h = h.parent), l == ">" && h.name == "OpenTag") {
      if (((a = (s = h.parent) === null || s === void 0 ? void 0 : s.lastChild) === null || a === void 0 ? void 0 : a.name) != "CloseTag" && (p = li(i.doc, h.parent, d))) {
        let u = r.state.doc.sliceString(d, d + 1) === ">", f = `${u ? "" : ">"}</${p}>`;
        return { range: w.cursor(d + 1), changes: { from: d + (u ? 1 : 0), insert: f } };
      }
    } else if (l == "/" && h.name == "OpenTag") {
      let u = h.parent, f = u == null ? void 0 : u.parent;
      if (u.from == d - 1 && ((c = f.lastChild) === null || c === void 0 ? void 0 : c.name) != "CloseTag" && (p = li(i.doc, f, d))) {
        let m = r.state.doc.sliceString(d, d + 1) === ">", O = `/${p}${m ? "" : ">"}`, x = d + O.length + (m ? 1 : 0);
        return { range: w.cursor(x), changes: { from: d, insert: O } };
      }
    }
    return { range: n };
  });
  return o.changes.empty ? !1 : (r.dispatch(o, { userEvent: "input.type", scrollIntoView: !0 }), !0);
});
function xe() {
  var r = arguments[0];
  typeof r == "string" && (r = document.createElement(r));
  var e = 1, t = arguments[1];
  if (t && typeof t == "object" && t.nodeType == null && !Array.isArray(t)) {
    for (var l in t)
      if (Object.prototype.hasOwnProperty.call(t, l)) {
        var i = t[l];
        typeof i == "string" ? r.setAttribute(l, i) : i != null && (r[l] = i);
      }
    e++;
  }
  for (; e < arguments.length; e++)
    BO(r, arguments[e]);
  return r;
}
function BO(r, e) {
  if (typeof e == "string")
    r.appendChild(document.createTextNode(e));
  else if (e != null)
    if (e.nodeType != null)
      r.appendChild(e);
    else if (Array.isArray(e))
      for (var t = 0; t < e.length; t++)
        BO(r, e[t]);
    else
      throw new RangeError("Unsupported child node: " + e);
}
const af = typeof String.prototype.normalize == "function" ? (r) => r.normalize("NFKD") : (r) => r;
class ii {
  /**
  Create a text cursor. The query is the search string, `from` to
  `to` provides the region to search.
  
  When `normalize` is given, it will be called, on both the query
  string and the content it is matched against, before comparing.
  You can, for example, create a case-insensitive search by
  passing `s => s.toLowerCase()`.
  
  Text is always normalized with
  [`.normalize("NFKD")`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/normalize)
  (when supported).
  */
  constructor(e, t, l = 0, i = e.length, o, n) {
    this.test = n, this.value = { from: 0, to: 0 }, this.done = !1, this.matches = [], this.buffer = "", this.bufferPos = 0, this.iter = e.iterRange(l, i), this.bufferStart = l, this.normalize = o ? (s) => o(af(s)) : af, this.query = this.normalize(t);
  }
  peek() {
    if (this.bufferPos == this.buffer.length) {
      if (this.bufferStart += this.buffer.length, this.iter.next(), this.iter.done)
        return -1;
      this.bufferPos = 0, this.buffer = this.iter.value;
    }
    return Be(this.buffer, this.bufferPos);
  }
  /**
  Look for the next match. Updates the iterator's
  [`value`](https://codemirror.net/6/docs/ref/#search.SearchCursor.value) and
  [`done`](https://codemirror.net/6/docs/ref/#search.SearchCursor.done) properties. Should be called
  at least once before using the cursor.
  */
  next() {
    for (; this.matches.length; )
      this.matches.pop();
    return this.nextOverlapping();
  }
  /**
  The `next` method will ignore matches that partially overlap a
  previous match. This method behaves like `next`, but includes
  such matches.
  */
  nextOverlapping() {
    for (; ; ) {
      let e = this.peek();
      if (e < 0)
        return this.done = !0, this;
      let t = kd(e), l = this.bufferStart + this.bufferPos;
      this.bufferPos += xt(e);
      let i = this.normalize(t);
      for (let o = 0, n = l; ; o++) {
        let s = i.charCodeAt(o), a = this.match(s, n);
        if (a)
          return this.value = a, this;
        if (o == i.length - 1)
          break;
        n == l && o < t.length && t.charCodeAt(o) == s && n++;
      }
    }
  }
  match(e, t) {
    let l = null;
    for (let i = 0; i < this.matches.length; i += 2) {
      let o = this.matches[i], n = !1;
      this.query.charCodeAt(o) == e && (o == this.query.length - 1 ? l = { from: this.matches[i + 1], to: t + 1 } : (this.matches[i]++, n = !0)), n || (this.matches.splice(i, 2), i -= 2);
    }
    return this.query.charCodeAt(0) == e && (this.query.length == 1 ? l = { from: t, to: t + 1 } : this.matches.push(1, t)), l && this.test && !this.test(l.from, l.to, this.buffer, this.bufferPos) && (l = null), l;
  }
}
typeof Symbol < "u" && (ii.prototype[Symbol.iterator] = function() {
  return this;
});
const LO = { from: -1, to: -1, match: /* @__PURE__ */ /.*/.exec("") }, eh = "gm" + (/x/.unicode == null ? "" : "u");
class GO {
  /**
  Create a cursor that will search the given range in the given
  document. `query` should be the raw pattern (as you'd pass it to
  `new RegExp`).
  */
  constructor(e, t, l, i = 0, o = e.length) {
    if (this.text = e, this.to = o, this.curLine = "", this.done = !1, this.value = LO, /\\[sWDnr]|\n|\r|\[\^/.test(t))
      return new FO(e, t, l, i, o);
    this.re = new RegExp(t, eh + (l != null && l.ignoreCase ? "i" : "")), this.test = l == null ? void 0 : l.test, this.iter = e.iter();
    let n = e.lineAt(i);
    this.curLineStart = n.from, this.matchPos = ts(e, i), this.getLine(this.curLineStart);
  }
  getLine(e) {
    this.iter.next(e), this.iter.lineBreak ? this.curLine = "" : (this.curLine = this.iter.value, this.curLineStart + this.curLine.length > this.to && (this.curLine = this.curLine.slice(0, this.to - this.curLineStart)), this.iter.next());
  }
  nextLine() {
    this.curLineStart = this.curLineStart + this.curLine.length + 1, this.curLineStart > this.to ? this.curLine = "" : this.getLine(0);
  }
  /**
  Move to the next match, if there is one.
  */
  next() {
    for (let e = this.matchPos - this.curLineStart; ; ) {
      this.re.lastIndex = e;
      let t = this.matchPos <= this.to && this.re.exec(this.curLine);
      if (t) {
        let l = this.curLineStart + t.index, i = l + t[0].length;
        if (this.matchPos = ts(this.text, i + (l == i ? 1 : 0)), l == this.curLineStart + this.curLine.length && this.nextLine(), (l < i || l > this.value.to) && (!this.test || this.test(l, i, t)))
          return this.value = { from: l, to: i, match: t }, this;
        e = this.matchPos - this.curLineStart;
      } else if (this.curLineStart + this.curLine.length < this.to)
        this.nextLine(), e = 0;
      else
        return this.done = !0, this;
    }
  }
}
const Pa = /* @__PURE__ */ new WeakMap();
class Bl {
  constructor(e, t) {
    this.from = e, this.text = t;
  }
  get to() {
    return this.from + this.text.length;
  }
  static get(e, t, l) {
    let i = Pa.get(e);
    if (!i || i.from >= l || i.to <= t) {
      let s = new Bl(t, e.sliceString(t, l));
      return Pa.set(e, s), s;
    }
    if (i.from == t && i.to == l)
      return i;
    let { text: o, from: n } = i;
    return n > t && (o = e.sliceString(t, n) + o, n = t), i.to < l && (o += e.sliceString(i.to, l)), Pa.set(e, new Bl(n, o)), new Bl(t, o.slice(t - n, l - n));
  }
}
class FO {
  constructor(e, t, l, i, o) {
    this.text = e, this.to = o, this.done = !1, this.value = LO, this.matchPos = ts(e, i), this.re = new RegExp(t, eh + (l != null && l.ignoreCase ? "i" : "")), this.test = l == null ? void 0 : l.test, this.flat = Bl.get(e, i, this.chunkEnd(
      i + 5e3
      /* Chunk.Base */
    ));
  }
  chunkEnd(e) {
    return e >= this.to ? this.to : this.text.lineAt(e).to;
  }
  next() {
    for (; ; ) {
      let e = this.re.lastIndex = this.matchPos - this.flat.from, t = this.re.exec(this.flat.text);
      if (t && !t[0] && t.index == e && (this.re.lastIndex = e + 1, t = this.re.exec(this.flat.text)), t) {
        let l = this.flat.from + t.index, i = l + t[0].length;
        if ((this.flat.to >= this.to || t.index + t[0].length <= this.flat.text.length - 10) && (!this.test || this.test(l, i, t)))
          return this.value = { from: l, to: i, match: t }, this.matchPos = ts(this.text, i + (l == i ? 1 : 0)), this;
      }
      if (this.flat.to == this.to)
        return this.done = !0, this;
      this.flat = Bl.get(this.text, this.flat.from, this.chunkEnd(this.flat.from + this.flat.text.length * 2));
    }
  }
}
typeof Symbol < "u" && (GO.prototype[Symbol.iterator] = FO.prototype[Symbol.iterator] = function() {
  return this;
});
function C2(r) {
  try {
    return new RegExp(r, eh), !0;
  } catch {
    return !1;
  }
}
function ts(r, e) {
  if (e >= r.length)
    return e;
  let t = r.lineAt(e), l;
  for (; e < t.to && (l = t.text.charCodeAt(e - t.from)) >= 56320 && l < 57344; )
    e++;
  return e;
}
function Uc(r) {
  let e = xe("input", { class: "cm-textfield", name: "line" }), t = xe("form", {
    class: "cm-gotoLine",
    onkeydown: (i) => {
      i.keyCode == 27 ? (i.preventDefault(), r.dispatch({ effects: rs.of(!1) }), r.focus()) : i.keyCode == 13 && (i.preventDefault(), l());
    },
    onsubmit: (i) => {
      i.preventDefault(), l();
    }
  }, xe("label", r.state.phrase("Go to line"), ": ", e), " ", xe("button", { class: "cm-button", type: "submit" }, r.state.phrase("go")));
  function l() {
    let i = /^([+-])?(\d+)?(:\d+)?(%)?$/.exec(e.value);
    if (!i)
      return;
    let { state: o } = r, n = o.doc.lineAt(o.selection.main.head), [, s, a, c, d] = i, h = c ? +c.slice(1) : 0, p = a ? +a : n.number;
    if (a && d) {
      let f = p / 100;
      s && (f = f * (s == "-" ? -1 : 1) + n.number / o.doc.lines), p = Math.round(o.doc.lines * f);
    } else
      a && s && (p = p * (s == "-" ? -1 : 1) + n.number);
    let u = o.doc.line(Math.max(1, Math.min(o.doc.lines, p)));
    r.dispatch({
      effects: rs.of(!1),
      selection: w.cursor(u.from + Math.max(0, Math.min(h, u.length))),
      scrollIntoView: !0
    }), r.focus();
  }
  return { dom: t };
}
const rs = /* @__PURE__ */ le.define(), cf = /* @__PURE__ */ Ue.define({
  create() {
    return !0;
  },
  update(r, e) {
    for (let t of e.effects)
      t.is(rs) && (r = t.value);
    return r;
  },
  provide: (r) => Hi.from(r, (e) => e ? Uc : null)
}), T2 = (r) => {
  let e = Fi(r, Uc);
  if (!e) {
    let t = [rs.of(!0)];
    r.state.field(cf, !1) == null && t.push(le.appendConfig.of([cf, z2])), r.dispatch({ effects: t }), e = Fi(r, Uc);
  }
  return e && e.dom.querySelector("input").focus(), !0;
}, z2 = /* @__PURE__ */ I.baseTheme({
  ".cm-panel.cm-gotoLine": {
    padding: "2px 6px 4px",
    "& label": { fontSize: "80%" }
  }
}), X2 = {
  highlightWordAroundCursor: !1,
  minSelectionLength: 1,
  maxMatches: 100,
  wholeWords: !1
}, HO = /* @__PURE__ */ Y.define({
  combine(r) {
    return ir(r, X2, {
      highlightWordAroundCursor: (e, t) => e || t,
      minSelectionLength: Math.min,
      maxMatches: Math.min
    });
  }
});
function A2(r) {
  let e = [D2, R2];
  return r && e.push(HO.of(r)), e;
}
const E2 = /* @__PURE__ */ B.mark({ class: "cm-selectionMatch" }), V2 = /* @__PURE__ */ B.mark({ class: "cm-selectionMatch cm-selectionMatch-main" });
function df(r, e, t, l) {
  return (t == 0 || r(e.sliceDoc(t - 1, t)) != Qe.Word) && (l == e.doc.length || r(e.sliceDoc(l, l + 1)) != Qe.Word);
}
function Z2(r, e, t, l) {
  return r(e.sliceDoc(t, t + 1)) == Qe.Word && r(e.sliceDoc(l - 1, l)) == Qe.Word;
}
const R2 = /* @__PURE__ */ Ze.fromClass(class {
  constructor(r) {
    this.decorations = this.getDeco(r);
  }
  update(r) {
    (r.selectionSet || r.docChanged || r.viewportChanged) && (this.decorations = this.getDeco(r.view));
  }
  getDeco(r) {
    let e = r.state.facet(HO), { state: t } = r, l = t.selection;
    if (l.ranges.length > 1)
      return B.none;
    let i = l.main, o, n = null;
    if (i.empty) {
      if (!e.highlightWordAroundCursor)
        return B.none;
      let a = t.wordAt(i.head);
      if (!a)
        return B.none;
      n = t.charCategorizer(i.head), o = t.sliceDoc(a.from, a.to);
    } else {
      let a = i.to - i.from;
      if (a < e.minSelectionLength || a > 200)
        return B.none;
      if (e.wholeWords) {
        if (o = t.sliceDoc(i.from, i.to), n = t.charCategorizer(i.head), !(df(n, t, i.from, i.to) && Z2(n, t, i.from, i.to)))
          return B.none;
      } else if (o = t.sliceDoc(i.from, i.to).trim(), !o)
        return B.none;
    }
    let s = [];
    for (let a of r.visibleRanges) {
      let c = new ii(t.doc, o, a.from, a.to);
      for (; !c.next().done; ) {
        let { from: d, to: h } = c.value;
        if ((!n || df(n, t, d, h)) && (i.empty && d <= i.from && h >= i.to ? s.push(V2.range(d, h)) : (d >= i.to || h <= i.from) && s.push(E2.range(d, h)), s.length > e.maxMatches))
          return B.none;
      }
    }
    return B.set(s);
  }
}, {
  decorations: (r) => r.decorations
}), D2 = /* @__PURE__ */ I.baseTheme({
  ".cm-selectionMatch": { backgroundColor: "#99ff7780" },
  ".cm-searchMatch .cm-selectionMatch": { backgroundColor: "transparent" }
}), W2 = ({ state: r, dispatch: e }) => {
  let { selection: t } = r, l = w.create(t.ranges.map((i) => r.wordAt(i.head) || w.cursor(i.head)), t.mainIndex);
  return l.eq(t) ? !1 : (e(r.update({ selection: l })), !0);
};
function N2(r, e) {
  let { main: t, ranges: l } = r.selection, i = r.wordAt(t.head), o = i && i.from == t.from && i.to == t.to;
  for (let n = !1, s = new ii(r.doc, e, l[l.length - 1].to); ; )
    if (s.next(), s.done) {
      if (n)
        return null;
      s = new ii(r.doc, e, 0, Math.max(0, l[l.length - 1].from - 1)), n = !0;
    } else {
      if (n && l.some((a) => a.from == s.value.from))
        continue;
      if (o) {
        let a = r.wordAt(s.value.from);
        if (!a || a.from != s.value.from || a.to != s.value.to)
          continue;
      }
      return s.value;
    }
}
const M2 = ({ state: r, dispatch: e }) => {
  let { ranges: t } = r.selection;
  if (t.some((o) => o.from === o.to))
    return W2({ state: r, dispatch: e });
  let l = r.sliceDoc(t[0].from, t[0].to);
  if (r.selection.ranges.some((o) => r.sliceDoc(o.from, o.to) != l))
    return !1;
  let i = N2(r, l);
  return i ? (e(r.update({
    selection: r.selection.addRange(w.range(i.from, i.to), !1),
    effects: I.scrollIntoView(i.to)
  })), !0) : !1;
}, th = /* @__PURE__ */ Y.define({
  combine(r) {
    return ir(r, {
      top: !1,
      caseSensitive: !1,
      literal: !1,
      wholeWord: !1,
      createPanel: (e) => new J2(e)
    });
  }
});
class KO {
  /**
  Create a query object.
  */
  constructor(e) {
    this.search = e.search, this.caseSensitive = !!e.caseSensitive, this.literal = !!e.literal, this.regexp = !!e.regexp, this.replace = e.replace || "", this.valid = !!this.search && (!this.regexp || C2(this.search)), this.unquoted = this.unquote(this.search), this.wholeWord = !!e.wholeWord;
  }
  /**
  @internal
  */
  unquote(e) {
    return this.literal ? e : e.replace(/\\([nrt\\])/g, (t, l) => l == "n" ? `
` : l == "r" ? "\r" : l == "t" ? "	" : "\\");
  }
  /**
  Compare this query to another query.
  */
  eq(e) {
    return this.search == e.search && this.replace == e.replace && this.caseSensitive == e.caseSensitive && this.regexp == e.regexp && this.wholeWord == e.wholeWord;
  }
  /**
  @internal
  */
  create() {
    return this.regexp ? new U2(this) : new j2(this);
  }
  /**
  Get a search cursor for this query, searching through the given
  range in the given state.
  */
  getCursor(e, t = 0, l) {
    let i = e.doc ? e : pe.create({ doc: e });
    return l == null && (l = i.doc.length), this.regexp ? Al(this, i, t, l) : Xl(this, i, t, l);
  }
}
class JO {
  constructor(e) {
    this.spec = e;
  }
}
function Xl(r, e, t, l) {
  return new ii(e.doc, r.unquoted, t, l, r.caseSensitive ? void 0 : (i) => i.toLowerCase(), r.wholeWord ? Y2(e.doc, e.charCategorizer(e.selection.main.head)) : void 0);
}
function Y2(r, e) {
  return (t, l, i, o) => ((o > t || o + i.length < l) && (o = Math.max(0, t - 2), i = r.sliceString(o, Math.min(r.length, l + 2))), (e(ls(i, t - o)) != Qe.Word || e(is(i, t - o)) != Qe.Word) && (e(is(i, l - o)) != Qe.Word || e(ls(i, l - o)) != Qe.Word));
}
class j2 extends JO {
  constructor(e) {
    super(e);
  }
  nextMatch(e, t, l) {
    let i = Xl(this.spec, e, l, e.doc.length).nextOverlapping();
    return i.done && (i = Xl(this.spec, e, 0, t).nextOverlapping()), i.done ? null : i.value;
  }
  // Searching in reverse is, rather than implementing inverted search
  // cursor, done by scanning chunk after chunk forward.
  prevMatchInRange(e, t, l) {
    for (let i = l; ; ) {
      let o = Math.max(t, i - 1e4 - this.spec.unquoted.length), n = Xl(this.spec, e, o, i), s = null;
      for (; !n.nextOverlapping().done; )
        s = n.value;
      if (s)
        return s;
      if (o == t)
        return null;
      i -= 1e4;
    }
  }
  prevMatch(e, t, l) {
    return this.prevMatchInRange(e, 0, t) || this.prevMatchInRange(e, l, e.doc.length);
  }
  getReplacement(e) {
    return this.spec.unquote(this.spec.replace);
  }
  matchAll(e, t) {
    let l = Xl(this.spec, e, 0, e.doc.length), i = [];
    for (; !l.next().done; ) {
      if (i.length >= t)
        return null;
      i.push(l.value);
    }
    return i;
  }
  highlight(e, t, l, i) {
    let o = Xl(this.spec, e, Math.max(0, t - this.spec.unquoted.length), Math.min(l + this.spec.unquoted.length, e.doc.length));
    for (; !o.next().done; )
      i(o.value.from, o.value.to);
  }
}
function Al(r, e, t, l) {
  return new GO(e.doc, r.search, {
    ignoreCase: !r.caseSensitive,
    test: r.wholeWord ? I2(e.charCategorizer(e.selection.main.head)) : void 0
  }, t, l);
}
function ls(r, e) {
  return r.slice(nt(r, e, !1), e);
}
function is(r, e) {
  return r.slice(e, nt(r, e));
}
function I2(r) {
  return (e, t, l) => !l[0].length || (r(ls(l.input, l.index)) != Qe.Word || r(is(l.input, l.index)) != Qe.Word) && (r(is(l.input, l.index + l[0].length)) != Qe.Word || r(ls(l.input, l.index + l[0].length)) != Qe.Word);
}
class U2 extends JO {
  nextMatch(e, t, l) {
    let i = Al(this.spec, e, l, e.doc.length).next();
    return i.done && (i = Al(this.spec, e, 0, t).next()), i.done ? null : i.value;
  }
  prevMatchInRange(e, t, l) {
    for (let i = 1; ; i++) {
      let o = Math.max(
        t,
        l - i * 1e4
        /* FindPrev.ChunkSize */
      ), n = Al(this.spec, e, o, l), s = null;
      for (; !n.next().done; )
        s = n.value;
      if (s && (o == t || s.from > o + 10))
        return s;
      if (o == t)
        return null;
    }
  }
  prevMatch(e, t, l) {
    return this.prevMatchInRange(e, 0, t) || this.prevMatchInRange(e, l, e.doc.length);
  }
  getReplacement(e) {
    return this.spec.unquote(this.spec.replace.replace(/\$([$&\d+])/g, (t, l) => l == "$" ? "$" : l == "&" ? e.match[0] : l != "0" && +l < e.match.length ? e.match[l] : t));
  }
  matchAll(e, t) {
    let l = Al(this.spec, e, 0, e.doc.length), i = [];
    for (; !l.next().done; ) {
      if (i.length >= t)
        return null;
      i.push(l.value);
    }
    return i;
  }
  highlight(e, t, l, i) {
    let o = Al(this.spec, e, Math.max(
      0,
      t - 250
      /* RegExp.HighlightMargin */
    ), Math.min(l + 250, e.doc.length));
    for (; !o.next().done; )
      i(o.value.from, o.value.to);
  }
}
const lo = /* @__PURE__ */ le.define(), rh = /* @__PURE__ */ le.define(), Zr = /* @__PURE__ */ Ue.define({
  create(r) {
    return new Ca(qc(r).create(), null);
  },
  update(r, e) {
    for (let t of e.effects)
      t.is(lo) ? r = new Ca(t.value.create(), r.panel) : t.is(rh) && (r = new Ca(r.query, t.value ? lh : null));
    return r;
  },
  provide: (r) => Hi.from(r, (e) => e.panel)
});
class Ca {
  constructor(e, t) {
    this.query = e, this.panel = t;
  }
}
const q2 = /* @__PURE__ */ B.mark({ class: "cm-searchMatch" }), B2 = /* @__PURE__ */ B.mark({ class: "cm-searchMatch cm-searchMatch-selected" }), L2 = /* @__PURE__ */ Ze.fromClass(class {
  constructor(r) {
    this.view = r, this.decorations = this.highlight(r.state.field(Zr));
  }
  update(r) {
    let e = r.state.field(Zr);
    (e != r.startState.field(Zr) || r.docChanged || r.selectionSet || r.viewportChanged) && (this.decorations = this.highlight(e));
  }
  highlight({ query: r, panel: e }) {
    if (!e || !r.spec.valid)
      return B.none;
    let { view: t } = this, l = new Yr();
    for (let i = 0, o = t.visibleRanges, n = o.length; i < n; i++) {
      let { from: s, to: a } = o[i];
      for (; i < n - 1 && a > o[i + 1].from - 2 * 250; )
        a = o[++i].to;
      r.highlight(t.state, s, a, (c, d) => {
        let h = t.state.selection.ranges.some((p) => p.from == c && p.to == d);
        l.add(c, d, h ? B2 : q2);
      });
    }
    return l.finish();
  }
}, {
  decorations: (r) => r.decorations
});
function xo(r) {
  return (e) => {
    let t = e.state.field(Zr, !1);
    return t && t.query.spec.valid ? r(e, t) : ev(e);
  };
}
const os = /* @__PURE__ */ xo((r, { query: e }) => {
  let { to: t } = r.state.selection.main, l = e.nextMatch(r.state, t, t);
  return l ? (r.dispatch({
    selection: { anchor: l.from, head: l.to },
    scrollIntoView: !0,
    effects: ih(r, l),
    userEvent: "select.search"
  }), !0) : !1;
}), ns = /* @__PURE__ */ xo((r, { query: e }) => {
  let { state: t } = r, { from: l } = t.selection.main, i = e.prevMatch(t, l, l);
  return i ? (r.dispatch({
    selection: { anchor: i.from, head: i.to },
    scrollIntoView: !0,
    effects: ih(r, i),
    userEvent: "select.search"
  }), !0) : !1;
}), G2 = /* @__PURE__ */ xo((r, { query: e }) => {
  let t = e.matchAll(r.state, 1e3);
  return !t || !t.length ? !1 : (r.dispatch({
    selection: w.create(t.map((l) => w.range(l.from, l.to))),
    userEvent: "select.search.matches"
  }), !0);
}), F2 = ({ state: r, dispatch: e }) => {
  let t = r.selection;
  if (t.ranges.length > 1 || t.main.empty)
    return !1;
  let { from: l, to: i } = t.main, o = [], n = 0;
  for (let s = new ii(r.doc, r.sliceDoc(l, i)); !s.next().done; ) {
    if (o.length > 1e3)
      return !1;
    s.value.from == l && (n = o.length), o.push(w.range(s.value.from, s.value.to));
  }
  return e(r.update({
    selection: w.create(o, n),
    userEvent: "select.search.matches"
  })), !0;
}, hf = /* @__PURE__ */ xo((r, { query: e }) => {
  let { state: t } = r, { from: l, to: i } = t.selection.main;
  if (t.readOnly)
    return !1;
  let o = e.nextMatch(t, l, l);
  if (!o)
    return !1;
  let n = [], s, a, c = [];
  if (o.from == l && o.to == i && (a = t.toText(e.getReplacement(o)), n.push({ from: o.from, to: o.to, insert: a }), o = e.nextMatch(t, o.from, o.to), c.push(I.announce.of(t.phrase("replaced match on line $", t.doc.lineAt(l).number) + "."))), o) {
    let d = n.length == 0 || n[0].from >= o.to ? 0 : o.to - o.from - a.length;
    s = { anchor: o.from - d, head: o.to - d }, c.push(ih(r, o));
  }
  return r.dispatch({
    changes: n,
    selection: s,
    scrollIntoView: !!s,
    effects: c,
    userEvent: "input.replace"
  }), !0;
}), H2 = /* @__PURE__ */ xo((r, { query: e }) => {
  if (r.state.readOnly)
    return !1;
  let t = e.matchAll(r.state, 1e9).map((i) => {
    let { from: o, to: n } = i;
    return { from: o, to: n, insert: e.getReplacement(i) };
  });
  if (!t.length)
    return !1;
  let l = r.state.phrase("replaced $ matches", t.length) + ".";
  return r.dispatch({
    changes: t,
    effects: I.announce.of(l),
    userEvent: "input.replace.all"
  }), !0;
});
function lh(r) {
  return r.state.facet(th).createPanel(r);
}
function qc(r, e) {
  var t, l, i, o;
  let n = r.selection.main, s = n.empty || n.to > n.from + 100 ? "" : r.sliceDoc(n.from, n.to);
  if (e && !s)
    return e;
  let a = r.facet(th);
  return new KO({
    search: ((t = e == null ? void 0 : e.literal) !== null && t !== void 0 ? t : a.literal) ? s : s.replace(/\n/g, "\\n"),
    caseSensitive: (l = e == null ? void 0 : e.caseSensitive) !== null && l !== void 0 ? l : a.caseSensitive,
    literal: (i = e == null ? void 0 : e.literal) !== null && i !== void 0 ? i : a.literal,
    wholeWord: (o = e == null ? void 0 : e.wholeWord) !== null && o !== void 0 ? o : a.wholeWord
  });
}
const ev = (r) => {
  let e = r.state.field(Zr, !1);
  if (e && e.panel) {
    let t = Fi(r, lh);
    if (!t)
      return !1;
    let l = t.dom.querySelector("[main-field]");
    if (l && l != r.root.activeElement) {
      let i = qc(r.state, e.query.spec);
      i.valid && r.dispatch({ effects: lo.of(i) }), l.focus(), l.select();
    }
  } else
    r.dispatch({ effects: [
      rh.of(!0),
      e ? lo.of(qc(r.state, e.query.spec)) : le.appendConfig.of(t$)
    ] });
  return !0;
}, tv = (r) => {
  let e = r.state.field(Zr, !1);
  if (!e || !e.panel)
    return !1;
  let t = Fi(r, lh);
  return t && t.dom.contains(r.root.activeElement) && r.focus(), r.dispatch({ effects: rh.of(!1) }), !0;
}, K2 = [
  { key: "Mod-f", run: ev, scope: "editor search-panel" },
  { key: "F3", run: os, shift: ns, scope: "editor search-panel", preventDefault: !0 },
  { key: "Mod-g", run: os, shift: ns, scope: "editor search-panel", preventDefault: !0 },
  { key: "Escape", run: tv, scope: "editor search-panel" },
  { key: "Mod-Shift-l", run: F2 },
  { key: "Alt-g", run: T2 },
  { key: "Mod-d", run: M2, preventDefault: !0 }
];
class J2 {
  constructor(e) {
    this.view = e;
    let t = this.query = e.state.field(Zr).query.spec;
    this.commit = this.commit.bind(this), this.searchField = xe("input", {
      value: t.search,
      placeholder: bt(e, "Find"),
      "aria-label": bt(e, "Find"),
      class: "cm-textfield",
      name: "search",
      form: "",
      "main-field": "true",
      onchange: this.commit,
      onkeyup: this.commit
    }), this.replaceField = xe("input", {
      value: t.replace,
      placeholder: bt(e, "Replace"),
      "aria-label": bt(e, "Replace"),
      class: "cm-textfield",
      name: "replace",
      form: "",
      onchange: this.commit,
      onkeyup: this.commit
    }), this.caseField = xe("input", {
      type: "checkbox",
      name: "case",
      form: "",
      checked: t.caseSensitive,
      onchange: this.commit
    }), this.reField = xe("input", {
      type: "checkbox",
      name: "re",
      form: "",
      checked: t.regexp,
      onchange: this.commit
    }), this.wordField = xe("input", {
      type: "checkbox",
      name: "word",
      form: "",
      checked: t.wholeWord,
      onchange: this.commit
    });
    function l(i, o, n) {
      return xe("button", { class: "cm-button", name: i, onclick: o, type: "button" }, n);
    }
    this.dom = xe("div", { onkeydown: (i) => this.keydown(i), class: "cm-search" }, [
      this.searchField,
      l("next", () => os(e), [bt(e, "next")]),
      l("prev", () => ns(e), [bt(e, "previous")]),
      l("select", () => G2(e), [bt(e, "all")]),
      xe("label", null, [this.caseField, bt(e, "match case")]),
      xe("label", null, [this.reField, bt(e, "regexp")]),
      xe("label", null, [this.wordField, bt(e, "by word")]),
      ...e.state.readOnly ? [] : [
        xe("br"),
        this.replaceField,
        l("replace", () => hf(e), [bt(e, "replace")]),
        l("replaceAll", () => H2(e), [bt(e, "replace all")])
      ],
      xe("button", {
        name: "close",
        onclick: () => tv(e),
        "aria-label": bt(e, "close"),
        type: "button"
      }, ["×"])
    ]);
  }
  commit() {
    let e = new KO({
      search: this.searchField.value,
      caseSensitive: this.caseField.checked,
      regexp: this.reField.checked,
      wholeWord: this.wordField.checked,
      replace: this.replaceField.value
    });
    e.eq(this.query) || (this.query = e, this.view.dispatch({ effects: lo.of(e) }));
  }
  keydown(e) {
    Cy(this.view, e, "search-panel") ? e.preventDefault() : e.keyCode == 13 && e.target == this.searchField ? (e.preventDefault(), (e.shiftKey ? ns : os)(this.view)) : e.keyCode == 13 && e.target == this.replaceField && (e.preventDefault(), hf(this.view));
  }
  update(e) {
    for (let t of e.transactions)
      for (let l of t.effects)
        l.is(lo) && !l.value.eq(this.query) && this.setQuery(l.value);
  }
  setQuery(e) {
    this.query = e, this.searchField.value = e.search, this.replaceField.value = e.replace, this.caseField.checked = e.caseSensitive, this.reField.checked = e.regexp, this.wordField.checked = e.wholeWord;
  }
  mount() {
    this.searchField.select();
  }
  get pos() {
    return 80;
  }
  get top() {
    return this.view.state.facet(th).top;
  }
}
function bt(r, e) {
  return r.state.phrase(e);
}
const Bo = 30, Lo = /[\s\.,:;?!]/;
function ih(r, { from: e, to: t }) {
  let l = r.state.doc.lineAt(e), i = r.state.doc.lineAt(t).to, o = Math.max(l.from, e - Bo), n = Math.min(i, t + Bo), s = r.state.sliceDoc(o, n);
  if (o != l.from) {
    for (let a = 0; a < Bo; a++)
      if (!Lo.test(s[a + 1]) && Lo.test(s[a])) {
        s = s.slice(a);
        break;
      }
  }
  if (n != i) {
    for (let a = s.length - 1; a > s.length - Bo; a--)
      if (!Lo.test(s[a - 1]) && Lo.test(s[a])) {
        s = s.slice(0, a);
        break;
      }
  }
  return I.announce.of(`${r.state.phrase("current match")}. ${s} ${r.state.phrase("on line")} ${l.number}.`);
}
const e$ = /* @__PURE__ */ I.baseTheme({
  ".cm-panel.cm-search": {
    padding: "2px 6px 4px",
    position: "relative",
    "& [name=close]": {
      position: "absolute",
      top: "0",
      right: "4px",
      backgroundColor: "inherit",
      border: "none",
      font: "inherit",
      padding: 0,
      margin: 0
    },
    "& input, & button, & label": {
      margin: ".2em .6em .2em 0"
    },
    "& input[type=checkbox]": {
      marginRight: ".2em"
    },
    "& label": {
      fontSize: "80%",
      whiteSpace: "pre"
    }
  },
  "&light .cm-searchMatch": { backgroundColor: "#ffff0054" },
  "&dark .cm-searchMatch": { backgroundColor: "#00ffff8a" },
  "&light .cm-searchMatch-selected": { backgroundColor: "#ff6a0054" },
  "&dark .cm-searchMatch-selected": { backgroundColor: "#ff00ff8a" }
}), t$ = [
  Zr,
  /* @__PURE__ */ kl.lowest(L2),
  e$
];
class r$ {
  constructor(e, t, l) {
    this.from = e, this.to = t, this.diagnostic = l;
  }
}
class il {
  constructor(e, t, l) {
    this.diagnostics = e, this.panel = t, this.selected = l;
  }
  static init(e, t, l) {
    let i = e, o = l.facet(Dl).markerFilter;
    o && (i = o(i));
    let n = B.set(i.map((s) => s.from == s.to || s.from == s.to - 1 && l.doc.lineAt(s.from).to == s.from ? B.widget({
      widget: new p$(s),
      diagnostic: s
    }).range(s.from) : B.mark({
      attributes: { class: "cm-lintRange cm-lintRange-" + s.severity },
      diagnostic: s
    }).range(s.from, s.to)), !0);
    return new il(n, t, oi(n));
  }
}
function oi(r, e = null, t = 0) {
  let l = null;
  return r.between(t, 1e9, (i, o, { spec: n }) => {
    if (!(e && n.diagnostic != e))
      return l = new r$(i, o, n.diagnostic), !1;
  }), l;
}
function l$(r, e) {
  return !!(r.effects.some((t) => t.is(oh)) || r.changes.touchesRange(e.pos));
}
function rv(r, e) {
  return r.field(wt, !1) ? e : e.concat(le.appendConfig.of([
    wt,
    I.decorations.compute([wt], (t) => {
      let { selected: l, panel: i } = t.field(wt);
      return !l || !i || l.from == l.to ? B.none : B.set([
        o$.range(l.from, l.to)
      ]);
    }),
    fk(n$, { hideOn: l$ }),
    f$
  ]));
}
function i$(r, e) {
  return {
    effects: rv(r, [oh.of(e)])
  };
}
const oh = /* @__PURE__ */ le.define(), nh = /* @__PURE__ */ le.define(), lv = /* @__PURE__ */ le.define(), wt = /* @__PURE__ */ Ue.define({
  create() {
    return new il(B.none, null, null);
  },
  update(r, e) {
    if (e.docChanged) {
      let t = r.diagnostics.map(e.changes), l = null;
      if (r.selected) {
        let i = e.changes.mapPos(r.selected.from, 1);
        l = oi(t, r.selected.diagnostic, i) || oi(t, null, i);
      }
      r = new il(t, r.panel, l);
    }
    for (let t of e.effects)
      t.is(oh) ? r = il.init(t.value, r.panel, e.state) : t.is(nh) ? r = new il(r.diagnostics, t.value ? js.open : null, r.selected) : t.is(lv) && (r = new il(r.diagnostics, r.panel, t.value));
    return r;
  },
  provide: (r) => [
    Hi.from(r, (e) => e.panel),
    I.decorations.from(r, (e) => e.diagnostics)
  ]
}), o$ = /* @__PURE__ */ B.mark({ class: "cm-lintRange cm-lintRange-active" });
function n$(r, e, t) {
  let { diagnostics: l } = r.state.field(wt), i = [], o = 2e8, n = 0;
  l.between(e - (t < 0 ? 1 : 0), e + (t > 0 ? 1 : 0), (a, c, { spec: d }) => {
    e >= a && e <= c && (a == c || (e > a || t > 0) && (e < c || t < 0)) && (i.push(d.diagnostic), o = Math.min(a, o), n = Math.max(c, n));
  });
  let s = r.state.facet(Dl).tooltipFilter;
  return s && (i = s(i)), i.length ? {
    pos: o,
    end: n,
    above: r.state.doc.lineAt(o).to < n,
    create() {
      return { dom: s$(r, i) };
    }
  } : null;
}
function s$(r, e) {
  return xe("ul", { class: "cm-tooltip-lint" }, e.map((t) => ov(r, t, !1)));
}
const a$ = (r) => {
  let e = r.state.field(wt, !1);
  (!e || !e.panel) && r.dispatch({ effects: rv(r.state, [nh.of(!0)]) });
  let t = Fi(r, js.open);
  return t && t.dom.querySelector(".cm-panel-lint ul").focus(), !0;
}, pf = (r) => {
  let e = r.state.field(wt, !1);
  return !e || !e.panel ? !1 : (r.dispatch({ effects: nh.of(!1) }), !0);
}, c$ = (r) => {
  let e = r.state.field(wt, !1);
  if (!e)
    return !1;
  let t = r.state.selection.main, l = e.diagnostics.iter(t.to + 1);
  return !l.value && (l = e.diagnostics.iter(0), !l.value || l.from == t.from && l.to == t.to) ? !1 : (r.dispatch({ selection: { anchor: l.from, head: l.to }, scrollIntoView: !0 }), !0);
}, d$ = [
  { key: "Mod-Shift-m", run: a$, preventDefault: !0 },
  { key: "F8", run: c$ }
], h$ = /* @__PURE__ */ Ze.fromClass(class {
  constructor(r) {
    this.view = r, this.timeout = -1, this.set = !0;
    let { delay: e } = r.state.facet(Dl);
    this.lintTime = Date.now() + e, this.run = this.run.bind(this), this.timeout = setTimeout(this.run, e);
  }
  run() {
    let r = Date.now();
    if (r < this.lintTime - 10)
      setTimeout(this.run, this.lintTime - r);
    else {
      this.set = !1;
      let { state: e } = this.view, { sources: t } = e.facet(Dl);
      Promise.all(t.map((l) => Promise.resolve(l(this.view)))).then((l) => {
        let i = l.reduce((o, n) => o.concat(n));
        this.view.state.doc == e.doc && this.view.dispatch(i$(this.view.state, i));
      }, (l) => {
        yt(this.view.state, l);
      });
    }
  }
  update(r) {
    let e = r.state.facet(Dl);
    (r.docChanged || e != r.startState.facet(Dl)) && (this.lintTime = Date.now() + e.delay, this.set || (this.set = !0, this.timeout = setTimeout(this.run, e.delay)));
  }
  force() {
    this.set && (this.lintTime = Date.now(), this.run());
  }
  destroy() {
    clearTimeout(this.timeout);
  }
}), Dl = /* @__PURE__ */ Y.define({
  combine(r) {
    return Object.assign({ sources: r.map((e) => e.source) }, ir(r.map((e) => e.config), {
      delay: 750,
      markerFilter: null,
      tooltipFilter: null
    }));
  },
  enables: h$
});
function iv(r) {
  let e = [];
  if (r)
    e:
      for (let { name: t } of r) {
        for (let l = 0; l < t.length; l++) {
          let i = t[l];
          if (/[a-zA-Z]/.test(i) && !e.some((o) => o.toLowerCase() == i.toLowerCase())) {
            e.push(i);
            continue e;
          }
        }
        e.push("");
      }
  return e;
}
function ov(r, e, t) {
  var l;
  let i = t ? iv(e.actions) : [];
  return xe("li", { class: "cm-diagnostic cm-diagnostic-" + e.severity }, xe("span", { class: "cm-diagnosticText" }, e.renderMessage ? e.renderMessage() : e.message), (l = e.actions) === null || l === void 0 ? void 0 : l.map((o, n) => {
    let s = (h) => {
      h.preventDefault();
      let p = oi(r.state.field(wt).diagnostics, e);
      p && o.apply(r, p.from, p.to);
    }, { name: a } = o, c = i[n] ? a.indexOf(i[n]) : -1, d = c < 0 ? a : [
      a.slice(0, c),
      xe("u", a.slice(c, c + 1)),
      a.slice(c + 1)
    ];
    return xe("button", {
      type: "button",
      class: "cm-diagnosticAction",
      onclick: s,
      onmousedown: s,
      "aria-label": ` Action: ${a}${c < 0 ? "" : ` (access key "${i[n]})"`}.`
    }, d);
  }), e.source && xe("div", { class: "cm-diagnosticSource" }, e.source));
}
class p$ extends br {
  constructor(e) {
    super(), this.diagnostic = e;
  }
  eq(e) {
    return e.diagnostic == this.diagnostic;
  }
  toDOM() {
    return xe("span", { class: "cm-lintPoint cm-lintPoint-" + this.diagnostic.severity });
  }
}
class uf {
  constructor(e, t) {
    this.diagnostic = t, this.id = "item_" + Math.floor(Math.random() * 4294967295).toString(16), this.dom = ov(e, t, !0), this.dom.id = this.id, this.dom.setAttribute("role", "option");
  }
}
class js {
  constructor(e) {
    this.view = e, this.items = [];
    let t = (i) => {
      if (i.keyCode == 27)
        pf(this.view), this.view.focus();
      else if (i.keyCode == 38 || i.keyCode == 33)
        this.moveSelection((this.selectedIndex - 1 + this.items.length) % this.items.length);
      else if (i.keyCode == 40 || i.keyCode == 34)
        this.moveSelection((this.selectedIndex + 1) % this.items.length);
      else if (i.keyCode == 36)
        this.moveSelection(0);
      else if (i.keyCode == 35)
        this.moveSelection(this.items.length - 1);
      else if (i.keyCode == 13)
        this.view.focus();
      else if (i.keyCode >= 65 && i.keyCode <= 90 && this.selectedIndex >= 0) {
        let { diagnostic: o } = this.items[this.selectedIndex], n = iv(o.actions);
        for (let s = 0; s < n.length; s++)
          if (n[s].toUpperCase().charCodeAt(0) == i.keyCode) {
            let a = oi(this.view.state.field(wt).diagnostics, o);
            a && o.actions[s].apply(e, a.from, a.to);
          }
      } else
        return;
      i.preventDefault();
    }, l = (i) => {
      for (let o = 0; o < this.items.length; o++)
        this.items[o].dom.contains(i.target) && this.moveSelection(o);
    };
    this.list = xe("ul", {
      tabIndex: 0,
      role: "listbox",
      "aria-label": this.view.state.phrase("Diagnostics"),
      onkeydown: t,
      onclick: l
    }), this.dom = xe("div", { class: "cm-panel-lint" }, this.list, xe("button", {
      type: "button",
      name: "close",
      "aria-label": this.view.state.phrase("close"),
      onclick: () => pf(this.view)
    }, "×")), this.update();
  }
  get selectedIndex() {
    let e = this.view.state.field(wt).selected;
    if (!e)
      return -1;
    for (let t = 0; t < this.items.length; t++)
      if (this.items[t].diagnostic == e.diagnostic)
        return t;
    return -1;
  }
  update() {
    let { diagnostics: e, selected: t } = this.view.state.field(wt), l = 0, i = !1, o = null;
    for (e.between(0, this.view.state.doc.length, (n, s, { spec: a }) => {
      let c = -1, d;
      for (let h = l; h < this.items.length; h++)
        if (this.items[h].diagnostic == a.diagnostic) {
          c = h;
          break;
        }
      c < 0 ? (d = new uf(this.view, a.diagnostic), this.items.splice(l, 0, d), i = !0) : (d = this.items[c], c > l && (this.items.splice(l, c - l), i = !0)), t && d.diagnostic == t.diagnostic ? d.dom.hasAttribute("aria-selected") || (d.dom.setAttribute("aria-selected", "true"), o = d) : d.dom.hasAttribute("aria-selected") && d.dom.removeAttribute("aria-selected"), l++;
    }); l < this.items.length && !(this.items.length == 1 && this.items[0].diagnostic.from < 0); )
      i = !0, this.items.pop();
    this.items.length == 0 && (this.items.push(new uf(this.view, {
      from: -1,
      to: -1,
      severity: "info",
      message: this.view.state.phrase("No diagnostics")
    })), i = !0), o ? (this.list.setAttribute("aria-activedescendant", o.id), this.view.requestMeasure({
      key: this,
      read: () => ({ sel: o.dom.getBoundingClientRect(), panel: this.list.getBoundingClientRect() }),
      write: ({ sel: n, panel: s }) => {
        n.top < s.top ? this.list.scrollTop -= s.top - n.top : n.bottom > s.bottom && (this.list.scrollTop += n.bottom - s.bottom);
      }
    })) : this.selectedIndex < 0 && this.list.removeAttribute("aria-activedescendant"), i && this.sync();
  }
  sync() {
    let e = this.list.firstChild;
    function t() {
      let l = e;
      e = l.nextSibling, l.remove();
    }
    for (let l of this.items)
      if (l.dom.parentNode == this.list) {
        for (; e != l.dom; )
          t();
        e = l.dom.nextSibling;
      } else
        this.list.insertBefore(l.dom, e);
    for (; e; )
      t();
  }
  moveSelection(e) {
    if (this.selectedIndex < 0)
      return;
    let t = this.view.state.field(wt), l = oi(t.diagnostics, this.items[e].diagnostic);
    l && this.view.dispatch({
      selection: { anchor: l.from, head: l.to },
      scrollIntoView: !0,
      effects: lv.of(l)
    });
  }
  static open(e) {
    return new js(e);
  }
}
function u$(r, e = 'viewBox="0 0 40 40"') {
  return `url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" ${e}>${encodeURIComponent(r)}</svg>')`;
}
function Ta(r) {
  return u$(`<path d="m0 2.5 l2 -1.5 l1 0 l2 1.5 l1 0" stroke="${r}" fill="none" stroke-width=".7"/>`, 'width="6" height="3"');
}
const f$ = /* @__PURE__ */ I.baseTheme({
  ".cm-diagnostic": {
    padding: "3px 6px 3px 8px",
    marginLeft: "-1px",
    display: "block",
    whiteSpace: "pre-wrap"
  },
  ".cm-diagnostic-error": { borderLeft: "5px solid #d11" },
  ".cm-diagnostic-warning": { borderLeft: "5px solid orange" },
  ".cm-diagnostic-info": { borderLeft: "5px solid #999" },
  ".cm-diagnosticAction": {
    font: "inherit",
    border: "none",
    padding: "2px 4px",
    backgroundColor: "#444",
    color: "white",
    borderRadius: "3px",
    marginLeft: "8px"
  },
  ".cm-diagnosticSource": {
    fontSize: "70%",
    opacity: 0.7
  },
  ".cm-lintRange": {
    backgroundPosition: "left bottom",
    backgroundRepeat: "repeat-x",
    paddingBottom: "0.7px"
  },
  ".cm-lintRange-error": { backgroundImage: /* @__PURE__ */ Ta("#d11") },
  ".cm-lintRange-warning": { backgroundImage: /* @__PURE__ */ Ta("orange") },
  ".cm-lintRange-info": { backgroundImage: /* @__PURE__ */ Ta("#999") },
  ".cm-lintRange-active": { backgroundColor: "#ffdd9980" },
  ".cm-tooltip-lint": {
    padding: 0,
    margin: 0
  },
  ".cm-lintPoint": {
    position: "relative",
    "&:after": {
      content: '""',
      position: "absolute",
      bottom: 0,
      left: "-2px",
      borderLeft: "3px solid transparent",
      borderRight: "3px solid transparent",
      borderBottom: "4px solid #d11"
    }
  },
  ".cm-lintPoint-warning": {
    "&:after": { borderBottomColor: "orange" }
  },
  ".cm-lintPoint-info": {
    "&:after": { borderBottomColor: "#999" }
  },
  ".cm-panel.cm-panel-lint": {
    position: "relative",
    "& ul": {
      maxHeight: "100px",
      overflowY: "auto",
      "& [aria-selected]": {
        backgroundColor: "#ddd",
        "& u": { textDecoration: "underline" }
      },
      "&:focus [aria-selected]": {
        background_fallback: "#bdf",
        backgroundColor: "Highlight",
        color_fallback: "white",
        color: "HighlightText"
      },
      "& u": { textDecoration: "none" },
      padding: 0,
      margin: 0
    },
    "& [name=close]": {
      position: "absolute",
      top: "0",
      right: "2px",
      background: "inherit",
      border: "none",
      font: "inherit",
      padding: 0,
      margin: 0
    }
  }
}), g$ = /* @__PURE__ */ (() => [
  kk(),
  $k(),
  qy(),
  G3(),
  _3(),
  Vy(),
  Ny(),
  pe.allowMultipleSelections.of(!0),
  c3(),
  y3(Q3, { fallback: !0 }),
  A3(),
  e2(),
  h2(),
  ik(),
  sk(),
  Ky(),
  A2(),
  mo.of([
    ...i2,
    ...tO,
    ...K2,
    ...iS,
    ...O3,
    ...AO,
    ...d$
  ])
])(), za = /* @__PURE__ */ Wt({
  __name: "CodeEditor",
  props: {
    theme: null,
    value: null
  },
  setup(r) {
    const e = r, t = {
      html: $2,
      javascript: NO,
      css: nO
    }, l = ke(), i = ke(), o = ke(e.value);
    return co(() => {
      i.value = new I({
        parent: l.value,
        doc: o.value,
        extensions: [
          mo.of(tO),
          g$,
          e.theme ? t[e.theme]() : t.javascript()
        ]
      });
    }), (n, s) => (Tt(), mr("div", {
      ref_key: "codeWrapper",
      ref: l,
      style: { width: "100%", height: "100%" }
    }, null, 512));
  }
}), m$ = /* @__PURE__ */ Wt({
  __name: "HtmlIframe",
  props: {
    html: null,
    javascript: null,
    css: null
  },
  setup(r) {
    const e = r, t = ke(), l = () => {
      if (t.value) {
        const i = document.createElement("style");
        i.innerHTML = e.css ?? "", i.id = "iframe-css";
        const o = document.createElement("script");
        o.innerHTML = e.javascript ?? "", o.id = "iframe-js", t.value.contentDocument && (t.value.contentDocument.head.appendChild(i), t.value.contentDocument.body.innerHTML = e.html ?? "", t.value.contentDocument.body.appendChild(o));
      }
    };
    return (i, o) => (Tt(), mr("iframe", {
      ref_key: "iframeRef",
      ref: t,
      class: "result-page",
      style: { width: "100%", height: "100%" },
      onLoad: l
    }, null, 544));
  }
}), b$ = /* @__PURE__ */ Wt({
  __name: "App",
  props: {
    html: null,
    js: null,
    css: null
  },
  setup(r) {
    const e = ke("result");
    return (t, l) => (Tt(), Od(De(I1), {
      modelValue: e.value,
      "onUpdate:modelValue": l[0] || (l[0] = (i) => e.value = i),
      class: "html-tabs",
      type: "card"
    }, {
      default: zl(() => [
        ce(De(Po), {
          label: "效果",
          name: "result"
        }, {
          default: zl(() => [
            ce(m$, {
              html: r.html,
              javascript: r.js,
              css: r.css
            }, null, 8, ["html", "javascript", "css"])
          ]),
          _: 1
        }),
        ce(De(Po), {
          label: "HTML",
          name: "HTML"
        }, {
          default: zl(() => [
            ce(za, {
              theme: "html",
              value: r.html
            }, null, 8, ["value"])
          ]),
          _: 1
        }),
        ce(De(Po), {
          label: "CSS",
          name: "CSS"
        }, {
          default: zl(() => [
            ce(za, {
              theme: "css",
              value: r.css
            }, null, 8, ["value"])
          ]),
          _: 1
        }),
        ce(De(Po), {
          label: "JavaScript",
          name: "JavaScript"
        }, {
          default: zl(() => [
            ce(za, {
              theme: "javascript",
              value: r.js
            }, null, 8, ["value"])
          ]),
          _: 1
        })
      ]),
      _: 1
    }, 8, ["modelValue"]));
  }
}), O$ = `.html-root {
  height: 100%;
}

.html-root .el-tabs {
  height: 100%;
  display: flex;
  flex-direction: column;
}

.html-root .el-tabs__header {
  margin-bottom: 0;
}

.html-root .el-tabs__content {
  flex: 1;
}

.html-root .el-tabs__content .el-tab-pane {
  height: 100%;
}

.cm-editor {
  height: 100%;
}
`;
var Bc = {}, v$ = {
  get exports() {
    return Bc;
  },
  set exports(r) {
    Bc = r;
  }
}, Lc = {}, x$ = {
  get exports() {
    return Lc;
  },
  set exports(r) {
    Lc = r;
  }
}, vn = 1;
function _$() {
  return vn = (vn * 9301 + 49297) % 233280, vn / 233280;
}
function w$(r) {
  vn = r;
}
var y$ = {
  nextValue: _$,
  seed: w$
}, Gc = y$, ol = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_-", Xr, ff, Pi;
function Fc() {
  Pi = !1;
}
function nv(r) {
  if (!r) {
    Xr !== ol && (Xr = ol, Fc());
    return;
  }
  if (r !== Xr) {
    if (r.length !== ol.length)
      throw new Error("Custom alphabet for shortid must be " + ol.length + " unique characters. You submitted " + r.length + " characters: " + r);
    var e = r.split("").filter(function(t, l, i) {
      return l !== i.lastIndexOf(t);
    });
    if (e.length)
      throw new Error("Custom alphabet for shortid must be " + ol.length + " unique characters. These characters were not unique: " + e.join(", "));
    Xr = r, Fc();
  }
}
function k$(r) {
  return nv(r), Xr;
}
function S$(r) {
  Gc.seed(r), ff !== r && (Fc(), ff = r);
}
function Q$() {
  Xr || nv(ol);
  for (var r = Xr.split(""), e = [], t = Gc.nextValue(), l; r.length > 0; )
    t = Gc.nextValue(), l = Math.floor(t * r.length), e.push(r.splice(l, 1)[0]);
  return e.join("");
}
function sv() {
  return Pi || (Pi = Q$(), Pi);
}
function $$(r) {
  var e = sv();
  return e[r];
}
function P$() {
  return Xr || ol;
}
var sh = {
  get: P$,
  characters: k$,
  seed: S$,
  lookup: $$,
  shuffled: sv
}, Xa = typeof window == "object" && (window.crypto || window.msCrypto), Hc;
!Xa || !Xa.getRandomValues ? Hc = function(r) {
  for (var e = [], t = 0; t < r; t++)
    e.push(Math.floor(Math.random() * 256));
  return e;
} : Hc = function(r) {
  return Xa.getRandomValues(new Uint8Array(r));
};
var C$ = Hc, T$ = function(r, e, t) {
  for (var l = (2 << Math.log(e.length - 1) / Math.LN2) - 1, i = -~(1.6 * l * t / e.length), o = ""; ; )
    for (var n = r(i), s = i; s--; )
      if (o += e[n[s] & l] || "", o.length === +t)
        return o;
}, z$ = sh, X$ = C$, A$ = T$;
function E$(r) {
  for (var e = 0, t, l = ""; !t; )
    l = l + A$(X$, z$.get(), 1), t = r < Math.pow(16, e + 1), e++;
  return l;
}
var V$ = E$, Go = V$, Z$ = 1567752802062, R$ = 7, Fo, gf;
function D$(r) {
  var e = "", t = Math.floor((Date.now() - Z$) * 1e-3);
  return t === gf ? Fo++ : (Fo = 0, gf = t), e = e + Go(R$), e = e + Go(r), Fo > 0 && (e = e + Go(Fo)), e = e + Go(t), e;
}
var W$ = D$, N$ = sh;
function M$(r) {
  if (!r || typeof r != "string" || r.length < 6)
    return !1;
  var e = new RegExp("[^" + N$.get().replace(/[|\\{}()[\]^$+*?.-]/g, "\\$&") + "]");
  return !e.test(r);
}
var Y$ = M$;
(function(r) {
  var e = sh, t = W$, l = Y$, i = 0;
  function o(c) {
    return e.seed(c), r.exports;
  }
  function n(c) {
    return i = c, r.exports;
  }
  function s(c) {
    return c !== void 0 && e.characters(c), e.shuffled();
  }
  function a() {
    return t(i);
  }
  r.exports = a, r.exports.generate = a, r.exports.seed = o, r.exports.worker = n, r.exports.characters = s, r.exports.isValid = l;
})(x$);
(function(r) {
  r.exports = Lc;
})(v$);
function j$(r, e, t = {}) {
  const l = document.createElement("iframe"), i = document.createElement("div");
  return i.id = "html-app-" + Bc.generate(), i.className = "html-root", l.style.width = t.width ? t.width : "100%", l.style.height = t.height ? t.height : "300px", l.onload = () => {
    var o, n;
    (o = t.stylesCss) == null || o.forEach((s) => {
      var c;
      const a = document.createElement("style");
      a.innerHTML = s, (c = l.contentDocument) == null || c.head.appendChild(a);
    }), (n = l.contentDocument) == null || n.body.appendChild(i), u_(r, e).mount(i);
  }, l;
}
function B$(r = {}) {
  return j$(
    b$,
    {
      html: r.html instanceof Array ? r.html.join(`
`) : r.html,
      css: r.css instanceof Array ? r.css.join(`
`) : r.css,
      js: r.javascript instanceof Array ? r.javascript.join(`
`) : r.javascript
    },
    {
      width: r.width ?? "100%",
      height: r.height ?? "600px",
      stylesCss: [hv, dv, O$]
    }
  );
}
export {
  B$ as createHtmlViewer
};
